/*!
 * maptalks-gl v0.115.0
 * LICENSE : MIT
 * (c) 2016-2025 maptalks.com
 */
!function(i,g){"object"==typeof exports&&"undefined"!=typeof module?g(exports):"function"==typeof define&&define.amd?define(["exports"],g):g((i="undefined"!=typeof globalThis?globalThis:i||self).maptalks=i.maptalks||{})}(this,(function(i){"use strict";
/*!
   * maptalks v1.5.0
   * LICENSE : BSD-3-Clause
   * (c) 2016-2025 maptalks.org
   */var g="1.5.0",m="[object process]"===Object.prototype.toString.call("undefined"!=typeof process?process:0)&&!process.versions.electron&&!process.versions.nw&&!process.versions["node-webkit"];function _(){return"undefined"!=typeof globalThis?globalThis:global||self}function b(i){var g=_().maptalksversion;if(g)throw new Error("Disallow duplicate imports of maptalks version "+i+" and "+g);_().maptalksversion=i}var T={isTest:!1,idleLog:!1,idleForceTimeThreshold:48,workerCount:_().MAPTALKS_WORKER_COUNT||0,messagePostRatioPerWorker:.3,maxFPS:0,crsMaxNativeZoom:22};function P(){return Date.now()}function I(i,...g){for(var m=0;m<g.length;m++){var _=g[m];for(var b in _)i[b]=_[b]}return i}function H(i){return null==i}function W(i){return"number"==typeof i&&!isNaN(i)}function q(i){return(0|i)===i}function $(i){return"object"==typeof i&&!!i}function ye(i){return!H(i)&&("string"==typeof i||null!==i.constructor&&i.constructor===String)}function Re(i){return!H(i)&&("function"==typeof i||null!==i.constructor&&i.constructor===Function)}var Be=Object.prototype.hasOwnProperty;function Ge(i,g){return Be.call(i,g)}var je=Math.PI/180;function Xe(i){return i*je}function Ze(i){return i/je}var Ye={};function Qe(){return window.devicePixelRatio||window.screen.deviceXDPI/window.screen.logicalXDPI}if(!m){var Je=navigator.userAgent.toLowerCase(),Ke=document.documentElement||{style:{}},et="ActiveXObject"in window,tt=-1!==Je.indexOf("webkit"),at=-1!==Je.indexOf("phantom"),ht=-1!==Je.search("android [23]"),gt=-1!==Je.indexOf("chrome"),yt=-1!==Je.indexOf("gecko")&&!tt&&!window.opera&&!et,vt=/iphone/i.test(Je)&&/micromessenger/i.test(Je),xt="undefined"!=typeof orientation||-1!==Je.indexOf("mobile"),bt=!window.PointerEvent&&window.MSPointerEvent,Tt=window.PointerEvent&&navigator.pointerEnabled||bt,Mt=et&&"transition"in Ke.style,Pt="WebKitCSSMatrix"in window&&"m11"in new window.WebKitCSSMatrix&&!ht,It="MozPerspective"in Ke.style,Et="OTransition"in Ke.style,Lt=(Mt||Pt||It)&&!Et&&!at,Dt="undefined"!=typeof window&&Re(window.createImageBitmap),Ft="undefined"!=typeof window&&Re(window.ResizeObserver),Ht="undefined"!=typeof window&&Re(window.btoa),Bt="undefined"!=typeof window&&Re(window.Proxy),zt="undefined"!=typeof window&&Re(window.requestIdleCallback),Vt="undefined"!=typeof CanvasRenderingContext2D&&Re(CanvasRenderingContext2D.prototype.roundRect),Ut=0;gt&&(Ut=Je.match(/chrome\/([\d.]+)/)[1]);var Gt=!at&&(Tt||"ontouchstart"in window||window.DocumentTouch&&document instanceof window.DocumentTouch),jt="undefined"!=typeof window&&"WebGLRenderingContext"in window,Wt=Qe(),qt=!1;try{new OffscreenCanvas(2,2).getContext("2d"),qt=!0}catch(i){qt=!1}var Xt=!1;try{var Zt=Object.defineProperty({},"passive",{get:function(){Xt=!0}});window.addEventListener("testPassive",null,Zt),window.removeEventListener("testPassive",null,Zt)}catch($D){}(Ye={IS_NODE:m,isTest:!1,ie:et,ielt9:et&&!document.addEventListener,edge:"msLaunchUri"in navigator&&!("documentMode"in document),webkit:tt,gecko:yt,android:-1!==Je.indexOf("android"),android23:ht,chrome:gt,chromeVersion:Ut,safari:!gt&&-1!==Je.indexOf("safari"),phantomjs:at,ie3d:Mt,webkit3d:Pt,gecko3d:It,opera12:Et,any3d:Lt,iosWeixin:vt,mobile:xt,mobileWebkit:xt&&tt,mobileWebkit3d:xt&&Pt,mobileOpera:xt&&window.opera,mobileGecko:xt&&yt,touch:!!Gt,msPointer:!!bt,pointer:!!Tt,retina:Wt>1,devicePixelRatio:Wt,language:navigator.browserLanguage?navigator.browserLanguage:navigator.language,ie9:et&&9===document.documentMode,ie10:et&&10===document.documentMode,webgl:jt,imageBitMap:Dt,roundRect:Vt,resizeObserver:Ft,btoa:Ht,decodeImageInWorker:qt,monitorDPRChange:!0,supportsPassive:Xt,proxy:Bt,requestIdleCallback:zt,checkDevicePixelRatio:function(){if("undefined"!=typeof window&&Ye.monitorDPRChange){var i=Qe(),g=i!==Ye.devicePixelRatio;return g&&(Ye.devicePixelRatio=i),g}return!1}}).roundRect||console.warn("current env the canvas not support roundRect")}var $t=Ye;function Yt(i,g){(null==g||g>i.length)&&(g=i.length);for(var m=0,_=Array(g);m<g;m++)_[m]=i[m];return _}function Qt(i){if(void 0===i)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return i}function Jt(i,g,m){return g&&function(i,g){for(var m=0;m<g.length;m++){var _=g[m];_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(i,sn(_.key),_)}}(i.prototype,g),Object.defineProperty(i,"prototype",{writable:!1}),i}function Kt(i,g){var m="undefined"!=typeof Symbol&&i[Symbol.iterator]||i["@@iterator"];if(m)return(m=m.call(i)).next.bind(m);if(Array.isArray(i)||(m=function(i,g){if(i){if("string"==typeof i)return Yt(i,g);var m={}.toString.call(i).slice(8,-1);return"Object"===m&&i.constructor&&(m=i.constructor.name),"Map"===m||"Set"===m?Array.from(i):"Arguments"===m||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(m)?Yt(i,g):void 0}}(i))||g){m&&(i=m);var _=0;return function(){return _>=i.length?{done:!0}:{done:!1,value:i[_++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function en(i){return en=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(i){return i.__proto__||Object.getPrototypeOf(i)},en(i)}function tn(i,g){i.prototype=Object.create(g.prototype),i.prototype.constructor=i,on(i,g)}function nn(){try{var i=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(i){}return(nn=function(){return!!i})()}function rn(){rn=function(){return g};var i,g={},m=Object.prototype,_=m.hasOwnProperty,b="function"==typeof Symbol?Symbol:{},T=b.iterator||"@@iterator",P=b.asyncIterator||"@@asyncIterator",I=b.toStringTag||"@@toStringTag";function H(i,g,m,_){return Object.defineProperty(i,g,{value:m,enumerable:!_,configurable:!_,writable:!_})}try{H({},"")}catch(i){H=function(i,g,m){return i[g]=m}}function W(g,m,_,b){var T=Object.create((m&&m.prototype instanceof ye?m:ye).prototype);return H(T,"_invoke",function(g,m,_){var b=1;return function(T,P){if(3===b)throw Error("Generator is already running");if(4===b){if("throw"===T)throw P;return{value:i,done:!0}}for(_.method=T,_.arg=P;;){var I=_.delegate;if(I){var H=Je(I,_);if(H){if(H===$)continue;return H}}if("next"===_.method)_.sent=_._sent=_.arg;else if("throw"===_.method){if(1===b)throw b=4,_.arg;_.dispatchException(_.arg)}else"return"===_.method&&_.abrupt("return",_.arg);b=3;var W=q(g,m,_);if("normal"===W.type){if(b=_.done?4:2,W.arg===$)continue;return{value:W.arg,done:_.done}}"throw"===W.type&&(b=4,_.method="throw",_.arg=W.arg)}}}(g,_,new tt(b||[])),!0),T}function q(i,g,m){try{return{type:"normal",arg:i.call(g,m)}}catch(i){return{type:"throw",arg:i}}}g.wrap=W;var $={};function ye(){}function Re(){}function Be(){}var Ge={};H(Ge,T,(function(){return this}));var je=Object.getPrototypeOf,Xe=je&&je(je(at([])));Xe&&Xe!==m&&_.call(Xe,T)&&(Ge=Xe);var Ze=Be.prototype=ye.prototype=Object.create(Ge);function Ye(i){["next","throw","return"].forEach((function(g){H(i,g,(function(i){return this._invoke(g,i)}))}))}function Qe(i,g){function m(b,T,P,I){var H=q(i[b],i,T);if("throw"!==H.type){var W=H.arg,$=W.value;return $&&"object"==typeof $&&_.call($,"__await")?g.resolve($.__await).then((function(i){m("next",i,P,I)}),(function(i){m("throw",i,P,I)})):g.resolve($).then((function(i){W.value=i,P(W)}),(function(i){return m("throw",i,P,I)}))}I(H.arg)}var b;H(this,"_invoke",(function(i,_){function T(){return new g((function(g,b){m(i,_,g,b)}))}return b=b?b.then(T,T):T()}),!0)}function Je(g,m){var _=m.method,b=g.i[_];if(b===i)return m.delegate=null,"throw"===_&&g.i.return&&(m.method="return",m.arg=i,Je(g,m),"throw"===m.method)||"return"!==_&&(m.method="throw",m.arg=new TypeError("The iterator does not provide a '"+_+"' method")),$;var T=q(b,g.i,m.arg);if("throw"===T.type)return m.method="throw",m.arg=T.arg,m.delegate=null,$;var P=T.arg;return P?P.done?(m[g.r]=P.value,m.next=g.n,"return"!==m.method&&(m.method="next",m.arg=i),m.delegate=null,$):P:(m.method="throw",m.arg=new TypeError("iterator result is not an object"),m.delegate=null,$)}function Ke(i){this.tryEntries.push(i)}function et(g){var m=g[4]||{};m.type="normal",m.arg=i,g[4]=m}function tt(i){this.tryEntries=[[-1]],i.forEach(Ke,this),this.reset(!0)}function at(g){if(null!=g){var m=g[T];if(m)return m.call(g);if("function"==typeof g.next)return g;if(!isNaN(g.length)){var b=-1,P=function m(){for(;++b<g.length;)if(_.call(g,b))return m.value=g[b],m.done=!1,m;return m.value=i,m.done=!0,m};return P.next=P}}throw new TypeError(typeof g+" is not iterable")}return Re.prototype=Be,H(Ze,"constructor",Be),H(Be,"constructor",Re),Re.displayName=H(Be,I,"GeneratorFunction"),g.isGeneratorFunction=function(i){var g="function"==typeof i&&i.constructor;return!!g&&(g===Re||"GeneratorFunction"===(g.displayName||g.name))},g.mark=function(i){return Object.setPrototypeOf?Object.setPrototypeOf(i,Be):(i.__proto__=Be,H(i,I,"GeneratorFunction")),i.prototype=Object.create(Ze),i},g.awrap=function(i){return{__await:i}},Ye(Qe.prototype),H(Qe.prototype,P,(function(){return this})),g.AsyncIterator=Qe,g.async=function(i,m,_,b,T){void 0===T&&(T=Promise);var P=new Qe(W(i,m,_,b),T);return g.isGeneratorFunction(m)?P:P.next().then((function(i){return i.done?i.value:P.next()}))},Ye(Ze),H(Ze,I,"Generator"),H(Ze,T,(function(){return this})),H(Ze,"toString",(function(){return"[object Generator]"})),g.keys=function(i){var g=Object(i),m=[];for(var _ in g)m.unshift(_);return function i(){for(;m.length;)if((_=m.pop())in g)return i.value=_,i.done=!1,i;return i.done=!0,i}},g.values=at,tt.prototype={constructor:tt,reset:function(g){if(this.prev=this.next=0,this.sent=this._sent=i,this.done=!1,this.delegate=null,this.method="next",this.arg=i,this.tryEntries.forEach(et),!g)for(var m in this)"t"===m.charAt(0)&&_.call(this,m)&&!isNaN(+m.slice(1))&&(this[m]=i)},stop:function(){this.done=!0;var i=this.tryEntries[0][4];if("throw"===i.type)throw i.arg;return this.rval},dispatchException:function(g){if(this.done)throw g;var m=this;function _(i){P.type="throw",P.arg=g,m.next=i}for(var b=m.tryEntries.length-1;b>=0;--b){var T=this.tryEntries[b],P=T[4],I=this.prev,H=T[1],W=T[2];if(-1===T[0])return _("end"),!1;if(!H&&!W)throw Error("try statement without catch or finally");if(null!=T[0]&&T[0]<=I){if(I<H)return this.method="next",this.arg=i,_(H),!0;if(I<W)return _(W),!1}}},abrupt:function(i,g){for(var m=this.tryEntries.length-1;m>=0;--m){var _=this.tryEntries[m];if(_[0]>-1&&_[0]<=this.prev&&this.prev<_[2]){var b=_;break}}b&&("break"===i||"continue"===i)&&b[0]<=g&&g<=b[2]&&(b=null);var T=b?b[4]:{};return T.type=i,T.arg=g,b?(this.method="next",this.next=b[2],$):this.complete(T)},complete:function(i,g){if("throw"===i.type)throw i.arg;return"break"===i.type||"continue"===i.type?this.next=i.arg:"return"===i.type?(this.rval=this.arg=i.arg,this.method="return",this.next="end"):"normal"===i.type&&g&&(this.next=g),$},finish:function(i){for(var g=this.tryEntries.length-1;g>=0;--g){var m=this.tryEntries[g];if(m[2]===i)return this.complete(m[4],m[3]),et(m),$}},catch:function(i){for(var g=this.tryEntries.length-1;g>=0;--g){var m=this.tryEntries[g];if(m[0]===i){var _=m[4];if("throw"===_.type){var b=_.arg;et(m)}return b}}throw Error("illegal catch attempt")},delegateYield:function(g,m,_){return this.delegate={i:at(g),r:m,n:_},"next"===this.method&&(this.arg=i),$}},g}function on(i,g){return on=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(i,g){return i.__proto__=g,i},on(i,g)}function sn(i){var g=function(i,g){if("object"!=typeof i||!i)return i;var m=i[Symbol.toPrimitive];if(void 0!==m){var _=m.call(i,g);if("object"!=typeof _)return _;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(i)}(i,"string");return"symbol"==typeof g?g:g+""}function an(i){var g="function"==typeof Map?new Map:void 0;return an=function(i){if(null===i||!function(i){try{return-1!==Function.toString.call(i).indexOf("[native code]")}catch(g){return"function"==typeof i}}(i))return i;if("function"!=typeof i)throw new TypeError("Super expression must either be null or a function");if(void 0!==g){if(g.has(i))return g.get(i);g.set(i,m)}function m(){return function(i,g,m){if(nn())return Reflect.construct.apply(null,arguments);var _=[null];_.push.apply(_,g);var b=new(i.bind.apply(i,_));return m&&on(b,m.prototype),b}(i,arguments,en(this).constructor)}return m.prototype=Object.create(i.prototype,{constructor:{value:m,enumerable:!1,writable:!0,configurable:!0}}),on(m,i)},an(i)}var ln,hn,cn=function(){function i(i,g,m){if(H(i)||H(g)?H(i.x)||H(i.y)?Array.isArray(i)&&(this.x=+i[0],this.y=+i[1],this.z=i[2]):(this.x=+i.x,this.y=+i.y,this.z=i.z):(this.x=+i,this.y=+g,this.z=m),this._isNaN())throw new Error("Position is NaN")}var g=i.prototype;return g.set=function(i,g,m){return this.x=i,this.y=g,this.z=m||0,this},g._abs=function(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),this},g._round=function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},g._ceil=function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},g.distanceTo=function(i){var g=i.x-this.x,m=i.y-this.y;return Math.sqrt(g*g+m*m)},g.mag=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},g._floor=function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},g._add=function(i,g){return H(i.x)?H(i[0])?(this.x+=i,this.y+=g):(this.x+=i[0],this.y+=i[1]):(this.x+=i.x,this.y+=i.y),this},g._sub=function(i,g){return H(i.x)?H(i[0])?(this.x-=i,this.y-=g):(this.x-=i[0],this.y-=i[1]):(this.x-=i.x,this.y-=i.y),this},g._substract=function(i,g){return W(g)?this._sub(i,g):this._sub(i)},g.substract=function(i,g){return this.sub(i,g)},g._multi=function(i){return this.x*=i,this.y*=i,this},g.div=function(i){return this.multi(1/i)},g._div=function(i){return this._multi(1/i)},g._isNaN=function(){return isNaN(this.x)||isNaN(this.y)||W(this.z)&&isNaN(this.z)},g.isZero=function(){return 0===this.x&&0===this.y},g.toArray=function(){return W(this.z)?[this.x,this.y,this.z]:[this.x,this.y]},g.toJSON=function(){var i={x:this.x,y:this.y};return W(this.z)&&(i.z=this.z),i},i}(),un=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.closeTo=function(i,g){return g||(g=0),this.x>=i.x-g&&this.x<=i.x+g&&this.y>=i.y-g&&this.y<=i.y+g},m.unit=function(){return this.copy()._unit()},m._unit=function(){return this._div(this.mag()),this},m.perp=function(){return this.copy()._perp()},m._perp=function(){return[this.x,this.y]=[-this.y,this.x],this},m.angleWith=function(i){return this.angleWithSep(i.x,i.y)},m.angleWithSep=function(i,g){return Math.atan2(this.x*g-this.y*i,this.x*i+this.y*g)},m._rotate=function(i){var g=Math.cos(i),m=Math.sin(i),_=m*this.x+g*this.y;return this.x=g*this.x-m*this.y,this.y=_,this},m.rotate=function(i){return this.copy()._rotate(i)},m.abs=function(){return new g(Math.abs(this.x),Math.abs(this.y))},m.round=function(){return new g(Math.round(this.x),Math.round(this.y))},m.ceil=function(){return new g(Math.ceil(this.x),Math.ceil(this.y))},m.floor=function(){return new g(Math.floor(this.x),Math.floor(this.y))},m.copy=function(){return new g(this.x,this.y,this.z)},m.toFixed=function(i){return new g(this.x.toFixed(i),this.y.toFixed(i),W(this.z)?this.z.toFixed(i):void 0)},m.add=function(i,m){var _,b;return H(i.x)?H(i[0])?(_=this.x+i,b=this.y+m):(_=this.x+i[0],b=this.y+i[1]):(_=this.x+i.x,b=this.y+i.y),new g(_,b)},m.sub=function(i,m){var _,b;return H(i.x)?H(i[0])?(_=this.x-i,b=this.y-m):(_=this.x-i[0],b=this.y-i[1]):(_=this.x-i.x,b=this.y-i.y),new g(_,b)},m.multi=function(i){return new g(this.x*i,this.y*i)},m.equals=function(i){return i instanceof this.constructor&&(this.x===i.x&&this.y===i.y&&this.z===i.z)},g}(cn);function fn(i){var g="data:image/svg+xml";return i.length>4&&".svg"===i.slice(-4)?1:i.slice(0,18)===g?2:0}function dn(i,g){m&&dn.node?dn.node(i,g):i.src=g[0]}!function(){if(m)return ln=function(i){return setTimeout(i,16)},void(hn=clearTimeout);ln=function(i){return requestAnimationFrame(i)},hn=function(i){return cancelAnimationFrame(i)}}();var pn=0;function gn(){return pn++}var mn=gn;function An(i){return i&&ye(i)?JSON.parse(i):i}function yn(...i){for(var g=i[0],m=1;m<i.length;m++){var _=i[m];if(_&&_.length)for(var b=0,T=_.length;b<T;b++)g.push(_[b])}return g.length}function _n(...i){for(var g=[],m=-1,_=0;_<i.length;_++){var b=i[_];if(b&&b.length)for(var T=0,P=b.length;T<P;T++)g[++m]=b[T]}return g}function xn(i,g){var m=g.indexOf(i);m>-1&&g.splice(m,1)}function bn(i,g,m){if(!Array.isArray(i))return m?g.call(m,i):g(i);for(var _,b,T=[],P=0,I=i.length;P<I;P++)H(_=i[P])?T.push(null):Array.isArray(_)?T.push(bn(_,g,m)):(b=m?g.call(m,_):g(_),T.push(b));return T}function wn(i,g){return void 0===i?g:i}function Sn(i){return Math.sign?Math.sign(i):0===(i=+i)||isNaN(i)?Number(i):i>0?1:-1}function Mn(i,g,m){return i*(1-m)+g*m}function Cn(i,g,m){if(i===m||i===g)return i;var _=m-g;return((i-g)%_+_)%_+g}function Pn(i,g,m){return Math.min(m,Math.max(g,i))}function kn(i){return Array.isArray(i)&&i.length>0}var On=/^([a-z][a-z\d+\-.]*:)?\/\//i;function En(i){return On.test(i)}var Rn=/^url\((['"])(.+)\1\)$/i,Ln=/^url\(([^'"].*[^'"])\)$/i;function Dn(i){return ye(i)?Ln.test(i)?1:Rn.test(i)?2:3:0}function Fn(i){var g=Dn(i);return 3===g?i:1===g?Ln.exec(i)[1]:2===g?Rn.exec(i)[2]:i}function Nn(i){if($t.btoa)return window.btoa(i);for(var g,m,_=String(i),b="",T=0,P="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";_.charAt(0|T)||(P="=",T%1);b+=P.charAt(63&g>>8-T%1*8)){if((m=_.charCodeAt(T+=3/4))>255)throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");g=g<<8|m}return b}function Hn(i,g){for(var m=atob(i),_=new ArrayBuffer(m.length),b=new Uint8Array(_),T=0;T<m.length;T++)b[T]=255&m.charCodeAt(T);return new Blob([_],{type:g})}function Bn(i,g,m,_){return Math.atan2(_-g,m-i)}var Vn="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";function Un(i,g){if(!i&&!g)return!0;if(!i||!g)return!1;for(var m in i)if("center"===m){if(!g[m]||!Gn(i[m][0],g[m][0])||!Gn(i[m][1],g[m][1]))return!1}else if(i[m]!==g[m])return!1;return!0}function Gn(i,g,m){return null==m&&(m=1e-6),i>=g-m&&i<=g+m}function jn(i=100,g=4,m=null,_=null){i||(i=100),g||(g=4);var b=this,T=this.isVisible();return g*=2,this._flashTimeout&&clearTimeout(this._flashTimeout),this._flashTimeout=setTimeout((function P(){if(0===g)return T?b.show():b.hide(),void(m&&(_?m.call(_):m()));g%2==0?b.hide():b.show(),g--,b._flashTimeout=setTimeout(P,i)}),i),this}function Wn(i=[],g="_pt"){for(var m=[],_=0,b=i.length;_<b;_++){var T=i[_];if(T){T[g]||(T[g]=new un(0,0));var P=T[g];P.x=0,P.y=0,m.push(P)}else m.push(null)}return m}function qn(i,g){g(i.data)}function Zn(i){if(i&&0===i.indexOf("http://")||0===i.indexOf("https://"))return i;var g=document.createElement("a");return g.href=i,i=g.href,g=null,i}var $n={cssWidth:"1px",cssHeight:"1px",width:1,height:1};function Yn(i,g=1){var{width:m,height:_}=i;return $n.cssWidth=m+"px",$n.cssHeight=_+"px",$n.width=Math.round(m*g),$n.height=Math.round(_*g),$n}var Qn="_maptalks__internal_layer_",Jn=["MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"],Kn=["FeatureCollection","Feature","Point","LineString","Polygon"].concat(Jn),er=["markerFile","polygonPatternFile","linePatternFile","markerFillPatternFile","markerLinePatternFile"],tr=[["markerWidth","markerHeight"],[],[null,"lineWidth"],[],[null,"markerLineWidth"]],nr={lineWidth:1,lineOpacity:1,lineDx:1,lineDy:1,polygonOpacity:1,markerWidth:1,markerHeight:1,markerDx:1,markerDy:1,markerOpacity:1,markerFillOpacity:1,markerLineWidth:1,markerLineOpacity:1,textSize:1,textOpacity:1,textHaloRadius:1,textWrapWidth:1,textLineSpacing:1,textDx:1,textDy:1},rr=["lineColor","polygonFill","markerFill","markerLineColor","textFill"],ir=function(){function i(i,g){W(i)&&W(g)?(this.width=i,this.height=g):W(i.width)?(this.width=i.width,this.height=i.height):Array.isArray(i)&&(this.width=i[0],this.height=i[1])}var g=i.prototype;return g.copy=function(){return new i(this.width,this.height)},g.add=function(g,m){var _,b;return g instanceof i?(_=this.width+g.width,b=this.height+g.height):(_=this.width+g,b=this.height+m),new i(_,b)},g.equals=function(i){return this.width===i.width&&this.height===i.height},g.multi=function(g){return new i(this.width*g,this.height*g)},g._multi=function(i){return this.width*=i,this.height*=i,this},g._round=function(){return this.width=Math.round(this.width),this.height=Math.round(this.height),this},g.toPoint=function(){return new un(this.width,this.height)},g.toArray=function(){return[this.width,this.height]},g.toJSON=function(){return{width:this.width,height:this.height}},i}(),or="";function sr(i){return i.trim?i.trim():i.replace(/^\s+|\s+$/g,"")}function lr(i,g,m){if(!i)return i;for(;i.indexOf(g)>-1;)i=i.replace(g,m);return i}var hr=/[\b\t\r\v\f]/gim;function cr(i){return ye(i)?i.replace(hr,or):i}function ur(i){return sr(i).split(/\s+/)}var fr="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):null;function dr(i,g){return dr.node?dr.node(i,g):(fr.font=g,fr.measureText(i).width)}function pr(i,g,m){var _=dr(i,g);return new ir(_,m||14)}function gr(i,g,m,_){if(!i||0===i.length)return[{text:"",width:0}];var b=H(_)?dr(i,g):_,T=b/i.length,P=Math.floor(m/T/2);if(T>=m||P<=0)return[{text:"",width:m}];if(b<=m)return[{text:i,width:b}];for(var I=[],W=i.substring(0,P),q=T*P,$=P,ye=i.length;$<ye;$++){var Re=i[$],Be=dr(W+Re);Be>=m?(I.push({text:W,width:q}),W=i.substring($,P+$),$+=P-1,q=T*P):(W+=Re,q=Be),$>=ye-1&&(q=dr(W),I.push({text:W,width:q}))}return I}var mr=["{","}"];function Ar(i,g){if(!ye(i))return i;var[m,_]=mr;if(-1===i.indexOf(m)&&-1===i.indexOf(_))return i;function b(i){if(!g)return or;var m=g[i];return H(m)?or:Array.isArray(m)?m.join():m}for(var T=function(i){i+=or;for(var[g,m]=mr,_=[],b=!1,T=or,P=0,I=i.length;P<I;P++){var H=i[P];b||H!==g||(b=!0),H===g&&b&&(T=or),b&&H!==g&&H!==m&&(T+=H),H===m&&T&&(b=!1,_.push(T),T=or)}return _}(i),P=0,I=T.length;P<I;P++){var W=T[P];i=lr(i,""+m+W+_,b(W))}return i}function yr(i,g){W(i)&&(i+="");var m=g.textMaxHeight||0,_=wr(i=i||"",g);return m&&m<_.size.height&&(_.size.height=m),_}function _r(i,g,m){var _=i.width,b=i.height;return new un("left"===g?-_:"right"===g?0:-_/2,"top"===m?-b:"bottom"===m?0:-b/2)}var vr="sans-serif",xr=14;function br(i){if(i.textFont)return i.textFont;var g=i.textSize;return H(g)&&(g=xr),(i.textStyle&&"normal"!==i.textStyle?i.textStyle+" ":"")+(i.textWeight&&"normal"!==i.textWeight?i.textWeight+" ":"")+g+"px "+(i.textFaceName&&function(i){for(var g=i.split(","),m=0;m<g.length;m++)g[m].trim&&(g[m]=g[m].trim()),g[m].indexOf(" ")>0&&'"'!==g[m][0]&&"'"!==g[m][0]&&(g[m]='"'+g[m]+'"');return g.join(",")}(i.textFaceName)||vr)}function wr(i,g){var m=br(g),_=g.textLineSpacing||0,b=pr(i,m,g.textSize),T=b.width,P=b.height,I=g.textWrapCharacter||"\n",H=[],W=g.textWrapWidth;(!W||W>T)&&(W=T),ye(i)||(i+="");var q=0;if(i.indexOf(I)>=0)for(var $=i.split(I),Re=0,Be=$.length;Re<Be;Re++){var Ge=$[Re],je=dr(Ge,m);if(je>W)for(var Xe=gr(Ge,m,W,je),Ze=0,Ye=Xe.length;Ze<Ye;Ze++){var Qe=Xe[Ze].width;Qe>q&&(q=Qe),H.push({text:Xe[Ze].text,size:new ir(Qe,P)})}else je>q&&(q=je),H.push({text:Ge,size:new ir(je,P)})}else if(T>W)for(var Je=gr(i,m,W,T),Ke=0;Ke<Je.length;Ke++){var et=Je[Ke].width;et>q&&(q=et),H.push({text:Je[Ke].text,size:new ir(et,P)})}else T>q&&(q=T),H.push({text:i,size:b});var tt=H.length;return{total:tt,size:new ir(q,P*tt+_*(tt-1)),rows:H,rawSize:b}}function Tr(i){var g=0,m=i&&i.length||0;if(!m)return g;for(var _=0;_<m;_++)g=(g<<5)-g+i.charCodeAt(_),g&=g;return g}var Sr=Object.freeze({__proto__:null,DEFAULT_FONT:vr,DEFAULT_TEXTSIZE:xr,EMPTY_STRING:or,describeText:yr,escapeSpecialChars:cr,getAlignPoint:_r,getFont:br,hashCode:Tr,replaceAll:lr,replaceVariable:Ar,splitContent:gr,splitTextToRow:wr,splitWords:ur,stringLength:pr,stringWidth:dr,trim:sr}),Mr=m?function(i){return i[0]}:function(i){for(var g=document.documentElement&&document.documentElement.style||{},m=0;m<i.length;m++)if(i[m]in g)return i[m];return!1},Cr=Mr(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),Pr=Mr(["transformOrigin","WebkitTransformOrigin","OTransformOrigin","MozTransformOrigin","msTransformOrigin"]),Ir=Mr(["transition","WebkitTransition","OTransition","MozTransition","msTransition"]),kr=Mr(["filter","WebkitFilter","OFilter","MozFilter","msFilter"]);function Or(i,g){var m=document.createElement(i);return g&&qr(m,g),m}function Er(i,g,m){var _=Or(i);return g&&Gr(_,g),m&&m.appendChild(_),_}function Rr(i){if(!i)return this;if($t.ielt9||$t.ie9){var g=Or("div");g.appendChild(i),g.innerHTML="",g=null}else i.parentNode&&i.parentNode.removeChild(i);return this}function Lr(i,g,m,_){if(!(i&&i.addEventListener&&g&&m))return this;for(var b=function(g){g||(g=window.event),m.call(_||i,g)},T=g.split(" "),P=T.length-1;P>=0;P--){var I=T[P];if(I)i["Z__"+I]||(i["Z__"+I]=[]),Fr(i,I,m)>=0&&(console.warn(i,"find '"+I+"' handler:",m," The old listener function will be removed"),Dr(i,I,m)),i["Z__"+I].push({callback:b,src:m}),i.addEventListener(I,b,!!$t.supportsPassive&&{capture:!1,passive:!1})}return this}function Dr(i,g,m){function _(g,m){"mousewheel"===g&&$t.gecko&&(g="DOMMouseScroll"),i.removeEventListener(g,m,!1)}if(!i||!i.removeEventListener||!g)return this;for(var b=g.split(" "),T=b.length-1;T>=0;T--){var P=b[T];if(P){if(!m&&i["Z__"+P]){for(var I=i["Z__"+P],H=0,W=I.length;H<W;H++)_(I[H].callback);return delete i["Z__"+P],this}var q=Fr(i,P,m);if(q<0)return this;_(P,i["Z__"+P][q].callback),i["Z__"+P].splice(q,1)}}return this}function Fr(i,g,m){if(!i||!i["Z__"+g]||!m)return-1;for(var _=i["Z__"+g],b=0,T=_.length;b<T;b++)if(_[b].src===m)return b;return-1}function Nr(i){return i.preventDefault?i.preventDefault():i.returnValue=!1,this}function Hr(i){return i._cancelBubble=!0,i.stopPropagation?i.stopPropagation():i.cancelBubble=!0,this}function Br(i){return i.onselectstart=function(){return!1},i.ondragstart=function(){return!1},i.setAttribute("unselectable","on"),this}function zr(i,g){return i?($t.any3d?Zr(i,g):(i.style.left=g.x+"px",i.style.top=g.y+"px"),g):null}function Vr(i){var g=window.getComputedStyle(i),m=[parseInt(g["padding-left"]),parseInt(g["padding-top"])],_=i.getBoundingClientRect(),b=i.offsetWidth,T=i.offsetHeight;return i.__position=[_.left+m[0],_.top+m[1],b?_.width/b:1,T?_.height/T:1],i.__position}function Ur(i,g){i||(i=window.event);var m=g.__position;m||(m=Vr(g));var _=i;return _.touches&&_.touches.length&&(i=_.touches[0]),_.changedTouches&&_.changedTouches.length&&(i=_.changedTouches[0]),new un((i.clientX-m[0]-g.clientLeft)/m[2],(i.clientY-m[1]-g.clientTop)/m[3])}function Gr(i,g){var m=i.style.cssText;return function(i,g){var m=i.length-g.length;return m>=0&&i.indexOf(g,m)===m}(m,";")||(m+=";"),i.style.cssText=m+g,this}function jr(i,g){if(void 0!==i.classList)return i.classList.contains(g);var m=Xr(i);return m.length>0&&new RegExp("(^|\\s)"+g+"(\\s|$)").test(m)}function Wr(i,g){if(void 0===i.classList||jr(i,g)){var m=Xr(i);qr(i,(m?m+" ":"")+g)}else for(var _=ur(g),b=0,T=_.length;b<T;b++)i.classList.add(_[b]);return this}function qr(i,g){return H(i.className.baseVal)?i.className=g:i.className.baseVal=g,this}function Xr(i){return H(i.className.baseVal)?i.className:i.className.baseVal}function Zr(i,g){var m=g||new un(0,0);return i.style[Cr]=$t.any3d?"translate3d("+m.x+"px,"+m.y+"px,0px)":"translate("+m.x+"px,"+m.y+"px)",this}function $r(i){return/<[a-z\][\s\S]*>/i.test(i)}function Yr(i,g){var m=Qr(i);ye(g)?m.innerHTML=g:m.appendChild(g);var _=new ir(m.clientWidth,m.clientHeight);return Rr(m),_}function Qr(i){var g=document.createElement(i);return g.style.cssText="position:absolute;left:-10000px;top:-10000px;",document.body.appendChild(g),g}var Jr=Lr,Kr=Dr;function ei(i){return i&&("mousemove"===i||"touchmove"===i)}function ti(i,g){var m=P();return!!(i._mousemoveTime&&m-i._mousemoveTime<(g||48))||(i._mousemoveTime=m,!1)}var ni=Object.freeze({__proto__:null,CSSFILTER:kr,MOUSEMOVE_THROTTLE_TIME:48,TRANSFORM:Cr,TRANSFORMORIGIN:Pr,TRANSITION:Ir,addClass:Wr,addDomEvent:Lr,computeDomPosition:Vr,createEl:Or,createElOn:Er,getClass:Xr,getDomRuler:Qr,getEventContainerPoint:Ur,hasClass:jr,isHTML:$r,isMousemoveEventBlocked:ti,isMoveEvent:ei,listensDomEvent:Fr,measureDom:Yr,off:Kr,offsetDom:zr,on:Jr,preventDefault:Nr,preventSelection:Br,removeDomEvent:Dr,removeDomNode:Rr,removeTransform:function(i){return i.style[Cr]&&(i.style[Cr]=""),this},setClass:qr,setOpacity:function(i,g){return i.style.opacity=g,this},setStyle:Gr,setTransform:Zr,setTransformMatrix:function(i,g){var m="matrix("+(ye(g)?g:g.join())+")";return i.style[Cr]!==m&&(i.style[Cr]=m),this},stopPropagation:Hr}),ri={jsonp:function(i,g){var m="_maptalks_jsonp_"+gn();i.match(/\?/)?i+="&callback="+m:i+="?callback="+m;var _=document.createElement("script");return _.type="text/javascript",_.src=i,window[m]=function(i){g(null,i),document.getElementsByTagName("head")[0].removeChild(_),_=null,delete window[m]},document.getElementsByTagName("head")[0].appendChild(_),this},get:function(i,g,_){if(Re(g)){var b=_;_=g,g=b}if(m&&ri.get.node)return ri.get.node(i,_,g);var T=ri._getClient(_);if(T.open("GET",i,!0),g){for(var P in g.headers)T.setRequestHeader(P,g.headers[P]);T.withCredentials="include"===g.credentials,g.responseType&&(T.responseType=g.responseType)}return T.send(null),T},post:function(i,g,_){var b;if(ye(i)){if(Re(g)){var T=_;_=g,g=T}b=(g=g||{}).postData}else{b=g,i=(g=i).url,_=_}if(m&&ri.post.node)return g.url=i,ri.post.node(g,b,_);var P=ri._getClient(_);if(P.open("POST",g.url,!0),g.headers||(g.headers={}),g.headers["Content-Type"]||(g.headers["Content-Type"]="application/x-www-form-urlencoded"),"setRequestHeader"in P)for(var I in g.headers)g.headers.hasOwnProperty(I)&&P.setRequestHeader(I,g.headers[I]);return ye(b)||(b=JSON.stringify(b)),P.send(b),P},_wrapCallback:function(i,g){return function(){4===i.readyState&&(200===i.status?"arraybuffer"===i.responseType?0===i.response.byteLength?g(new Error("http status 200 returned without content.")):g(null,{data:i.response,cacheControl:i.getResponseHeader("Cache-Control"),expires:i.getResponseHeader("Expires"),contentType:i.getResponseHeader("Content-Type")}):g(null,i.responseText):g(new Error(i.statusText+","+i.status)))}},_getClient:function(i){var g;try{g=new XMLHttpRequest}catch(i){try{g=new ActiveXObject("Msxml2.XMLHTTP")}catch(i){try{g=new ActiveXObject("Microsoft.XMLHTTP")}catch(i){}}}return g.onreadystatechange=ri._wrapCallback(g,i),g},getArrayBuffer:function(i,g,m){if(Re(g)){var _=m;m=g,g=_}return g||(g={}),g.responseType="arraybuffer",ri.get(i,g,m)},getImage:function(i,g,m){return ri.getArrayBuffer(g,m,(function(g,m){if(g)i.onerror&&i.onerror(g);else if(m){var _=window.URL||window.webkitURL,b=i.onload;i.onload=function(){b&&b(),_.revokeObjectURL(i.src)};var T=new Blob([new Uint8Array(m.data)],{type:m.contentType});i.cacheControl=m.cacheControl,i.expires=m.expires,i.src=m.data.byteLength?_.createObjectURL(T):Vn}}))},getJSON:function(i,g,m){}};ri.getJSON=function(i,g,m){if(Re(g)){var _=m;m=g,g=_}var b=function(i,g){var _=g?An(g):null;m(i,_)};return g&&g.jsonp?ri.jsonp(i,b):ri.get(i,g,b)};var ii=/data:image\/.*;base64,/;function oi(i,g={}){for(var m in g){var _=g[m];if(_&&_.target&&(P=m,W(T=i)&&(T+=""),W(P)&&(P+=""),T&&P&&(T.includes?T.includes(P):T.indexOf(P)>-1))){var{target:b}=_;return i.replace(m,b)}}var T,P;return""}var si,ai={host:"",resources:{},proxy:{},origin:{},fromJSON:function(i){try{ye(i)&&(i=JSON.parse(i)),$(i)&&I(ai,i)}catch(i){console.error(i)}},toJSON:function(){return{host:ai.host,proxy:I({},ai.proxy||{}),origin:I({},ai.origin||{})}},getResource:function(i){return ai.resources[i]},removeResource:function(i){delete ai.resources[i]},addResource:function(i,g){ai.resources[i]?console.warn(i+" resource Already exists,the "+i+" Cannot be added,the resource name Cannot repeat "):ai.resources[i]=g},updateResource:function(i,g){ai.resources[i]=g},allResource:function(){return ai.resources},loadSprite:function(i={imgUrl:"",jsonUrl:""}){return new Promise((function(g,m){var{imgUrl:_,jsonUrl:b}=i;if(!_||!b)return m(new Error("not find imgUrl/jsonUrl from options")),void console.error(i);function T(i,g,m){i.width=g,i.height=m;var _=i.getContext("2d");return _.clearRect(0,0,g,m),_}function P(_={},b){var P=function(){var i;return $t.IS_NODE?console.error("Current environment does not support canvas dom"):i=Or("canvas"),i}();if(P){var I=[];for(var H in _){I.push({name:H,spriteItem:_[H]})}var W=function(){var i;return $t.decodeImageInWorker&&(i=new OffscreenCanvas(2,2)),i}(),q=i.sourceName||"";I.forEach((function(i){var g,{name:m,spriteItem:_}=i,{x:I,y:H,width:$,height:ye}=_;W?(T(W,$,ye).drawImage(b,I,H,$,ye,0,0,$,ye),g=W.transferToImageBitmap()):(T(P,$,ye).drawImage(b,I,H,$,ye,0,0,$,ye),g=P.toDataURL());i.resource=g,ai.addResource(q+m,g)})),g(I)}else m(new Error("can not create canvas"))}ri.getJSON(b,{},(function(i,g){if(i)m(i);else{var b=new Image;b.onload=function(){P(g,b)},b.onerror=function(i){m(i)},ri.getImage(b,_,{})}}))}))},loadSvgs:function(i){return new Promise((function(g,m){var _="",b=[],T="",P="",I="";if(Array.isArray(i)||i instanceof NodeList)b=i;else if($(i)){_=i.url,b=i.symbols,T=i.fill,P=i.stroke,I=i.sourceName||""}else ye(i)&&(_=i);if(_||!b||0!==b.length){var H=[],W=function(i,g){var m=ci(g);m&&(m.forEach((function(i){T&&(i.fill=T),P&&(i.stroke=P)})),ai.addResource(I+i,m)),H.push({name:i,paths:m,body:g})};if(_&&ye(_))fetch(_).then((function(i){return i.json()})).then((function(i){i.forEach((function(i){var{name:g,body:m}=i;W(g,m)})),g(H)})).catch((function(i){console.log(i),m(i)}));else if(b){for(var q=0,Re=b.length;q<Re;q++){var Be=b[q],Ge=Be.id;Ge&&W(Ge,"<xml><svg>"+Be.innerHTML+"</svg></xml>")}g(H)}else m(new Error("not support svgs params type"))}else m(new Error("not find svgs data"))}))}};function li(i){if(W(i)&&(i+=""),!i)return console.error("resouce path is null,path:",i),i;if(!ye(i))return i;if(function(i){return ii.test(i)}(i)||function(i){return 0===i.indexOf("blob:")}(i))return i;if("$"===i[0])return ai.getResource(i.substring(1,1/0))||"";var g=ai.origin||{},m=En(i);if(m&&$(g)){var _=oi(i,g);return _||i}var b=ai.proxy||{};if($(b)){var T=oi(i,b);if(T)return T}var{host:P}=ai;return!m&&P&&ye(P)?""+P+i:Zn(i)}function hi(i,g){return i?i[g]&&i[g].value:null}function ci(i){var g=(si||(si=new DOMParser),si).parseFromString(i,"text/xml").querySelector("svg");if(!g)return null;for(var m=g.childNodes,_=[],b=g.attributes,T=hi(b,"fill"),P=hi(b,"fill-opacity"),I=hi(b,"stroke"),H=hi(b,"stroke-opacity"),W=hi(b,"stroke-width"),q=0,$=m.length;q<$;q++){var ye=m[q],Re=ye.attributes;if(Re){var Be=void 0,Ge="path"===(ye.tagName||"").toLowerCase();if(Be=Ge?hi(Re,"d"):ye){var je=hi(Re,"fill")||T,Xe=hi(Re,"stroke")||I,Ze={path:Be};if(je&&(Ze.fill=je,Ze["fill-opacity"]=hi(Re,"fill-opacity")||P||1),Xe&&(Ze.stroke=Xe,Ze["stroke-opacity"]=hi(Re,"stroke-opacity")||H||1,Ze["stroke-width"]=hi(Re,"stroke-width")||W||1),_.push(Ze),!Ge)for(var Ye in Ze)"path"!==Ye&&Ze.hasOwnProperty(Ye)&&ye.setAttribute(Ye,Ze[Ye])}}}return _}let ui;const fi={width:100,height:10};let di=!1;try{const i=new OffscreenCanvas(1,1);i.getContext("2d").fillText("hello",0,0),di=!0}catch(i){di=!1}let pi=class ColorIn{constructor(i,g={}){if(!Array.isArray(i))return void console.error("colors is not array");if(i.length<2)return void console.error("colors.length should >1");this.colors=i;let m=1/0,_=-1/0;for(let g=0,b=i.length;g<b;g++){const b=i[g][0];m=Math.min(b,m),_=Math.max(b,_)}this.min=m,this.max=_,this.valueOffset=this.max-this.min,this.options=Object.assign({},fi,g),this._initImgData()}getImageData(){return this.imgData}_initImgData(){const i=function(){if(!ui){const{width:i,height:g}=fi;di?ui=new OffscreenCanvas(i,g):(ui=document.createElement("canvas"),ui.width=i,ui.height=g)}return ui}(),{width:g,height:m}=this.options;i.width=g,i.height=m;const _=i.getContext("2d");_.clearRect(0,0,i.width,i.height);const b=_.createLinearGradient(0,0,i.width,0),{colors:T,valueOffset:P}=this;for(let i=0,g=T.length;i<g;i++){const[g,m]=T[i];b.addColorStop((g-this.min)/P,m)}_.fillStyle=b,_.fillRect(0,0,i.width,i.height),this.imgData=_.getImageData(0,0,i.width,i.height)}getColor(i){i=Math.max(this.min,i),i=Math.min(i,this.max);let g=Math.round((i-this.min)/this.valueOffset*this.imgData.width);g=Math.min(g,this.imgData.width-1);const m=4*g;return[this.imgData.data[m],this.imgData.data[m+1],this.imgData.data[m+2],this.imgData.data[m+3]]}};var gi;function mi(i){return null==i}function Ai(i){return!mi(i)}function yi(i){return""===i}function _i(i,g){var m,_,b;if(Ii(i)){var T,P=i.stops&&"object"==typeof i.stops[0][0],I=P||Ai(i.property),H=P||!I,W=i.type||g||"exponential";if("exponential"===W)T=bi;else if("interval"===W)T=xi;else if("categorical"===W)T=vi;else if("identity"===W)T=Si;else if("color-interpolate"===W)T=Ti;else{if("calculate-expression"!==W)throw new Error('Unknown function type "'+W+'"');T=Mi}if(P){var q={},$=[];for(let g=0;g<i.stops.length;g++){var ye=i.stops[g];void 0===q[ye[0].zoom]&&(q[ye[0].zoom]={zoom:ye[0].zoom,type:i.type,property:i.property,default:i.default,stops:[]}),q[ye[0].zoom].stops.push([ye[0].value,ye[1]])}for(let i in q)$.push([q[i].zoom,_i(q[i])]);m=function(g,m){const _=bi({stops:$,base:i.base},g)(g,m);return"function"==typeof _?_(g,m):_},_=!1,b=!1}else H?(m=function(g){const m=T(i,g);return"function"==typeof m?m(g):m},_=!0,b=!1):(m=function(g,m){const _=T(i,m?m[i.property]:null);return"function"==typeof _?_(g,m):_},_=!1,b=!0)}else m=function(){return i},_=!0,b=!0;return m.isZoomConstant=b,m.isFeatureConstant=_,m}function vi(i,g){for(let m=0;m<i.stops.length;m++)if(g===i.stops[m][0])return i.stops[m][1];return i.default}function xi(i,g){for(var m=0;m<i.stops.length&&!(g<i.stops[m][0]);m++);return i.stops[Math.max(m-1,0)][1]}function bi(i,g){for(var m=Ai(i.base)&&!yi(i.base)?i.base:1,_=0;!(_>=i.stops.length||g<=i.stops[_][0]);)_++;return 0===_?i.stops[_][1]:_===i.stops.length?i.stops[_-1][1]:Ci(g,m,i.stops[_-1][0],i.stops[_][0],i.stops[_-1][1],i.stops[_][1])}"function"==typeof Map&&(gi=new Map);const wi={width:100,height:1};function Ti(i,g){const m=i.stops;if(m&&m.length>1){let i;if(gi){const g=JSON.stringify(m);if(!gi.has(g)){const i=new pi(m,wi);gi.set(g,i)}i=gi.get(g)}else i=new pi(m,wi);const[_,b,T,P]=i.getColor(g);return[_/255,b/255,T/255,P/255]}return m&&1===m.length?m[0][1]:null}function Si(i,g){return function(i,g,m){return Ai(i)?i:Ai(g)?g:Ai(m)?m:null}(g,i.default)}function Mi(i,g){const m=String(i.property),_=i.expression,b=g;function T(g){return mi(g)||yi(g)||isNaN(g)?i.default:g}if(!Ai(g)||yi(g)||isNaN(g)||g<0)return T(i.default);{const g=function i(g,m,_){const b=Number(_),T=String(m);return Array.isArray(g)?g.map((g=>i(g,T,b))):g===T?b:g}(_,m,b);return T(function g(m){if(!Array.isArray(m)){if("number"==typeof m)return m;throw new Error("Invalid expression format")}{const _=m[0];if(!["+","-","*","/"].includes(_))throw new Error(`Unknown operator: ${_}`);const b=m.slice(1).map((i=>g(i)));switch(_){case"+":return b.reduce(((i,g)=>i+g),0);case"-":return b.reduce(((i,g)=>i-g));case"*":return b.reduce(((i,g)=>i*g),1);case"/":return b.some((i=>0===i))?i.default:b.reduce(((i,g)=>i/g));default:throw new Error(`Unsupported operator: ${_}`)}}}(g))}}function Ci(i,g,m,_,b,T){return"function"==typeof b?function(){var P=b.apply(void 0,arguments),I=T.apply(void 0,arguments);return Ci(i,g,m,_,P,I)}:b.length?function(i,g,m,_,b,T){var P=[];for(let I=0;I<b.length;I++)P[I]=Pi(i,g,m,_,b[I],T[I]);return P}(i,g,m,_,b,T):Pi(i,g,m,_,b,T)}function Pi(i,g,m,_,b,T){var P,I=_-m,H=i-m;return b*(1-(P=1===g?H/I:(Math.pow(g,H)-1)/(Math.pow(g,I)-1)))+T*P}function Ii(i){return i&&"object"==typeof i&&(i.stops||i.property&&"identity"===i.type||i.expression&&"calculate-expression"===i.type)}function ki(i){for(const g in i)if(Ii(i[g]))return!0;return!1}function Oi(i){return Li(i,"exponential")}function Ei(i,g){if(!i)return null;var m=!1;if(Array.isArray(i)){var _,b=[];for(let T=0;T<i.length;T++)(_=Ei(i[T],g))?(b.push(_),m=!0):b.push(i[T]);return m?b:i}var T,P={__fn_types_loaded:!0},I=[];for(T in i)i.hasOwnProperty(T)&&I.push(T);const H=function(i){Object.defineProperty(P,i,{get:function(){return this["__fn_"+i]||(this["__fn_"+i]=Oi(this["_"+i])),this["__fn_"+i].apply(this,g())},set:function(g){this["_"+i]=g},configurable:!0,enumerable:!0})};for(let g=0,_=I.length;g<_;g++)Ii(i[T=I[g]])?(m=!0,P["_"+T]=i[T],H(T)):P[T]=i[T];return m?P:i}function Ri(i){if(!i||!i.stops)return[];const g=[];for(let m=0,_=i.stops.length;m<_;m++)g.push(i.stops[m][1]);return g}function Li(i,g){if(!Ii(i))return function(){return i};let m=!0,_=!0;const b=(i=JSON.parse(JSON.stringify(i))).stops;if(b)for(let i=0;i<b.length;i++)if(Ii(b[i][1])){const T=Li(b[i][1],g);m=m&&T.isZoomConstant,_=_&&T.isFeatureConstant,b[i]=[b[i][0],T]}const T=_i(i,g);return T.isZoomConstant=m&&T.isZoomConstant,T.isFeatureConstant=_&&T.isFeatureConstant,T}
/*!
      Feature Filter by

      (c) mapbox 2016 and maptalks 2018
      www.mapbox.com | www.maptalks.org
      License: MIT, header required.
  */const Di=["Unknown","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"];function Fi(i){return new Function("f",`var p = (f && f.properties || {}); return ${Ni(i)}`)}function Ni(i){if(!i)return"true";const g=i[0];if(i.length<=1)return"any"===g?"false":"true";const m="=="===g?Bi(i[1],i[2],"===",!1):"!="===g?Bi(i[1],i[2],"!==",!1):"<"===g||">"===g||"<="===g||">="===g?Bi(i[1],i[2],g,!0):"any"===g?Vi(i.slice(1),"||"):"all"===g?Vi(i.slice(1),"&&"):"none"===g?ji(Vi(i.slice(1),"||")):"in"===g?Ui(i[1],i.slice(2)):"!in"===g?ji(Ui(i[1],i.slice(2))):"has"===g?Gi(i[1]):"!has"===g?ji(Gi(i[1])):"contains"===g?function(i,g,m){const _=Hi(i);return void 0!==m?`(${_} + '').indexOf("${g}") === ${m}`:`(${_} + '').indexOf("${g}") >= 0`}(i[1],i[2],i[3]):"true";return`(${m})`}function Hi(i){return"$"===i[0]?"f."+i.substring(1):"p["+JSON.stringify(i)+"]"}function Bi(i,g,m,_){if("object"==typeof(b=i)&&b&&i.op)return function(i,g,m,_){const b=i.property,T=i.op;let P=Hi(b);return"length"!==T?(console.error(`not support ${T} op`),"false"):(P=`((${P}+='').length)`,zi(P,b,g,m,_))}(i,g,m,_);var b;return zi(Hi(i),i,g,m,_)}function zi(i,g,m,_,b){const T="$type"===g?Di.indexOf(m):JSON.stringify(m);return(b?`typeof ${i}=== typeof ${T}&&`:"")+i+_+T}function Vi(i,g){return i.map(Ni).join(g)}function Ui(i,g){"$type"===i&&(g=g.map((i=>Di.indexOf(i))));const m=JSON.stringify(g.sort(Wi)),_=Hi(i);return g.length<=200?`${m}.indexOf(${_}) !== -1`:`function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(${_}, ${m},0,${g.length-1})`}function Gi(i){return"$id"===i?'"id" in f':`${JSON.stringify(i)} in p`}function ji(i){return`!(${i})`}function Wi(i,g){return i<g?-1:i>g?1:0}function qi(i){const g=i._toJSON(),m=g.feature;return m.type=Di.indexOf(m.geometry.type),m.subType=g.subType,m}function Xi(i){if(!Array.isArray(i))return Xi([i]);const g=[];for(let m=0;m<i.length;m++){let _;_=!0===i[m].filter?function(){return!0}:Fi(i[m].filter),g.push(Zi({},i[m],{filter:_}))}return g}function Zi(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}var $i=[],Yi={};function Qi(i,g){return Ei(i,(function(){var i=g.getMap();return function(i,g,m){return i[0]=g,i[1]=m,i}($i,i?i.getZoom():12,I({},g.getProperties(),function(i,g,m,_){return i["{bearing}"]=g,i["{pitch}"]=m,i["{zoom}"]=_,i}(Yi,i&&i.getBearing()||0,i&&i.getPitch()||0,i?i.getZoom():10)))}))}var Ji=Object.freeze({__proto__:null,compileStyle:Xi,createFilter:Fi,getFilterFeature:qi,getFunctionTypeResources:Ri,hasFunctionDefinition:ki,interpolated:Oi,isFeatureFilter:function i(g){if(!0===g||!1===g)return!0;if(!Array.isArray(g)||0===g.length)return!1;switch(g[0]){case"has":case"!has":return 2===g.length&&("string"==typeof g[1]||g[1].property&&g[1].op);case"in":case"!in":return g.length>=2&&("string"==typeof g[1]||g[1].property&&g[1].op);case"==":case"!=":case">":case">=":case"<":case"<=":return 3===g.length&&("string"==typeof g[1]||g[1].property&&g[1].op);case"none":case"any":case"all":for(const m of g.slice(1))if(!i(m)&&"boolean"!=typeof m)return!1;return!0;case"contains":return!0;default:return!1}},isFunctionDefinition:Ii,loadFunctionTypes:Ei,loadGeoSymbol:Qi});function Ki(i){var g={stroke:{stroke:i.markerLineColor,"stroke-width":i.markerLineWidth,"stroke-opacity":i.markerLineOpacity,"stroke-dasharray":null,"stroke-linecap":"butt","stroke-linejoin":"round"},fill:{fill:i.markerFill,"fill-opacity":i.markerFillOpacity}};return 0===g.stroke["stroke-width"]&&(g.stroke["stroke-opacity"]=0),g}function to(i,g,m){if(!i.markerPath)return null;var _=1,b=Ki(i);W(i.markerOpacity)&&(_=i.markerOpacity),W(i.opacity)&&(_*=i.opacity);var T,P={};if(b){for(var q in b.stroke)b.stroke.hasOwnProperty(q)&&(H(b.stroke[q])||(P[q]=b.stroke[q]));for(var $ in b.fill)b.fill.hasOwnProperty($)&&(H(b.fill[$])||(P[$]=b.fill[$]))}var Re,Be=i.markerPath;T=ye(Be)&&"$"===Be[0]?ai.getResource(Be.substring(1,1/0))||[]:Array.isArray(i.markerPath)?i.markerPath:[i.markerPath];for(var Ge=[],je=0;je<T.length;je++)(Re=I({},Re=ye(T[je])?{path:T[je]}:T[je],P)).d=Re.path,delete Re.path,Ge.push(Re);var Xe=['<svg version="1.1"','xmlns="http://www.w3.org/2000/svg"'];_<1&&Xe.push('opacity="'+_+'"'),i.markerPathWidth&&i.markerPathHeight&&Xe.push('viewBox="0 0 '+i.markerPathWidth+" "+i.markerPathHeight+'"'),Xe.push('preserveAspectRatio="none"'),g&&Xe.push('width="'+g+'"'),m&&Xe.push('height="'+m+'"'),Xe.push("><defs></defs>");for(var Ze=0;Ze<Ge.length;Ze++)if(Ge[Ze].d instanceof Element)Xe.push(Ge[Ze].d.outerHTML);else{var Ye="<path ";for(var Qe in Ge[Ze])Ge[Ze].hasOwnProperty(Qe)&&(Ye+=" "+Qe+'="'+Ge[Ze][Qe]+'"');Xe.push(Ye+="></path>")}return Xe.push("</svg>"),"data:image/svg+xml;base64,"+Nn(Xe.join(" "))}function no(i,g){if(!i)return[];var m=i;Array.isArray(i)||(m=[i]);for(var _,b,T,P,I=[],H=er,W=m.length-1;W>=0;W--)if(i=m[W]){g&&(i=ro(i));for(var q=0;q<H.length;q++)if(Ii(_=i[H[q]])&&(_=Ri(_)),_){Array.isArray(_)||(_=[_]);for(var $=0;$<_.length;$++)"url("===_[$].slice(0,4)&&(_[$]=Fn(_[$])),I.push([_[$],i[(b=tr[q])[0]],i[b[1]]])}if("path"===i.markerType&&i.markerPath)if(T=Ii(i.markerWidth)?200:i.markerWidth,P=Ii(i.markerHeight)?200:i.markerHeight,Ii(i.markerPath)){_=Ri(i.markerPath);for(var ye=i.markerPath,Re=0;Re<_.length;Re++)i.markerPath=_[Re],I.push([to(i),T,P]);i.markerPath=ye}else I.push([to(i),T,P])}return I}function ro(i){if(!i)return null;var g=i;if(m)return g;for(var _,b=er,T=0,P=b.length;T<P;T++)(_=g[b[T]])&&(g[b[T]]=io(_));return g}function io(i){if(Ii(i)&&i.stops){for(var g=i.stops,m=0;m<g.length;m++)g[m][1]=io(g[m][1]);return i}return"url("===i.slice(0,4)&&(i=Fn(i)),i}function oo(i){return i&&$t.decodeImageInWorker&&i instanceof ImageBitmap}function so(i){return i&&i.colorStops}function ao(i){var g=[i.type];if(i.places&&g.push(i.places.join()),i.colorStops){for(var m=[],_=i.colorStops.length-1;_>=0;_--)m.push(i.colorStops[_].join());g.push(m.join(","))}return g.join("_")}function lo(i,g){if(!i)return 1;var m=[];if(Array.isArray(i)){for(var _=0;_<i.length;_++)m.push(lo(i[_],g));return m.sort().join(",")}var b=Object.keys(i).sort().reduce((function(m,_){return g&&0!==_.indexOf(g)||(m[_]=i[_]),m}),{});return Tr(JSON.stringify(b))}function ho(i,g){function m(i,g){H(i.opacity)?i.opacity=g:i.opacity*=g}var _;if(Array.isArray(i)){_=[];for(var b=0;b<i.length;b++){var T=I({},i[b]);m(T,g),_.push(T)}}else m(_=I({},i),g);return _}function co(...i){var g=i[0],m=Array.prototype.slice.call(i,1);if(m&&m.length||(m=[{}]),Array.isArray(g)){for(var _,b,T=[],P=0,W=g.length;P<W;P++){_=g[P],b={};for(var q=0,$=m.length;q<$;q++)Array.isArray(m[q])?H(m[q][P])?I(b,_||{}):I(b,_,m[q][P]):I(b,_,m[q]?m[q]:{});T.push(b)}return T}var ye=[{},g];return ye.push.apply(ye,m),I.apply(this,ye)}function uo(i){if(i.symbol&&(i=[i]),Array.isArray(i))return i;var g=i.$root,m=i.$iconset;if(i=i.style,g||m){g&&"/"===g[g.length-1]&&(g=g.substring(0,g.length-1)),m&&"/"===m[m.length-1]&&(m=m.substring(0,m.length-1));fo(i,(function(i){return"{$root}"===i?g:"{$iconset}"===i?m:null}))}return i}function fo(i,g){for(var m=0;m<i.length;m++){var{symbol:_}=i[m];_&&mo(_,g)}}var go=/(\{\$root\}|\{\$iconset\})/g;function mo(i,g){for(var m in i)i.hasOwnProperty(m)&&"textName"!==m&&(ye(i[m])&&i[m].length>2?i[m]=i[m].replace(go,g):Ii(i[m])?i[m]=Ao(i[m],g):$(i[m])&&mo(i[m],g))}function Ao(i,g){var m=i.default;ye(m)&&(i.default=m.replace(go,g));var _=i.stops;if(!_)return i;for(var b=0;b<_.length;b++)Array.isArray(_[b])&&(ye(_[b][1])?_[b][1]=_[b][1].replace(go,g):Ii(_[b][1])&&(_[b][1]=Ao(_[b][1],g)));return i}function yo(i=[]){Array.isArray(i)||(i=[i]);for(var g=i.length,m=0;m<g;m++){var _=i[m];if(_.style){var{lineDasharray:b,lineWidth:T}=_.style;if(T&&W(T)&&T>0&&b&&Array.isArray(b)&&b.length)return!0}}return!1}function _o(i,g,m,_,b){var T=1/Math.tan(g/2),P=1/(_-b);return i[0]=T/m,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=T,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=(b+_)*P,i[11]=-1,i[12]=0,i[13]=0,i[14]=2*b*_*P,i[15]=0,i}function vo(i,g,m){var _,b,T,P,I,H,W,q,$,ye,Re,Be,Ge=m[0],je=m[1],Xe=m[2];return g===i?(i[12]=g[0]*Ge+g[4]*je+g[8]*Xe+g[12],i[13]=g[1]*Ge+g[5]*je+g[9]*Xe+g[13],i[14]=g[2]*Ge+g[6]*je+g[10]*Xe+g[14],i[15]=g[3]*Ge+g[7]*je+g[11]*Xe+g[15]):(b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=g[9],Re=g[10],Be=g[11],i[0]=_=g[0],i[1]=b,i[2]=T,i[3]=P,i[4]=I,i[5]=H,i[6]=W,i[7]=q,i[8]=$,i[9]=ye,i[10]=Re,i[11]=Be,i[12]=_*Ge+I*je+$*Xe+g[12],i[13]=b*Ge+H*je+ye*Xe+g[13],i[14]=T*Ge+W*je+Re*Xe+g[14],i[15]=P*Ge+q*je+Be*Xe+g[15]),i}function xo(i,g,m){var _=m[0],b=m[1],T=m[2];return i[0]=g[0]*_,i[1]=g[1]*_,i[2]=g[2]*_,i[3]=g[3]*_,i[4]=g[4]*b,i[5]=g[5]*b,i[6]=g[6]*b,i[7]=g[7]*b,i[8]=g[8]*T,i[9]=g[9]*T,i[10]=g[10]*T,i[11]=g[11]*T,i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15],i}function bo(i,g,m){var _=Math.sin(m),b=Math.cos(m),T=g[4],P=g[5],I=g[6],H=g[7],W=g[8],q=g[9],$=g[10],ye=g[11];return g!==i&&(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[4]=T*b+W*_,i[5]=P*b+q*_,i[6]=I*b+$*_,i[7]=H*b+ye*_,i[8]=W*b-T*_,i[9]=q*b-P*_,i[10]=$*b-I*_,i[11]=ye*b-H*_,i}function wo(i,g,m){var _=Math.sin(m),b=Math.cos(m),T=g[0],P=g[1],I=g[2],H=g[3],W=g[4],q=g[5],$=g[6],ye=g[7];return g!==i&&(i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[0]=T*b+W*_,i[1]=P*b+q*_,i[2]=I*b+$*_,i[3]=H*b+ye*_,i[4]=W*b-T*_,i[5]=q*b-P*_,i[6]=$*b-I*_,i[7]=ye*b-H*_,i}function To(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=g[9],Re=g[10],Be=g[11],Ge=g[12],je=g[13],Xe=g[14],Ze=g[15],Ye=m[0],Qe=m[1],Je=m[2],Ke=m[3];return i[0]=Ye*_+Qe*I+Je*$+Ke*Ge,i[1]=Ye*b+Qe*H+Je*ye+Ke*je,i[2]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[3]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[4]=(Ye=m[4])*_+(Qe=m[5])*I+(Je=m[6])*$+(Ke=m[7])*Ge,i[5]=Ye*b+Qe*H+Je*ye+Ke*je,i[6]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[7]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[8]=(Ye=m[8])*_+(Qe=m[9])*I+(Je=m[10])*$+(Ke=m[11])*Ge,i[9]=Ye*b+Qe*H+Je*ye+Ke*je,i[10]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[11]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[12]=(Ye=m[12])*_+(Qe=m[13])*I+(Je=m[14])*$+(Ke=m[15])*Ge,i[13]=Ye*b+Qe*H+Je*ye+Ke*je,i[14]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[15]=Ye*P+Qe*q+Je*Be+Ke*Ze,i}function So(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8],$=g[9],ye=g[10],Re=g[11],Be=g[12],Ge=g[13],je=g[14],Xe=g[15],Ze=m*I-_*P,Ye=m*H-b*P,Qe=m*W-T*P,Je=_*H-b*I,Ke=_*W-T*I,et=b*W-T*H,tt=q*Ge-$*Be,at=q*je-ye*Be,ht=q*Xe-Re*Be,gt=$*je-ye*Ge,yt=$*Xe-Re*Ge,vt=ye*Xe-Re*je,xt=Ze*vt-Ye*yt+Qe*gt+Je*ht-Ke*at+et*tt;return xt?(i[0]=(I*vt-H*yt+W*gt)*(xt=1/xt),i[1]=(b*yt-_*vt-T*gt)*xt,i[2]=(Ge*et-je*Ke+Xe*Je)*xt,i[3]=(ye*Ke-$*et-Re*Je)*xt,i[4]=(H*ht-P*vt-W*at)*xt,i[5]=(m*vt-b*ht+T*at)*xt,i[6]=(je*Qe-Be*et-Xe*Ye)*xt,i[7]=(q*et-ye*Qe+Re*Ye)*xt,i[8]=(P*yt-I*ht+W*tt)*xt,i[9]=(_*ht-m*yt-T*tt)*xt,i[10]=(Be*Ke-Ge*Qe+Xe*Ze)*xt,i[11]=($*Qe-q*Ke-Re*Ze)*xt,i[12]=(I*at-P*gt-H*tt)*xt,i[13]=(m*gt-_*at+b*tt)*xt,i[14]=(Ge*Ye-Be*Je-je*Ze)*xt,i[15]=(q*Je-$*Ye+ye*Ze)*xt,i):null}function Mo(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function Co(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15],i}var Po=Object.freeze({__proto__:null,DEFAULT_FONT:vr,DEFAULT_TEXTSIZE:xr,EMPTY_STRING:or,GUID:mn,IS_NODE:m,UID:gn,_defaults:function(i,g){for(var m=Object.getOwnPropertyNames(g),_=0;_<m.length;_++){var b=m[_],T=Object.getOwnPropertyDescriptor(g,b);T&&T.configurable&&void 0===i[b]&&Object.defineProperty(i,b,T)}return i},b64toBlob:Hn,btoa:Nn,calCanvasSize:Yn,get cancelAnimFrame(){return hn},checkMTKVersion:b,clamp:Pn,computeDegree:Bn,convertResourceUrl:ro,convertStylePath:fo,copy:Co,describeText:yr,emptyImageUrl:Vn,equalMapView:Un,escapeSpecialChars:cr,extend:I,extendSymbol:co,extractCssUrl:Fn,flash:jn,forEachCoord:bn,getAbsoluteURL:Zn,getAlignPoint:_r,getExternalResources:no,getFont:br,getGlobalThis:_,getGradientStamp:ao,getImageBitMap:qn,getMarkerPathBase64:to,getPointsResultPts:Wn,getSymbolHash:lo,getSymbolStamp:function(i,g){return lo(i,g)},getValueOrDefault:wn,hasOwn:Ge,hashCode:Tr,identity:Mo,interpolate:Mn,invert:So,isArrayHasData:kn,isCssUrl:Dn,isDashLine:yo,isEmpty:function(i){var g;for(g in i)return!1;return!g},isFunction:Re,isGradient:so,isImageBitMap:oo,isInteger:q,isNil:H,isNoContentHttpCode:function(i){return 204===i||i>=400&&i<500||501===i},isNumber:W,isObject:$,isSVG:fn,isString:ye,isURL:En,join:function(i,g){return i.join?i.join(g||","):Array.prototype.join.call(i,g||",")},loadImage:dn,log2:function(i){if(Math.log2)return Math.log2(i);var g=Math.log(i)*Math.LOG2E,m=Math.round(g);return Math.abs(m-g)<1e-14?m:g},lowerSymbolOpacity:ho,mergeArray:_n,multiply:To,now:P,parseJSON:An,parseStyleRootPath:uo,parseSymbolPath:mo,perspective:_o,pushIn:yn,removeFromArray:xn,replaceAll:lr,replaceVariable:Ar,get requestAnimFrame(){return ln},rotateX:bo,rotateZ:wo,scale:xo,sign:Sn,splitContent:gr,splitTextToRow:wr,splitWords:ur,stringLength:pr,stringWidth:dr,toDegree:Ze,toRadian:Xe,translate:vo,translateToSVGStyles:Ki,trim:sr,wrap:Cn});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function Io(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var ko=Oo;function Oo(i,g,m){var _,b,T,P,I,H=i.length,W=Ro(i[0],g),q=[];for(m||(m=[]),_=1;_<H;_++){for(b=i[_-1],P=I=Ro(T=i[_],g);;){if(!(W|P)){q.push(b),P!==I?(q.push(T),_<H-1&&(m.push(q),q=[])):_===H-1&&q.push(T);break}if(W&P)break;W?W=Ro(b=Eo(b,T,W,g),g):P=Ro(T=Eo(b,T,P,g),g)}W=I}return q.length&&m.push(q),m}function Eo(i,g,m,_){return 8&m?[i[0]+(g[0]-i[0])*(_[3]-i[1])/(g[1]-i[1]),_[3]]:4&m?[i[0]+(g[0]-i[0])*(_[1]-i[1])/(g[1]-i[1]),_[1]]:2&m?[_[2],i[1]+(g[1]-i[1])*(_[2]-i[0])/(g[0]-i[0])]:1&m?[_[0],i[1]+(g[1]-i[1])*(_[0]-i[0])/(g[0]-i[0])]:null}function Ro(i,g){var m=0;return i[0]<g[0]?m|=1:i[0]>g[2]&&(m|=2),i[1]<g[1]?m|=4:i[1]>g[3]&&(m|=8),m}Oo.polyline=Oo,Oo.polygon=function(i,g){var m,_,b,T,P,I,H;for(_=1;_<=8;_*=2){for(m=[],T=!(Ro(b=i[i.length-1],g)&_),P=0;P<i.length;P++)(H=!(Ro(I=i[P],g)&_))!==T&&m.push(Eo(b,I,_,g)),H&&m.push(I),b=I,T=H;if(!(i=m).length)break}return m};var Lo=Io(ko),Do=1/0,Fo=1/0,No=-1/0,Ho=-1/0;function Bo(){return[Do,Fo,No,Ho]}var zo=Bo();function Uo(i){i[0]=Do,i[1]=Fo,i[2]=No,i[3]=Ho}function Go(i,g){if(i)if(Array.isArray(i[0]))for(var m=0,_=i.length;m<_;m++)Go(i[m],g);else if(Array.isArray(i))for(var b=0,T=i.length;b<T;b++){var{x:P,y:I}=i[b];g[0]=Math.min(P,g[0]),g[1]=Math.min(I,g[1]),g[2]=Math.max(P,g[2]),g[3]=Math.max(I,g[3])}else{var{x:H,y:W}=i;g[0]=Math.min(H,g[0]),g[1]=Math.min(W,g[1]),g[2]=Math.max(H,g[2]),g[3]=Math.max(W,g[3])}}function jo(i,g,m,_,b){(0===g||g)&&(Array.isArray(g)&&(m=g[1],_=g[2],b=g[3],g=g[0]),i[0]=Math.min(g,i[0]),i[1]=Math.min(m,i[1]),i[2]=Math.max(_,i[2]),i[3]=Math.max(b,i[3]))}function Wo(i){return i&&i[0]!==1/0&&void 0!==i[0]}function qo(i,g=0){i[0]-=g,i[1]-=g,i[2]+=g,i[3]+=g}function Xo(i,g){return!(i[2]<g[0])&&(!(i[1]>g[3])&&(!(i[0]>g[2])&&!(i[3]<g[1])))}function Zo(i,g){var[m,_,b,T]=i;return m>=g[0]&&b<=g[2]&&_>=g[1]&&T<=g[3]}function $o(i,g){var m=g.bbox;if(!m)return console.error("maskGeoJSON bbox is null:",g),!1;if(Xo(m,i)){var _=g.geometry;if(!_)return console.error("maskGeoJSON is error,not find geometry.",g),!1;var{coordinates:b}=_;"Polygon"===_.type&&(b=[b]);for(var T=0,P=b.length;T<P;T++){var I=Lo.polygon(b[T][0],i);if(I.length>0){for(var H=1/0,W=-1/0,q=1/0,$=-1/0,ye=0,Re=I.length;ye<Re;ye++){var[Be,Ge]=I[ye];H=Math.min(Be,H),q=Math.min(Ge,q),W=Math.max(Be,W),$=Math.max(Ge,$)}if(H!==W&&q!==$)return!0}}return!1}return!1}var Yo=Object.freeze({__proto__:null,BBOX_TEMP:zo,bboxInBBOX:Zo,bboxInMask:$o,bboxIntersect:Xo,bufferBBOX:qo,getDefaultBBOX:Bo,pointsBBOX:Go,resetBBOX:Uo,setBBOX:jo,validateBBOX:Wo}),Qo=function(){function i(){this.resources=new Map,this._errors=new Map}var g=i.prototype;return g.addResource=function(i,g){var m=this,_=this._getImgUrl(i);if(this.resources.set(_,{image:g,width:+i[1],height:+i[2],refCnt:0}),g&&g.width&&g.height&&!g.close&&$t.imageBitMap&&!$t.safari&&!$t.iosWeixin){if(g.src&&fn(g.src))return;createImageBitmap(g).then((function(i){m.resources.has(_)&&(m.resources.get(_).image=i)}))}},g.isResourceLoaded=function(i,g){if(!i)return!1;var m=this._getImgUrl(i);if(this._errors.has(m))return!0;var _=this.resources.get(m);return!!_&&!(g&&fn(i[0])&&(+i[1]>_.width||+i[2]>_.height))},g.login=function(i){var g=this.resources.get(i);g&&g.refCnt++},g.logout=function(i){var g=this.resources.get(i);g&&g.refCnt--<=0&&(g.image&&g.image.close&&g.image.close(),this.resources.delete(i))},g.getImage=function(i){var g=this._getImgUrl(i);return!this.isResourceLoaded(i)||this._errors.has(g)?null:this.resources.get(g).image},g.markErrorResource=function(i){var g=this._getImgUrl(i);this._errors.set(g,1)},g.merge=function(i){var g=this;if(!i)return this;var m=i.resources;return m&&m.forEach((function(i,m){g.addResource([m,i.width,i.height],i.image)})),this},g.forEach=function(i){return this.resources?(this.resources.forEach((function(g,m){i(m,g)})),this):this},g._getImgUrl=function(i){return oo(i)?i:Array.isArray(i)?i[0]:i},g.remove=function(){return this.resources?(this.resources.forEach((function(i){i&&i.image&&i.image.close&&i.image.close()})),this.resources.clear(),this):this},i}(),Jo=function(){function i(){this.resources={},this._errors={}}var g=i.prototype;return g.addResource=function(i,g){var m=this;if(this.resources[i[0]]={image:g,width:+i[1],height:+i[2],refCnt:0},g&&g.width&&g.height&&!g.close&&$t.imageBitMap&&!$t.safari&&!$t.iosWeixin){if(g.src&&fn(g.src))return;createImageBitmap(g).then((function(g){m.resources[i[0]]&&(m.resources[i[0]].image=g)}))}},g.isResourceLoaded=function(i,g){if(!i)return!1;var m=this._getImgUrl(i);if(this._errors[m])return!0;var _=this.resources[m];return!!_&&!(g&&fn(i[0])&&(+i[1]>_.width||+i[2]>_.height))},g.login=function(i){var g=this.resources[i];g&&g.refCnt++},g.logout=function(i){var g=this.resources[i];g&&g.refCnt--<=0&&(g.image&&g.image.close&&g.image.close(),delete this.resources[i])},g.getImage=function(i){var g=this._getImgUrl(i);return!this.isResourceLoaded(i)||this._errors[g]?null:this.resources[g].image},g.markErrorResource=function(i){this._errors[this._getImgUrl(i)]=1},g.merge=function(i){if(!i)return this;for(var g in i.resources){var m=i.resources[g];this.addResource([g,m.width,m.height],m.image)}return this},g.forEach=function(i){if(!this.resources)return this;for(var g in this.resources)Ge(this.resources,g)&&i(g,this.resources[g]);return this},g._getImgUrl=function(i){return Array.isArray(i)?i[0]:i},g.remove=function(){for(var i in this.resources){var g=this.resources[i];g&&g.image&&g.image.close&&g.image.close()}this.resources={}},i}();function Ko(){return $t.decodeImageInWorker?new Qo:new Jo}function es(i,g,m,_){return i[0]=g,i[1]=m,i[2]=_,i}function ts(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i}function rs(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i}function is(i,g,m){return rs(i,g,m)}function os(i){var g=i[0],m=i[1],_=i[2];return Math.sqrt(g*g+m*m+_*_)}function ss(i,g){var m=g[0],_=g[1],b=g[2],T=m*m+_*_+b*b;return T>0&&(T=1/Math.sqrt(T),i[0]=g[0]*T,i[1]=g[1]*T,i[2]=g[2]*T),i}function ls(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]}function hs(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i}function cs(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[0],I=m[1],H=m[2];return i[0]=b*H-T*I,i[1]=T*P-_*H,i[2]=_*I-b*P,i}function fs(i,g){var m=g[0]-i[0],_=g[1]-i[1],b=g[2]-i[2];return Math.hypot?Math.hypot(m,_,b):function(...i){var g=0,m=i.length;for(;m--;)g+=i[m]*i[m];return Math.sqrt(g)}(m,_,b)}function ds(i,g){ss(i,i),ss(g,g);var m=ls(i,g);return m>1?0:m<-1?Math.PI:Math.acos(m)}var ps,ms=function(){function i(i,g){this.normal=i,this.constant=g}return i.prototype.distanceToPoint=function(i){return ls(this.normal,i)+this.constant},i}(),As=[0,0,0],ys=[0,0,0],_s=[0,0,0],vs=[0,0,0],xs=[0,0,0],bs=new ms([0,0,1],0),ws=function(){function i(i,g){this.setFromTo(i,g)}var g=i.prototype;return g.setFromTo=function(i,g){this.origin=i;var m=this.direction||[0,0,0];this.direction=ss(m,is(m,g,i))},g.distanceToPlane=function(i){var g=ls(i.normal,this.direction);if(0===g)return 0===i.distanceToPoint(this.origin)?0:null;var m=-(ls(this.origin,i.normal)+i.constant)/g;return m>=0?m:null},g.intersectGround=function(i){return this.intersectPlane(bs,i)},g.distanceToGround=function(){return this.distanceToPlane(bs)},g.intersectPlane=function(i,g){var m=this.distanceToPlane(i);return null===m?null:this.at(m,g)},g.intersectBox=function(i,g){var m,_,b,T,P,I,H=1/this.direction[0],W=1/this.direction[1],q=1/this.direction[2],$=this.origin;return H>=0?(m=(i[0][0]-$[0])*H,_=(i[1][0]-$[0])*H):(m=(i[1][0]-$[0])*H,_=(i[0][0]-$[0])*H),W>=0?(b=(i[0][1]-$[1])*W,T=(i[1][1]-$[1])*W):(b=(i[1][1]-$[1])*W,T=(i[0][1]-$[1])*W),m>T||b>_?null:((b>m||isNaN(m))&&(m=b),(T<_||isNaN(_))&&(_=T),q>=0?(P=(i[0][2]-$[2])*q,I=(i[1][2]-$[2])*q):(P=(i[1][2]-$[2])*q,I=(i[0][2]-$[2])*q),m>I||P>_?null:((P>m||m!=m)&&(m=P),(I<_||_!=_)&&(_=I),_<0?null:this.at(m>=0?m:_,g)))},g.intersectTriangle=function(i,g,m,_,b){is(ys,g,i),is(_s,m,i),cs(vs,ys,_s);var T,P=ls(this.direction,vs);if(P>0){if(_)return null;T=1}else{if(!(P<0))return null;T=-1,P=-P}is(xs,this.origin,i),cs(_s,xs,_s);var I=T*ls(this.direction,_s);if(I<0)return null;cs(ys,ys,xs);var H=T*ls(this.direction,ys);if(H<0)return null;if(I+H>P)return null;var W=-T*ls(xs,vs);return W<0?null:this.at(W/P,b)},g.at=function(i,g){return function(i,g){i[0]=g[0],i[1]=g[1],i[2]=g[2]}(g,this.origin),ts(g,g,hs(As,this.direction,i))},i}(),Ts=Object.freeze({__proto__:null,Plane:ms,Ray:ws}),Ss="core-fetch-image";var Ms=!1;var Cs=[];function Ps(i){return Cs.indexOf(i)>-1}function Is(i){Ps(i)||Cs.push(i)}var ks={};function Os(i,g){ks[i]=g}var Es;function Rs(){if("undefined"==typeof window)return null;if(!Es){var i=function(){var i="\n    var adapters = {};\n    // Dynamic Create Adapter\n    function createAdapter(key,code){\n        if(adapters[key]||!code){\n            return;\n        }\n        var func=new Function('exports',code+'(exports)');\n        var workerExports={};\n        func(workerExports,self);\n        adapters[key]=workerExports;\n        workerExports.initialize && workerExports.initialize(self);\n\n    }\n    onmessage = function (msg) {\n        msg = msg.data;\n        //createAdapter\n        if (msg.messageType === 'createAdapter') {\n           var key=msg.key;\n           var code=msg.code;\n           createAdapter(key,code);\n           postMessage({adapterName:key});\n           return;\n        }\n        // postMessage when main thread idle\n        if(msg.messageType==='idle'){\n            var messageRatio = msg.messageRatio;\n            handleMessageQueue(messageRatio);\n            return;\n        }\n        if (msg.messageType === 'batch') {\n            const messages = msg.messages;\n            if (messages) {\n                for (let i = 0; i < messages.length; i++) {\n                    dispatch(messages[i]);\n                }\n            }\n        } else {\n            dispatch(msg);\n        }\n    };\n\n    function dispatch(msg) {\n        var workerKey = msg.workerKey;\n        var adapter = adapters[workerKey];\n        if (!adapter) {\n            post(msg.callback, 'Unregistered worker adapters for ' + workerKey);\n            return;\n        }\n        try {\n            adapter.onmessage(msg, wrap(msg.callback));\n        } catch (err) {\n            post(msg.callback, workerKey + ':' + err.message);\n            console.error(err);\n            throw err;\n        }\n    }\n\n    var messageResultQueue = [];\n\n    function handleMessageQueue(messageRatio){\n       if(messageResultQueue.length===0){\n          return;\n       }\n       var count = Math.ceil((messageRatio || 1) * messageResultQueue.length);\n       var queues = messageResultQueue.slice(0, count);\n       queues.forEach(function(queue){\n          post(queue.callback,queue.err,queue.data,queue.buffers);\n       });\n       messageResultQueue=messageResultQueue.slice(count, Infinity);\n    }\n\n    function post(callback, err, data, buffers) {\n        var msg = {\n            callback : callback\n        };\n        if (err) {\n            msg.error = err;\n        } else {\n            msg.data = data;\n        }\n        if (buffers && buffers.length > 0) {\n            postMessage(msg, buffers);\n        } else {\n            postMessage(msg);\n        }\n    }\n\n    function joinQueue(callback,err,data,buffers){\n        messageResultQueue.push({\n            callback:callback,\n            err:err,\n            data:data,\n            buffers:buffers\n        });\n    }\n\n    function wrap(callback) {\n        return function (err, data, buffers) {\n            joinQueue(callback, err, data, buffers);\n        };\n    }\n    var workerExports;\n";for(var g in ks){var m=ks[g];Is(g),Re(m)&&0===m.length&&(m=m()),i+="\n    workerExports = {};\n    ("+m+")(workerExports, self);\n    adapters['"+g+"'] = workerExports",i+="\n    workerExports.initialize && workerExports.initialize(self);\n        "}return i+"\n    workerExports = null;\n"}();Es=window.URL.createObjectURL(new Blob([i],{type:"text/javascript"})),ks={}}return Es}function Ls(i,g){if(ks[i]){var m=ks[i];Re(m)&&0===m.length&&(m=m()),m="("+m+")";if(ps){var _=ps.workers||[];0===_.length&&console.error("workerpool workers count is 0");var b=0,T=function(m){(m=m.data||{}).adapterName===i&&++b===_.length&&(_.forEach((function(i){i.removeEventListener("message",T)})),delete ks[i],g())};_.forEach((function(g){g.addEventListener("message",T),g.postMessage({key:i,code:m,messageType:"createAdapter"})}))}}else console.error("not find "+i+" adapter")}var Ds,Fs="undefined"!=typeof window?window.navigator.hardwareConcurrency||4:0,Ns=Math.max(Math.floor(Fs/2),1),Hs=function(){function i(i=50){this._limit=i,this._messages=[],this.buffers=[]}var g=i.prototype;return g.addMessage=function(i,g){if(this._messages.push(i),Array.isArray(g))for(var m=0;m<g.length;m++)this.buffers.indexOf(g[m])<0&&this.buffers.push(g[m])},g.isFull=function(){return this._messages.length>=this._limit},g.getMessage=function(){return{messageType:"batch",messages:this._messages}},i}(),Bs=function(){function i(){this.active={},this.workerCount="undefined"!=typeof window?T.workerCount||Ns:0,this._messages=[],this._messageBuffers=[]}var g=i.prototype;return g.acquire=function(i){if(!this.workers){this.workers=[];for(var g=Rs(),m=0;m<this.workerCount;m++){var _=new Worker(g);_.id=m,this.workers.push(_)}URL.revokeObjectURL(g),Ms=!0}return this.active[i]=!0,this.workers.slice()},g.release=function(i){delete this.active[i],0===Object.keys(this.active).length&&(this.workers.forEach((function(i){i.terminate()})),this.workers=null)},g.addMessage=function(i,g,m){var _=this._messages[i];_&&_.length||(_=this._messages[i]=[new Hs]);var b=_[_.length-1];b.isFull()&&(b=new Hs,this._messages[i].push(b)),b.addMessage(g,m)},g.commit=function(){if(this.workers&&this._messages.length)for(var i=0;i<this._messages.length;i++)if(this._messages[i]&&this._messages[i].length){var g=this._messages[i].shift();this.workers[i].postMessage(g.getMessage(),g.buffers)}},g.getWorkers=function(){return this.workers||[]},g.broadcastIdleMessage=function(i){return this.getWorkers().forEach((function(g){g.postMessage({messageType:"idle",messageRatio:i})})),this},i}();function zs(){return Ds||(Ds=new Bs,ps=Ds),Ds}var Vs=[],Us=[];function Gs(i){return $s(),new Promise((function(g,m){if(i)if(Re(i)&&(i={count:1,run:i}),i.run)if(H(i.count)&&(i.count=1),i.count=Math.ceil(i.count),W(i.count)){var _=i;_.results=[],Vs.push(_),_.resolve=g}else m(new Error("task.count is not number"));else m(new Error("task.run is null"));else m(new Error("task is null"))}))}function js(i){var g=T.messagePostRatioPerWorker*(i?.5:1);zs().commit(),zs().broadcastIdleMessage(g),function(){if(0!==Vs.length){for(var i=[],g=[],m=Vs.length,_=0;_<m;_++){var b=Vs[_];if(b.count--,-1===b.count)g.push(b);else{i.push(b);var T=b.run();b.results.push(T)}}Vs=i,m=g.length;for(var P=0;P<m;P++){var I=g[P];I.resolve&&I.resolve(I.results)}}}(),Us.forEach((function(i){i()}))}var Ws=P();function qs(){js(),Ws=P(),requestIdleCallback(qs)}function Xs(){if($t.requestIdleCallback){var{idleForceTimeThreshold:i,idleLog:g}=T;P()-Ws>i&&(js(!0),Ws=P(),g&&console.warn("did not apply for availability, forced run idle"))}else js();ln(Xs)}var Zs=!1;function $s(){Zs||(Zs=!0,$t.requestIdleCallback&&requestIdleCallback(qs),ln(Xs))}function Ys(i){Us.indexOf(i)>-1||Re(i)&&Us.push(i)}var Qs=Object.freeze({__proto__:null,pushLoopHook:Ys,runTaskAsync:Gs,startTasks:$s}),Js=function(){function i(i,g){this.max=i,this.onRemove=g||function(){},this.reset()}var g=i.prototype;return g.reset=function(){if(this.data)for(var i,g=Kt(this.data.values());!(i=g()).done;){this.onRemove(i.value)}return this.data=new Map,this},g.clear=function(){this.reset(),delete this.onRemove},g.add=function(i,g){return g?(this.has(i)?(this.data.delete(i),this.data.set(i,g)):this.data.set(i,g),this):this},g.keys=function(){for(var i,g=new Array(this.data.size),m=0,_=Kt(this.data.keys());!(i=_()).done;){g[m++]=i.value}return g},g.shrink=function(){for(var i=this.data.keys(),g=i.next();this.data.size>this.max;){var m=this.getAndRemove(g.value);m&&this.onRemove(m),g=i.next()}},g.has=function(i){return this.data.has(i)},g.getAndRemove=function(i){if(!this.has(i))return null;var g=this.data.get(i);return this.data.delete(i),g},g.get=function(i){return this.has(i)?this.data.get(i):null},g.remove=function(i){if(!this.has(i))return this;var g=this.data.get(i);return this.data.delete(i),this.onRemove(g),this},g.setMaxSize=function(i){return this.max=i,this.data.size>this.max&&this.shrink(),this},i}(),Ks={exports:{}},ea={exports:{}};!function(i){i.exports=function(){function i(i,m,b,T,P){g(i,m,b||0,T||i.length-1,P||_)}function g(i,_,b,T,P){for(;T>b;){if(T-b>600){var I=T-b+1,H=_-b+1,W=Math.log(I),q=.5*Math.exp(2*W/3),$=.5*Math.sqrt(W*q*(I-q)/I)*(H-I/2<0?-1:1);g(i,_,Math.max(b,Math.floor(_-H*q/I+$)),Math.min(T,Math.floor(_+(I-H)*q/I+$)),P)}var ye=i[_],Re=b,Be=T;for(m(i,b,_),P(i[T],ye)>0&&m(i,b,T);Re<Be;){for(m(i,Re,Be),Re++,Be--;P(i[Re],ye)<0;)Re++;for(;P(i[Be],ye)>0;)Be--}0===P(i[b],ye)?m(i,b,Be):m(i,++Be,T),Be<=_&&(b=Be+1),_<=Be&&(T=Be-1)}}function m(i,g,m){var _=i[g];i[g]=i[m],i[m]=_}function _(i,g){return i<g?-1:i>g?1:0}return i}()}(ea);var ta=ea.exports;Ks.exports=ra,Ks.exports.default=ra;var na=ta;function ra(i,g){if(!(this instanceof ra))return new ra(i,g);this._maxEntries=Math.max(4,i||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),g&&this._initFormat(g),this.clear()}function ia(i,g,m){if(!m)return g.indexOf(i);for(var _=0;_<g.length;_++)if(m(i,g[_]))return _;return-1}function oa(i,g){sa(i,0,i.children.length,g,i)}function sa(i,g,m,_,b){b||(b=ma(null)),b.minX=1/0,b.minY=1/0,b.maxX=-1/0,b.maxY=-1/0;for(var T,P=g;P<m;P++)T=i.children[P],aa(b,i.leaf?_(T):T);return b}function aa(i,g){return i.minX=Math.min(i.minX,g.minX),i.minY=Math.min(i.minY,g.minY),i.maxX=Math.max(i.maxX,g.maxX),i.maxY=Math.max(i.maxY,g.maxY),i}function la(i,g){return i.minX-g.minX}function ha(i,g){return i.minY-g.minY}function ca(i){return(i.maxX-i.minX)*(i.maxY-i.minY)}function ua(i){return i.maxX-i.minX+(i.maxY-i.minY)}function fa(i,g){return(Math.max(g.maxX,i.maxX)-Math.min(g.minX,i.minX))*(Math.max(g.maxY,i.maxY)-Math.min(g.minY,i.minY))}function da(i,g){var m=Math.max(i.minX,g.minX),_=Math.max(i.minY,g.minY),b=Math.min(i.maxX,g.maxX),T=Math.min(i.maxY,g.maxY);return Math.max(0,b-m)*Math.max(0,T-_)}function pa(i,g){return i.minX<=g.minX&&i.minY<=g.minY&&g.maxX<=i.maxX&&g.maxY<=i.maxY}function ga(i,g){return g.minX<=i.maxX&&g.minY<=i.maxY&&g.maxX>=i.minX&&g.maxY>=i.minY}function ma(i){return{children:i,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function Aa(i,g,m,_,b){for(var T,P=[g,m];P.length;)(m=P.pop())-(g=P.pop())<=_||(T=g+Math.ceil((m-g)/_/2)*_,na(i,T,g,m,b),P.push(g,T,T,m))}ra.prototype={all:function(){return this._all(this.data,[])},search:function(i){var g=this.data,m=[],_=this.toBBox;if(!ga(i,g))return m;for(var b,T,P,I,H=[];g;){for(b=0,T=g.children.length;b<T;b++)P=g.children[b],ga(i,I=g.leaf?_(P):P)&&(g.leaf?m.push(P):pa(i,I)?this._all(P,m):H.push(P));g=H.pop()}return m},collides:function(i){var g=this.data,m=this.toBBox;if(!ga(i,g))return!1;for(var _,b,T,P,I=[];g;){for(_=0,b=g.children.length;_<b;_++)if(T=g.children[_],ga(i,P=g.leaf?m(T):T)){if(g.leaf||pa(i,P))return!0;I.push(T)}g=I.pop()}return!1},load:function(i){if(!i||!i.length)return this;if(i.length<this._minEntries){for(var g=0,m=i.length;g<m;g++)this.insert(i[g]);return this}var _=this._build(i.slice(),0,i.length-1,0);if(this.data.children.length)if(this.data.height===_.height)this._splitRoot(this.data,_);else{if(this.data.height<_.height){var b=this.data;this.data=_,_=b}this._insert(_,this.data.height-_.height-1,!0)}else this.data=_;return this},insert:function(i){return i&&this._insert(i,this.data.height-1),this},clear:function(){return this.data=ma([]),this},remove:function(i,g){if(!i)return this;for(var m,_,b,T,P=this.data,I=this.toBBox(i),H=[],W=[];P||H.length;){if(P||(P=H.pop(),_=H[H.length-1],m=W.pop(),T=!0),P.leaf&&-1!==(b=ia(i,P.children,g)))return P.children.splice(b,1),H.push(P),this._condense(H),this;T||P.leaf||!pa(P,I)?_?(m++,P=_.children[m],T=!1):P=null:(H.push(P),W.push(m),m=0,_=P,P=P.children[0])}return this},toBBox:function(i){return i},compareMinX:la,compareMinY:ha,toJSON:function(){return this.data},fromJSON:function(i){return this.data=i,this},_all:function(i,g){for(var m=[];i;)i.leaf?g.push.apply(g,i.children):m.push.apply(m,i.children),i=m.pop();return g},_build:function(i,g,m,_){var b,T=m-g+1,P=this._maxEntries;if(T<=P)return oa(b=ma(i.slice(g,m+1)),this.toBBox),b;_||(_=Math.ceil(Math.log(T)/Math.log(P)),P=Math.ceil(T/Math.pow(P,_-1))),(b=ma([])).leaf=!1,b.height=_;var I,H,W,q,$=Math.ceil(T/P),ye=$*Math.ceil(Math.sqrt(P));for(Aa(i,g,m,ye,this.compareMinX),I=g;I<=m;I+=ye)for(Aa(i,I,W=Math.min(I+ye-1,m),$,this.compareMinY),H=I;H<=W;H+=$)q=Math.min(H+$-1,W),b.children.push(this._build(i,H,q,_-1));return oa(b,this.toBBox),b},_chooseSubtree:function(i,g,m,_){for(var b,T,P,I,H,W,q,$;_.push(g),!g.leaf&&_.length-1!==m;){for(q=$=1/0,b=0,T=g.children.length;b<T;b++)H=ca(P=g.children[b]),(W=fa(i,P)-H)<$?($=W,q=H<q?H:q,I=P):W===$&&H<q&&(q=H,I=P);g=I||g.children[0]}return g},_insert:function(i,g,m){var _=m?i:(0,this.toBBox)(i),b=[],T=this._chooseSubtree(_,this.data,g,b);for(T.children.push(i),aa(T,_);g>=0&&b[g].children.length>this._maxEntries;)this._split(b,g),g--;this._adjustParentBBoxes(_,b,g)},_split:function(i,g){var m=i[g],_=m.children.length,b=this._minEntries;this._chooseSplitAxis(m,b,_);var T=this._chooseSplitIndex(m,b,_),P=ma(m.children.splice(T,m.children.length-T));P.height=m.height,P.leaf=m.leaf,oa(m,this.toBBox),oa(P,this.toBBox),g?i[g-1].children.push(P):this._splitRoot(m,P)},_splitRoot:function(i,g){this.data=ma([i,g]),this.data.height=i.height+1,this.data.leaf=!1,oa(this.data,this.toBBox)},_chooseSplitIndex:function(i,g,m){var _,b,T,P,I,H,W,q;for(H=W=1/0,_=g;_<=m-g;_++)P=da(b=sa(i,0,_,this.toBBox),T=sa(i,_,m,this.toBBox)),I=ca(b)+ca(T),P<H?(H=P,q=_,W=I<W?I:W):P===H&&I<W&&(W=I,q=_);return q},_chooseSplitAxis:function(i,g,m){var _=i.leaf?this.compareMinX:la,b=i.leaf?this.compareMinY:ha;this._allDistMargin(i,g,m,_)<this._allDistMargin(i,g,m,b)&&i.children.sort(_)},_allDistMargin:function(i,g,m,_){i.children.sort(_);var b,T,P=this.toBBox,I=sa(i,0,g,P),H=sa(i,m-g,m,P),W=ua(I)+ua(H);for(b=g;b<m-g;b++)T=i.children[b],aa(I,i.leaf?P(T):T),W+=ua(I);for(b=m-g-1;b>=g;b--)T=i.children[b],aa(H,i.leaf?P(T):T),W+=ua(H);return W},_adjustParentBBoxes:function(i,g,m){for(var _=m;_>=0;_--)aa(g[_],i)},_condense:function(i){for(var g,m=i.length-1;m>=0;m--)0===i[m].children.length?m>0?(g=i[m-1].children).splice(g.indexOf(i[m]),1):this.clear():oa(i[m],this.toBBox)},_initFormat:function(i){var g=["return a"," - b",";"];this.compareMinX=new Function("a","b",g.join(i[0])),this.compareMinY=new Function("a","b",g.join(i[1])),this.toBBox=new Function("a","return {minX: a"+i[0]+", minY: a"+i[1]+", maxX: a"+i[2]+", maxY: a"+i[3]+"};")}};var ya=Io(Ks.exports),_a={},va=function(){function i(){this._tree=ya(9,["[0]","[1]","[2]","[3]"])}var g=i.prototype;return g.collides=function(i){return[_a.minX,_a.minY,_a.maxX,_a.maxY]=i,this._tree.collides(_a)},g.insertBox=function(i){return this._tree.insert(i),this},g.bulkInsertBox=function(i){return this._tree.load(i),this},g.clear=function(){return this._tree.clear(),this},i}(),xa=new Js(5e4);function ba(i,g,m){var _=i.font,b=i.fillStyle,T=i.strokeStyle,P=g.textHaloFill||wa,I=g.textHaloRadius||0,H=g.textHaloOpacity;W(H)||(H=1);var q=_+"_"+b+"_"+P+"_"+I+"_"+H+"_"+m,$=xa.get(q);if(!$){var ye=0!==H&&0!==I,Re=2*(1.2*(g.textSize||14)+I),Be=Va.createCanvas(Re,Re);Be.style.width=Re/2+"px",Be.style.height=Re/2+"px";var Ge=Re/4,je=Re/4,Xe=Va.getCanvas2DContext(Be);Xe.scale(2,2),Xe.font=_,Xe.textAlign="center",Xe.textBaseline="middle",ye&&(Xe.strokeStyle=T,Xe.lineWidth=2*I,Xe.globalAlpha=1,Xe.globalAlpha*=H,Xe.strokeText(m,Ge,je),Xe.globalAlpha=1),Xe.fillStyle=b,Xe.fillText(m,Ge,je),xa.add(q,$=Be)}return $}var wa="#000",Ta=!1,Sa=null,Ma=Math.PI/180,Ca=new va,Pa=new va;var Ia,ka=function(){for(var i={},g=32;g<128;g++){var m=String.fromCharCode(g);i[m]=m}return i}();function Oa(i){if(i.toReversed)return i.toReversed();for(var g=[],m=0,_=i.length-1;m<=_;m++)g[m]=i[_-m];return g}function Ea(i,g,m,_,b){var T=Math.atan2(g.y-i.y,g.x-i.x),P=T/Math.PI*180;return"left"===_?T=(P+=180)/180*Math.PI:"down"!==_||b?"up"!==_||b?T:T=(P+=90)/180*Math.PI:T=(P-=90)/180*Math.PI}function Ra(i,g){var m=g,_=g;return ka[i]&&(m=g/4,_=g),Math.sqrt(m*m+_*_)}function La(i,g){var{distance:m,p1:_,p2:b}=i,T=g/m;return new un(_.x+T*(b.x-_.x),_.y+T*(b.y-_.y),(_.z||0)+T*((b.z||0)-(_.z||0)))}function Da(i){for(var g=i[0].point,m=i[i.length-1].point,_=Bo(),b=0,T=i.length;b<T;b++){Go(i[b].point,_)}var[P,I,H,W]=_,q=!0;return W-I>H-P&&(q=!1),q?g.x<m.x?"right":"left":g.y<m.y?"down":"up"}function Fa(i,g,m,_){var b=Ha(i),T=[],P=0,I=!1;Ca.clear();for(var H=1,W=0,q=g.length;W<q;W++){for(var $=g[W],ye=Ra($,m),Re=ye+P,Be=H,Ge=i.length;Be<Ge;Be++){var je=i[Be-1],Xe=i[Be];if(!(Xe.distance<Re)){H=Be;var Ze=(Re-je.distance)/(Xe.distance-je.distance),Ye=new un(je.x+(Xe.x-je.x)*Ze,je.y+(Xe.y-je.y)*Ze),{x:Qe,y:Je}=Ye,Ke=ye/3,et=[Qe-Ke,Je-Ke,Qe+Ke,Je+Ke];if(_&&_.collides(et)){I=!0;break}if(Ca.collides(et)){I=!0;break}Ca.insertBox(et),T.push({char:$,charSize:ye,point:Ye,bbox:[Qe-(Ke=ye/2),Je-Ke,Qe+Ke,Je+Ke]}),P+=ye;break}}if(I)break}return I||b<P?[]:T}function Na(i,g,m,_,b,T,P,I,H,W){var q=(i+m)/2,$=(g+_)/2,ye=(m+b)/2,Re=(_+T)/2,Be=(b+P)/2,Ge=(T+I)/2,je=Math.sqrt((m-i)*(m-i)+(_-g)*(_-g)),Xe=Math.sqrt((b-m)*(b-m)+(T-_)*(T-_)),Ze=je/(je+Xe),Ye=Xe/(Xe+Math.sqrt((P-b)*(P-b)+(I-T)*(I-T))),Qe=q+(ye-q)*Ze,Je=$+(Re-$)*Ze,Ke=ye+(Be-ye)*Ye,et=Re+(Ge-Re)*Ye,tt=Qe+(ye-Qe)*H+m-Qe,at=Je+(Re-Je)*H+_-Je,ht=Ke+(ye-Ke)*H+b-Ke,gt=et+(Re-et)*H+T-et,yt=[tt,at,ht,gt];return W<1?function(i,g,m,_,b,T,P,I,H,W){var q=1-i,$=1-g,ye=m*$*$+2*b*g*$+P*g*g,Re=b*$*$+2*P*g*$+H*g*g,Be=_*$*$+2*T*g*$+I*g*g,Ge=T*$*$+2*I*g*$+W*g*g;return[(m*q*q+2*b*i*q+P*i*i)*$+(b*q*q+2*P*i*q+H*i*i)*g,(_*q*q+2*T*i*q+I*i*i)*$+(T*q*q+2*I*i*q+W*i*i)*g,ye*q+Re*i,Be*q+Ge*i,ye*$+Re*g,Be*$+Ge*g]}(0,W,m,_,tt,at,ht,gt,b,T):yt}function Ha(i){if(i.length<2)return 0;var g=0;i[0].distance=0;for(var m=1,_=i.length;m<_;m++){var b=i[m-1],T=i[m],P=b.distanceTo(T);T.distance=P+b.distance,g+=P}return g}function Ba(i,g,m){var _=i.x,b=i.y;return new un(_+(g.x-_)*m,b+(g.y-b)*m)}function za(i,g,m,_){return"rgba("+i+", "+g+", "+m+", "+_/255+")"}var Va={getTempCanvas:function(){return Ia||(Ia=Va.createCanvas(1,1)),Ia},getCanvas2DPerformanceContext:function(i){return i.getContext("2d",{})},getCanvas2DContext:function(i){return i.getContext("2d",{willReadFrequently:!0})},setHitTesting:function(i){Ta=i},createCanvas:function(i,g,_){var b;return m?b=new _(i,g):((b=Or("canvas")).width=i,b.height=g),b},prepareCanvasFont:function(i,g,m){"top"!==i.textBaseline&&(i.textBaseline="top"),m=m||br(g),i.font!==m&&(i.font=m);var _=g.textFill;_||(_="#000");var b=Va.getRgba(_,g.textOpacity);i.fillStyle!==b&&(i.fillStyle=b)},prepareCanvas:function(i,g,m,_){if(g){var b=g.lineWidth;H(b)||i.lineWidth===b||(i.lineWidth=b);var T=g.linePatternFile,P=g.lineColor||wa,I=g.lineStrokeColor,W=g.lineStrokeWidth;if(i.lineStrokeColor=null,i.lineStrokeWidth=null,I&&(Array.isArray(I)&&(I=Va.normalizeColorToRGBA(I)),i.lineStrokeColor=I),W&&W>0&&(i.lineStrokeWidth=W),_)i.strokeStyle="#000";else if(T&&m){var q;(g.linePatternDx||g.linePatternDy)&&(q=[g.linePatternDx,g.linePatternDy]),Va._setStrokePattern(i,T,b,q,m),g.lineDasharray=[]}else so(P)?i.strokeStyle=g.lineGradientExtent?Va._createGradient(i,P,g.lineGradientExtent):wa:(Array.isArray(P)&&(P=Va.normalizeColorToRGBA(P)),i.strokeStyle=P);g.lineJoin&&(i.lineJoin=g.lineJoin),g.lineCap&&(i.lineCap=g.lineCap),i.setLineDash&&kn(g.lineDasharray)&&i.setLineDash(g.lineDasharray);var $=g.polygonPatternFile,ye=g.polygonFill||"rgba(255,255,255,0)";if(_)i.fillStyle="#000";else if($&&m){var Re=ja($),Be=m.getImage([Re,null,null]);if(Be||(Be=m.getImage([Re+"-texture",null,b])),fn(Re)&&Be instanceof Image&&($t.edge||$t.ie)){var Ge=Be.width||20,je=Be.height||20,Xe=Va.createCanvas(Ge,je);Va.image(Xe.getContext("2d"),Be,0,0,Ge,je),Be=Xe}Be?(i.fillStyle=i.createPattern(Be,"repeat"),(g.polygonPatternDx||g.polygonPatternDy)&&(i.fillStyle.polygonPatternOffset=[g.polygonPatternDx,g.polygonPatternDy])):"undefined"!=typeof console&&console.warn("img not found for",Re)}else so(ye)?i.fillStyle=g.polygonGradientExtent?Va._createGradient(i,ye,g.polygonGradientExtent):"rgba(255,255,255,0)":(Array.isArray(ye)&&(ye=Va.normalizeColorToRGBA(ye)),i.fillStyle=ye)}},_createGradient:function(i,g,m){var _=null,b=g.places,T=m.getMin(),P=m.getMax(),I=m.getWidth(),H=m.getHeight();if(g.type&&"linear"!==g.type){if("radial"===g.type){if(b){if(6!==b.length)throw new Error("A radial gradient's places should have 6 numbers.");b=[T.x+b[0]*I,T.y+b[1]*H,I*b[2],T.x+b[3]*I,T.y+b[4]*H,I*b[5]]}else{var W=m.getCenter()._round();b=[W.x,W.y,Math.abs(W.x-T.x),W.x,W.y,0]}_=i.createRadialGradient.apply(i,b)}}else{if(b){if(4!==b.length)throw new Error("A linear gradient's places should have 4 numbers.");b=[T.x+b[0]*I,T.y+b[1]*H,T.x+b[2]*I,T.y+b[3]*H]}else b=[T.x,T.y,P.x,T.y];_=i.createLinearGradient.apply(i,b)}return g.colorStops.forEach((function(i){_.addColorStop.apply(_,i)})),_},_setStrokePattern:function(i,g,_,b,T){var P,I=ja(g);if(m)P=T.getImage([I,null,_]);else{var H=I+"-texture-"+_;if(!(P=T.getImage(H))){var W=T.getImage([I,null,null]);if(W){var q;q=W.width&&W.height?Math.round(W.width*_/W.height):_;var $=Va.createCanvas(q,_,i.canvas.constructor);Va.image($.getContext("2d"),W,0,0,q,_),T.addResource([H,null,_],$),P=$}}}P?(i.strokeStyle=i.createPattern(P,"repeat"),i.strokeStyle.linePatternOffset=b):"undefined"!=typeof console&&console.warn("img not found for",I)},clearRect:function(i,g,m,_,b){i.canvas._drawn=!1,i.clearRect(g,m,_,b)},fillCanvas:function(i,g,m,_){if(Ta&&(g=1),i.canvas._drawn=!0,0!==g){var b,T=Va._isPattern(i.fillStyle),P=i.fillStyle&&i.fillStyle.polygonPatternOffset,I=P?P[0]:0,W=P?P[1]:0;H(g)&&(g=1),g<1&&(b=i.globalAlpha,i.globalAlpha*=g),T&&i.translate((m=m||0)+I,(_=_||0)+W),i.fill(),T&&i.translate(-m-I,-_-W),g<1&&(i.globalAlpha=b)}},getRgba:function(i,g){return H(g)&&(g=1),"#"===i[0]&&1===g?i:"#"!==i[0]?(Array.isArray(i)&&(i=Va.normalizeColorToRGBA(i,g)),i):(7===i.length?(m=parseInt(i.substring(1,3),16),_=parseInt(i.substring(3,5),16),b=parseInt(i.substring(5,7),16)):(m=17*parseInt(i.substring(1,2),16),_=17*parseInt(i.substring(2,3),16),b=17*parseInt(i.substring(3,4),16)),"rgba("+m+","+_+","+b+","+g+")");var m,_,b},normalizeColorToRGBA:function(i,g=1){return"rgba("+255*i[0]+", "+255*i[1]+", "+255*i[2]+", "+(4===i.length?i[3]:1)*g+")"},image:function(i,g,m,_,b,T){i.canvas._drawn=!0;try{W(b)&&W(T)?i.drawImage(g,m,_,b,T):i.drawImage(g,m,_)}catch(i){console&&(console.warn("error when drawing image on canvas:",i),console.warn(g))}},text:function(i,g,m,_,b){return Va._textOnMultiRow(i,b.rows,_,m,b.size,b.rawSize)},_textOnMultiRow:function(i,g,m,_,b,T){var P,I,H=_r(b,m.textHorizontalAlignment,m.textVerticalAlignment),W=T.height+m.textLineSpacing,q=_.add(0,H.y),$=m.textMaxHeight,ye=0;Uo(zo);for(var Re=0,Be=g.length;Re<Be;Re++){P=g[Re].text,I=_r(g[Re].size,m.textHorizontalAlignment,m.textVerticalAlignment);var Ge=q.add(I.x,Re*W);Va._textOnLine(i,P,Ge,m.textHaloRadius,m.textHaloFill,m.textHaloOpacity);var je=g[Re].size,Xe=Ge.x,Ze=Ge.y;if(jo(zo,Xe,Ze,Xe+je.width,Ze+je.height),$>0&&(ye+=W)+je.height>=$)break}return zo},_textOnLine:function(i,g,m,_,b,T){Ta&&(T=1);var P,I,H=0!==T&&0!==_;i.textBaseline="top";var W=i.shadowBlur,q=i.shadowOffsetX,$=i.shadowOffsetY;if(H){var ye=i.globalAlpha;i.globalAlpha*=T,i.miterLimit=2,i.lineJoin="round",i.lineCap="round",i.lineWidth=2*_,Array.isArray(b)&&(b=Va.normalizeColorToRGBA(b)),i.strokeStyle=b,i.strokeText(g,m.x,m.y+1),i.miterLimit=10,i.globalAlpha=ye,P=i.globalCompositeOperation,i.globalCompositeOperation="destination-out",I=i.fillStyle,i.fillStyle="#000"}W&&H&&(i.shadowBlur=i.shadowOffsetX=i.shadowOffsetY=0),Va.fillText(i,g,m),P&&(i.globalCompositeOperation=P,Va.fillText(i,g,m,I),W&&(i.shadowBlur=W,i.shadowOffsetX=q,i.shadowOffsetY=$))},fillText:function(i,g,m,_){i.canvas._drawn=!0,_&&(i.fillStyle=_),i.fillText(g,m.x,m.y+1)},textAlongLine:function(i,g,m,_,b,T){if(g){var P=_.textSize||14,I=_.textSpacing||0,H=function(i,g){for(var m=0,_=0,b=i.length;_<b;_++)m+=Ra(i[_],g);return m}(g,P);if(!(I<H)){Array.isArray(m[0])||(m=[m]);var q=i.textBaseline,$=i.textAlign,ye=i.strokeStyle,Re=i.globalAlpha,Be=i.lineWidth,Ge=_.textAlongDebug,je=_.textHaloFill||wa,Xe=_.textHaloRadius||0,Ze=_.textHaloOpacity;W(Ze)||(Ze=1);var Ye=0!==Ze&&0!==Xe;i.textBaseline="middle",i.textAlign="center",Ye&&(Array.isArray(je)&&(je=Va.normalizeColorToRGBA(je)),i.strokeStyle=je,i.lineWidth=2*Xe),Pa.clear();var Qe=Bo(),Je=g.split(""),Ke=function(i){for(var g=0,m=i.length;g<m;g++)if(!ka[i[g]])return!1;return!0}(Je);if(m.forEach((function(g){if(!(Ha(g)<H)){var m=function(i,g){g=Object.assign({segDistance:1,isGeo:!0},g);for(var m=Math.max(g.segDistance,1e-17),_=[],b=0,T=0,P=0,I=i.length;P<I-1;P++){var H=i[P],W=i[P+1],q=W.distanceTo(H);_[T]={p1:H,distance:q,p2:W},T++,b+=q}if(b<=m)return[{distance:b,points:i}];var $,ye=_.length;T=0;for(var Re=0,Be=[],Ge=[_[0].p1];T<ye;){var{distance:je,p2:Xe}=_[T];if((Re+=je)<m)Ge.push(Xe),T++;else if(Re!==m){if(Re>m){var Ze=m-(Re-je);$=La(_[T],Ze),Ge.push($),Be.push(Ge),Re=0,_[T].p1=$,_[T].distance=je-Ze,Ge=[$]}}else Ge.push(Xe),Re=0,Be.push(Ge),Ge=[Xe],T++}Ge.length&&Be.push(Ge);for(var Ye=[],Qe=0,Je=Be.length;Qe<Je;Qe++){var Ke=Be[Qe];Ye[Qe]={points:Ke,distance:Ha(Ke)}}return Ye}(g,{segDistance:I});if(m&&m.length)for(var b=0,W=m.length;b<W;b++){var q=m[b];if(!(q.distance<H)){var $=q.points;if(Ge){var ye=i.fillStyle;i.fillStyle="red";var{x:Re,y:Be}=$[0];i.beginPath(),i.fillRect(Re-2,Be-2,4,4),i.fillStyle=ye}var je=Je,Xe=Fa($,je,P,T);if(Xe.length){var Ze=Da(Xe);"left"===Ze&&(Xe=Fa($,je=Oa(je),P,T)),"up"!==Ze||Ke||(Xe=Fa($,je=Oa(je),P,T));for(var Ye=!1,et=0,tt=Xe.length;et<tt;et++){var{bbox:at}=Xe[et];if(Pa.collides(at)){Ye=!0;break}if(T&&T.collides(at)){Ye=!0;break}}if(!Ye)for(var ht=0,gt=Xe.length;ht<gt;ht++){var yt=void 0,vt=void 0;0===ht?(yt=Xe[ht].point,vt=Xe[1].point):ht===gt-1?(yt=Xe[gt-2].point,vt=Xe[gt-1].point):(yt=Xe[ht-1].point,vt=Xe[ht].point);var xt=je[ht],{point:bt,bbox:Tt}=Xe[ht];Pa.insertBox(Tt),T&&T.insertBox(Tt);var{x:Mt,y:Pt}=bt,It=Ea(yt,vt,0,Ze,Ke);i.save(),i.translate(Mt,Pt),i.rotate(It);var Et=ba(i,_,xt),{width:Lt,height:Dt}=Et;if(i.drawImage(Et,-Lt/4,-Dt/4,Lt/2,Dt/2),i.restore(),jo(Qe,Tt),Ge){var Ft=i.strokeStyle,Ht=i.lineWidth;i.strokeStyle="red",i.lineWidth=.5;var[Bt,zt,Vt,Ut]=Tt;i.beginPath(),i.rect(Bt,zt,Vt-Bt,Ut-zt),i.stroke(),i.lineWidth=Ht,i.strokeStyle=Ft}}}}}}})),i.textBaseline=q,i.textAlign=$,i.strokeStyle=ye,i.globalAlpha=Re,i.lineWidth=Be,Wo(Qe))return Qe}}},_stroke:function(i,g,m,_){if(Ta&&(g=1),i.canvas._drawn=!0,0!==g){!function(){if(i.lineStrokeColor&&i.lineStrokeWidth&&i.lineStrokeWidth>0){var m=i.lineStrokeColor,_=i.lineStrokeWidth,b=i.globalAlpha,T=i.strokeStyle,P=i.lineWidth;W(g)&&g<1&&(i.globalAlpha=1,i.globalAlpha*=g),i.lineWidth=P+2*_,i.strokeStyle=m,i.stroke(),i.lineWidth=P,i.strokeStyle=T,i.globalAlpha=b}}();var b,T=i.strokeStyle&&i.strokeStyle.linePatternOffset,P=T?T[0]:0,I=T?T[1]:0,q=Va._isPattern(i.strokeStyle)&&(!H(m)&&!H(_)||!H(P)&&!H(I));H(g)&&(g=1),g<1&&(b=i.globalAlpha,i.globalAlpha*=g),q&&i.translate((m=m||0)+P,(_=_||0)+I),i.stroke(),q&&i.translate(-m-P,-_-I),g<1&&(i.globalAlpha=b)}},_gradientPath:function(i,g,m,_,b=!1){if(W(_)||(_=1),Ta&&(_=1),0!==_&&0!==i.lineWidth){var T=i.globalAlpha;i.globalAlpha*=_;var P,I,H,q,$,ye,Re,Be=i.lineColorIn,Ge=function(i){if(W(i.minStep))return i.minStep;for(var g=i.colors||[],m=g.length,_=[],b=0;b<m;b++)_[b]=g[b][0];_.sort((function(i,g){return i-g}));for(var T=1/0,P=1;P<m;P++)T=Math.min(T,_[P]-_[P-1]);return i.minStep=T,T}(Be),je=Ha(g),Xe=0,[Ze,Ye,Qe,Je]=Be.getColor(0);P=za(Ze,Ye,Qe,Je);var Ke=g[0];if(H=Ke.x,q=Ke.y,b)Ke.equals(g[g.length-1])||g.push(Ke);for(var et=m&&Array.isArray(m)&&m.length>1,tt=function(){!et&&Re&&(i.strokeStyle=I,i.beginPath(),i.moveTo(H,q),i.lineTo($,ye),i.lineTo(Re.x,Re.y),i.stroke());var g=i.createLinearGradient(H,q,$,ye);g.addColorStop(0,P),g.addColorStop(1,I),i.strokeStyle=g,i.beginPath(),i.moveTo(H,q),i.lineTo($,ye),i.stroke(),P=I,H=$,q=ye},at=1,ht=g.length;at<ht;at++){var gt=g[at-1],yt=g[at];Re=g[at+1];var vt=yt.x,xt=yt.y,bt=yt.distanceTo(gt)/je;if(bt<=Ge){var[Tt,Mt,Pt,It]=Be.getColor(Xe+bt);I=za(Tt,Mt,Pt,It),$=vt,ye=xt,tt()}else{var Et=Math.ceil(bt/Ge);Re=yt;for(var Lt=1;Lt<=Et;Lt++){var Dt=Math.min(Lt*Ge,bt),[Ft,Ht,Bt,zt]=Be.getColor(Xe+Dt);if((I=za(Ft,Ht,Bt,zt))!==P){var Vt=Ba(gt,yt,Dt/bt);$=Vt.x,ye=Vt.y,tt()}}}Xe+=bt}i.globalAlpha=T}},_path:function(i,g,m,_,b){if(kn(g))for(var T,P=kn(m),I=!0!==b&&Va._isPattern(i.strokeStyle),H=0,W=g.length;H<W;H++)if(T=g[H],!P||i.setLineDash)i.lineTo(T.x,T.y),I&&H>0&&(q(g[H-1],T),i.beginPath(),i.moveTo(T.x,T.y));else if(P){if(H===W-1)break;Ua(i,T,g[H+1],m)}function q(g,m){var b=Bn(g.x,g.y,m.x,m.y);i.save();var T=Math.cos(b);Math.abs(T)<1e-7?i.translate(g.x-i.lineWidth/2,g.y):i.translate(g.x,g.y-i.lineWidth/2/T),i.rotate(b),Va._stroke(i,_),i.restore()}},path:function(i,g,m,_,b){kn(g)&&(i.lineColorIn?Va._gradientPath(i,g,b,m):(i.beginPath(),i.moveTo(g[0].x,g[0].y),Va._path(i,g,b,m)),Va._stroke(i,m))},roundRect:function(i,g,m,_){if($t.roundRect){for(var b=1/0,T=1/0,P=-1/0,I=-1/0,H=0,q=g.length;H<q;H++){var $=g[H],{x:ye,y:Re}=$;b=Math.min(b,ye),T=Math.min(T,Re),P=Math.max(P,ye),I=Math.max(I,Re)}var Be=Math.abs(P-b),Ge=Math.abs(I-T);if(!(Be*Ge<=0)){var je=Math.min(Be,Ge);i.roundRect(b,T,Be,Ge,je/4);var Xe=i.globalAlpha;W(_)&&_<1&&(i.globalAlpha=1,i.globalAlpha*=_),i.fill(),i.globalAlpha=Xe,W(m)&&m<1&&(i.globalAlpha=1,i.globalAlpha*=m),i.stroke(),i.globalAlpha=Xe}}},_multiClip:function(i,g){g&&0!==g.length&&g.forEach((function(g){for(var m=0,_=g.length;m<_;m++){var b=g[m],T=b.x,P=b.y;0===m?i.moveTo(T,P):i.lineTo(T,P),m===_-1&&i.lineTo(T=g[0].x,P=g[0].y)}}))},polygon:function(i,g,_,b,T,P){if(i.isMultiClip)Va._multiClip(i,g);else if(i.isClip)Va._multiClip(i,Array.isArray(g[0])?g:[g]);else if(kn(g)){var I=Va._isPattern(i.strokeStyle),H=kn(T)&&!i.setLineDash||I&&!P;kn(g[0])||(g=[g]);var W=i,q=i.dpr||1,$=1!==q;g.length>1&&!m&&(Sa||(Sa=Va.createCanvas(1,1)),i.canvas._drawn=!1,Sa.width=i.canvas.width,Sa.height=i.canvas.height,qa(i=Sa.getContext("2d"),[]),qa(i,T),Wa(i,W),$&&i.scale(q,q));var ye,Re,Be,Ge=i.lineColorIn,je=i.lineWidth;if(H){for(i.save(),Re=0,Be=g.length;Re<Be;Re++)kn(g[Re])&&(Ge&&(i.lineWidth=.1),Va._ring(i,g[Re],null,0,!0),ye=b,Re>0&&(i.globalCompositeOperation="destination-out",ye=1),Va.fillCanvas(i,ye,g[Re][0].x,g[Re][0].y),Re>0?i.globalCompositeOperation="source-over":Be>1&&(i.fillStyle="#fff"),Va._stroke(i,0),i.lineWidth=je,Ge&&Va._gradientPath(i,g,null,0,!0));i.restore()}var Xe=i.fillStyle;for(Re=0,Be=g.length;Re<Be;Re++)kn(g[Re])&&(Ge&&(i.lineWidth=.1),P?(Va.paintSmoothLine(i,g[Re],_,P,!0),i.closePath()):Va._ring(i,g[Re],T,_),H||(ye=b,Re>0&&(i.globalCompositeOperation="destination-out",ye=1),Va.fillCanvas(i,ye,g[Re][0].x,g[Re][0].y),Re>0?i.globalCompositeOperation="source-over":Be>1&&(i.fillStyle="#fff")),Va._stroke(i,_),i.lineWidth=je,Ge&&Va._gradientPath(i,g[Re],T,_,!0));if(i.fillStyle!==Xe&&(i.fillStyle=Xe),g.length>1&&!m){if($){var Ze=1/q;W.scale(Ze,Ze)}W.drawImage(Sa,0,0),$&&W.scale(q,q),W.canvas._drawn=i.canvas._drawn,Wa(W,i)}}},_ring:function(i,g,m,_,b){var T=Va._isPattern(i.strokeStyle);b||!T||g[0].equals(g[g.length-1])||(g=g.concat([g[0]])),i.beginPath(),i.moveTo(g[0].x,g[0].y),Va._path(i,g,m,_,b),T||i.closePath()},paintSmoothLine_bak:function(i,g,m,_,b,T,P){if(g)if(g.length<=2||!_)Va.path(i,g,m);else{var I,H=g.length,W=b?H:H-1;i.beginPath(),i.moveTo(g[0].x,g[0].y),void 0!==P&&(W-=Math.max(W-T-1,0));for(var q=0;q<W;q++){var $=void 0,ye=void 0,Re=void 0,Be=void 0,Ge=void 0,je=void 0;q-1<0?b?($=g[W-1].x,ye=g[W-1].y):($=g[q+1].x,ye=g[q+1].y):($=g[q-1].x,ye=g[q-1].y),q+1<H?(Re=g[q+1].x,Be=g[q+1].y):(Re=g[q+1-H].x,Be=g[q+1-H].y),q+2<H?(Ge=g[q+2].x,je=g[q+2].y):b?(Ge=g[q+2-H].x,je=g[q+2-H].y):(Ge=g[q].x,je=g[q].y);var Xe=Na($,ye,g[q].x,g[q].y,Re,Be,Ge,je,_,q===W-1?P:1);if(q===W-1&&P>=0&&P<1){i.bezierCurveTo(Xe[0],Xe[1],Xe[2],Xe[3],Xe[4],Xe[5]),g.splice(W-1,H-(W-1)-1);var Ze=new un(Xe[4],Xe[5]);Ze.prevCtrlPoint=new un(Xe[2],Xe[3]),g.push(Ze),H=g.length}else i.bezierCurveTo(Xe[0],Xe[1],Xe[2],Xe[3],Re,Be);g[q].nextCtrlPoint=Xe.slice(0,2),g[q].prevCtrlPoint=I?I.slice(2):null,I=Xe}!b&&g[1].prevCtrlPoint&&(g[0].nextCtrlPoint=g[1].prevCtrlPoint,delete g[0].prevCtrlPoint),g[H-1].prevCtrlPoint||(g[H-1].prevCtrlPoint=g[H-2].nextCtrlPoint),Va._stroke(i,m)}},paintSmoothLine:function(i,g,m,_,b,T,P){if(g)if(g.length<=2||!_)Va.path(i,g,m);else{var I,H,W=g.length,q=b?W:W-1;i.beginPath(),i.moveTo(g[0].x,g[0].y),void 0!==P&&(q-=Math.max(q-T-1,0));for(var $=0;$<q;$++){var ye=void 0,Re=void 0,Be=void 0,Ge=void 0,je=void 0,Xe=void 0;$-1<0?b?(ye=g[q-1].x,Re=g[q-1].y):(ye=g[$+1].x,Re=g[$+1].y):(ye=g[$-1].x,Re=g[$-1].y),$+1<W?(Be=g[$+1].x,Ge=g[$+1].y):(Be=g[$+1-W].x,Ge=g[$+1-W].y),$+2<W?(je=g[$+2].x,Xe=g[$+2].y):b?(je=g[$+2-W].x,Xe=g[$+2-W].y):(je=g[$].x,Xe=g[$].y);var Ze=g[$],Ye=Na(ye,Re,g[$].x,g[$].y,Be,Ge,je,Xe,_,$===q-1?P:1);if($===q-1&&P>=0&&P<1){i.bezierCurveTo(Ye[0],Ye[1],Ye[2],Ye[3],Ye[4],Ye[5]),g.splice(q-1,W-(q-1)-1);var Qe=new un(Ye[4],Ye[5]);g.push(Qe),W=g.length}else i.bezierCurveTo(Ye[0],Ye[1],Ye[2],Ye[3],Be,Ge);0===$?(Ze.arrowNextPoint=Ze.arrowNextPoint||new un(0,0),H=Ye[3],Ze.arrowNextPoint.x=I=Ye[2],Ze.arrowNextPoint.y=H):(Ze.arrowPrePoint=Ze.arrowPrePoint||new un(0,0),Ze.arrowPrePoint.x=I,Ze.arrowPrePoint.y=H,I=Ye[2],H=Ye[3],$===q-1&&g[$+1]&&(g[$+1].arrowPrePoint=g[$+1].arrowPrePoint||new un(0,0),g[$+1].arrowPrePoint.x=Ye[0],g[$+1].arrowPrePoint.y=Ye[1]))}Va._stroke(i,m)}},_arcBetween:function(i,g,m,_){var b=Math.abs(_),T=g.distanceTo(m),P=Math.abs(T/2/Math.sin(b/2)),I=Math.asin((m.y-g.y)/T);g.x>m.x&&(I=Math.PI-I);var H=I-(90*Ma-b/2),W=Math.cos(H)*P,q=Math.sin(H)*P,$=g.x+W,ye=g.y+q,Re=Math.asin((m.y-ye)/P);$>m.x&&(Re=Math.PI-Re);var Be=Re+b;if(_<0){Re+=Math.PI,Be+=Math.PI;var Ge=(g.x+m.x)/2,je=(g.y+m.y)/2;$=Ge-($-Ge),ye=je-(ye-je)}i.beginPath(),i.arc($,ye,P,Re,Be);var Xe=(Be-Re)/100,Ze=Math.cos(Re+Xe)*P+$,Ye=Math.sin(Re+Xe)*P+ye,Qe=Math.cos(Be-Xe)*P+$,Je=Math.sin(Be-Xe)*P+ye;return g.arrowNextPoint=g.arrowNextPoint||new un(0,0),m.arrowPrePoint=m.arrowPrePoint||new un(0,0),_<0?(g.arrowNextPoint.x=Ze,g.arrowNextPoint.y=Ye,m.arrowPrePoint.x=Qe,m.arrowPrePoint.y=Je):(g.arrowNextPoint.x=Qe,g.arrowNextPoint.y=Je,m.arrowPrePoint.x=Ze,m.arrowPrePoint.y=Ye),[$,ye]},_lineTo:function(i,g){i.lineTo(g.x,g.y)},bezierCurveAndFill:function(i,g,m,_){i.beginPath();var b=g[0];i.moveTo(b.x,b.y);var T=[i];T.push.apply(T,g.splice(1)),Va._bezierCurveTo.apply(Va,T),Va.fillCanvas(i,_),Va._stroke(i,m)},_bezierCurveTo:function(i,g,m,_){i.bezierCurveTo(g.x,g.y,m.x,m.y,_.x,_.y)},ellipse:function(i,g,m,_,b,T,P){i.beginPath(),m===_&&m===b?i.arc(g.x,g.y,m,0,2*Math.PI):i.ellipse?_!==b?(i.ellipse(g.x,g.y,m,_,0,180*Ma,360*Ma,!1),i.ellipse(g.x,g.y,m,b,0,0,180*Ma,!1)):i.ellipse(g.x,g.y,m,_,0,0,360*Ma,!1):function(g,m,_,b,T){var P=.5522848,I=_*P,H=b*P,W=T*P;i.moveTo(g-_,m),i.bezierCurveTo(g-_,m-H,g-I,m-b,g,m-b),i.bezierCurveTo(g+I,m-b,g+_,m-H,g+_,m),i.bezierCurveTo(g+_,m+W,g+I,m+T,g,m+T),i.bezierCurveTo(g-I,m+T,g-_,m+W,g-_,m),i.closePath()}(g.x,g.y,m,_,b),Va.fillCanvas(i,P,g.x-m,g.y-_),Va._stroke(i,T,g.x-m,g.y-_)},rectangle:function(i,g,m,_,b){var{x:T,y:P}=g;i.beginPath(),i.rect(T,P,m.width,m.height),Va.fillCanvas(i,b,T,P),Va._stroke(i,_,T,P)},sector:function(i,g,m,_,b,T){var P=Ma;function I(i,g,m,_,I,H){var W=P*-H,q=P*-I;i.beginPath(),i.moveTo(g,m),i.arc(g,m,_,W,q),i.lineTo(g,m),Va.fillCanvas(i,T,g-_,m-_),Va._stroke(i,b,g-_,m-_)}I(i,g.x,g.y,m,_[0],_[1])},_isPattern:function(i){return!ye(i)&&!("addColorStop"in i)},drawCross:function(i,g,m,_,b){i.canvas._drawn=!0,i.strokeStyle=b,i.lineWidth=_,i.beginPath(),i.moveTo(g-5,m),i.lineTo(g+5,m),i.moveTo(g,m-5),i.lineTo(g,m+5),i.stroke()},copy:function(i,g){var m=g||Or("canvas");return m.width=i.width,m.height=i.height,m.getContext("2d").drawImage(i,0,0),m},pixelRect:function(i,g,m,_){var b=i.globalAlpha,T=!1;if(i.lineWidth>0&&m>0)T=!0,m<1&&(i.globalAlpha*=m);else{if(!(_>0))return;_<1&&(i.globalAlpha*=_)}i.canvas._drawn=!0,T?i.strokeRect(g[0],g[1],1,1):i.fillRect(g[0],g[1],1,1),i.globalAlpha!==b&&(i.globalAlpha=b)}};function Ua(i,g,m,_){var b=g.x,T=g.y,P=m.x,I=m.y,H=_,W=function(i,g){return i<=g},q=function(i,g){return i>=g},$=function(i,g){return Math.min(i,g)},ye=function(i,g){return Math.max(i,g)},Re={thereYet:q,cap:$},Be={thereYet:q,cap:$};T-I>0&&(Be.thereYet=W,Be.cap=ye),b-P>0&&(Re.thereYet=W,Re.cap=ye),i.moveTo(b,T);for(var Ge,je,Xe=b,Ze=T,Ye=0,Qe=!0;!Re.thereYet(Xe,P)||!Be.thereYet(Ze,I);)Ge=Math.atan2(I-T,P-b),je=H[Ye],Xe=Re.cap(P,Xe+Math.cos(Ge)*je),Ze=Be.cap(I,Ze+Math.sin(Ge)*je),Qe?i.lineTo(Xe,Ze):i.moveTo(Xe,Ze),Ye=(Ye+1)%H.length,Qe=!Qe}var Ga="data:image/";function ja(i){return i.substring(0,Ga.length)===Ga?i:Fn(i)}function Wa(i,g){i.filter=g.filter,i.fillStyle=g.fillStyle,i.globalAlpha=g.globalAlpha,i.lineCap=g.lineCap,i.lineDashOffset=g.lineDashOffset,i.lineJoin=g.lineJoin,i.lineWidth=g.lineWidth,i.shadowBlur=g.shadowBlur,i.shadowColor=g.shadowColor,i.shadowOffsetX=g.shadowOffsetX,i.shadowOffsetY=g.shadowOffsetY,i.strokeStyle=g.strokeStyle,i.lineColorIn=g.lineColorIn,i.lineStrokeColor=g.lineStrokeColor,i.lineStrokeWidth=g.lineStrokeWidth}function qa(i,g){g&&i.setLineDash&&Array.isArray(g)&&i.setLineDash(g)}function Xa(i){return"Z__"+i}function Za(i){return function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.on=function(i,g,m){if(!i)return this;if(!ye(i))return this._switch("on",i,g);if(!g)return this;this._eventMap||(this._eventMap={});var _,b=i.toLowerCase().split(" ");m||(m=this);var P,I=W(g._id);g._id=gn();for(var H=0,q=b.length;H<q;H++){var $=Xa(_=b[H]);if(g[$]&&(g[$]._id=g._id),(P=this._eventMap[_])||(this._eventMap[_]=P=[]),I){var Re=P.length;if(Re>0)for(var Be=0;Be<Re;Be++)if(g===P[Be].handler&&P[Be].context===m)return T.isTest||console.warn(this,"find '"+i+"' handler:",g," The old listener function will be removed"),this;P.push({handler:g,context:m})}else P.push({handler:g,context:m})}return this},m.addEventListener=function(...i){return this.on.call(this,...i)},m.once=function(i,g,m){if(!ye(i)){var _={};for(var b in i)i.hasOwnProperty(b)&&(_[b]=this._wrapOnceHandler(b,i[b],g));return this._switch("on",_)}for(var T=i.split(" "),P=0,I=T.length;P<I;P++)this.on(T[P],this._wrapOnceHandler(T[P],g,m));return this},m.off=function(i,g,m){if(!this._eventMap||!i)return this;if(!ye(i))return this._switch("off",i,g);if(!g)return this;if(!W(g._id))return this;var _,b,T,P=i.split(" ");m||(m=this);for(var I=0,H=P.length;I<H;I++)if(T=Xa(_=P[I].toLowerCase()),b=this._eventMap[_]){for(var q=b.length-1;q>=0;q--){var $=b[q];g!==$.handler&&g!==$.handler[T]||$.context!==m||(delete $.handler[T],b.splice(q,1))}b.length||delete this._eventMap[_]}return this},m.removeEventListener=function(...i){return this.off.call(this,...i)},m.listens=function(i,g,m){if(!this._eventMap||!ye(i))return 0;var _=this._eventMap[i.toLowerCase()];if(!_||!_.length)return 0;if(!g)return _.length;for(var b=0,T=_.length;b<T;b++)if(g===_[b].handler&&(H(m)||_[b].context===m))return 1;return 0},m.getListeningEvents=function(){return this._eventMap?Object.keys(this._eventMap):[]},m.copyEventListeners=function(i){var g,m=i._eventMap;if(!m)return this;for(var _ in m)for(var b=0,T=(g=m[_]).length;b<T;b++)this.on(_,g[b].handler,g[b].context);return this},m.fire=function(i,g){return this._eventParent?this._eventParent.fire.call(this._eventParent,i,g):this._fire.call(this,i,g)},m._wrapOnceHandler=function(i,g,m){var _=Xa(i),b=!1,T=function i(...P){b||(delete T[_],b=!0,m?g.call(m,...P):g.call(this,...P),i._called=!0)};return T[_]=g,T},m._switch=function(i,g,m){for(var _ in g)g.hasOwnProperty(_)&&this[i](_,g[_],m);return this},m._clearListeners=function(i){this._eventMap&&ye(i)&&(this._eventMap[i.toLowerCase()]&&(this._eventMap[i]=null))},m._clearAllListeners=function(){this._eventMap=null},m._setEventParent=function(i){return this._eventParent=i,this},m._setEventTarget=function(i){return this._eventTarget=i,this},m._fire=function(i,g){if(!this._eventMap)return this;i=i.toLowerCase();var m=this._eventMap[i];if(!m)return this;g||(g={type:i,target:this._eventTarget||this}),g.type=i,g.target=this._eventTarget||this;for(var _,b,T=m.slice(0),P=0,H=T.length;P<H;P++){if(T[P])T[P].handler._called||(_=T[P].context,b=I({},g),!1===(_?T[P].handler.call(_,b):T[P].handler(b))&&g.domEvent&&Hr(g.domEvent))}var W=this._eventMap[i];if(W){for(var q=[],$=0,ye=W.length;$<ye;$++){W[$].handler._called||q.push(W[$])}this._eventMap[i]=q}return this},g}(i)}var $a=function(i){function g(g){var m;return(m=i.call(this)||this)._enabled=!1,m.target=g,m}tn(g,i);var m=g.prototype;return m.enable=function(){return this._enabled||(this._enabled=!0,this.addHooks()),this},m.disable=function(){return this._enabled?(this._enabled=!1,this.removeHooks(),this):this},m.enabled=function(){return!!this._enabled},m.remove=function(){this.disable(),delete this.target,delete this.dom},g}(Za((function(){}))),Ya=function(){function i(i){if(!this||!this._setOptions)throw new Error('Class instance is being created without "new" operator.');this._setOptions(i),this.callInitHooks(),this._isUpdatingOptions=!1}var g=i.prototype;return g.proxyOptions=function(){var i=this;return $t.proxy?(this.options=new Proxy(this.options,{set:function(g,m,_){if(g[m]===_)return!0;if(g[m]=_,i._isUpdatingOptions)return!0;var b={};return b[m]=_,i.config(b),!0}}),this):this},g.callInitHooks=function(){var i=Object.getPrototypeOf(this);return this._visitInitHooks(i),this},g._setOptions=function(i){if(this.hasOwnProperty("options")&&!H(this.options)||(this.options=this.options?Object.create(this.options):{}),!i)return this;for(var g in i)this.options[g]=i[g];return this},g.setOptions=function(i){return console.warn("setOptions(options) It is a private method and deprecated, please use _setOptions(options) instead. If you want to update options, please use config(options) instead."),this._setOptions(i)},g.config=function(i,g){if(this._isUpdatingOptions=!0,!i){var m={};for(var _ in this.options)this.options.hasOwnProperty(_)&&(m[_]=this.options[_]);return this._isUpdatingOptions=!1,m}if(2===arguments.length&&"string"==typeof i){var b={};b[i]=g,i=b}for(var T in i)this.options[T]=i[T],this[T]&&this[T]instanceof $a&&(i[T]?this[T].enable():this[T].disable());return this.onConfig(i),this._isUpdatingOptions=!1,this},g.onConfig=function(i){},g._visitInitHooks=function(i){if(!this._initHooksCalled){var g=Object.getPrototypeOf(i);g._visitInitHooks&&g._visitInitHooks.call(this,g),this._initHooksCalled=!0;var m=i._initHooks;if(m&&m!==g._initHooks)for(var _=0;_<m.length;_++)m[_].call(this)}},i.addInitHook=function(i,...g){var m="function"==typeof i?i:function(){this[i].call(this,...g)},_=this.prototype,b=Object.getPrototypeOf(_);return _._initHooks&&_._initHooks!==b._initHooks||(_._initHooks=[]),_._initHooks.push(m),this},i.include=function(...i){for(var g=0;g<i.length;g++)I(this.prototype,i[g]);return this},i.mergeOptions=function(i){var g=this.prototype,m=Object.getPrototypeOf(g);return g.options&&g.options!==m.options||(g.options=g.options?Object.create(g.options):{}),I(g.options,i),this},i}(),Qa=function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g}(Za((function(){}))),Ja=new Qa,Ka="dprchange",el="docvisibilitychange",tl="dragstart",nl="dragend";if("undefined"!=typeof window&&window.matchMedia)for(var rl=1;rl<500;rl++){var il=(.01*rl).toFixed(2),ol=window.matchMedia("screen and (resolution: "+il+"dppx)");ol&&(ol.addEventListener?ol.addEventListener("change",$t.checkDevicePixelRatio):ol.addListener&&ol.addListener($t.checkDevicePixelRatio))}if($t.devicePixelRatio){var sl=$t.devicePixelRatio;Object.defineProperty($t,"devicePixelRatio",{get:function(){return sl},set:function(i){i!==sl&&(sl=i,$t.monitorDPRChange&&Ja.fire(Ka,{devicePixelRatio:i}))}})}$t.webgl&&"undefined"!=typeof document&&(Lr(document,"visibilitychange",(function(){Ja.fire(el,{visibilityState:document.visibilityState})})),Lr(document,"dragstart",(function(){Ja.fire(tl)})),Lr(document,"dragend",(function(){Ja.fire(nl)})));var al={};function ll(i){return function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g.registerJSONType=function(i){i&&(al[i]?console.error(i+" has register. please use Different name for:",this):al[i]=this)},g.getJSONClass=function(i){return i?al[i]:null},g.prototype.getJSONType=function(){if(void 0===this._jsonType){var i=Object.getPrototypeOf(this).constructor;for(var g in al)if(al[g]===i){this._jsonType=g;break}}if(!this._jsonType)throw new Error("Found an unregistered Layer/Geometry class!");return this._jsonType},g}(i)}function hl(i){return function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.addHandler=function(i,g){if(!g)return this;if(this._handlers||(this._handlers=[]),this[i])return this[i].enable(),this;var m=this[i]=new g(this);return this._handlers.push(m),this.options[i]&&m.enable(),this},m.removeHandler=function(i){if(!i)return this;var g=this[i];if(g){var m=this._handlers.indexOf(g);m>=0&&this._handlers.splice(m,1),this[i].remove(),delete this[i]}return this},m._clearHandlers=function(){for(var i=0,g=this._handlers.length;i<g;i++)this._handlers[i].remove();this._handlers=[]},g}(i)}var cl="touchstart mousedown",ul={mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"},fl={mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},dl=function(i){function g(g,m={}){var _;return(_=i.call(this,null)||this).dom=g,_.options=m,_}tn(g,i);var m=g.prototype;return m.addHooks=function(){},m.removeHooks=function(){},m.enable=function(){return this.dom?(this._onMouseDown=function(i){return this.onMouseDown(i)},Jr(this.dom,cl,this._onMouseDown,this),this):this},m.disable=function(){return this.dom?(this._offEvents(),Kr(this.dom,cl,this._onMouseDown),delete this._onMouseDown,this):this},m.onMouseDown=function(i){if(this.options.rightclick||2!==i.button){var g=i;if(!(g.touches&&g.touches.length>1||this.options.cancelOn&&!0===this.options.cancelOn(i))){var m=this.dom;m.setCapture?m.setCapture():window.captureEvents&&window.captureEvents(),m.ondragstart=function(){return!1},delete this.moved;var _=g.touches?g.touches[0]:i;this.startPos=new un(_.clientX,_.clientY),Kr(document,ul[i.type],this.onMouseMove),Kr(document,fl[i.type],this.onMouseUp),Jr(document,ul[i.type],this.onMouseMove,this),Jr(document,fl[i.type],this.onMouseUp,this),this.options.ignoreMouseleave||(Kr(this.dom,"mouseleave",this.onMouseUp),Jr(this.dom,"mouseleave",this.onMouseUp,this)),this.fire("mousedown",{domEvent:i,mousePos:new un(_.clientX,_.clientY)})}}},m.onMouseMove=function(i){var g=i;if(g.touches&&g.touches.length>1)this.moved&&(this.interupted=!0,this.onMouseUp(i));else{var m=g.touches?g.touches[0]:i,_=new un(m.clientX,m.clientY).sub(this.startPos);(_.x||_.y)&&(this.moved?this.fire("dragging",{domEvent:i,mousePos:new un(m.clientX,m.clientY)}):(this.fire("dragstart",{domEvent:i,mousePos:this.startPos.copy()}),this.moved=!0))}},m.onMouseUp=function(i){var g=i.changedTouches?i.changedTouches[0]:i;this._offEvents();var m={domEvent:i};W(g.clientX)&&(m.mousePos=new un(parseInt(g.clientX+"",0),parseInt(g.clientY+"",0))),this.moved&&(m.interupted=this.interupted,this.fire("dragend",m),delete this.interupted,delete this.moved),this.fire("mouseup",m)},m._offEvents=function(){var i=this.dom;if(Kr(i,"mouseleave",this.onMouseUp),"undefined"!=typeof document&&"undefined"!=typeof window){for(var g in ul)Kr(document,ul[g],this.onMouseMove),Kr(document,fl[g],this.onMouseUp);i.releaseCapture?i.releaseCapture():window.captureEvents&&window.captureEvents()}},g}($a),pl=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i),g.toNumberArrays=function(i){return Array.isArray(i)?bn(i,(function(i){return i.toArray()})):i.toArray()},g.toCoordinates=function(i){if(W(i[0])&&W(i[1]))return new g(i);if(i instanceof g)return i;for(var m=[],_=0,b=i.length;_<b;_++){var T=i[_];Array.isArray(T)?W(T[0])?m.push(new g(T)):m.push(g.toCoordinates(T)):m.push(T instanceof g?T:new g(T))}return m};var m=g.prototype;return m.closeTo=function(i,g){return g||(g=0),this.x>=i.x-g&&this.x<=i.x+g&&this.y>=i.y-g&&this.y<=i.y+g},m.abs=function(){return new g(Math.abs(this.x),Math.abs(this.y))},m.round=function(){return new g(Math.round(this.x),Math.round(this.y))},m.ceil=function(){return new g(Math.ceil(this.x),Math.ceil(this.y))},m.floor=function(){return new g(Math.floor(this.x),Math.floor(this.y))},m.copy=function(){return new g(this.x,this.y,this.z)},m.toFixed=function(i){return new g(this.x.toFixed(i),this.y.toFixed(i),W(this.z)?this.z.toFixed(i):void 0)},m.add=function(i,m,_){var b,T,P=this.z;return H(i.x)?H(i[0])?(b=this.x+i,T=this.y+m,H(_)||(P=(this.z||0)+_)):(b=this.x+i[0],T=this.y+i[1],H(i[2])||(P=(this.z||0)+i[2])):(b=this.x+i.x,T=this.y+i.y,H(i.z)||(P=(this.z||0)+i.z)),new g(b,T,P)},m.sub=function(i,m,_){var b,T,P=this.z;return H(i.x)?H(i[0])?(b=this.x-i,T=this.y-m,H(_)||(P=(this.z||0)-_)):(b=this.x-i[0],T=this.y-i[1],H(i[2])||(P=(this.z||0)-i[2])):(b=this.x-i.x,T=this.y-i.y,H(i.z)||(P=(this.z||0)-i.z)),new g(b,T,P)},m.multi=function(i){return new g(this.x*i,this.y*i,H(this.z)?this.z:this.z*i)},m.equals=function(i){return i instanceof this.constructor&&(this.x===i.x&&this.y===i.y&&this.z===i.z)},g}(cn),gl=function(){function i(i,g){this.type=i,this.properties=g}return i.createProj4=function(g){return new i("proj4",{proj:g})},i.fromProjectionCode=function(g){return g&&i[g=g.toUpperCase().replace(":","")]||null},i}();gl.WGS84=gl.createProj4("+proj=longlat +datum=WGS84 +no_defs"),gl.EPSG3857=gl.createProj4("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"),gl.IDENTITY=gl.createProj4("+proj=identity +no_defs"),gl.CGCS2000=gl.createProj4("+proj=longlat +datum=CGCS2000"),gl.EPSG4490=gl.CGCS2000,gl.BD09LL=gl.createProj4("+proj=longlat +datum=BD09"),gl.GCJ02=gl.createProj4("+proj=longlat +datum=GCJ02");var ml,Al=new un(0,0),yl=new pl(0,0),_l=new pl(0,0),vl=new pl(0,0),xl=new pl(0,0),bl=new pl(0,0),wl=new pl(0,0),Tl=new pl(0,0),Sl=new pl(0,0),Ml=[],Cl=[],Pl=function(){function i(...i){this._clazz=pl;var g=i.length,m=g>0?i[g-1]:null;m&&m.unproject&&(this.projection=i[g-1]),this._dirty=!0,this.antiMeridian=!1,this._initialize(i[0],i[1],i[2],i[3])}var g=i.prototype;return g._initialize=function(i,g,m,_){if(this.xmin=null,this.xmax=null,this.ymin=null,this.ymax=null,!H(i)){var b=this.projection;if(W(i)&&W(g)&&W(m)&&W(_))b?this.set(i,g,m,_):this.set(Math.min(i,m),Math.min(g,_),Math.max(i,m),Math.max(g,_));else if(Array.isArray(i))b?this.set(i[0],i[1],i[2],i[3]):this.set(Math.min(i[0],i[2]),Math.min(i[1],i[3]),Math.max(i[0],i[2]),Math.max(i[1],i[3]));else if(W(i.x)&&W(g.x)&&W(i.y)&&W(g.y)){var T=i,P=g;b?this.set(T.x,T.y,P.x,P.y):(T.x>P.x?(this.xmin=P.x,this.xmax=T.x):(this.xmin=T.x,this.xmax=P.x),T.y>P.y?(this.ymin=P.y,this.ymax=T.y):(this.ymin=T.y,this.ymax=P.y))}else W(i.xmin)&&W(i.xmax)&&W(i.ymin)&&W(i.ymax)&&this.set(i.xmin,i.ymin,i.xmax,i.ymax)}},g._add=function(i){return this._dirty=!0,H(i.x)?H(i.xmin)?H(i[0])||(this.xmin+=i[0],this.ymin+=i[1],this.xmax+=i[0],this.ymax+=i[1]):(this.xmin+=i.xmin,this.ymin+=i.ymin,this.xmax+=i.xmax,this.ymax+=i.ymax):(this.xmin+=i.x,this.ymin+=i.y,this.xmax+=i.x,this.ymax+=i.y),this},g.add=function(i){return new this.constructor(this.xmin,this.ymin,this.xmax,this.ymax,this.projection)._add(i)},g._scale=function(i){return this._dirty=!0,this.xmin*=i,this.ymin*=i,this.xmax*=i,this.ymax*=i,this},g._sub=function(i){return this._dirty=!0,H(i.x)?H(i.xmin)?H(i[0])||(this.xmin-=i[0],this.ymin-=i[1],this.xmax-=i[0],this.ymax-=i[1]):(this.xmin-=i.xmin,this.ymin-=i.ymin,this.xmax-=i.xmax,this.ymax-=i.ymax):(this.xmin-=i.x,this.ymin-=i.y,this.xmax-=i.x,this.ymax-=i.y),this},g._substract=function(i){return this._sub(i)},g.sub=function(i){return new this.constructor(this.xmin,this.ymin,this.xmax,this.ymax,this.projection)._sub(i)},g.substract=function(i){return this.sub(i)},g.round=function(){return new this.constructor(Math.round(this.xmin),Math.round(this.ymin),Math.round(this.xmax),Math.round(this.ymax),this.projection)},g._round=function(){return this._dirty=!0,this.xmin=Math.round(this.xmin),this.ymin=Math.round(this.ymin),this.xmax=Math.round(this.xmax),this.ymax=Math.round(this.ymax),this},g.getMin=function(i){return i?(i.set(this.xmin,this.ymin),i):new this._clazz(this.xmin,this.ymin)},g.getMax=function(i){return i?(i.set(this.xmax,this.ymax),i):new this._clazz(this.xmax,this.ymax)},g.getCenter=function(i){var g=(this.xmin+this.xmax)/2,m=(this.ymin+this.ymax)/2;return i?(i.set(g,m),i):new this._clazz(g,m)},g.isValid=function(){return!(H(this.xmin)||H(this.ymin)||H(this.xmax)||H(this.ymax))},g.equals=function(i){return this.xmin===i.xmin&&this.xmax===i.xmax&&this.ymin===i.ymin&&this.ymax===i.ymax},g.intersects=function(i){this._project(this),this._project(i);var g=Math.max(this.pxmin,i.pxmin),m=Math.max(this.pymin,i.pymin),_=Math.min(this.pxmax,i.pxmax),b=Math.min(this.pymax,i.pymax);return!(g>_||m>b)},g.within=function(i){return this._project(this),this._project(i),this.pxmin>=i.pxmin&&this.pxmax<=i.pxmax&&this.pymin>=i.pymin&&this.pymax<=i.pymax},g.contains=function(i){if(!i)return!1;this._project(this);var g=this.projection;if(g){var m=yl;Array.isArray(i)?(m.x=i[0],m.y=i[1],i=g.project(m,m)):void 0!==i.x?(m.x=i.x,m.y=i.y,i=g.project(m,m)):void 0!==i.xmin&&this._project(i)}return(i.x||i.pxmin||0)>=this.pxmin&&(i.x||i.pxmax||0)<=this.pxmax&&(i.y||i.pymin||0)>=this.pymin&&(i.y||i.pymax||0)<=this.pymax},g.getWidth=function(){return Math.abs(this.xmax-this.xmin)},g.getHeight=function(){return Math.abs(this.ymax-this.ymin)},g.getSize=function(){return new ir(this.getWidth(),this.getHeight())},g.set=function(i,g,m,_){return this.xmin=i,this.ymin=g,this.xmax=m,this.ymax=_,this._dirty=!0,this},g.__combine=function(i){var g,m,_,b;void 0!==i.x&&(ml.xmin=ml.xmax=i.x,ml.ymin=ml.ymax=i.y,ml._dirty=!0,i=ml),this._project(i),this._project(this),W(this.pxmin)?(g=Math.min(this.pxmin,i.pxmin),m=Math.min(this.pymin,i.pymin),_=Math.max(this.pxmax,i.pxmax),b=Math.max(this.pymax,i.pymax)):(g=i.pxmin,m=i.pymin,_=i.pxmax,b=i.pymax);var T=this.projection;if(T){_l.set(g,m),vl.set(_,b);var P=T.unproject(_l,_l),I=T.unproject(vl,vl);g=P.x,m=P.y,_=I.x,b=I.y}return Cl[0]=g,Cl[1]=m,Cl[2]=_,Cl[3]=b,Cl},g._combine=function(i){if(!i||i.isValid&&!i.isValid())return this;var g=this.__combine(i);return this.set(g[0],g[1],g[2],g[3]),this._dirty=!0,this},g.combine=function(i){if(!i||i.isValid&&!i.isValid())return this;var g=this.__combine(i);return new this.constructor(g[0],g[1],g[2],g[3],this.projection)},g.intersection=function(i){if(!this.intersects(i))return null;xl.x=Math.max(this.pxmin,i.pxmin),xl.y=Math.max(this.pymin,i.pymin),bl.x=Math.min(this.pxmax,i.pxmax),bl.y=Math.min(this.pymax,i.pymax);var g=xl,m=bl,_=this.projection;return _&&(g=_.unproject(g,g),m=_.unproject(m,m)),new this.constructor(g,m,_)},g.expand=function(i){var g,m;return W(i)?g=m=i:(g=i.width||i.x||i[0]||0,m=i.height||i.y||i[1]||0),new this.constructor(this.xmin-g,this.ymin-m,this.xmax+g,this.ymax+m,this.projection)},g._expand=function(i){var g,m;return W(i)?g=m=i:(g=i.width||i.x||i[0]||0,m=i.height||i.y||i[1]||0),this.xmin-=g,this.ymin-=m,this.xmax+=g,this.ymax+=m,this._dirty=!0,this},g.toJSON=function(){return{xmin:this.xmin,ymin:this.ymin,xmax:this.xmax,ymax:this.ymax}},g.toArray=function(i){var g=this.xmin,m=this.ymin,_=this.xmax,b=this.ymax;return i?(i[0].x=g,i[0].y=b,i[1].x=_,i[1].y=b,i[2].x=_,i[2].y=m,i[3].x=g,i[3].y=m,i[4].x=g,i[4].y=b,i):[new this._clazz([g,b]),new this._clazz([_,b]),new this._clazz([_,m]),new this._clazz([g,m]),new this._clazz([g,b])]},g.toString=function(){return this.xmin+","+this.ymin+","+this.xmax+","+this.ymax},g.copy=function(){return new this.constructor(this.xmin,this.ymin,this.xmax,this.ymax,this.projection)},g.convertTo=function(i,g){if(!this.isValid())return null;var m,_=g||new this.constructor;return g&&_.set(null,null,null,null),this._clazz===pl?m=wl:this._clazz===un&&(m=Al),m.x=this.xmin,m.y=this.ymax,_._combine(i(m)),m.x=this.xmax,_._combine(i(m)),m.y=this.ymin,_._combine(i(m)),m.x=this.xmin,_._combine(i(m)),_},g._project=function(i){if(i&&i.isValid()){var g=this.projection;if(g){if(i._dirty){Tl.set(i.xmin,i.ymin),Sl.set(i.xmax,i.ymax),Ml[0]=Tl,Ml[1]=Sl;var m=g.projectCoords(Ml,this.antiMeridian),_=m[0],b=m[1];i.pxmin=Math.min(_.x,b.x),i.pymin=Math.min(_.y,b.y),i.pxmax=Math.max(_.x,b.x),i.pymax=Math.max(_.y,b.y)}delete i._dirty}else i.pxmin=i.xmin,i.pxmax=i.xmax,i.pymin=i.ymin,i.pymax=i.ymax}else i&&(i.pxmin=i.pxmax=i.pymin=i.pymax=null)},i}();ml=new Pl(0,0,0,0);var Il,kl=function(i){function g(...g){var m;return(m=i.call(this,...g)||this)._clazz=un,m}return tn(g,i),g}(Pl),Ol=function(){function i(i){this.matrix=i}var g=i.prototype;return g.transform=function(i,g,m){var _=this.matrix[0]*(i.x-this.matrix[2])/g,b=-this.matrix[1]*(i.y-this.matrix[3])/g;return m?(m.x=_,m.y=b,m):new un(_,b)},g.untransform=function(i,g,m){var _=i.x*g/this.matrix[0]+this.matrix[2],b=i.y*g/-this.matrix[1]+this.matrix[3];return m?(m.x=_,m.y=b,m):new pl(_,b)},i}(),El={code:"",is:function(i){if(this.code===i)return!0;if(!this.aliases)return!1;for(var g=0;g<this.aliases.length;g++)if(this.aliases[g]===i)return!0;return!1},project:function(i){return i},unproject:function(i){return i},projectCoords:function(i,g){var m=this;if(!i)return[];if(!Array.isArray(i))return this.project(i);if(0===i.length)return[];if(!this.isSphere())return bn(i,this.project,this);if(Array.isArray(i[0]))return i.map((function(i){return m.projectCoords(i,g)}));for(var _,b,T,P,I,H=g,W=this.getCircum(),q=this.getSphereExtent().sy,$=i[0],ye=[this.project($)],Re=1,Be=i.length;Re<Be;Re++){T=(b=i[Re]).x-$.x,P=b.y-$.y,I=this.project(b);var Ge=!1;Math.abs(T)>180&&H&&(b.x=T<0?360-Math.abs(b.x):-180-(180-Math.abs(b.x)),Ge=!0),Math.abs(P)>90&&H&&(void 0===_&&(_=b.y<$.y),_&&(I._add(0,-W.y*Sn(P)*q),b._add(0,-180*Sn(P)))),Ge&&(I=this.project(b)),$=b,ye.push(I)}return ye},unprojectCoords:function(i){return i?Array.isArray(i)?bn(i,this.unproject,this):this.unproject(i):[]},isSphere:function(){return!!this.sphere},isOutSphere:function(i){return!!this.isSphere()&&!this.getSphereExtent().contains(i)},wrapCoord:function(i){if(!this.isSphere())return i;var g=this.getSphereExtent(),m=new pl(i);return g.contains(m)||(m.x=Cn(i.x,g.xmin,g.xmax),m.y=Cn(i.y,g.ymin,g.ymax)),m},getCircum:function(){if(!this.circum&&this.isSphere()){var i=this.getSphereExtent();this.circum={x:i.getWidth(),y:i.getHeight()}}return this.circum},getSphereExtent:function(){if(!this.extent&&this.isSphere()){var i=this.project(new pl(180,90)),g=this.project(new pl(-180,-90));this.extent=new Pl(g,i,this),this.extent.sx=i.x>g.x?1:-1,this.extent.sy=i.y>g.y?1:-1}return this.extent}},Rl={measureLength:function(i,g){if(!Array.isArray(i))return this.measureLenBetween(i,g);for(var m=0,_=0,b=i.length;_<b-1;_++)m+=this.measureLenBetween(i[_],i[_+1]);return m}},Ll={measure:"IDENTITY",measureLenBetween:function(i,g,m=!1){if(!i||!g)return 0;try{var _=Math.sqrt(Math.pow(i.x-g.x,2)+Math.pow(i.y-g.y,2));if(m)return _;var b=(i.z||0)-(g.z||0);return 0===b?_:Math.sqrt(_*_+b*b)}catch(i){return 0}},measureArea:function(i){if(!Array.isArray(i))return 0;for(var g=0,m=0,_=i.length;m<_;m++){var b=i[m],T=null;g+=b.x*(T=m===_-1?i[0]:i[m+1]).y-b.y*T.x}return Math.abs(g/2)},locate:function(i,g,m,_){return(_=_||new pl(0,0)).set(i.x,i.y),this._locate(_,g,m)},_locate:function(i,g,m){return i?(g||(g=0),m||(m=0),g||m?(i.x=i.x+g,i.y=i.y+m,i):i):null},rotate:function(i,g,m){return i=new pl(i.x,i.y),this._rotate(i,g,m)},_rotate:(Il=new un(0,0),function(i,g,m){return Il.x=i.x-g.x,Il.y=i.y-g.y,Il._rotate(m*Math.PI/180),i.x=g.x+Il.x,i.y=g.y+Il.y,i})},Dl=I(Ll,Rl),Fl=function(){function i(i){this.radius=i}var g=i.prototype;return g.measureLenBetween=function(i,g,m=!1){if(!i||!g)return 0;var _=Xe(i.y),b=Xe(g.y),T=_-b,P=Xe(i.x)-Xe(g.x);_=2*Math.asin(Math.sqrt(Math.pow(Math.sin(T/2),2)+Math.cos(_)*Math.cos(b)*Math.pow(Math.sin(P/2),2)));_*=this.radius;if(m)return _;var I=(i.z||0)-(g.z||0);return 0===I?_:Math.sqrt(_*_+I*I)},g.measureArea=function(i){var g,m=Xe(this.radius),_=0,b=i,T=b.length;if(T<3)return 0;for(g=0;g<T-1;g++){var P=b[g],I=b[g+1];_+=P.x*m*Math.cos(Xe(P.y))*I.y*m-I.x*m*Math.cos(Xe(I.y))*P.y*m}var H=b[g],W=b[0];return _+=H.x*m*Math.cos(Xe(H.y))*W.y*m-W.x*m*Math.cos(Xe(W.y))*H.y*m,.5*Math.abs(_)},g.locate=function(i,g,m,_){return(_=_||new pl(0,0)).set(i.x,i.y),this._locate(_,g,m)},g._locate=function(i,g,m){if(!i)return null;if(g||(g=0),m||(m=0),!g&&!m)return i;var _,b,T=Xe(i.y);if(0!==m){var P=Math.abs(m);b=Cn(180*(T+=2*Math.sin(P/(2*this.radius))*(m>0?1:-1))/Math.PI,-90,90)}else b=i.y;if(0!==g){var I=Math.abs(g),H=Xe(i.x);_=Cn(180*(H+=2*Math.sqrt(Math.pow(Math.sin(I/(2*this.radius)),2)/Math.pow(Math.cos(T),2))*(g>0?1:-1))/Math.PI,-180,180)}else _=i.x;return i.x=_,i.y=b,i},g.rotate=function(i,g,m){var _=new pl(i);return this._rotate(_,g,m)},g._rotate=function(i,g,m){var _=function(i,g,m={}){var _;_=m.final?Nl(g,i):Nl(i,g);return _>180?-(360-_):_}(g,i),b=_-m,T=this.measureLenBetween(g,i,!0);return i.x=g.x,i.y=g.y,function(i,g,m,_){var b=g/_,T=i.x*Math.PI/180,P=Xe(i.y),I=Xe(m),H=b*Math.cos(I),W=P+H;Math.abs(W)>Math.PI/2&&(W=W>0?Math.PI-W:-Math.PI-W);var q=Math.log(Math.tan(W/2+Math.PI/4)/Math.tan(P/2+Math.PI/4)),$=Math.abs(q)>1e-11?H/q:Math.cos(P),ye=b*Math.sin(I)/$;return i.x=(180*(T+ye)/Math.PI+540)%360-180,i.y=180*W/Math.PI,i}(i,T,b,this.radius)},i}();function Nl(i,g){var m=Xe(i.y),_=Xe(g.y),b=Xe(g.x-i.x);b>Math.PI&&(b-=2*Math.PI),b<-Math.PI&&(b+=2*Math.PI);var T=Math.log(Math.tan(_/2+Math.PI/4)/Math.tan(m/2+Math.PI/4));return(Ze(Math.atan2(b,T))+360)%360}var Hl={measure:"EPSG:4326",sphere:new Fl(6378137),measureLenBetween:function(i,g){return this.sphere.measureLenBetween(i,g)},measureArea:function(i){return this.sphere.measureArea.call(this.sphere,i)},_locate:function(i,g,m){return this.sphere._locate.call(this.sphere,i,g,m)},locate:function(i,g,m,_){return this.sphere.locate.call(this.sphere,i,g,m,_)},_rotate:function(i,g,m){return this.sphere._rotate.call(this.sphere,i,g,m)},rotate:function(i,g,m){return this.sphere.rotate.call(this.sphere,i,g,m)}},Bl=I(Hl,Rl),zl={measure:"BAIDU",sphere:new Fl(6370996.81),measureLenBetween:function(i,g){return this.sphere.measureLenBetween.call(this.sphere,i,g)},measureArea:function(i){return this.sphere.measureArea.call(this.sphere,i)},_locate:function(i,g,m){return this.sphere._locate.call(this.sphere,i,g,m)},locate:function(i,g,m,_){return this.sphere.locate.call(this.sphere,i,g,m,_)},_rotate:function(i,g,m){return this.sphere._rotate.call(this.sphere,i,g,m)},rotate:function(i,g,m){return this.sphere.rotate.call(this.sphere,i,g,m)}},Vl=I(zl,Rl),Ul=Bl,Gl={};function jl(i){Gl[i.measure]=i}jl(Dl),jl(Bl),jl(Vl);var Wl={getInstance:function(i){if(!i)return Ul;for(var g in Gl)if(Ge(Gl,g)){var m=Gl[g].measure;if(!m)continue;if(i.toLowerCase()===m.toLowerCase())return Gl[g]}return null}},ql=Object.freeze({__proto__:null,BaiduSphere:Vl,DEFAULT:Ul,Identity:Dl,Measurer:Wl,WGS84Sphere:Bl}),Xl={code:"EPSG:3857",rad:Math.PI/180,metersPerDegree:6378137*Math.PI/180,maxLatitude:85.0511287798,project:function(i,g){var m=this.rad,_=this.metersPerDegree,b=this.maxLatitude,T=i.x,P=Math.max(Math.min(b,i.y),-b),I=T*_,H=(0===P?0:Math.log(Math.tan((90+P)*m/2))/m)*_,W=i.z;return g?(g.x=I,g.y=H,g.z=W,g):new pl(I,H,W)},unproject:function(i,g){var m,_=this.rad,b=this.metersPerDegree,T=i.x/b,P=i.y;0===P?m=0:(m=P/b,m=(2*Math.atan(Math.exp(m*_))-Math.PI/2)/_),Math.abs(Math.abs(T)-180)<1e-7&&(T=180*Sn(T)),Math.abs(Math.abs(m)-this.maxLatitude)<1e-7&&(m=Sn(m)*this.maxLatitude);var I=T,H=m,W=i.z;return g?(g.x=I,g.y=H,g.z=W,g):new pl(I,H,W)}},Zl=I({},El,Xl,Bl),$l={code:"EPSG:4326",aliases:["EPSG:4490"],project:function(i,g){return g?(g.x=i.x,g.y=i.y,g.z=i.z,g):new pl(i)},unproject:function(i,g){return g?(g.x=i.x,g.y=i.y,g.z=i.z,g):new pl(i)}},Yl=I({},El,$l,Bl),Ql=Math.abs,Jl=Math.sin,Kl=Math.cos,eh=Math.tan,th=Math.atan,nh=Math.atan2,rh=Math.sqrt,ih=Math.log,oh=Math.hypot,sh=Math.sinh,ah=Math.cosh,lh=1/0;function hh(i){var g,m,_,b,T,P,I=[],H=[],W=[],q=[];function $(i,g){for(var m,_=2*Kl(2*g),b=i.length-1,T=i[b],P=0;--b>=0;)m=_*T-P+i[b],P=T,T=m;return g+m*Jl(2*g)}function ye(i,g,m){for(var _,b,T=Jl(g),P=Kl(g),I=sh(m),H=ah(m),W=2*P*H,q=-2*T*I,$=i.length-1,ye=i[$],Re=0,Be=0,Ge=0;--$>=0;)_=Be,b=Re,ye=W*(Be=ye)-_-q*(Re=Ge)+i[$],Ge=q*Be-b+W*Re;return[(W=T*H)*ye-(q=P*I)*Ge,W*Ge+q*ye]}T=b=(_=i.es/(1+rh(1-i.es)))/(2-_),I[0]=b*(2+b*(-2/3+b*(b*(116/45+b*(26/45+b*(-2854/675)))-2))),H[0]=b*(b*(2/3+b*(4/3+b*(-82/45+b*(32/45+b*(4642/4725)))))-2),I[1]=(T*=b)*(7/3+b*(b*(-227/45+b*(2704/315+b*(2323/945)))-1.6)),H[1]=T*(5/3+b*(-16/15+b*(-13/9+b*(904/315+b*(-1522/945))))),I[2]=(T*=b)*(56/15+b*(-136/35+b*(-1262/105+b*(73814/2835)))),H[2]=T*(-26/15+b*(34/21+b*(1.6+b*(-12686/2835)))),I[3]=(T*=b)*(4279/630+b*(-332/35+b*(-399572/14175))),H[3]=T*(1237/630+b*(b*(-24832/14175)-2.4)),I[4]=(T*=b)*(4174/315+b*(-144838/6237)),H[4]=T*(-734/315+b*(109598/31185)),I[5]=(T*=b)*(601676/22275),H[5]=T*(444337/155925),g=i.k0/(1+b)*(1+(T=b*b)*(1/4+T*(1/64+T/256))),W[0]=b*(b*(2/3+b*(-37/96+b*(1/360+b*(81/512+b*(-96199/604800)))))-.5),q[0]=b*(.5+b*(-2/3+b*(5/16+b*(41/180+b*(-127/288+b*(7891/37800)))))),W[1]=T*(-1/48+b*(-1/15+b*(437/1440+b*(-46/105+b*(1118711/3870720))))),q[1]=T*(13/48+b*(b*(557/1440+b*(281/630+b*(-1983433/1935360)))-.6)),W[2]=(T*=b)*(-17/480+b*(37/840+b*(209/4480+b*(-5569/90720)))),q[2]=T*(61/240+b*(-103/140+b*(15061/26880+b*(167603/181440)))),W[3]=(T*=b)*(-4397/161280+b*(11/504+b*(830251/7257600))),q[3]=T*(49561/161280+b*(-179/168+b*(6601661/7257600))),W[4]=(T*=b)*(-4583/161280+b*(108847/3991680)),q[4]=T*(34729/80640+b*(-3418889/1995840)),W[5]=(T*=b)*(-20648693/638668800),q[5]=.6650675310896665*T,P=$(H,i.phi0),m=-g*(P+function(i,g){var m,_=2*Kl(g),b=i.length-1,T=i[b],P=0;for(;--b>=0;)m=_*T-P+i[b],P=T,T=m;return Jl(g)*m}(q,2*P)),i.fwd=function(i,_){var b,T,P,I,W,Re=i.phi,Be=i.lam;Re=$(H,Re),b=Jl(Re),T=Kl(Re),I=Jl(Be),P=Kl(Be),Re=nh(b,P*T),Be=nh(I*T,oh(b,T*P)),Be=function(i){var g=Ql(i);return g=function(i){var g=1+i,m=g-1;return 0===m?i:i*ih(g)/m}(g*(1+g/(oh(1,g)+1))),i<0?-g:g}(eh(Be)),W=ye(q,2*Re,2*Be),Re+=W[0],Be+=W[1],Ql(Be)<=2.623395162778?(_.y=g*Re+m,_.x=g*Be):_.x=_.y=lh},i.inv=function(i,_){var b,T,P,H,q,Re=i.y,Be=i.x;Re=(Re-m)/g,Be/=g,Ql(Be)<=2.623395162778?(Re+=(q=ye(W,2*Re,2*Be))[0],Be=th(sh(Be+=q[1])),b=Jl(Re),T=Kl(Re),H=Jl(Be),P=Kl(Be),Be=nh(H,P*T),Re=nh(b*P,oh(H,P*T)),_.phi=$(I,Re),_.lam=Be):_.phi=_.lam=lh}}var ch=57.29577951308232,uh=.017453292519943295,fh=["Traverse_Mercator"],dh={code:"EPSG:9807",aliases:fh,centralMeridian:0,create:function(i){var g={a:6378137,es:.0066943799901413165,x0:H(i.falseEasting)?5e5:i.falseEasting,y0:H(i.falseNorthing)?0:i.falseNorthing,k0:i.scaleFactor||.9996,lam0:(i.centralMeridian||0)*uh,phi0:(i.latitudeOfOrigin||0)*uh,originLam0:i.startLongtitude||0,originPhi0:i.startLatitude||0};hh(g);var m={lam:0,phi:0},_={},b=0,T=0;(g.originLam0||g.originPhi0)&&(m.lam=g.originLam0*uh-g.lam0,m.phi=g.originPhi0*uh,g.fwd(m,_),b=g.a*_.x+g.x0,T=g.a*_.y+g.y0);var P={code:"EPSG:9807",aliases:fh,centralMeridian:i.centralMeridian,project:function(i,P){m.lam=i.x*uh-g.lam0,m.phi=i.y*uh,g.fwd(m,_);var I=g.a*_.x+g.x0-b,H=g.a*_.y+g.y0-T,W=i.z;return P?(P.x=I,P.y=H,P.z=W,P):new pl(I,H,W)},unproject:function(i,P){_.x=(i.x-g.x0+b)/g.a,_.y=(i.y-g.y0+T)/g.a,g.inv(_,m);var I=(m.lam+g.lam0)*ch,H=m.phi*ch,W=i.z;return P?(P.x=I,P.y=H,P.z=W,P):new pl(I,H,W)}};return I({},El,P,Bl)}},ph=I({},El,dh),gh={code:"utm",aliases:[],create:function(i){var g={},m=parseInt(i.zone);if(g.falseNorthing=i.south?1e7:0,g.falseEasting=5e5,!(m>0&&m<=60))throw new Error("zone must be > 0 and <= 60.");return m--,g.centralMeridian=6*(m+.5)-180,g.scaleFactor=.9996,ph.create(g)}},mh=I({},ph,gh),Ah={EARTHRADIUS:6370996.81,MCBAND:[12890594.86,8362377.87,5591021,3481989.83,1678043.12,0],LLBAND:[75,60,45,30,15,0],MC2LL:[[1.410526172116255e-8,898305509648872e-20,-1.9939833816331,200.9824383106796,-187.2403703815547,91.6087516669843,-23.38765649603339,2.57121317296198,-.03801003308653,17337981.2],[-7.435856389565537e-9,8983055097726239e-21,-.78625201886289,96.32687599759846,-1.85204757529826,-59.36935905485877,47.40033549296737,-16.50741931063887,2.28786674699375,10260144.86],[-3.030883460898826e-8,898305509983578e-20,.30071316287616,59.74293618442277,7.357984074871,-25.38371002664745,13.45380521110908,-3.29883767235584,.32710905363475,6856817.37],[-1.981981304930552e-8,8983055099779535e-21,.03278182852591,40.31678527705744,.65659298677277,-4.44255534477492,.85341911805263,.12923347998204,-.04625736007561,4482777.06],[3.09191371068437e-9,8983055096812155e-21,6995724062e-14,23.10934304144901,-.00023663490511,-.6321817810242,-.00663494467273,.03430082397953,-.00466043876332,2555164.4],[2.890871144776878e-9,8983055095805407e-21,-3.068298e-8,7.47137025468032,-353937994e-14,-.02145144861037,-1234426596e-14,.00010322952773,-323890364e-14,826088.5]],LL2MC:[[-.0015702102444,111320.7020616939,0x60e374c3105a3,-0x24bb4115e2e164,0x5cc55543bb0ae8,-0x7ce070193f3784,0x5e7ca61ddf8150,-0x261a578d8b24d0,0x665d60f3742ca,82.5],[.0008277824516172526,111320.7020463578,647795574.6671607,-4082003173.641316,10774905663.51142,-15171875531.51559,12053065338.62167,-5124939663.577472,913311935.9512032,67.5],[.00337398766765,111320.7020202162,4481351.045890365,-23393751.19931662,79682215.47186455,-115964993.2797253,97236711.15602145,-43661946.33752821,8477230.501135234,52.5],[.00220636496208,111320.7020209128,51751.86112841131,3796837.749470245,992013.7397791013,-1221952.21711287,1340652.697009075,-620943.6990984312,144416.9293806241,37.5],[-.0003441963504368392,111320.7020576856,278.2353980772752,2485758.690035394,6070.750963243378,54821.18345352118,9540.606633304236,-2710.55326746645,1405.483844121726,22.5],[-.0003218135878613132,111320.7020701615,.00369383431289,823725.6402795718,.46104986909093,2351.343141331292,1.58060784298199,8.77738589078284,.37238884252424,7.45]],convertMC2LL:function(i,g){for(var m,_=0,b=this.MCBAND.length;_<b;_++)if(Math.abs(i.y)>=this.MCBAND[_]){m=this.MC2LL[_];break}return this.convertor(i,m,g)},convertLL2MC:function(i,g){var m,_,b;i.x=this.getLoop(i.x,-180,180),i.y=this.getRange(i.y,-74,74);var T=new pl(i.x,i.y);for(_=0,b=this.LLBAND.length;_<b;_++)if(T.y>=this.LLBAND[_]){m=this.LL2MC[_];break}if(!m)for(_=this.LLBAND.length-1;_>=0;_--)if(T.y<=-this.LLBAND[_]){m=this.LL2MC[_];break}return this.convertor(i,m,g)},convertor:function(i,g,m){if(!i||!g)return null;var _=g[0]+g[1]*Math.abs(i.x),b=Math.abs(i.y)/g[9],T=g[2]+g[3]*b+g[4]*b*b+g[5]*b*b*b+g[6]*b*b*b*b+g[7]*b*b*b*b*b+g[8]*b*b*b*b*b*b;_*=i.x<0?-1:1,T*=i.y<0?-1:1;var P=i.z;return m?(m.x=_,m.y=T,m.z=P,m):new pl(_,T,P)},toRadians:function(i){return Math.PI*i/180},toDegrees:function(i){return 180*i/Math.PI},getRange:function(i,g,m){return null!=g&&(i=Math.max(i,g)),null!=m&&(i=Math.min(i,m)),i},getLoop:function(i,g,m){if(i===1/0)return m;if(i===-1/0)return g;for(;i>m;)i-=m-g;for(;i<g;)i+=m-g;return i}},yh=I({},El,{code:"BAIDU",project:function(i,g){return this.convertLL2MC(i,g)},unproject:function(i,g){return this.convertMC2LL(i,g)}},Vl,Ah),_h=I({},El,{code:"IDENTITY",project:function(i,g){return g?(g.x=i.x,g.y=i.y,g.z=i.z,g):i.copy()},unproject:function(i,g){return g?(g.x=i.x,g.y=i.y,g.z=i.z,g):i.copy()}},Dl),vh=Zl,xh=Object.freeze({__proto__:null,BAIDU:yh,Common:El,DEFAULT:vh,EPSG3857:Zl,EPSG4326:Yl,EPSG9807:ph,IDENTITY:_h,UTM:mh});function bh(i){return function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g.registerRenderer=function(i,g){var m=this.prototype,_=Object.getPrototypeOf(m);return m._rendererClasses&&m._rendererClasses!==_._rendererClasses||(m._rendererClasses=m._rendererClasses?Object.create(m._rendererClasses):{}),m._rendererClasses[i.toLowerCase()]=g,this},g.getRendererClass=function(i){var g=this.prototype;return g._rendererClasses?g._rendererClasses[i.toLowerCase()]:null},g}(i)}var wh=10,Th=10,Sh=1,Mh=new un(0,0);function Ch(i,g,m,_,b,T){var P=b.x+T.x,I=b.y+T.y;Mh.x=P,Mh.y=I;var H=function(i){if(!i)return 0;var{x:g,y:m}=i;if(0===g&&0===m)return 0;if(0===g||!g){if(m<0)return-Math.PI/2;if(m>0)return Math.PI/2}var _=m/g;return m<0&&g<0?Math.atan(_)-Math.PI:m>0&&g<0?Math.atan(_)+Math.PI:Math.atan(_)}(Mh),W=Math.sqrt(P*P+I*I),q=0,$=0;q+=Math.cos(g+H)*W,$+=Math.sin(g+H)*W;var[ye,Re,Be,Ge]=function(i,g,m){var _=Math.PI/2+m,b=Math.PI/4+m,T=m,P=g,I=Math.sqrt(i*i+g*g),H=i,W=Math.cos(_)*P,q=Math.sin(_)*P,$=Math.cos(b)*I,ye=Math.sin(b)*I,Re=Math.cos(T)*H,Be=Math.sin(T)*H,Ge=Math.min(W,$,Re,0),je=Math.min(q,ye,Be,0);return[Ge,je,Math.max(W,$,Re,0)-Ge,Math.max(q,ye,Be,0)-je]}(m,_,g);$+=Re;var je=(q+=ye)+Math.max(m,Be),Xe=$+Math.max(_,Ge);return i.set(q,$,je,Xe),i}var Ph=new un(0,0);function Ih(i,g,m,_,b,T,P){var I=Ph.set(g,m);if(_)return Ch(i,_,T,P,I,b);var H=i.set(I.x,I.y,I.x+T,I.y+P);return H._add(b),_&&function(i,g){var{xmin:m,ymin:_,xmax:b,ymax:T}=i;Nh.set(m,_,b,T),Nh.convertTo((function(i){return i._rotate(g)}),i)}(H,_),H}var kh=[];function Oh(i,g,m){if((m=m||Fh(kh,g))&&(0===m[0]||0===m[1]))return Yh(i),i;var _=Dh(g,m[0],m[1]);return Ih(i,g.markerDx||0,g.markerDy||0,Hh(g),_,m[0],m[1])}function Eh(i){return"rectangle"===i||"roundrectangle"===i?"right":"middle"}function Rh(i){return"bar"===i||"pie"===i||"pin"===i?"top":"rectangle"===i||"roundrectangle"===i?"bottom":"middle"}var Lh=new ir(0,0);function Dh(i,g,m){var _=2*(i.shadowBlur||0)+.5;Lh.width=g,Lh.height=m;var b=i.markerType,T=_r(Lh,i.markerHorizontalAlignment||Eh(b),i.markerVerticalAlignment||Rh(b));return T.x!==-g/2&&(T.x-=Sn(T.x+g/2)*_),T.y!==-m/2&&(T.y-=Sn(T.y+m/2)*_),T}function Fh(i,g){var m=wn(g.markerWidth,wh),_=wn(g.markerHeight,Th);if(0===m||0===_)return i[0]=0,i[1]=0,i;var b=wn(g.markerLineWidth,Sh),T=2*((g.shadowBlur||0)+Math.max(Math.abs(g.shadowOffsetX||0)+Math.abs(g.shadowOffsetY||0))),P=Math.round(m+b+T+1),I=Math.round(_+b+T+1);return i[0]=P,i[1]=I,i}var Nh=new kl;function Hh(i,g="markerRotation"){var m=i[g];return W(m)?-m*Math.PI/180:0}function Bh(i,g,m){var _=m?m.getImage(g.markerFile):null,b=g.markerWidth||(_?_.width:0),T=g.markerHeight||(_?_.height:0);if(Lh.width=b,Lh.height=T,0===g.markerWidth||0===g.markerHeight)return Yh(i),i;var P=_r(Lh,g.markerHorizontalAlignment||"middle",g.markerVerticalAlignment||"top");return Ih(i,g.markerDx||0,g.markerDy||0,Hh(g),P,b,T)}function zh(i,g,m){var _=m.size;if(_&&(0===_.width||0===_.height))return Yh(i),i;var b=_r(_,g.textHorizontalAlignment,g.textVerticalAlignment),T=g.textHaloRadius||0,P=Ih(i,g.textDx||0,g.textDy||0,Hh(g,"textRotation"),b,_.width,_.height);return P.xmin-=T,P.xmax+=T,P.ymin-=T,P.ymax+=T,P}var Vh=new kl;function Uh(i,g,m,_){var b=i||new kl;if(Array.isArray(g)){for(var T=g,P=0;P<T.length;P++)Uh(b,T[P],m,_[P]);return b}return Gh(g)&&b._combine(zh(Vh,g,_)),jh(g)&&b._combine(Bh(Vh,g,m)),Wh(g)&&b._combine(Oh(Vh,g)),qh(g)&&b._combine(Bh(Vh,g)),b}function Gh(i){return!!i&&!H(i.textName)}function jh(i){return!!i&&!H(i.markerFile)}function Wh(i){return!!i&&!(!H(i.markerFile)||H(i.markerType)||"path"===i.markerType)}function qh(i){return!!i&&!(!H(i.markerFile)||"path"!==i.markerType)}var Xh,Zh=["markerWidth","markerHeight","markerHorizontalAlignment","markerVerticalAlignment","markerDx","markerDy","markerRotation","textName","textSize","textDx","textDy","textVerticalAlignment","textHorizontalAlignment","textRotation","textWrapWidth"],$h=["textName","markerType","markerFile","textHaloRadius","shadowBlur","shadowOffsetX","shadowOffsetY","textWrapWidth"];function Yh(i){i&&(i.xmin=1/0,i.ymin=1/0,i.xmax=-1/0,i.ymax=-1/0)}function Qh(i,g,m,_){for(var b,T=[],P=0,I=0,H=i.length;I<H-1;I++)(b=Jh(i[I],i[I+1],g,I,m,_))&&(T[P]=T[P]||[],T[P].push({point:b[0],index:I}),b[1]===i[I+1]&&I!==H-2||(T[P].push({point:b[1],index:I+1}),P++));return T}function Jh(i,g,m,_,b,T){var P,I,H,W=_?Xh:tc(i,m),q=tc(g,m);for(Xh=q;;){if(!(W|q))return[i,g];if(W&q)return!1;if(T)return[i,g];H=tc(I=ec(i,g,P=W||q,m,b),m),P===W?(i=I,W=H):(g=I,q=H)}}function Kh(i,g,m){var _,b,T,P,I,H,W,q,$,ye=[1,4,2,8];for(b=0,W=i.length;b<W;b++)i[b]._code=tc(i[b],g);for(P=0;P<4;P++){for(q=ye[P],_=[],b=0,T=(W=i.length)-1;b<W;T=b++)H=i[T],(I=i[b])._code&q?H._code&q||(($=ec(H,I,q,g,m))._code=tc($,g),_.push($)):(H._code&q&&(($=ec(H,I,q,g,m))._code=tc($,g),_.push($)),_.push(I));i=_}return i}function ec(i,g,m,_,b){var T,P,I=g.x-i.x,H=g.y-i.y,W=_.getMin(),q=_.getMax();8&m?(T=i.x+I*(q.y-i.y)/H,P=q.y):4&m?(T=i.x+I*(W.y-i.y)/H,P=W.y):2&m?(T=q.x,P=i.y+H*(q.x-i.x)/I):1&m&&(T=W.x,P=i.y+H*(W.x-i.x)/I);var $=new un(T,P);return b&&$._round(),$}function tc(i,g){var m=0;return i.x<g.getMin().x?m|=1:i.x>g.getMax().x&&(m|=2),i.y<g.getMin().y?m|=4:i.y>g.getMax().y&&(m|=8),m}function nc(i,g,m,_){i=new un(i);var b,T,P,I=Math.abs(m.x-g.x),H=Math.abs(m.y-g.y),W=Math.sqrt(Math.abs(I*I-H*H));return I>=H?(b=new un(g.x-W,g.y),T=new un(g.x+W,g.y),P=2*I):(b=new un(g.x,g.y-W),T=new un(g.x,g.y+W),P=2*H),i.distanceTo(b)+i.distanceTo(T)<=P+2*_}function rc(i){if(!i)return[0,0];var g=1/0,m=-1/0;if(W(i))return[g=m=i,m];var _=function(i){for(var _=0,b=i.length;_<b;_++){var T=i[_];g=Math.min(g,T),m=Math.max(m,T)}};if(!Array.isArray(i[0]))return _(i),[g,m];for(var b=0,T=i.length;b<T;b++){_(i[b])}return[g,m]}function ic(i,g,m){var _=g.x,b=g.y,T=m.x,P=m.y;return(b-P)*i.x+(T-_)*i.y+_*P-T*b>0}function oc(i,g,m){return!ic(i,g,m)}function sc(i,g,m,_,b){var T=oc(i,g,m),P=oc(i,m,_),I=oc(i,_,b),H=oc(i,b,g);return T&&P&&I&&H}function ac(i,g,m,_){var b=g.x-i.x,T=g.y-i.y,P=_.x-m.x,I=_.y-m.y;if(0===b&&0===P)return null;if(0===T&&0===I)return null;var H=T/b,W=I/P;if(Math.abs(H)===Math.abs(W))return null;var q,$,ye=i.y-H*i.x,Re=m.y-W*m.x;return 0===b?$=W*(q=i.x)+Re:0===P?$=H*(q=m.x)+ye:0===T?q=(($=i.y)-Re)/W:0===I?q=(($=m.y)-ye)/H:$=H*(q=(Re-ye)/(H-W))+ye,new un(q,$)}function lc(i){if(W(i))return 0!==i;if(Array.isArray(i)&&i.length>0)for(var g=0,m=i.length;g<m;g++)if(W(i[g])&&0!==i[g])return!0;return!1}var hc=function(){function i(){this.bbox=Bo()}var g=i.prototype;return g._setBBOX=function(i,g,m,_,b){return i.isHitTesting||jo(this.bbox,g,m,_,b),this},g._bufferBBOX=function(i,g){return i.isHitTesting||qo(this.bbox,g),this},g.getMap=function(){return this.geometry.getMap()},g.getPainter=function(){return this.painter},g.isDynamicSize=function(){return!1},g.isVisible=function(){if(!this.style)return!0;var i=this.style.visible;return!1!==i&&0!==i&&!(this.style.opacity<=0)},i.testColor=function(i){return!(!i||!ye(i))&&rr.indexOf(i)>=0},i}(),cc=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m._prepareContext=function(i){if(Ii(this.symbol.opacity)?this._opacityFn||(this._opacityFn=Oi(this.symbol.opacity)):delete this._opacityFn,W(this.symbol.opacity))i.globalAlpha!==this.symbol.opacity&&(i.globalAlpha=this.symbol.opacity);else if(this._opacityFn){var g=this.getMap();i.globalAlpha=this._opacityFn(g.getZoom())}else 1!==i.globalAlpha&&(i.globalAlpha=1)},m.prepareCanvas=function(i,g,m){i.setLineDash&&kn(g.lineDasharray)&&i.setLineDash(g.lineDasharray);var _=this.getPainter().isHitTesting();Va.prepareCanvas(i,g,m,_)},m.remove=function(){},m.setZIndex=function(){},m.show=function(){},m.hide=function(){},m._defineStyle=function(i){return this.symbol&&(i.visible=this.symbol.visible,i.opacity=this.symbol.opacity),Qi(i,this.geometry)},g}(hc);function uc(i,g,m,_,b){var T,P=fc(m),I=m,H=I.markerType.toLowerCase(),W=dc(H,I.markerWidth,I.markerHeight),q=P.lineOpacity,$=P.polygonOpacity;so(P.polygonFill)&&(so(P.polygonFill)&&(T||(T=function(i,g,m){var _=new kl;return _._combine(i),_.xmin+=-g/2,_.ymin+=-m/2,_.xmax+=g/2,_.ymax+=m/2,_}(g,I.markerWidth,I.markerHeight)),P.polygonGradientExtent=T));Va.prepareCanvas(i,P,_);var ye=I.markerWidth,Re=I.markerHeight,Be=I.markerLineWidth||0,Ge=Be/2;if("ellipse"===H)Va.ellipse(i,g,ye/2,Re/2,Re/2,q,$);else if("cross"===H||"x"===H){for(var je=W.length-1;je>=0;je--)W[je]._add(g);Va.path(i,W.slice(0,2),q),Va.path(i,W.slice(2,4),q)}else if("diamond"===H||"bar"===H||"square"===H||"rectangle"===H||"triangle"===H||"roundrectangle"===H){"bar"===H?g=g.add(0,-Ge):"rectangle"!==H&&"roundrectangle"!==H||(g=g.add(Ge,Ge));for(var Xe=W.length-1;Xe>=0;Xe--)W[Xe]._add(g);"roundrectangle"===H?Va.roundRect(i,W,q,$):Va.polygon(i,W,q,$)}else if("pin"===H){g=g.add(0,-Ge);for(var Ze=W.length-1;Ze>=0;Ze--)W[Ze]._add(g);var Ye=i.lineCap;i.lineCap="round",Va.bezierCurveAndFill(i,W,q,$),i.lineCap=Ye}else{if("pie"!==H)throw new Error("unsupported markerType: "+H);g=g.add(0,-Ge);var Qe=180*Math.atan(ye/2/Re)/Math.PI,Je=i.lineCap;i.lineCap="round",Va.sector(i,g,Re,[90-Qe,90+Qe],q,$),i.lineCap=Je}if(b){var{x:Ke,y:et}=g;b[0]=Ke-ye/2-Be,b[1]=et-Re/2-Be,b[2]=Ke+ye/2+Be,b[3]=et+Re/2+Be}return i.canvas}function fc(i){var g={lineColor:i.markerLineColor,linePatternFile:i.markerLinePatternFile,lineWidth:i.markerLineWidth,lineOpacity:i.markerLineOpacity,lineDasharray:i.markerLineDasharray,lineCap:"butt",lineJoin:"round",polygonFill:i.markerFill,polygonPatternFile:i.markerFillPatternFile,polygonOpacity:i.markerFillOpacity};return 0===g.lineWidth&&(g.lineOpacity=0),g}function dc(i,g,m){var _,b,T,P,I=m/2,H=g/2;if("triangle"===i)return[_=new un(0,0-I),b=new un(0-H,0+I),T=new un(0+H,0+I)];if("cross"===i)return[_=new un(0-H,0),b=new un(0+H,0),T=new un(0,0-I),P=new un(0,0+I)];if("diamond"===i)return[_=new un(0-H,0),b=new un(0,0-I),T=new un(0+H,0),P=new un(0,0+I)];if("square"===i)return[_=new un(0-H,0+I),b=new un(0+H,0+I),T=new un(0+H,0-I),P=new un(0-H,0-I)];if("rectangle"===i||"roundrectangle"===i)return b=(_=new un(0,0)).add(g,0),T=_.add(g,m),P=_.add(0,m),[_,b,T,P];if("x"===i)return[_=new un(0-H,0+I),b=new un(0+H,0-I),T=new un(0+H,0+I),P=new un(0-H,0-I)];if("bar"===i)return[_=new un(0-H,0-m),b=new un(0+H,0-m),T=new un(0+H,0),P=new un(0-H,0)];if("pin"===i||"pie"===i){var W=m*Math.atan(H/I);return[_=new un(0,0),b=new un(0-W,0-m),T=new un(0+W,0-m),P=new un(0,0)]}return[]}var pc=new un(0,0),gc=new un(0,0),mc=new un(0,0),Ac=new un(0,0),yc=function(i){function g(g,m,_){var b;return(b=i.call(this)||this).symbol=g,b.geometry=m,b.painter=_,b.rotations=[],b}tn(g,i);var m=g.prototype;return m.get2DExtent=function(){for(var i=this.getMap(),g=i.getGLRes(),m=new kl,_=this._getRenderPoints()[0],b=_.length-1;b>=0;b--)_[b]&&m._combine(i._pointAtResToPoint(_[b],g));return m},m.isDynamicSize=function(){var i=this.symbol;return Ii(i.markerWidth)||Ii(i.markerHeight)||Ii(i.textSize)},m._rotateExtent=function(i,g){return i.convertTo((function(i){return i._rotate(g)}))},m._getRenderPoints=function(){var i=this.getPainter().isSpriting()?"center":this.getPlacement();return this.getPainter().getRenderPoints(i)},m._getRenderContainerPoints=function(i){var g=this.getPainter();if(g.isSpriting())return this._getRenderPoints()[0];var m,_=this.geometry,b=this.getDxDy();if(_._cPoint&&!i){var T=i?mc:Ac;T.set(_._cPoint.x,_._cPoint.y),T._sub(g.containerOffset);var P=b.x,I=b.y;(P||I)&&T._add(P||0,I||0),m=[T]}else{var H=this._getRenderPoints()[0];m=this.painter._pointContainerPoints(H,b.x,b.y,i,!0,this.getPlacement())}if(!m||!Array.isArray(m[0]))return m;for(var W=[],q=0,$=m.length;q<$;q++)for(var ye=0,Re=m[q].length;ye<Re;ye++)W.push(m[q][ye]);return W},m.getPlacement=function(){return this.symbol.markerPlacement},m.getRotation=function(){return Hh(this.style)},m.getDxDy=function(){var i=this.style;return new un(i.markerDx,i.markerDy)},m._getRotationAt=function(i){var g=this.getRotation();g||(g=0);var m=this._getRenderPoints()[1];if(!m||!m[i])return g;var _=this.getMap(),b=m[i][0],T=m[i][1];if(!b||!T)return g;if(_.isTransforming()){var P=_.getGLRes();return b=_._pointAtResToContainerPoint(m[i][0],P,0,pc),T=_._pointAtResToContainerPoint(m[i][1],P,0,gc),g+Bn(b.x,b.y,T.x,T.y)}return g+-Bn(b.x,b.y,T.x,T.y)},m._rotate=function(i,g,m){if(m){var _=this.getDxDy(),b=g.sub(_);return i.save(),i.translate(b.x,b.y),i.rotate(m),_}return null},g}(cc),_c=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.getPlacement=function(){return"point"},m.getDxDy=function(){return new un(0,0)},m.symbolize=function(i){var g=this.geometry,m=g.getLayer();if(g.options.debug||!m||m.options.debug){var _=this.getMap();if(_&&!_.isZooming()){var b=m.options.debugOutline;i.strokeStyle=b,i.fillStyle=b,i.lineWidth=1,i.font="18px  serif";var T=g.getContainerExtent().toArray();Va.polygon(i,[T],1,0);for(var P=this._getRenderContainerPoints(),I=this.geometry.getId(),W=dc("cross",10,10),q=0;q<P.length;q++){var $=P[q];H(I)||Va.fillText(i,I,$.add(8,-4),b);for(var ye=[],Re=0;Re<W.length;Re++)ye.push(W[Re].add($));Va.path(i,ye.slice(0,2),1),Va.path(i,ye.slice(2,4),1)}}}},g}(yc),vc=new ir(1,1),xc=new kl,bc=function(i){function g(g,m,_){var b;return(b=i.call(this,g,m,_)||this).style=b._defineStyle(b.translate()),b}tn(g,i),g.test=function(i){return jh(i)};var m=g.prototype;return m.symbolize=function(i,g){if(this.isVisible()){var m=this.style;if(this.painter.isHitTesting()||0!==m.markerWidth&&0!==m.markerHeight&&0!==m.markerOpacity){var _=this._getRenderContainerPoints();if(kn(_))if(m.markerFile||this._url){var b=this._getImage(g);if(b){this._prepareContext(i);var T,P=m.markerWidth,I=m.markerHeight;if(!W(P)||!W(I)){I=b.height,m.markerWidth=P=b.width,m.markerHeight=I;var H=m.markerFile;g.isResourceLoaded(H)||g.addResource(H,b);var q=this.getPainter();q.isSpriting()||q.removeCache()}"path"!==this.symbol.markerType&&W(m.markerOpacity)&&m.markerOpacity<1&&(T=i.globalAlpha,i.globalAlpha*=m.markerOpacity),vc.width=P,vc.height=I;var $=_r(vc,m.markerHorizontalAlignment,m.markerVerticalAlignment);this.rotations=[];for(var ye=0,Re=_.length;ye<Re;ye++){var Be=_[ye],Ge=this._rotate(i,Be,this._getRotationAt(ye)),je=void 0;if(Ge){var Xe=Be.sub(Ge);Be=Ge;var Ze=this._getRotationAt(ye);(je=Ch(xc,Ze,P,I,Be,$))._add(Xe),this.rotations.push(Ze)}var Ye=Be.x+$.x,Qe=Be.y+$.y;Va.image(i,b,Ye,Qe,P,I),Ge&&i.restore(),Ge?this._setBBOX(i,je.xmin,je.ymin,je.xmax,je.ymax):this._setBBOX(i,Ye,Qe,Ye+P,Qe+I)}void 0!==T&&(i.globalAlpha=T)}else"undefined"!=typeof console&&console.warn("no img found for "+(this.style.markerFile||this._url[0]))}else console.warn("not find icon url:",m)}}},m._getImage=function(i){return function(i,g){return i&&i.getImage(g)||null}(i,this.style.markerFile)},m.getFixedExtent=function(i){return this._fixedExtent=this._fixedExtent||new kl,Bh(this._fixedExtent,this.style,i)},m.translate=function(){var i=this.symbol;return{markerFile:i.markerFile,markerOpacity:wn(i.markerOpacity,1),markerWidth:wn(i.markerWidth,null),markerHeight:wn(i.markerHeight,null),markerRotation:wn(i.markerRotation,0),markerDx:wn(i.markerDx,0),markerDy:wn(i.markerDy,0),markerHorizontalAlignment:wn(i.markerHorizontalAlignment,"middle"),markerVerticalAlignment:wn(i.markerVerticalAlignment,"top")}},g}(yc);let wc;const Tc={width:100,height:10};let Sc=!1;try{const i=new OffscreenCanvas(1,1);i.getContext("2d").fillText("hello",0,0),Sc=!0}catch(i){Sc=!1}let Mc=class ColorIn{constructor(i,g={}){if(!Array.isArray(i))return void console.error("colors is not array");if(i.length<2)return void console.error("colors.length should >1");this.colors=i;let m=1/0,_=-1/0;for(let g=0,b=i.length;g<b;g++){const b=i[g][0];m=Math.min(b,m),_=Math.max(b,_)}this.min=m,this.max=_,this.valueOffset=this.max-this.min,this.options=Object.assign({},Tc,g),this._initImgData()}getImageData(){return this.imgData}_initImgData(){const i=function(){if(!wc){const{width:i,height:g}=Tc;Sc?wc=new OffscreenCanvas(i,g):(wc=document.createElement("canvas"),wc.width=i,wc.height=g)}return wc}(),{width:g,height:m}=this.options;i.width=g,i.height=m;const _=i.getContext("2d");_.clearRect(0,0,i.width,i.height);const b=_.createLinearGradient(0,0,i.width,0),{colors:T,valueOffset:P}=this;for(let i=0,g=T.length;i<g;i++){const[g,m]=T[i];b.addColorStop((g-this.min)/P,m)}_.fillStyle=b,_.fillRect(0,0,i.width,i.height),this.imgData=_.getImageData(0,0,i.width,i.height)}getColor(i){i=Math.max(this.min,i),i=Math.min(i,this.max);let g=Math.round((i-this.min)/this.valueOffset*this.imgData.width);g=Math.min(g,this.imgData.width-1);const m=4*g;return[this.imgData.data[m],this.imgData.data[m+1],this.imgData.data[m+2],this.imgData.data[m+3]]}};var Cc=new pl(0,0),Pc=new pl(0,0),Ic=function(i){function g(g,m,_){var b;return(b=i.call(this)||this).symbol=g,b.geometry=m,b.painter=_,m.isPoint?Qt(b):(b.style=b._defineStyle(b.translate()),b)}tn(g,i),g.test=function(i,g){if(!i)return!1;if(g&&g.isPoint)return!1;for(var m in i){var _=m.slice(0,4);if("line"===_||"poly"===_)return!0}return!1};var m=g.prototype;return m.symbolize=function(i,g){if(this.isVisible()){var m=this.style;if(0!==m.polygonOpacity||0!==m.lineOpacity||this.painter.isHitTesting()){var _=this._getPaintParams();if(_){this._prepareContext(i);var b=so(m.lineColor)||m.lineGradientProperty,T="Polygon"===this.geometry.getJSONType()||"LineString"===this.geometry.type;!b||!m.lineColor.places&&T||(m.lineGradientExtent=this.geometry.getContainerExtent()._expand(m.lineWidth)),so(m.polygonFill)&&(m.polygonGradientExtent=this.geometry.getContainerExtent());var P=this.geometry.getLayer().options.geometryEventTolerance||0,I=this.geometry._hitTestTolerance()+P,H=_[0];if("Polygon"===this.geometry.getJSONType()&&H.length>0&&Array.isArray(H[0][0])||"LineString"===this.geometry.type&&H.length>0&&Array.isArray(H[0]))for(var W=0;W<H.length;W++){this.prepareCanvas(i,m,g),b&&T&&!m.lineColor.places&&this._createGradient(i,H[W],m.lineColor);var q=[i,H[W]];_.length>1&&q.push(..._.slice(1)),q.push(m.lineOpacity,m.polygonOpacity,m.lineDasharray),b&&q.push(this._lineColorIn);var $=this.geometry._paintOn(...q);this._setBBOX(i,$),this._bufferBBOX(i,I)}else{this.prepareCanvas(i,m,g),b&&T&&!m.lineColor.places&&this._createGradient(i,H,m.lineColor);var ye=[i];ye.push(..._),ye.push(m.lineOpacity,m.polygonOpacity,m.lineDasharray),b&&ye.push(this._lineColorIn);var Re=this.geometry._paintOn(...ye);this._setBBOX(i,Re),this._bufferBBOX(i,I)}i.setLineDash&&Array.isArray(m.lineDasharray)&&i.setLineDash([]),this._tempRenderPoints=H}}}},m.get2DExtent=function(){var i=this.getMap(),g=this.geometry._getPrjExtent();if(!g)return null;this._extMin&&this._extMax||(this._extMin=new pl(0,0),this._extMax=new pl(0,0)),this._extMin.x=g.xmin,this._extMin.y=g.ymin,this._extMax.x=g.xmax,this._extMax.y=g.ymax;var m=i._prjToPoint(this._extMin,void 0,Cc),_=i._prjToPoint(this._extMax,void 0,Pc);return this._pxExtent?this._pxExtent.set(Math.min(m.x,_.x),Math.min(m.y,_.y),Math.max(m.x,_.x),Math.max(m.y,_.y)):this._pxExtent=new kl(m,_),this._pxExtent},m.getFixedExtent=function(){var i=this.style.lineWidth/2;return new kl(-i,-i,i,i)},m._getPaintParams=function(){return this.getPainter().getPaintParams(this.style.lineDx,this.style.lineDy)},m.translate=function(){var i=this.symbol,g={lineColor:wn(i.lineColor,"#000"),lineWidth:wn(i.lineWidth,2),lineOpacity:wn(i.lineOpacity,1),lineDasharray:wn(i.lineDasharray,[]),lineCap:wn(i.lineCap,"butt"),lineJoin:wn(i.lineJoin,"miter"),linePatternFile:wn(i.linePatternFile,null),lineDx:wn(i.lineDx,0),lineDy:wn(i.lineDy,0),polygonFill:wn(i.polygonFill,null),polygonOpacity:wn(i.polygonOpacity,1),polygonPatternFile:wn(i.polygonPatternFile,null),polygonPatternDx:wn(i.polygonPatternDx,0),polygonPatternDy:wn(i.polygonPatternDy,0),linePatternDx:wn(i.linePatternDx,0),linePatternDy:wn(i.linePatternDy,0),lineGradientProperty:wn(i.lineGradientProperty,null),lineStrokeColor:wn(i.lineStrokeColor,null),lineStrokeWidth:wn(i.lineStrokeWidth,null)};return 0===g.lineWidth&&(g.lineOpacity=0),"LineString"!==this.geometry.type||g.polygonFill||(g.polygonFill=g.lineColor),g},m._createGradient=function(i,g,m){if(Array.isArray(g)&&g.length){var[_,b]=function(i){var g,m=!0;Array.isArray(i[0])?(g=i[0],m=!1):g=i;var _=g.length;if(m)return[g[0],g[_-1]];for(var b,T=g[0],P=0,I=1;I<_;I++){var H=g[I],W=T.distanceTo(H);W>P&&(P=W,b=H)}return[T,b]}(g);if(_&&b){var T;if(m.colorStops&&(T=m.colorStops),!T)T=(this.geometry.properties||{})[(this.style||{}).lineGradientProperty];if(T&&Array.isArray(T)&&!(T.length<2)){if(!Array.isArray(T[0])){for(var P=[],I=[],H=0,W=0,q=T.length;W<q;W+=2)I[0]=T[W],I[1]=T[W+1],P[H]=I,H++,I=[];T=P}var $=i.createLinearGradient(_.x,_.y,b.x,b.y);T.forEach((function(i){$.addColorStop(...i)})),i.strokeStyle=$;var ye=JSON.stringify(T);if(ye!==this._lineColorStopsKey){this._lineColorStopsKey=ye;var Re=T.map((function(i){return[parseFloat(i[0]),i[1]]}));this._lineColorIn=new Mc(Re,{height:1,width:100})}}}else console.error("unable create canvas LinearGradient,error data:",g)}},g}(cc);var kc=new kl;var Oc,Ec=function(i){function g(g,m,_){var b,T=(b=i.call(this,g,m,_)||this).translate();return b._dynamic=ki(T),b.style=b._defineStyle(T),0===b.style.textWrapWidth?Qt(b):(b.strokeAndFill=b._defineStyle(b.translateLineAndFill(b.style)),b)}tn(g,i),g.test=function(i){return Gh(i)};var m=g.prototype;return m.isAlongLine=function(){var i=this.getPlacement(),g=this.style.textSpacing;return"line"===i&&W(g)&&g>0},m.symbolize=function(i,g){if(this.isVisible()){var m=this.style;if(this.painter.isHitTesting()||0!==m.textSize&&(m.textOpacity||m.textHaloRadius&&m.textHaloOpacity)&&0!==m.textWrapWidth){var _=this.strokeAndFill,b=Ar(this.style.textName,this.geometry.getProperties());this._dynamic&&delete this._textDesc;var T=this._textDesc=this._textDesc||yr(b,this.style);this._prepareContext(i),this.prepareCanvas(i,_,g),this._textFont||(this._textFont=br(m)),Va.prepareCanvasFont(i,m,this._dynamic?null:this._textFont);var P=m.textHaloRadius||0;if(this.rotations=[],this.isAlongLine()){var I=this.getPainter().getPathTempRenderPoints();if(!I)return;if(I=function(i,g){var{width:m,height:_}=g,b=m+0,T=_+0;kc.xmin=-0,kc.ymin=-0,kc.xmax=b,kc.ymax=T,Array.isArray(i[0])||(i=[i]);var P=[];return i.forEach((function(i){for(var g=!1,m=0,_=i.length;m<_;m++){var{x:I,y:H}=i[m];if(I<-0||I>b||H<-0||H>T){g=!0;break}}g?Qh(i,kc,!1,!1).forEach((function(i){for(var g=[],m=0,_=i.length;m<_;m++)g[m]=i[m].point;P.push(g)})):P.push(i)})),P}(I,this.getMap().getSize()),I){var H=this.geometry.getLayer(),W=Va.textAlongLine(i,b,I,m,T,H.options.collision?H.getCollisionIndex():null);W&&(this._setBBOX(i,W),this._bufferBBOX(i,P))}}else{var q=this._getRenderContainerPoints();if(!kn(q))return;for(var $=0,ye=q.length;$<ye;$++){var Re=q[$],Be=this._rotate(i,Re,this._getRotationAt($)),Ge=void 0;if(Be){var je=Re.sub(Be);Re=Be;var Xe=this._getRotationAt($),{width:Ze,height:Ye}=T.size||{width:0,height:0},Qe=_r(T.size,m.textHorizontalAlignment,m.textVerticalAlignment);(Ge=Ch(kc,Xe,Ze,Ye,Re,Qe))._add(je),this.rotations.push(Xe)}var Je=Va.text(i,b,Re,m,T);Be?(this._setBBOX(i,Ge.xmin,Ge.ymin,Ge.xmax,Ge.ymax),i.restore()):this._setBBOX(i,Je),this._bufferBBOX(i,P)}}}}},m.getPlacement=function(){return this.symbol.textPlacement},m.getRotation=function(){var i=this.style.textRotation;return W(i)?-i*Math.PI/180:null},m.getDxDy=function(){var i=this.style;return new un(i.textDx,i.textDy)},m.getFixedExtent=function(){var i=this.geometry.getTextDesc();return Array.isArray(i)&&(i=i[this._index]),this._fixedExtent=this._fixedExtent||new kl,i?zh(this._fixedExtent,this.style,i):this._fixedExtent},m.translate=function(){var i=this.symbol,g={textName:i.textName,textFaceName:wn(i.textFaceName,"monospace"),textWeight:wn(i.textWeight,"normal"),textStyle:wn(i.textStyle,"normal"),textSize:wn(i.textSize,14),textFont:wn(i.textFont,null),textFill:wn(i.textFill,"#000"),textOpacity:wn(i.textOpacity,1),textHaloFill:wn(i.textHaloFill,"#ffffff"),textHaloRadius:wn(i.textHaloRadius,0),textHaloOpacity:wn(i.textHaloOpacity,1),textWrapWidth:wn(i.textWrapWidth,null),textWrapCharacter:wn(i.textWrapCharacter,"\n"),textLineSpacing:wn(i.textLineSpacing,0),textDx:wn(i.textDx,0),textDy:wn(i.textDy,0),textHorizontalAlignment:wn(i.textHorizontalAlignment,"middle"),textVerticalAlignment:wn(i.textVerticalAlignment,"middle"),textAlign:wn(i.textAlign,"center"),textRotation:wn(i.textRotation,0),textMaxWidth:wn(i.textMaxWidth,0),textMaxHeight:wn(i.textMaxHeight,0),textSpacing:wn(i.textSpacing,0),textAlongDebug:wn(i.textAlongDebug,!1)};return g.textMaxWidth>0&&(!g.textWrapWidth||g.textWrapWidth>g.textMaxWidth)&&(g.textWrapWidth||(g.textMaxHeight=1),g.textWrapWidth=g.textMaxWidth),g},m.translateLineAndFill=function(i){return{lineColor:i.textHaloRadius?i.textHaloFill:i.textFill,lineWidth:i.textHaloRadius,lineOpacity:i.textOpacity,lineDasharray:null,lineCap:"butt",lineJoin:"round",polygonFill:i.textFill,polygonOpacity:i.textOpacity}},g}(yc),Rc=[0,0],Lc=new kl,Dc=new un(0,0),Fc=Bo(),Nc=function(i){function g(g,m,_){var b,T=(b=i.call(this,g,m,_)||this).translate();return b._dynamic=ki(T),b.style=b._defineStyle(T),b.strokeAndFill=b._defineStyle(fc(b.style)),b.padding=0,b}tn(g,i),g.test=function(i){return Wh(i)};var m=g.prototype;return m.symbolize=function(i,g){if(this.isVisible()){var m=this.style;if(this.painter.isHitTesting()||0!==m.markerWidth&&0!==m.markerHeight&&(0!==m.polygonOpacity||0!==m.lineOpacity)){var _=this._getRenderContainerPoints();kn(_)&&(this._prepareContext(i),this.getPainter().isSpriting()||this.geometry.getLayer().getMask()===this.geometry||this._dynamic||!1===this.geometry.getLayer().options.cacheVectorOnCanvas?this._drawMarkersWithDynamic(i,_,g):this._drawMarkersWithCache(i,_,g))}}},m._drawMarkersWithDynamic=function(i,g,m){for(var _=g.length-1;_>=0;_--){var b=g[_],T=Fh(Rc,this.style),[P,I]=T,H=this._rotate(i,b,this._getRotationAt(_));this.rotations=[];var W=void 0;if(H){var q=b.sub(H);b=H;var $=this._getRotationAt(_);(W=Ch(Lc,$,P,I,b,Dc))._add(q),this.rotations.push($)}var ye=this._drawVectorMarker(i,b,m);if(H)i.restore(),this._setBBOX(i,W.xmin,W.ymin,W.xmax,W.ymax);else if(ye)this._setBBOX(i,ye[0],ye[1],ye[2],ye[3]);else{var{x:Re,y:Be}=b;this._setBBOX(i,Re,Be,Re+P,Be+I)}}},m._drawMarkersWithCache=function(i,g,m){var _=this._stampSymbol(),b=m.getImage(_);b||(b=this._createMarkerImage(i,m),m.addResource([_,b.width,b.height],b));for(var T=Dh(this.style,b.width,b.height),P=g.length-1;P>=0;P--){var I=g[P],H=this._rotate(i,I,this._getRotationAt(P));this.rotations=[];var W=void 0;if(H){var q=I.sub(H);I=H;var $=this._getRotationAt(P);(W=Ch(Lc,$,b.width,b.height,I,T))._add(q),this.rotations.push($)}var ye=I.x+T.x,Re=I.y+T.y;Va.image(i,b,ye,Re),H?(i.restore(),this._setBBOX(i,W.xmin,W.ymin,W.xmax,W.ymax)):this._setBBOX(i,ye,Re,ye+b.width,Re+b.height)}},m._createMarkerImage=function(i,g){var m=i.canvas.constructor,_=Fh(Rc,this.style),b=Va.createCanvas(_[0],_[1],m),T=this._getCacheImageAnchor(_[0],_[1]),P=b.getContext("2d");return this._drawVectorMarker(P,T,g),b},m._stampSymbol=function(){return this._stamp||(this._stamp=Tr([this.style.markerType,so(this.style.markerFill)?ao(this.style.markerFill):this.style.markerFill,this.style.markerFillOpacity,this.style.markerFillPatternFile,so(this.style.markerLineColor)?ao(this.style.markerLineColor):this.style.markerLineColor,this.style.markerLineWidth,this.style.markerLineOpacity,this.style.markerLineDasharray?this.style.markerLineDasharray.join(","):"",this.style.markerLinePatternFile,this.style.markerWidth,this.style.markerHeight,this.style.markerHorizontalAlignment,this.style.markerVerticalAlignment].join("_"))),this._stamp},m._getCacheImageAnchor=function(i,g){var m=2*(this.symbol.shadowBlur||0)+this.padding,_=this.style.markerType;return"bar"===_||"pie"===_||"pin"===_?new un(i/2,g-m):"rectangle"===_||"roundrectangle"===_?new un(m,m):new un(i/2,g/2)},m._getGraidentExtent=function(i){var g=new kl,m=this.getDxDy(),_=this.getFixedExtent();if(Array.isArray(i))for(var b=i.length-1;b>=0;b--)g._combine(i[b]);else g._combine(i);return g.xmin+=_.xmin-m.x,g.ymin+=_.ymin-m.y,g.xmax+=_.xmax-m.x,g.ymax+=_.ymax-m.y,g},m._drawVectorMarker=function(i,g,m){return Uo(Fc),uc(i,g,this.style,m,Fc),Fc},m.getFixedExtent=function(){return this._fixedExtent=this._fixedExtent||new kl,Oh(this._fixedExtent,this.style,null)},m.translate=function(){var i=this.symbol,g={markerType:wn(i.markerType,"ellipse"),markerFill:wn(i.markerFill,"#00f"),markerFillOpacity:wn(i.markerFillOpacity,1),markerFillPatternFile:wn(i.markerFillPatternFile,null),markerLineColor:wn(i.markerLineColor,"#000"),markerLineWidth:wn(i.markerLineWidth,Sh),markerLineOpacity:wn(i.markerLineOpacity,1),markerLineDasharray:wn(i.markerLineDasharray,[]),markerLinePatternFile:wn(i.markerLinePatternFile,null),markerDx:wn(i.markerDx,0),markerDy:wn(i.markerDy,0),markerWidth:wn(i.markerWidth,wh),markerHeight:wn(i.markerHeight,Th),markerRotation:wn(i.markerRotation,0),shadowBlur:wn(i.shadowBlur,0),shadowOffsetX:wn(i.shadowOffsetX,0),shadowOffsetY:wn(i.shadowOffsetY,0)},m=g.markerType,_=Eh(m),b=Rh(m);return g.markerHorizontalAlignment=wn(i.markerHorizontalAlignment,_),g.markerVerticalAlignment=wn(i.markerVerticalAlignment,b),W(i.markerOpacity)&&(W(i.markerFillOpacity)&&(g.markerFillOpacity*=i.markerOpacity),W(i.markerLineOpacity)&&(g.markerLineOpacity*=i.markerOpacity)),g},g}(yc),Hc=function(i){function g(g,m,_){var b;H(g.markerWidth)&&(g.markerWidth=80),H(g.markerHeight)&&(g.markerHeight=80),g=I({},g,(b=i.call(this,g,m,_)||this).translate());var T=b.style=b._defineStyle(g);return b._url=$t.gecko?[to(T,T.markerWidth,T.markerHeight),T.markerWidth,T.markerHeight]:[to(T),T.markerWidth,T.markerHeight],b}tn(g,i),g.test=function(i){return qh(i)};var m=g.prototype;return m._prepareContext=function(){},m._getImage=function(i){var g=this;if(i&&i.isResourceLoaded(this._url))return i.getImage(this._url);var m=this.painter,_=new Image;return _.onload=function(){var i=m.getLayer()&&m.getLayer().getRenderer();i&&i.setToRedraw()},_.onerror=function(m){m&&"undefined"!=typeof console&&console.warn(m),i.markErrorResource(g._url)},_.src=this._url[0],i&&i.addResource(this._url,_),_},g}(bc),Bc={lineWidth:1,polygonFill:"#fff",polygonOpacity:.5},zc=function(i){function g(g,m,_){var b;return(b=i.call(this,g,m,_)||this).style=m.getLayer().options.drawAltitude,b.style&&$(b.style)||(b.style={lineWidth:2}),b.style.lineWidth||(b.style.lineWidth=0),b.dxdy=b._defineStyle({dx:g.textDx||g.markerDx,dy:g.textDy||g.markerDy}),b}tn(g,i),g.test=function(i,g){if(!g.getLayer())return!1;var m=g.getJSONType();return"Marker"===m||"LineString"===m};var m=g.prototype;return m.symbolize=function(i){if(this.geometry.getLayer().options.drawAltitude&&this.geometry.hasAltitude()){var g=this._getStyle();if(this._prepareContext(i),"LineString"===this.geometry.type){var m=this._getPaintParams(g.lineDx,g.lineDy);if(!m)return;var _=this.getPainter().getPaintParams(g.lineDx,g.lineDy,!0,!0,"_groundpt")[0];this._drawLineAltitude(i,m[0],_)}else{var b=this._getRenderContainerPoints(),T=this._getRenderContainerPoints(!0);if(!b||0===b.length)return;this._drawMarkerAltitude(i,b[0],T[0])}}},m.getDxDy=function(){var i=this.dxdy;return new un(i.dx||0,i.dy||0)},m.get2DExtent=function(){return"LineString"===this.geometry.type?Ic.prototype.get2DExtent.apply(this):i.prototype.get2DExtent.call(this)},m.getPlacement=function(){return"point"},m._getPaintParams=function(i,g){return this.getPainter().getPaintParams(i||0,g||0,null,!0,"_altpt")},m._drawMarkerAltitude=function(i,g,m){var _=this._getStyle();this.prepareCanvas(i,_),Va.path(i,[g,m],_.lineOpacity,null,_.lineDasharray)},m._drawLineAltitude=function(i,g,m){var _=this._getStyle();if(g.length>0&&Array.isArray(g[0]))for(var b=0;b<g.length;b++)this._drawLine(i,g[b],m[b]);else this._drawLine(i,g,m);i.setLineDash&&Array.isArray(_.lineDasharray)&&i.setLineDash([])},m._drawLine=function(i,g,m){var _=this._getStyle();this.prepareCanvas(i,_);for(var b=0,T=g.length-1;b<T;b++)Va.polygon(i,[g[b],g[b+1],m[b+1],m[b]],_.lineOpacity,_.polygonOpacity,_.lineDasharray)},m._getStyle=function(){var i=this.geometry.getLayer(),g=i.options.drawAltitude;if(Array.isArray(g)){var m=(i.getGeometries()||[]).indexOf(this.geometry);m>=0&&(g=g[m]||Bc)}return $(g)||(g=Bc),g.lineWidth||(g.lineWidth=0,g.lineOpacity=0),g},g}(yc),Vc=Object.freeze({__proto__:null,CanvasSymbolizer:cc,DebugSymbolizer:_c,DrawAltitudeSymbolizer:zc,ImageMarkerSymbolizer:bc,PointSymbolizer:yc,StrokeAndFillSymbolizer:Ic,Symbolizer:hc,TextMarkerSymbolizer:Ec,VectorMarkerSymbolizer:Nc,VectorPathMarkerSymbolizer:Hc}),Uc=[zc,Ic,bc,Hc,Nc,Ec],Gc=new un(0,0),jc=new kl,Wc=new kl,qc=new kl,Xc=new kl,Zc=new kl,$c={code:void 0},Yc={minx:1/0,miny:1/0,maxx:-1/0,maxy:-1/0},Qc=[],Jc=function(i){function g(g){var m;return(m=i.call(this)||this).geometry=g,m.symbolizers=m._createSymbolizers(),m._altAtGL=m._getGeometryAltitude(),m.bbox=Bo(),m._drawTime=0,m}tn(g,i);var m=g.prototype;return m._setDrawTime=function(i){return this._drawTime=i,this},m.getRenderBBOX=function(){var i=this.getLayer();if(i&&i._drawTime!==this._drawTime)return null;Uo(this.bbox);for(var g=!1,m=this.symbolizers.length-1;m>=0;m--){var _=this.symbolizers[m];if(!(_ instanceof zc||_ instanceof _c)){var b=_.bbox;if(!Wo(b)){g=!0;break}jo(this.bbox,b)}}return g?null:Wo(this.bbox)?this.bbox:null},m.getMap=function(){return this.geometry.getMap()},m.getLayer=function(){return this.geometry&&this.geometry.getLayer()},m._createSymbolizers=function(){var i=this.getSymbol(),g=[],m=Uc,_=i;Array.isArray(i)||(_=[i]);for(var b=_.length-1;b>=0;b--)for(var T=_[b],P=m.length-1;P>=0;P--)if(m[P].test(T,this.geometry)){var I=new m[P](T,this.geometry,this);I._index=b,g.push(I),I instanceof yc&&(this._hasPoint=!0)}if(!g.length&&console){var H=this.geometry.getId();console.warn("invalid symbol for geometry("+(this.geometry?this.geometry.getType()+(H?":"+H:""):"")+") to draw : "+JSON.stringify(i))}return this._debugSymbolizer=new _c(i,this.geometry,this),g},m.hasPoint=function(){return!!this._hasPoint},m.getRenderPoints=function(i){return this._verifyProjection(),this._renderPoints||(this._renderPoints={}),i||(i="center"),this._renderPoints[i]||(this._renderPoints[i]=this.geometry._getRenderPoints(i)),this._renderPoints[i]},m.getPaintParams=function(i,g,m,_,b="_pt"){var T,P,I,H,q,$=this.getLayer()._getRenderer().mapStateCache,ye=this.getMap();$&&!this._hitPoint?(T=$.resolution,P=$.pitch,I=$.bearing,H=$.glScale,q=$.containerExtent):(T=ye.getResolution(),P=ye.getPitch(),I=ye.getBearing(),H=ye.getGLScale(),q=ye.getContainerExtent());var Re=this.geometry,Be=T,Ge=0!==P,je=0!==I,Xe=this._cachedParams,Ze=Re._paintAsPath&&Re._paintAsPath();if(Ze&&this._unsimpledParams&&Be<=this._unsimpledParams._res)Xe=this._unsimpledParams;else if(!Xe||Xe._res!==T||this._pitched!==Ge&&Re._redrawWhenPitch()||this._rotated!==je&&Re._redrawWhenRotate()){if(!(Xe=Re._getPaintParams()))return null;Xe._res=Be,!Re._simplified&&Ze&&(this._unsimpledParams||(this._unsimpledParams=Xe),Be>this._unsimpledParams._res&&(this._unsimpledParams._res=Be)),this._cachedParams=Xe}if(!Xe)return null;this._pitched=Ge,this._rotated=je;var Ye=H,Qe=[],Je=!!Re.getHoles,Ke=this._pointContainerPoints(Xe[0],i,g,m,_||this._hitPoint&&!q.contains(this._hitPoint),null,b,Je);if(!Ke)return null;Qe.push(Ke);for(var et=1,tt=Xe.length;et<tt;et++)W(Xe[et])||Xe[et]instanceof ir?W(Xe[et])?Qe.push(Xe[et]/Ye):Qe.push(Xe[et].multi(1/Ye)):Qe.push(Xe[et]);return Qe},m._pointContainerPoints=function(i,g,m,_,b,T,P="_pt",I){if(this._aboveCamera())return null;var H,q,$,ye=this.getLayer()._getRenderer(),Re=ye.mapStateCache,Be=this.getMap(),Ge=this.geometry,je=this.containerOffset;Re?(H=Re.glRes,q=Re.containerExtent):(H=Be.getGLRes(),q=Be.getContainerExtent());var Xe=this.getLayer().options.roundPoint,Ze=1/0,Ye=1/0,Qe=-1/0,Je=-1/0,Ke=!b,et=ye.layer.options.clipBBoxBufferSize||3,tt=this.symbolizers,at=Ge.options.enableClip,ht=Ge.options.strictClip;function gt(i=[],_=[]){var b=i;if(ht&&Be._currentViewGLInfo&&i.length>1&&!lc(_)){b=[];for(var{lt:T,rt:W,rb:$,lb:ye,RB:Re,LB:gt}=Be._currentViewGLInfo,yt=0,vt=i.length;yt<vt;yt++){var xt=i[yt];if(!sc(xt,T,W,$,ye)&&ic(xt,Re,gt)){var bt=i[yt-1]||(I?i[vt-1]:i[1]),Tt=i[yt+1]||(I?i[0]:i[vt-2]);if(bt&&Tt){var Mt=ic(bt,Re,gt),Pt=ic(Tt,Re,gt);if(Mt&&Pt)b.push(xt);else{var It=!1;if(!Mt){var Et=ac(bt,xt,Re,gt);Et&&(b.push(Et),It=!0)}if(!Pt){var Lt=ac(Tt,xt,Re,gt);Lt&&(b.push(Lt),It=!0)}It||b.push(xt)}}else b.push(xt)}else b.push(xt)}}for(var Dt=Wn(b,P),Ft=0,Ht=(Dt=Be._pointsAtResToContainerPoints(b,H,_,Dt)).length;Ft<Ht;Ft++){var Bt=Dt[Ft];Bt._sub(je),(g||m)&&Bt._add(g||0,m||0),Xe&&(Bt.x=Math.ceil(Bt.x),Bt.y=Math.ceil(Bt.y)),Ze=Math.min(Bt.x,Ze),Ye=Math.min(Bt.y,Ye),Qe=Math.max(Bt.x,Qe),Je=Math.max(Bt.y,Je)}if(at&&Ke&&yo(tt)){if(Zc.ymin=q.ymin,Zc.ymin<et&&(Zc.ymin=q.ymin-et),Zc.xmin=q.xmin-et,Zc.xmax=q.xmax+et,Zc.ymax=q.ymax+et,Ge.getShell&&Ge.getHoles)return Kh(Dt,Zc);var zt=Qh(Dt,Zc,!1);if(zt.length){var Vt=[];return zt.forEach((function(i){for(var g=0,m=i.length;g<m;g++)Vt.push(i[g].point)})),Vt}}return Dt}var yt=this.getAltitude();if(Array.isArray(i)){var vt;!b&&this.geometry.options.enableClip?(vt=this._clip(i,yt)).inView&&(Ke=!1):vt={points:i,altitude:yt};var xt=vt.points;yt=vt.altitude,_&&(yt=0);var bt=yt;$=[];for(var Tt=[],Mt=W(yt),Pt=0,It=xt.length;Pt<It;Pt++){var Et=xt[Pt];if(Array.isArray(Et)){if(Mt){var Lt=gt(Et,yt);$.push(Lt);continue}for(var Dt=[],Ft=0,Ht=Et.length;Ft<Ht;Ft++)Array.isArray(yt)&&(bt=yt[Pt]?yt[Pt][Ft]:0),Dt.push(bt);var Bt=gt(Et,Dt);$.push(Bt)}else Array.isArray(yt)&&(bt="vertex-last"===T?yt[yt.length-1-Pt]:"line"===T?(yt[Pt]+yt[Pt+1])/2:yt[Pt]),Tt.push(bt)}Tt.length&&($=gt(xt,Tt))}else i instanceof un&&(_&&(yt=0),$=Be._pointAtResToContainerPoint(i,H,yt)._sub(je),(g||m)&&$._add(g,m));return Yc.minx=Ze,Yc.miny=Ye,Yc.maxx=Qe,Yc.maxy=Je,this._containerBbox=Yc,$},m._clip=function(i,g){if(lc(g))return{points:i,altitude:g};var m=this.getMap(),_=this.geometry,b=this.getSymbol().lineWidth;W(b)||(b=4);var T,P,I,H=this.getLayer()._getRenderer().mapStateCache;H?(T=H._2DExtent,P=H.glExtent,I=H.pitch):(T=m.get2DExtent(),P=m.get2DExtentAtRes(m.getGLRes()),I=m.getPitch());var q=T._expand(b);if(I>0&&g){var $=m.cameraLookAt,ye=m.cameraPosition;Gc.set(ye[0],ye[1]),q=q._combine(Gc._add(Sn($[0]-ye[0]),Sn($[1]-ye[1])))}var Re=i;if(this.get2DExtent(null,Xc).within(q))return{points:Re,altitude:g,inView:!0};var Be=P._expand(b*m.getGLScale());qc.xmin=Be.xmin,qc.xmax=Be.xmax,qc.ymin=Be.ymin,qc.ymax=Be.ymax;var Ge=_.options.smoothness;if(_.getShell&&this.geometry.getHoles&&!Ge){var{xmin:je,ymin:Xe,xmax:Ze,ymax:Ye}=Be,Qe=Math.abs(Ze-je),Je=Math.abs(Ye-Xe),Ke=Math.sqrt(Qe*Qe+Je*Je),et=(Ke-Qe)/2,tt=(Ke-Je)/2;if(qc.xmin=Be.xmin-et,qc.xmax=Be.xmax+et,qc.ymin=Be.ymin-tt,qc.ymax=Be.ymax+tt,Array.isArray(i[0])){Re=[];for(var at=0;at<i.length;at++){var ht=Kh(i[at],qc);ht.length&&Re.push(ht)}}else Re=Kh(i,qc)}else if("LineString"===_.getJSONType()&&!Ge){if(Array.isArray(i[0])){Re=[];for(var gt=0;gt<i.length;gt++)yn(Re,Qh(i[gt],qc,!1,!!Ge))}else Re=Qh(i,qc,!1,!!Ge);return this._interpolateSegAlt(Re,i,g)}return{points:Re,altitude:g}},m._interpolateSegAlt=function(i,g,m){if(!Array.isArray(m)){var _=function(i){return i.point};return{points:i.map((function(i){return Array.isArray(i)?i.map(_):i.point})),altitude:m}}var b=Kc(i,g,m);m=[];var T=b.map((function(i){if(Array.isArray(i)){var g=[],_=i.map((function(i){return g.push(i.altitude),i.point}));return m.push(g),_}return m.push(i.altitude),i.point}));return{points:T,altitude:m}},m.getSymbol=function(){return this.geometry._getInternalSymbol()},m._resetSymbolizersBBOX=function(){for(var i=this.symbolizers.length-1;i>=0;i--){Uo(this.symbolizers[i].bbox)}return this},m.paint=function(i,g,m){if(this.symbolizers){var _=this.getLayer(),b=_._getRenderer();if(b&&(b.context||g)){var T=b.mapStateCache||{offset:void 0};if((this.geometry._isCheck||!i||i.intersects(this.get2DExtent(b.resources,jc)))&&!this._aboveCamera()){if(this.containerOffset=m||T.offset,!this.containerOffset){var P=this.getMap();this.containerOffset=P._pointToContainerPoint(b.middleWest)._add(0,-P.height/2)}this._beforePaint();var I=g||b.context;I.isHitTesting||this._resetSymbolizersBBOX(),Qc[0]=I,Qc[1]=b.resources;for(var H=this.symbolizers.length-1;H>=0;H--)(I.shadowBlur||this.symbolizers[H].symbol.shadowBlur)&&this._prepareShadow(I,this.symbolizers[H].symbol),this.symbolizers[H].symbolize(...Qc);this._afterPaint(),this._painted=!0,(this.geometry.options.debug||_.options.debug)&&this._debugSymbolizer.symbolize(I)}}}},m.getSprite=function(i,g){if(!this.geometry.isPoint)return null;if(this._spriting=!0,!this._sprite&&this.symbolizers.length>0){var m=new kl;this.symbolizers.forEach((function(g){var _=g.getFixedExtent(i);m._combine(_)}));var _,b=m.getMin().multi(-1),T=g||(this.getMap()?this.getMap().CanvasClass:null),P=Va.createCanvas(m.getWidth(),m.getHeight(),T);this._renderPoints&&(_=this._renderPoints);for(var I=P.getContext("2d"),H=[I,i],W=this.symbolizers.length-1;W>=0;W--){var q=this.symbolizers[W].getDxDy();this._renderPoints={center:[[b.add(q)]]},this._prepareShadow(I,this.symbolizers[W].symbol),this.symbolizers[W].symbolize(...H)}_&&(this._renderPoints=_),this._sprite={canvas:P,offset:m.getCenter()}}return this._spriting=!1,this._sprite},m.isSpriting=function(){return!!this._spriting},m.hitTest=function(i,g){if((!g||g<.5)&&(g=.5),this._hitPoint=i.sub(g,g),!Oc){var m=this.getMap()?this.getMap().CanvasClass:null;Oc=Va.createCanvas(1,1,m)}Va.setHitTesting(!0),Oc.width=Oc.height=2*g;var _=Va.getCanvas2DContext(Oc);_.isHitTesting=!0;try{this.paint(null,_,this._hitPoint)}finally{Va.setHitTesting(!1)}delete this._hitPoint;try{for(var b=_.getImageData(0,0,Oc.width,Oc.height).data,T=3,P=b.length;T<P;T+=4)if(b[T]>0)return!0}catch(i){console.error(i)}return!1},m.isHitTesting=function(){return!!this._hitPoint},m._prepareShadow=function(i,g){g.shadowBlur?(i.shadowBlur=this.isHitTesting()?0:g.shadowBlur,i.shadowColor=g.shadowColor||"#000",i.shadowOffsetX=g.shadowOffsetX||0,i.shadowOffsetY=g.shadowOffsetY||0):i.shadowBlur&&(i.shadowBlur=null,i.shadowColor=null,i.shadowOffsetX=null,i.shadowOffsetY=null)},m._eachSymbolizer=function(i,g){if(this.symbolizers){g||(g=this);for(var m=this.symbolizers.length-1;m>=0;m--)i.apply(g,[this.symbolizers[m]])}},m.get2DExtent=function(i,g){this._verifyProjection();var m=this.getMap();i=i||this.getLayer()._getRenderer().resources;var _=m.getZoom(),b=this._isDynamicSize();if(this._extent2D&&this._extent2D._zoom===_&&this._fixedExtent||(this._extent2D&&this._extent2D._zoom!==_&&delete this._extent2D,this.symbolizers&&(this._extent2D||(this._extent2D=this._computeExtent2D(new kl),this._extent2D._zoom=_),this._fixedExtent||(this._fixedExtent=this._computeFixedExtent(i,new kl)))),!this._extent2D)return b&&delete this._fixedExtent,null;var{xmin:T,ymin:P,xmax:I,ymax:H}=this._fixedExtent;return b&&delete this._fixedExtent,Wc.set(T,-H,I,-P),g?(g.set(this._extent2D.xmin,this._extent2D.ymin,this._extent2D.xmax,this._extent2D.ymax),g._add(Wc),g):this._extent2D.add(Wc)},m._computeExtent2D=function(i){for(var g=this.symbolizers.length-1;g>=0;g--){i._combine(this.symbolizers[g].get2DExtent())}return i},m._computeFixedExtent=function(i,g){for(var m=this.symbolizers.length-1;m>=0;m--){var _=this.symbolizers[m];_.getFixedExtent&&g._combine(_.getFixedExtent(i))}return g},m._isDynamicSize=function(){for(var i=this.symbolizers.length-1;i>=0;i--){if(this.symbolizers[i].isDynamicSize())return!0}return!1},m._aboveCamera=function(){var i=this.getMinAltitude(),g=this.getMap(),m=g.getGLRes();i=g.altitudeToPoint(i,m)*Sn(i);var _=g.getFrustumAltitude();return i&&_&&_<i},m.getFixedExtent=function(){var i=this.getMap().getZoom();return this._isDynamicSize()?this._computeFixedExtent(null,new kl):(this._extent2D&&this._extent2D._zoom===i||this.get2DExtent(null,Wc),this._fixedExtent)},m.setZIndex=function(i){this._eachSymbolizer((function(g){g.setZIndex(i)}))},m.show=function(){this._painted?(this.removeCache(),this._eachSymbolizer((function(i){i.show()}))):this.getLayer().isCanvasRender()||this.paint()},m.hide=function(){this._eachSymbolizer((function(i){i.hide()}))},m.repaint=function(){this._altAtGL=this._getGeometryAltitude(),this.removeCache();var i=this.getLayer();if(i){var g=i.getRenderer();g&&g.setToRedraw()&&g.setToRedraw()}},m.refreshSymbol=function(){this.removeCache(),this._removeSymbolizers(),this.symbolizers=this._createSymbolizers()},m.remove=function(){this.removeCache(),this._removeSymbolizers()},m._removeSymbolizers=function(){this._eachSymbolizer((function(i){delete i.painter,i.remove()})),delete this.symbolizers},m.removeCache=function(){delete this._renderPoints,delete this._paintParams,delete this._sprite,delete this._extent2D,delete this._fixedExtent,delete this._cachedParams,delete this._unsimpledParams},m.getAltitude=function(){return this.geometry._getAltitude()!==this._propAlt&&(this._altAtGL=this._getGeometryAltitude()),this._altAtGL?this._altAtGL:0},m.getMinAltitude=function(){return this.minAltitude?this.minAltitude:0},m.getMaxAltitude=function(){return this.maxAltitude?this.maxAltitude:0},m._getGeometryAltitude=function(){if(!this.getMap())return 0;var i=this.geometry._getAltitude();this._propAlt=i;var[g,m]=rc(i);return this.minAltitude=g,this.maxAltitude=m,i&&this.geometry.getCenter()?i:0},m._verifyProjection=function(){var i=this.geometry._getProjection()||$c;this._projCode&&this._projCode!==i.code&&this.removeCache(),this._projCode=i.code},m._beforePaint=function(){},m._afterPaint=function(){},m.getPathTempRenderPoints=function(){for(var i=0,g=(this.symbolizers||[]).length;i<g;i++){var m=this.symbolizers[i];if(m instanceof Ic&&m._tempRenderPoints)return m._tempRenderPoints}},g}(Ya);function Kc(i,g,m){if(!Array.isArray(m))return i;for(var _=[],b=0,T=i.length;b<T;b++)if(Array.isArray(i[b]))_.push(Kc(i[b],g,m));else{var P=i[b];if(P.point.equals(g[P.index]))P.altitude=m[P.index],_.push(P);else{var I=void 0,H=void 0;0===P.index?(I=P.index,H=P.index+1):(I=P.index-1,H=P.index);var W=P.point.distanceTo(g[H]),q=W/(W+g[I].distanceTo(P.point)),$=Mn(m[I],m[H],1-q);P.altitude=$,_.push(P)}}return _}var eu=new kl,tu=function(i){function g(g,m){var _;return(_=i.call(this)||this).geometry=g,_.isMask=m,_.bbox=Bo(),_._drawTime=0,_}tn(g,i);var m=g.prototype;return m._setDrawTime=function(i){return this._drawTime=i,this._eachPainter((function(g){g._setDrawTime(i)})),this},m.getRenderBBOX=function(){var i=this,g=this.getLayer();if(g&&g._drawTime!==this._drawTime)return null;Uo(this.bbox);var m=!1;return this._eachPainter((function(g){var _=g.getRenderBBOX();Wo(_)?jo(i.bbox,_):m=!0})),m?null:Wo(this.bbox)?this.bbox:null},m._eachPainter=function(i){for(var g,m=this.geometry.getGeometries(),_=0,b=m.length;_<b&&(!(g=this.isMask?m[_]._getMaskPainter():m[_]._getPainter())||!g||!1!==i.call(this,g));_++);},m.getLayer=function(){return this.geometry&&this.geometry.getLayer()},m.paint=function(i){this.geometry&&this._eachPainter((function(g){g.paint(i)}))},m.get2DExtent=function(i,g){g&&g.set(null,null,null,null);var m=g||new kl;return this._eachPainter((function(g){m=m._combine(g.get2DExtent(i,eu))})),m},m.remove=function(){this._eachPainter((function(i){i.remove()}))},m.setZIndex=function(i){this._eachPainter((function(g){g.setZIndex(i)}))},m.show=function(){this._eachPainter((function(i){i.show()}))},m.hide=function(){this._eachPainter((function(i){i.hide()}))},m.repaint=function(){this._eachPainter((function(i){i.repaint()}))},m.refreshSymbol=function(){this._eachPainter((function(i){i.refreshSymbol()}))},m.hasPoint=function(){var i=!1;return this._eachPainter((function(g){return!g.hasPoint()||(i=!0,!1)})),i},m.getMinAltitude=function(){var i=!0,g=0;return this._eachPainter((function(m){var _=m.getMinAltitude();(i||_<g)&&(i=!1,g=_)})),g},m.getMaxAltitude=function(){var i=0;return this._eachPainter((function(g){var m=g.getMaxAltitude();m>i&&(i=m)})),i},g}(Ya);function nu(i,g=[]){return g.forEach((function(g){var[m,_]=g;i=i.replace(m,_)})),i}function ru(i){var{projection:g,isArcgis:m,isGeoServer:_,isSuperMap:b}=i,T=.0002645833333333333;return(m||_||b)&&(T=28e-5),g&&g.indexOf("4326")>-1&&(T=2.3767925226029154e-9,(m||b)&&(T=2.518101729011901e-9),_&&(T=2.51528279553466e-9)),T}function iu(i,g){var m=i.getElementsByTagName(g);return m&&m.length?m:i.getElementsByTagName("wmts:"+g)}function ou(i,g){for(var m=0;m<i.length;m++){var _=i[m];if((_=_.getElementsByTagName("ows:Identifier")[0])&&_.textContent===g)return i[m]}return null}function su(i,g={}){var m,_,b,T=iu(i,"TileMatrix"),P=[],I=[],H=[],W=!1;if(!m){var q=i.getElementsByTagName("ows:SupportedCRS")[0];q&&(m=function(i){for(var g="",m=i.split(""),_=m.length-1;_>=0&&!isNaN(m[_]);_--)g=m[_]+g;return g}(m=(m=q.textContent).split("EPSG")[1]),m=function(i){var g=i.indexOf("EPSG")>-1?i:"EPSG:"+i;return nu(g,[["4490","4326"],["102100","3857"],["900913","3857"]])}(m))}_||(_=i.getElementsByTagName("ows:Identifier")[0])&&(_=_.textContent),g.projection=m;for(var $=1/0,ye=0;ye<T.length;ye++){var Re=T[ye],Be=Re.getElementsByTagName("ows:Identifier")[0].textContent;isNaN(parseInt(Be))?(b=Be.substr(0,Be.lastIndexOf(":")),Be=(Be=Be.split(":"))[Be.length-1],Be=parseInt(Be),W=!0,g.isGeoServer=!0):Be=parseInt(Be),$=Math.min($,Be);var Ge=iu(Re,"ScaleDenominator")[0].textContent,je=iu(Re,"TopLeftCorner")[0].textContent,Xe=iu(Re,"TileWidth")[0].textContent,Ze=iu(Re,"TileHeight")[0].textContent;if(0===H.length&&H.push(parseInt(Xe),parseInt(Ze)),0===I.length){var[Ye,Qe]=je.split(" ").filter((function(i){return""!==i})).map((function(i){return parseFloat(i)}));Ye>0?I.push(1,-1,Qe,Ye):I.push(1,-1,Ye,Qe)}var Je=ru(g),Ke=parseFloat(Ge)*Je;P.push(Ke)}if($>0)for(var et=P[0],tt=$-1;tt>=0;tt--)P.splice(0,0,et*=2);return{resolutions:P,tileSize:H,tileSystem:I,projection:m,TileMatrixSet:_,isGeoServer:W,levelStr:b}}var au=function(i,g,m={jsonp:!0}){ye(i)&&ri.get(i,(function(_,b){if(_)g(_);else{var T=function(i,g,m){["isArcgis","isSuperMap","isGeoServer"].every((function(i){return null==m[i]}))&&console.warn("Please specify the server type, such as isArcgis, isSuperMap, isGeoServer, Otherwise, the system will determine by itself"),null==m.isArcgis&&(m.isArcgis=["arcgis","geoscene"].some((function(g){return i.indexOf(g)>-1}))),null==m.isSuperMap&&(m.isSuperMap=i.indexOf("supermap")>-1);var _=(new DOMParser).parseFromString(i,"text/xml").querySelectorAll("Contents")[0];if(!_)return[];var b=iu(_,"Layer");if(!b.length)return[];for(var T=[],P=0,I=_.childNodes.length;P<I;P++)"TileMatrixSet"===_.childNodes[P].localName&&T.push(_.childNodes[P]);if(!T.length)return[];for(var H=[],W=0,q=b.length;W<q;W++){var $=b[W],ye=$.querySelectorAll("Style")[0];ye&&(ye=ye.getElementsByTagName("ows:Identifier")[0])&&(ye=ye.textContent);var Re=$.getElementsByTagName("ows:Identifier")[0];Re&&(Re=Re.textContent);var Be=iu($,"TileMatrixSetLink");if(0!==Be.length)for(var Ge=0,je=Be.length;Ge<je;Ge++){var Xe=Be[Ge];(Xe=iu(Xe,"TileMatrixSet")[0])&&(Xe=Xe.textContent);var Ze=ou(T,Xe);if(Ze){var Ye=$.querySelectorAll("ResourceURL")[0],Qe="";Ye&&(Qe=Ye.attributes.template.value);var{resolutions:Je,tileSize:Ke,tileSystem:et,projection:tt,TileMatrixSet:at,isGeoServer:ht,levelStr:gt}=su(Ze,m);Qe.length||(Qe=g.substr(0,g.lastIndexOf("?")),Qe+="?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER={LAYER}&STYLE={Style}&TILEMATRIXSET={TileMatrixSet}&FORMAT={tiles}&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}");var yt=nu(Qe,[["{LAYER}",Re],["{Layer}",Re],["{layer}",Re],["{STYLE}",ye],["{Style}",ye],["{style}",ye],["{TileMatrixSet}",at],["{TileMatrix}",ht?gt+":{z}":"{z}"],["{TileRow}","{y}"],["{TileCol}","{x}"],["{tiles}",ht?"image/png":"tiles"]]);H.push({tileSize:Ke,tileSystem:et,spatialReference:{resolutions:Je,projection:tt},urlTemplate:yt,info:{layerName:Re,TileMatrixSet:at,style:ye,tileSize:Ke,tileSystem:et,resolutions:Je,projection:tt,urlTemplate:yt}})}}}return H}(b,i,m);g(null,T)}}),m)};function lu(i){for(var g=i.tileInfo,m=[g.cols,g.rows],_=[],b=g.lods,T=0,P=b.length;T<P;T++)_.push(b[T].resolution);var I=i.fullExtent,H=g.origin,W=[1,-1,H.x,H.y];return delete I.spatialReference,{spatialReference:{resolutions:_,fullExtent:I},tileSystem:W,tileSize:m}}var hu;function cu(){if(!hu){var i=Math.round(T.crsMaxNativeZoom||22);hu={"EPSG:3857":{projection:"EPSG:3857",resolutions:function(){for(var g=[],m=12756274*Math.PI,_=0;_<=i;_++)g[_]=m/(256*Math.pow(2,_));return g}(),fullExtent:{top:6378137*Math.PI,left:-6378137*Math.PI,bottom:-6378137*Math.PI,right:6378137*Math.PI}},"EPSG:4326":{projection:"EPSG:4326",fullExtent:{top:90,left:-180,bottom:-90,right:180},resolutions:function(){for(var g=[],m=0;m<=i;m++)g[m]=180/(128*Math.pow(2,m));return g}()},BAIDU:{projection:"baidu",resolutions:function(){for(var g=Math.pow(2,18),m=[],_=0;_<=i;_++)m[_]=g,g*=.5;return m}(),fullExtent:{top:33554432,left:-33554432,bottom:-33554432,right:33554432}},IDENTITY:{projection:"identity",resolutions:function(){for(var g=Math.pow(2,8),m=[],_=0;_<=i;_++)m[_]=g,g*=.5;return m}(),fullExtent:{top:2e5,left:-2e5,bottom:-2e5,right:2e5}},"PRESET-VT-3857":{projection:"EPSG:3857",resolutions:function(){for(var g=[],m=6378137*Math.PI,_=0;_<=i;_++)g[_]=m/(256*Math.pow(2,_));return g}(),fullExtent:{top:6378137*Math.PI,left:-6378137*Math.PI,bottom:-6378137*Math.PI,right:6378137*Math.PI}},"PRESET-VT-4326":{projection:"EPSG:4326",fullExtent:{top:90,left:-180,bottom:-90,right:180},resolutions:function(){for(var g=[],m=0;m<=i;m++)g[m]=45/(128*Math.pow(2,m));return g}()}},hu["EPSG:4490"]=hu["EPSG:4326"],hu["PRESET-3857-512"]=hu["PRESET-VT-3857"],hu["PRESET-4326-512"]=hu["PRESET-VT-4326"],hu["PRESET-4490-512"]=hu["PRESET-VT-4326"]}return hu}var uu=function(){function i(i={}){this.options=i,this._initSpatialRef()}i.registerPreset=function(i,g){i=i&&i.toUpperCase();var m=cu();m[i]&&console.warn("Spatial reference "+i+" already registered."),m[i]=g},i.getPreset=function(i){return cu()[i.toUpperCase()]},i.getAllPresets=function(){return Object.keys(cu())},i.loadArcgis=function(i,g,m){return function(i,g,m={jsonp:!0}){if(ye(i)&&"{"!==i.substring(0,1))ri.getJSON(i,(function(i,m){if(i)g(i);else{var _=lu(m);g(null,_)}}),m);else{ye(i)&&(i=An(i));var _=lu(i);g(null,_)}}(i,g,m),this},i.loadWMTS=function(i,g,m){return au(i,g,m),this},i.getProjectionInstance=function(i){var g;if(!i)return null;if((g=ye(i)?{code:i}:i).project)return g.locate||(g=I({},g),I(g,Wl.getInstance("identity"===g.measure?"IDENTITY":"EPSG:4326"))),g;var m=(g.code+"").toLowerCase();for(var _ in xh)if(Ge(xh,_)){var b=xh[_].aliases||[],T=xh[_].code;T&&b.push(T);for(var P=0;P<b.length;P++)if(b[P].toLowerCase()===m){if(xh[_].create){var H=xh[_].create(i);return H.code=b[P],H}if(xh[_].code===b[P])return xh[_];var W=I({},xh[_]);return W.code=b[P],W}}return null},i.equals=function(i,g){if(ye(i)||ye(g))return i===g;if(!i&&!g)return!0;if(!i||!g)return!1;if(i.projection!==g.projection)return!1;var m=i.fullExtent,_=g.fullExtent;if(m&&!_||!m&&_)return!1;if(m&&_&&(m.top!==_.top||m.bottom!==_.bottom||m.left!==_.left||m.right!==_.right))return!1;var b=i.resolutions,T=g.resolutions;if(b&&T){if(b.length!==T.length)return!1;for(var P=0;P<b.length;P++)if(b[P]!==T[P])return!1}else if(b||T)return!1;return!0};var g=i.prototype;return g._initSpatialRef=function(){var g;if(!(g=this.options.projection?i.getProjectionInstance(this.options.projection):vh))throw new Error("must provide a valid projection in map's spatial reference.");(g=I({},El,g)).measureLength||I(g,Ul),this._projection=g;var m,_=cu(),b=this.options.resolutions;if(!b&&(g.code&&(m=_[g.code.toUpperCase()])&&(b=m.resolutions,this.isEPSG="IDENTITY"!==g.code),!b))throw new Error("must provide valid resolutions in map's spatial reference.");if(this._resolutions=b,this._pyramid=!0,this._pyramid)for(var T=0;T<b.length;T++)if(b[T]&&b[T-1]&&Math.round(b[T-1]/b[T]*1e4)/1e4!=2){this._pyramid=!1;break}var P=this.options.fullExtent;if(!P&&(g.code&&(m=_[g.code.toUpperCase()])&&(P=m.fullExtent),!P))throw new Error("must provide a valid fullExtent in map's spatial reference.");if(H(P.left)?(this._fullExtent=new Pl(P),P.left=P.xmin,P.right=P.xmax,P.top=P.ymax,P.bottom=P.ymin):this._fullExtent=new Pl(new pl(P.left,P.top),new pl(P.right,P.bottom)),H(P.top)||H(P.bottom)||H(P.left)||H(P.right))throw new Error("must provide valid top/bottom/left/right in fullExtent.");I(this._fullExtent,P),this._projection.fullExtent=P,this._transformation=new Ol([P.right>=P.left?1:-1,P.top>=P.bottom?-1:1,0,0])},g.getResolutions=function(){return this._resolutions||[]},g.getResolution=function(i){var g=0|i;g<0?g=0:g>this._resolutions.length-1&&(g=this._resolutions.length-1);var m=this._resolutions[g];return g!==i&&i>0&&g<this._resolutions.length-1?m+(this._resolutions[g+1]-m)*(i-g):m},g.getProjection=function(){return this._projection},g.getFullExtent=function(){return this._fullExtent},g.getTransformation=function(){return this._transformation},g.getMinZoom=function(){for(var i=0;i<this._resolutions.length;i++)if(!H(this._resolutions[i]))return i;return 0},g.getMaxZoom=function(){for(var i=this._resolutions.length-1;i>=0;i--)if(!H(this._resolutions[i]))return i;return this._resolutions.length-1},g.getZoomDirection=function(){return Sn(this._resolutions[this.getMinZoom()]-this._resolutions[this.getMaxZoom()])},g.toJSON=function(){return this.json||(this.json={resolutions:this._resolutions,fullExtent:{top:this._fullExtent.top,left:this._fullExtent.left,bottom:this._fullExtent.bottom,right:this._fullExtent.right},projection:this._projection.code}),this.json},g.isPyramid=function(){return this._pyramid},i}();var fu=new un(0,0),du=new kl,pu={};var gu=function(i){function g(g){var m,_=I({},g),b=_.symbol,T=_.properties,P=_.id;return delete _.symbol,delete _.id,delete _.properties,m=i.call(this,_)||this,b?m.setSymbol(b):m._genSizeSymbol(),T&&m.setProperties(T),H(P)||m.setId(P),g&&W(g.rotateAngle)&&(m._dirtyRotate=!0),m}tn(g,i),g.fromJSON=function(i){return i};var m=g.prototype;return m.getFirstCoordinate=function(){if("GeometryCollection"===this.type){var i=this.getGeometries();return i.length?i[0].getFirstCoordinate():null}var g=this.getCoordinates();if(!Array.isArray(g))return g;do{g=g[0]}while(Array.isArray(g)&&g.length>0);return g},m.getLastCoordinate=function(){if("GeometryCollection"===this.type){var i=this.getGeometries();return i.length?i[i.length-1].getLastCoordinate():null}var g=this.getCoordinates();if(!Array.isArray(g))return g;do{g=g[g.length-1]}while(Array.isArray(g)&&g.length>0);return g},m.addTo=function(i,g){return i.addGeometry(this,g),this},m.getLayer=function(){return this._layer?this._layer:null},m.getMap=function(){return this._layer?this._layer.getMap():null},m.getId=function(){return this._id},m.setId=function(i){var g=this.getId();return this._id=i,this._fireEvent("idchange",{old:g,new:i}),this},m.getProperties=function(){return this.properties?this.properties:this._getParent()?this._getParent().getProperties():null},m.setProperties=function(i){var g=this.properties;return this.properties=$(i)?I({},i):i,(this.getGeometries?this.getGeometries():[]).forEach((function(g){var m=I(g.getProperties&&g.getProperties()||{},i||{});g.setProperties&&g.setProperties(m)})),this._clearAltitudeCache(),this._repaint(),this._fireEvent("propertieschange",{old:g,new:i}),this},m.getType=function(){return this.type},m.getSymbol=function(){var i=this._symbol;return i?Array.isArray(i)?co(i):I({},i):null},m.setSymbol=function(i){return this._symbolUpdated=i,this._symbol=this._prepareSymbol(i),this.onSymbolChanged(),delete this._compiledSymbol,delete this._symbolHash,this},m.getSymbolHash=function(){return this._symbolHash||(this._symbolHash=lo(this._symbolUpdated)),this._symbolHash},m.updateSymbol=function(i){if(!i)return this;var g=this._getSymbol(),m=Array.isArray(i);if(g||(g=this._getInternalSymbol()||{}),!Array.isArray(g)&&m&&(i=i[0]||{}),Array.isArray(g)){if(!m)for(i=[i];i.length<g.length;)i.push({});for(var _=0;_<i.length;_++)Gh(i[_])&&delete this._textDesc,g[_]&&i[_]&&(g[_]=co(g[_],i[_]))}else{if(Array.isArray(i))return console.error("Geometry's symbol is object but the update symbol is array."),console.error("Geometry's symbol and update symbol:",g,i),this;Gh(g)&&delete this._textDesc,g=co(g||this._getInternalSymbol(),i)}return this._eventSymbolProperties=i,delete this._compiledSymbol,this.setSymbol(g)},m.getTextContent=function(){var i=this._getInternalSymbol();if(Array.isArray(i)){for(var g=[],m=!1,_=0;_<i.length;_++)g[_]=Ar(i[_]&&i[_].textName,this.getProperties()),H(g[_])||(m=!0);return m?g:null}return Ar(i&&i.textName,this.getProperties())},m.getTextDesc=function(){if(!this._textDesc){var i=this.getTextContent(),g=this._sizeSymbol,m=Array.isArray(i);this._textDesc=Array.isArray(g)?g.map((function(g,_){return yr(m?i[_]:"",g)})):yr(i,g)}return this._textDesc},m.getCenter=function(){return this._computeCenter(this._getMeasurer())},m.getExtent=function(){var i=this._getPrjExtent(),g=this._getProjection();if(i&&g){var m=g.unproject(new pl(i.xmin,i.ymin)),_=g.unproject(new pl(i.xmax,i.ymax));return new Pl(m,_,g)}return this._computeExtent(this._getMeasurer())},m.getContainerExtent=function(i){var g=this.get2DExtent();if(!g||!g.isValid())return null;var m=this.getMap(),_=m.getGLRes(),b=this.getMinAltitude(),T=g.convertTo((function(i){return m._pointAtResToContainerPoint(i,_,b,fu)}),i),P=this.getMaxAltitude();if(P!==b){var I=g.convertTo((function(i){return m._pointAtResToContainerPoint(i,_,P,fu)}),du);T._combine(I)}var H=this.getLayer();if(H&&"LineString"===this.type&&P&&H.options.drawAltitude){var W=g.convertTo((function(i){return m._pointAtResToContainerPoint(i,_,0,fu)}),du);T._combine(W)}if(T){var q=this._getFixedExtent();(function(i){if(!i)return!1;var{xmin:g,ymin:m,xmax:_,ymax:b}=i;return _-g>0&&b-m>0})(q)&&T._add(q)}return this.options.smoothness&&T._expand(.15*T.getWidth()),T},m._getFixedExtent=function(){this._fixedExtent||(this._fixedExtent=new kl);var i=this._sizeSymbol,g=(i&&i.lineWidth||1)/2;return this._fixedExtent.set(-(g+=i&&i.lineStrokeWidth||0),-g,g,g),this._fixedExtent._add([i&&i.lineDx||0,0]),this._fixedExtent._add([0,i&&i.lineDy||0]),this._fixedExtent},m.get2DExtent=function(){var i=this.getMap();if(!i)return null;if(this._extent2d)return this._extent2d;var g=this._getPrjExtent();if(!g||!g.isValid())return null;var m=g.getMin(),_=g.getMax(),b=i.getGLRes();return i._prjToPointAtRes(m,b,m),i._prjToPointAtRes(_,b,_),this._extent2d=new kl(m,_),this._extent2d.z=i.getZoom(),this._extent2d},m.getSize=function(){var i=this.getContainerExtent();return i?i.getSize():null},m.containsPoint=function(i,g){if(!this.getMap())throw new Error('The geometry is required to be added on a map to perform "containsPoint".');return i instanceof pl&&(i=this.getMap().coordToContainerPoint(i)),this._containsPoint(i,g)},m._containsPoint=function(i,g){var m=this._getPainter();return!!m&&(g=g||0,this._hitTestTolerance&&(g+=this._hitTestTolerance()),m.hitTest(i,g))},m.show=function(){if(this.options.visible=!0,this.getMap()){var i=this._getPainter();i&&i.show(),this._fireEvent("show")}return this},m.hide=function(){if(this.options.visible=!1,this.getMap()){this.onHide();var i=this._getPainter();i&&i.hide(),this._fireEvent("hide")}return this},m.isVisible=function(){if(!this.options.visible)return!1;var i=this._getInternalSymbol();if(!i)return!0;if(!this.symbolIsVisible())return!1;if(Array.isArray(i)){if(!i.length)return!0;for(var g=0,m=i.length;g<m;g++)if(H(i[g].opacity)||i[g].opacity>0)return!0;return!1}return H(i.opacity)||$(i.opacity)||W(i.opacity)&&i.opacity>0},m.symbolIsVisible=function(){var i=this._getCompiledSymbol();if(!i)return!0;Array.isArray(i)||(i=[i]);for(var g=0,m=i.length;g<m;g++){var _=i[g];if(_){var b=_.visible;if(!1!==b&&0!==b)return!0}}return!1},m.getZIndex=function(){return this.options.zIndex||0},m.setZIndex=function(i){var g=this.options.zIndex;return this.options.zIndex=i,this._fireEvent("zindexchange",{old:g,new:i}),this},m.setZIndexSilently=function(i){return this.options.zIndex=i,this},m.bringToFront=function(){var i=this.getLayer();if(!i||!i.getGeoMaxZIndex)return this;var g=i.getGeoMaxZIndex();return this.setZIndex(g+1),this},m.bringToBack=function(){var i=this.getLayer();if(!i||!i.getGeoMinZIndex)return this;var g=i.getGeoMinZIndex();return this.setZIndex(g-1),this},m.translate=function(i,g,m){if(H(i))return this;var _=new pl(i,g,m);if(0===_.x&&0===_.y&&(H(_.z)||0===_.z))return this;var b=this.getCoordinates();if(this._silence=!0,b)if(Array.isArray(b)){var T=bn(b,(function(i){return i.add(_)}));this.setCoordinates(T)}else this.setCoordinates(b.add(_));return this._silence=!1,this._fireEvent("positionchange"),this},m._translateRotatePivot=function(i){if(!this._pivot||!i)return this;if(this.options.rotatePivot){var g=this.getCoordinates();if(!g)return this;i instanceof pl||(i=new pl(i));var m=i.sub(g);if(0===m.x&&0===m.y)return this;this._pivot._add(m),this.options.rotatePivot=this._pivot.toArray()}return this},m.flash=function(i,g,m,_){return jn.call(this,i,g,m,_)},m.copy=function(){var i=this.toJSON(),m=g.fromJSON(i);return m.options.visible=!0,m},m.remove=function(){return this.getLayer()?(this._fireEvent("removestart"),this._unbind(),this._fireEvent("removeend"),this._fireEvent("remove"),this):this},m.toGeoJSONGeometry=function(){return this._exportGeoJSONGeometry()},m.toGeoJSON=function(i){i||(i={});var g={type:"Feature",geometry:null};if(H(i.geometry)||i.geometry){var m=this._exportGeoJSONGeometry();g.geometry=m}var _,b=this.getId();return H(b)||(g.id=b),(H(i.properties)||i.properties)&&(_=this._exportProperties()),g.properties=_,g},m.toJSON=function(i){i||(i={});var g=this._toJSON(i);return I(g,this._exportGraphicOptions(i)),g},m.getLength=function(){return this._computeGeodesicLength(this._getMeasurer())},m.getArea=function(){return this._computeGeodesicArea(this._getMeasurer())},m.rotate=function(i,g){if(!W(i))return console.error("angle:"+i+" is not number"),this;if(this._painter||(this._dirtyRotate=!0),"GeometryCollection"===this.type)return this.getGeometries().forEach((function(m){return m.rotate(i,g)})),this;g=g?new pl(g):this.getCenter(),this._angle=i,this._pivot=g;var m=this._getMeasurer(),_=this.getCoordinates();if(!Array.isArray(_)){if(g.x===_.x&&g.y===_.y||this.getShell)this.onPositionChanged();else{var b=m._rotate(_,g,i);this.setCoordinates(b)}return this.getShell&&(this.options.rotateAngle=i,this.options.rotatePivot=g.toArray()),this}return bn(_,(function(_){return m._rotate(_,g,i)})),this.setCoordinates(_),this},m._rotatePrjCoordinates=function(i){if(!i||0===this._angle||!this._pivot)return i;var g=this._getProjection();if(!g)return i;var m,_,b=0,T=Array.isArray(i),P=T?i:[i],I=[];if(this.getRotateOffsetAngle){b=this.getRotateOffsetAngle();var H=P[P.length-1];m=H.x,_=H.y}else{var W=Bo();Go(P,W);var[q,$,ye,Re]=W;m=(q+ye)/2,_=($+Re)/2}for(var Be=0,Ge=P.length;Be<Ge;Be++){var je=P[Be],{x:Xe,y:Ze}=je,Ye=Xe-m,Qe=Ze-_,Je=Math.sqrt(Ye*Ye+Qe*Qe),Ke=(xu(m,_,Xe,Ze)-this._angle+b)/180*Math.PI,et=Math.cos(Ke)*Je,tt=Math.sin(Ke)*Je,at=new pl(m+et,_+tt);I.push(at)}for(var ht=g.project(this._pivot),gt=m-ht.x,yt=_-ht.y,vt=0,xt=I.length;vt<xt;vt++){var bt=I[vt];bt.x-=gt,bt.y-=yt}return T?I:I[0]},m.isRotated=function(){return!(!W(this._angle)||!this._pivot)},m._getConnectPoints=function(){return[this.getCenter()]},m._initOptions=function(i){var g=I({},i),m=g.symbol,_=g.properties,b=g.id;delete g.symbol,delete g.id,delete g.properties,this._setOptions(g),m&&this.setSymbol(m),_&&this.setProperties(_),H(b)||this.setId(b)},m._bindLayer=function(i){if(i!==this.getLayer()){if(this.getLayer())throw new Error("Geometry cannot be added to two or more layers at the same time.");this._layer=i,this._clearCache(),this._bindInfoWindow(),this._bindMenu()}},m._prepareSymbol=function(i){if(Array.isArray(i)){for(var g=[],m=0;m<i.length;m++)g.push(ro(this._checkAndCopySymbol(i[m])));return g}return i?ro(i=this._checkAndCopySymbol(i)):null},m._checkAndCopySymbol=function(i){var g={};for(var m in i)g[m]=nr[m]&&ye(i[m])?+i[m]:i[m];return g},m._getSymbol=function(){return this._symbol},m._setExternSymbol=function(i){return this._eventSymbolProperties=i,this._symbol||delete this._textDesc,this._externSymbol=this._prepareSymbol(i),this.onSymbolChanged(),this},m._getInternalSymbol=function(){return this._symbol?this._symbol:this._externSymbol?this._externSymbol:this.options.symbol?this.options.symbol:null},m._getPrjExtent=function(){var i=this._getProjection();return this._verifyProjection(),!this._extent&&i&&(this._extent=this._computePrjExtent(i)),this._extent},m._unbind=function(){var i=this.getLayer();i&&(this._animPlayer&&this._animPlayer.finish(),this._unbindMenu(),this._unbindInfoWindow(),this.isEditing()&&this.endEdit(),this._removePainter(),this.onRemove&&this.onRemove(),i.onRemoveGeometry&&i.onRemoveGeometry(this),delete this._layer,delete this._internalId,delete this._extent)},m._getInternalId=function(){return this._internalId},m._setInternalId=function(i){this._internalId=i},m._getMeasurer=function(){return this._getProjection()?this._getProjection():uu.getProjectionInstance(this.options.defaultProjection)},m._getProjection=function(){var i=this.getMap();return i?i.getProjection():null},m._verifyProjection=function(){var i=this._getProjection();this._projCode&&i&&this._projCode!==i.code&&this._clearProjection(),this._projCode=i?i.code:this._projCode},m._getExternalResources=function(){return no(this._getInternalSymbol())},m._getPainter=function(){if(this._painter)return this._painter;var i=this.getLayer();if(i)if(-1!==Jn.indexOf(this.type)){if(i.constructor.getCollectionPainterClass){var g=i.constructor.getCollectionPainterClass();g&&(this._painter=new g(this))}}else if(i.constructor.getPainterClass){var m=i.constructor.getPainterClass();m&&(this._painter=new m(this))}return this._painter},m._getMaskPainter=function(){return this._maskPainter||(this._maskPainter=this.getGeometries&&this.getGeometries()?new tu(this,!0):new Jc(this)),this._maskPainter},m._removePainter=function(){this._painter&&this._painter.remove(),delete this._painter},m._paint=function(i){if(this.symbolIsVisible()&&this._painter){if(this._dirtyCoords){delete this._dirtyCoords;var g=this._getProjection();g&&(this._pcenter=g.project(this._coordinates),this._clearCache())}this._dirtyRotate&&W(this.options.rotateAngle)&&this.rotate(this.options.rotateAngle,this.options.rotatePivot),this._dirtyRotate=!1,this._painter.paint(i)}},m._clearCache=function(){delete this._extent,delete this._extent2d,this._clearAltitudeCache()},m._clearProjection=function(){delete this._extent,delete this._extent2d},m._repaint=function(){this._painter&&this._painter.repaint()},m.onHide=function(){this.closeMenu(),this.closeInfoWindow()},m.onShapeChanged=function(){this._clearCache(),this._repaint(),this._fireEvent("shapechange")},m.onPositionChanged=function(){this._clearCache(),this._repaint(),this._fireEvent("positionchange")},m.onSymbolChanged=function(){this._painter&&this._painter.refreshSymbol();var i={};this._eventSymbolProperties?(i.properties=JSON.parse(JSON.stringify(this._eventSymbolProperties)),delete this._eventSymbolProperties):delete this._textDesc,this._genSizeSymbol(),this._fireEvent("symbolchange",i)},m._genSizeSymbol=function(){var i=this._getInternalSymbol();if(i)if(Array.isArray(i)){this._sizeSymbol=[];for(var g=!1,m=0;m<i.length;m++){var _=this._sizeSymbol[m]=this._getSizeSymbol(i[m]);!g&&_&&_._dynamic&&(g=!0)}this._sizeSymbol._dynamic=g}else this._sizeSymbol=this._getSizeSymbol(i);else delete this._sizeSymbol},m._getSizeSymbol=function(i){var g=Qi({lineWidth:i.lineWidth,lineDx:i.lineDx,lineDy:i.lineDy},this);return(Ii(i.lineWidth)||Ii(i.lineDx)||Ii(i.lineDy))&&(g._dynamic=!0),g},m._getCompiledSymbol=function(){return this._compiledSymbol||(this._compiledSymbol=Qi(this._getInternalSymbol(),this)),this._compiledSymbol},m.onConfig=function(i){var g;i.properties&&(g=i.properties,delete i.properties);var m=!1;for(var _ in i)if(i.hasOwnProperty(_)){var b=_.slice(0,5);if("arrow"===b||"smoot"===b){m=!0;break}}g?(this.setProperties(g),this._repaint()):m&&this._repaint()},m._setParent=function(i){i&&(this._parent=i)},m._getParent=function(){return this._parent},m._fireEvent=function(i,g){this._silence||(this.getLayer()&&this.getLayer()._onGeometryEvent&&(g||(g={}),g.type=i,g.target=this,this.getLayer()._onGeometryEvent(g)),this.fire(i,g))},m._toJSON=function(i){return{feature:this.toGeoJSON(i)}},m._recordVisible=function(){var i=this.options.visible;H(i)&&(i=!0),this._savedVisible=i},m._recoveryVisible=function(){delete this._savedVisible},m._exportGraphicOptions=function(i){var g={};return(H(i.options)||i.options)&&(g.options=this.config()),g.options&&this.isEditing&&this.isEditing()&&(g.options.visible=this._savedVisible),(H(i.symbol)||i.symbol)&&(g.symbol=this.getSymbol()),(H(i.infoWindow)||i.infoWindow)&&this._infoWinOptions&&(g.infoWindow=this._infoWinOptions),g},m._exportGeoJSONGeometry=function(){var i=this.getCoordinates(),g=pl.toNumberArrays(i);return{type:this.getType(),coordinates:g}},m._exportProperties=function(){var i=null,g=this.getProperties();return H(g)||(i=$(g)?I({},g):g),i},m._hitTestTolerance=function(){return 0},m._getAltitude=function(){var i=this.getLayer();if(!i)return 0;var g=i.options,m=i.getAltitude?i.getAltitude():0,_=g.enableAltitude;if(!_&&i.isVectorLayer)return m;var b=mu(i),T=(this.properties||pu)[b];if(H(T)){var P=Au(this,m,_);return H(P)?m:P}return Array.isArray(T)?T.map((function(i){return i+m})):T+m},m.getAltitude=function(){var i=mu(this.getLayer()),g=(this.properties||pu)[i];if(!H(g))return g;var m=Au(this,0,!1);return H(m)?0:m},m.hasAltitude=function(){return this._genMinMaxAlt(),!!this._minAlt||!!this._maxAlt},m.setAltitude=function(i){if(!W(i))return this;var g=this.getLayer(),m=mu(g),_=this.properties||pu,b=_[m];if(!H(b))if(Array.isArray(b))for(var T=0,P=b.length;T<P;T++)b[T]=i;else _[m]=i;var I=this.getCoordinates?this.getCoordinates():null;if(!I)return this;if(yu(I,i),g){var q=g.getRenderer();q&&(q.gl||q.device)?this.setCoordinates(I):q&&this._repaint()}return this._clearAltitudeCache(),this.onPositionChanged(),this},m._genMinMaxAlt=function(){if(void 0===this._minAlt||void 0===this._maxAlt){var i=this._getAltitude(),[g,m]=rc(i);this._minAlt=g,this._maxAlt=m}},m.getMinAltitude=function(){return this._genMinMaxAlt(),this._minAlt},m.getMaxAltitude=function(){return this._genMinMaxAlt(),this._maxAlt},m._clearAltitudeCache=function(){return this._minAlt=void 0,this._maxAlt=void 0,this},m._getEditCenter=function(){var i=this.getCenter().copy();i.z=0;var g=this.getAltitude();if(W(g))return i.z=g,i;var m=0,_=0,b=function(i){for(var g=0,T=i.length;g<T;g++)Array.isArray(i[g])?b(i[g]):(_++,m+=i[g])};return Array.isArray(g)&&(b(g),i.z=m/_),i},g}(ll(Za(hl(Ya))));function mu(i){var g="altitude";if(i){if(!i.isVectorLayer)return null;g=i.options.altitudeProperty}return g}function Au(i,g,m){var _=i.getCoordinates?i.getCoordinates():null;if(_){var b=[];if(_u(_,b),b.length)return vu(_,g,m)}return null}function yu(i,g){if(Array.isArray(i))for(var m=0,_=i.length;m<_;m++)yu(i[m],g);else i.z=g}function _u(i,g){if(!g.length)if(Array.isArray(i))for(var m=0,_=i.length;m<_;m++)_u(i[m],g);else W(i.z)&&g.push(i.z)}function vu(i,g,m){if(Array.isArray(i)){for(var _=[],b=0,T=i.length;b<T;b++)_.push(vu(i[b],g,m));return _}return W(i.z)?m?g+i.z:i.z:m?g:0}function xu(i,g,m,_){return i===m?_>g?-90:90:(m-=i,_=-(_-=g),Math.atan2(_,m)/Math.PI*180)}gu.mergeOptions({id:null,visible:!0,interactive:!0,editable:!0,cursor:null,antiMeridian:!1,defaultProjection:"EPSG:4326"});var bu="check_browser_max_fps";Os(bu,(function(){return"function (exports) {\n    exports.initialize = function () {};\n    function now(){\n        return new Date().getTime();\n    }\n    function checkFPS(cb) {\n        if (typeof(requestAnimationFrame) === 'undefined') {\n            cb(-1);\n            return;\n        }\n        const count = 100;\n        let idx = 0;\n        let id;\n        let startTime;\n        function loop() {\n            idx++;\n            if (idx === count) {\n                cancelAnimationFrame(id);\n                const endTime = now();\n                const timePerFPS = (endTime - startTime) / count;\n                const fps = Math.floor(1000 / timePerFPS);\n                cb(fps);\n            } else {\n                id = requestAnimationFrame(loop);\n            }\n        }\n        startTime = now();\n        id = requestAnimationFrame(loop);\n    }\n    //recive message\n    exports.onmessage = function (msg, postResponse) {\n        checkFPS((fps) => {\n            if (fps <= -1) {\n                postResponse('check fps fail');\n            } else {\n                postResponse(null, { fps });\n            }\n        })\n    }\n}"}));var wu,Tu=0,Su=[],Mu=function(){function i(i){var g=this;$s(),this._delayMessages=[],this.initializing=!1;var m=Ps(i);Ms&&!m&&(this.initializing=!0,console.log("Injecting codes in worker with worker key: :"+i),Ls(i,(function(){g.initializing=!1,g.created()}))),this.workerKey=i,this.workerPool=zs(),this.currentActor=0,this.actorId=gn(),this.workers=this.workerPool.acquire(this.actorId),this.callbacks={},this.callbackID=0,this.receiveFn=this.receive.bind(this),this.workers.forEach((function(i){i.addEventListener("message",g.receiveFn,!1)})),Is(i)}var g=i.prototype;return g.created=function(){var i=this;this._delayMessages.forEach((function(g){var{command:m,data:_,buffers:b,cb:T,workerId:P}=g;i[m](_,b,T,P)})),this._delayMessages=[]},g.isActive=function(){return!!this.workers},g.broadcast=function(i,g,m){var _=this;return this.initializing?(this._delayMessages.push({command:"broadcast",data:i,buffers:g,cb:m}),this):(function(i,g,m){i.length||m(null,[]);var _=i.length,b=new Array(i.length),T=null;i.forEach((function(i,P){g(i,(function(i,g){i&&(T=i),b[P]=g,0===--_&&m(T,b)}))}))}(this.workers,(function(m,b){_.send(i,g,b,m.id)}),m=m||function(){}),this)},g.send=function(i,g,m,_){if(this.initializing)return this._delayMessages.push({command:"send",data:i,buffers:g,cb:m,workerId:_}),this;var b=m?this.actorId+":"+this.callbackID++:null;return m&&(this.callbacks[b]=m),this.post({data:i,callback:String(b)},g,_),this},g.receive=function(i){var g=this,m=i.data,_=m.callback,b=this.callbacks[_];delete this.callbacks[_],"<request>"===m.type?this.actorId===m.actorId&&this[m.command](m.params,(function(i,_,b){var T={type:"<response>",callback:m.callback};i?T.error=i.message:T.data=_,g.post(T,b||Su,m.workerId)})):b&&m.error?b(m.error):b&&b(null,m.data)},g.remove=function(){var i=this;this.workers.forEach((function(g){g.removeEventListener("message",i.receiveFn,!1)})),delete this.receiveFn,delete this.workers,delete this.callbacks,delete this.workerPool},g.post=function(i,g,m){return("number"!=typeof m||isNaN(m))&&(m=this.currentActor=(this.currentActor+1)%this.workerPool.workerCount),i.workerId=m,i.workerKey=this.workerKey,i.actorId=this.actorId,this.workerPool.addMessage(m,i,g||Su),m},g.getDedicatedWorker=function(){return Tu=(Tu+1)%this.workerPool.workerCount},i}();var Cu=function(i){function g(){return i.call(this,bu)||this}return tn(g,i),g}(Mu),Pu=!1;var Iu=!1;Ys((function(){var i;Iu||T.maxFPS<=0&&(Iu=!0,i=function(i){W(i)&&i>0&&T.maxFPS<=0&&(T.maxFPS=i),Iu=!1},wu||(wu=new Cu),wu.send({},[],(function(g,m){g?(Pu||(console.error(g),Pu=!0),i()):i(m.fps)})))}));var ku=[],Ou=function(i){function g(){return i.call(this,Ss)||this}return tn(g,i),g.prototype.fetchImage=function(i,g){this.send({url:i},ku,g)},g}(Mu),Eu={depth:1,stencil:0},Ru={color:[0,0,0,0],depth:1,stencil:0},Lu=function(i){function g(g){var m;return(m=i.call(this)||this).layer=g,m._painted=!1,m._drawTime=0,!$t.decodeImageInWorker||$t.safari||$t.iosWeixin||(m._resWorkerConn=new Ou),m.setToRedraw(),m}tn(g,i);var _=g.prototype;return _.render=function(i){this.prepareRender(),this.getMap()&&this.layer.isVisible()&&(this.resources||(this.resources=Ko()),this.checkAndDraw(this._tryToDraw,i),this._frameTime=i)},_.getFrameTimestamp=function(){return this._frameTime||0},_.checkAndDraw=function(i,...g){var m=this;if(this._toRedraw=!1,this.checkResources){var _=this.checkResources();_.length>0?(this._loadingResource=!0,this.loadResources(_).then((function(){if(m._loadingResource=!1,m.layer){m.layer.fire("resourceload");var i=m.layer.getMap();m.setToRedraw(),i.getRenderer().callInNextFrame((function(){m.setToRedraw()}))}}))):i.call(this,...g)}else i.call(this,...g)},_.testIfNeedRedraw=function(){var i=this.getMap();return!this._loadingResource&&(!!this._toRedraw||!(i.isInteracting()&&!this.drawOnInteracting)&&!!this.needToRedraw())},_.needToRedraw=function(){var i=this.getMap();return!(!i.isInteracting()&&!i.getRenderer().isViewChanged())},_.onSkipDrawOnInteracting=function(){},_.isLoadingResource=function(){return this._loadingResource},_.isRenderComplete=function(){return!!this._renderComplete},_.mustRenderOnInteracting=function(){return!this._painted},_.setToRedraw=function(){return this._toRedraw=!0,this},_.remove=function(){this.onRemove(),delete this._loadingResource,delete this.middleWest,delete this.canvas,delete this.context,delete this.canvasExtent2D,delete this._extent2D,this.resources&&this.resources.remove(),delete this.resources,this._resWorkerConn&&(this._resWorkerConn.remove(),delete this._resWorkerConn),delete this.layer},_.onRemove=function(){},_.onAdd=function(){},_.getMap=function(){return this.layer?this.layer.getMap():null},_.clear=function(){this.clearContext(),this.setToRedraw()},_.isBlank=function(){return!this._painted},_.show=function(){this.setToRedraw()},_.hide=function(){this.clear(),this.setToRedraw()},_.setZIndex=function(i){this.setToRedraw()},_.screenshotRenderResult=function(i,g,m,_){if(this.canvas){var b=Va.getTempCanvas();b.width=m,b.height=_;var T=Va.getCanvas2DContext(b);return T.clearRect(0,0,m,_),T.drawImage(this.canvas,i,g,m,_,0,0,m,_),T}console.warn("not find layer canvas for screenshotRenderResult,the layerId:",this.layer.getId())},_.hitDetect=function(i){if(!this.context||this.layer.isEmpty&&this.layer.isEmpty()||this.isBlank()||this._errorThrown||this.layer.isVisible&&!this.layer.isVisible())return!1;var g=this.getMap(),m=this.mapDPR||g.getDevicePixelRatio(),_=g.getSize();if(i.x<0||i.x>_.width*m||i.y<0||i.y>_.height*m)return!1;var b=Math.round(m*i.x),T=Math.round(m*i.y),P=this.getImageData&&this.getImageData();if(P)return P.data[T*P.width*4+4*b+3]>0;try{var I=this.screenshotRenderResult(b,T,2,2);if(I)if(I.getImageData(b,T,1,1).data[3]>0)return!0}catch(i){return this._errorThrown||(console&&console.warn("hit detect failed with tainted canvas, some geometries have external resources in another domain:\n",i),this._errorThrown=!0),!1}return!1},_.loadResources=function(i){this.resources||(this.resources=new Jo);var g=this.resources,m=[];if(kn(i))for(var _={},b=i.length-1;b>=0;b--){var T=i[b];if(T&&T.length){var P=T.join("-");if(!oo(T[0])){if(_[P])continue;_[P]=1}g.isResourceLoaded(T,!0)||m.push(new Promise(this._promiseResource(T)))}}return Promise.all(m)},_.prepareRender=function(){delete this._renderComplete;var i=this.getMap();this._renderZoom=i.getZoom(),this.canvasExtent2D=this._extent2D=i.get2DExtent(),this.middleWest=i._containerPointToPoint(new un(0,i.height/2))},_.prepareCanvas=function(){var i=this.layer.parent,{canvas:g,context:m}=i.getRenderer(),_=m instanceof CanvasRenderingContext2D;if(this.context)_&&(this.clearContext(),this.resizeCanvas());else{if(_)this.createContext();else{this.canvas=g,this.context=m;var{gl:b,regl:T,reglGL:P,device:I}=m;this.gl=b,this.regl=T,this.reglGL=P,this.device=I}this.initContext()}this.prepareContext(),delete this._maskExtent;var H=this.layer.getMask();if(!H)return this.layer.fire("renderstart",{context:this.context}),null;var W=this._maskExtent=H._getMaskPainter().get2DExtent();return W&&this._extent2D&&W.intersects(this._extent2D),this.layer.fire("renderstart",{context:this.context}),W},_.initContext=function(){},_.prepareContext=function(){},_.clearContext=function(){if(this.device){var i=this.getMap().getRenderer();i.isWebGL()||i.isWebGPU()?this.device.clear(Eu):this.device.clear(Ru)}},_.createContext=function(){throw new Error("createContext not implemented")},_.getViewExtent=function(){return{extent:this._extent2D,maskExtent:this._maskExtent,zoom:this._renderZoom,middleWest:this.middleWest}},_.completeRender=function(){this.getMap()&&(this._renderComplete=!0,this.layer.fire("renderend",{context:this.context}),this.setCanvasUpdated())},_.getEvents=function(){return{_zoomstart:this.onZoomStart,_zooming:this.onZooming,_zoomend:this.onZoomEnd,_resize:this.onResize,_movestart:this.onMoveStart,_moving:this.onMoving,_moveend:this.onMoveEnd,_dragrotatestart:this.onDragRotateStart,_dragrotating:this.onDragRotating,_dragrotateend:this.onDragRotateEnd,_spatialreferencechange:this.onSpatialReferenceChange}},_.onZoomStart=function(i){},_.onZoomEnd=function(i){this.setToRedraw()},_.onZooming=function(i){},_.onMoveStart=function(i){},_.onMoving=function(i){},_.onMoveEnd=function(i){this.setToRedraw()},_.onResize=function(i){delete this._extent2D,this.setToRedraw()},_.onDragRotateStart=function(i){},_.onDragRotating=function(i){},_.onDragRotateEnd=function(i){this.setToRedraw()},_.onSpatialReferenceChange=function(i){},_.getDrawTime=function(){return this._drawTime},_._tryToDraw=function(i){this._toRedraw=!1,!this.canvas&&this.layer.isEmpty&&this.layer.isEmpty()?this._renderComplete=!0:this._drawAndRecord(i)},_._drawAndRecord=function(i){var g=this.getMap();if(g){var m=this._painted;this._painted=!0;var _=P();this.mapDPR=g.getDevicePixelRatio(),this.draw(i),_=P()-_,this._drawTime=m?_:_/2,m&&this.layer&&this.layer.options.logDrawTime&&console.log(this.layer.getId(),"frameTimeStamp:",i,"drawTime:",this._drawTime)}},_._promiseResource=function(i){var g=this,_=this.layer,b=this.resources,T=_.options.crossOrigin,P=_.options.renderer||"";return function(I){if(b.isResourceLoaded(i,!0))I(i);else{var W=li(i[0]);if(oo(W))createImageBitmap(W).then((function(m){g._cacheResource(i,m),I(i)})).catch((function(g){console.error(g),I(i)}));else if(!fn(i[0])&&g._resWorkerConn&&("canvas"!==_.options.renderer||_.options.decodeImageInWorker))g._resWorkerConn.fetchImage(W,(function(m,_){if(m)return m&&"undefined"!=typeof console&&console.warn(m),void I(i);qn(_,(function(m){g._cacheResource(i,m),I(i)}))}));else{var q=new Image;H(T)?"canvas"!==P&&(q.crossOrigin=""):q.crossOrigin=T,fn(i[0])&&!m&&(i[1]&&(i[1]*=2),i[2]&&(i[2]*=2)),q.onload=function(){g._cacheResource(i,q),I(i)},q.onabort=function(g){console&&console.warn("image loading aborted: "+i[0]),g&&console&&console.warn(g),I(i)},q.onerror=function(g){g&&"undefined"!=typeof console&&console.warn(g),b.markErrorResource(i),I(i)},dn(q,[W])}}}},_._cacheResource=function(i,g){if(this.layer&&this.resources){var m=i[1],_=i[2];if(this.layer.options.cacheSvgOnCanvas&&1===fn(i[0])&&($t.edge||$t.ie)){H(m)&&(m=g.width||this.layer.options.defaultIconSize[0]),H(_)&&(_=g.height||this.layer.options.defaultIconSize[1]);var b=Va.createCanvas(m,_);Va.image(b.getContext("2d"),g,0,0,m,_),g=b}this.resources.addResource(i,g)}},_.setCanvasUpdated=function(){return this._canvasUpdated=!0,this},_.isCanvasUpdated=function(){return!!this._canvasUpdated},_.getCanvasImage=function(){var i=this.getMap();if(this._canvasUpdated=!1,this._renderZoom!==i.getZoom()||!this.canvas||!this._extent2D)return null;if(this.isBlank())return null;if(this.layer.isEmpty&&this.layer.isEmpty())return null;var g=i._pointToContainerPoint(this.middleWest)._add(0,-i.height/2);return{image:this.canvas,layer:this.layer,point:g}},_.clearCanvas=function(){this.clearContext()},_.createCanvas=function(){if(!this.canvas){var i=this.getMap(),g=i.getSize(),m=i.getDevicePixelRatio(),_=Math.round(m*g.width),b=Math.round(m*g.height);if(this.layer._canvas){var T=this.layer._canvas;T.width=_,T.height=b,T.style&&(T.style.width=g.width+"px",T.style.height=g.height+"px"),this.canvas=this.layer._canvas}else this.canvas=Va.createCanvas(_,b,i.CanvasClass);this.onCanvasCreate()}},_.onCanvasCreate=function(){},_.resizeCanvas=function(i){var g=this.canvas,m=this.getMap();if(g&&g!==m.canvas){var _=i||m.getSize(),b=m.getDevicePixelRatio(),{width:T,height:P,cssWidth:I,cssHeight:H}=Yn(_,b);!this.layer._canvas||g.style.width===I&&g.style.height===H||(g.style.width=I,g.style.height=H),g.width===T&&g.height===P||(g.height=P,g.width=T,this.context&&(this.context.dpr=1),1!==b&&this.context&&this._canvasContextScale(this.context,b))}},_.clipCanvas=function(i){var g=this.layer.getMask();if(!g)return!1;if(!this.layer.options.maskClip)return!1;var m=this.middleWest,_=this.getMap();this.middleWest=_._containerPointToPoint(new un(0,_.height/2));var b=i.globalAlpha;i.save();var T=this.mapDPR||_.getDevicePixelRatio();if(1!==T&&(i.save(),this._canvasContextScale(i,T)),g.getGeometries){i.isMultiClip=!0;var P=g.getGeometries()||[];i.beginPath(),P.forEach((function(g){g._getMaskPainter().paint(null,i)})),i.stroke(),i.isMultiClip=!1}else{i.isClip=!0,i.beginPath(),g._getMaskPainter().paint(null,i),i.isClip=!1}1!==T&&i.restore();try{i.clip("evenodd")}catch(i){console.error(i)}return this.middleWest=m,i.globalAlpha=b,!0},_._canvasContextScale=function(i,g){return i.scale?(i.scale(g,g),i.dpr=g,this):this},g}(Ya);$t.decodeImageInWorker&&Os(Ss,(function(){return"\nfunction (exports) {\n    exports.onmessage = function (msg, postResponse) {\n        var url = msg.data.url;\n        var fetchOptions = msg.data.fetchOptions;\n        requestImageOffscreen(url, function (err, data) {\n            var buffers = [];\n            if (data && data.data) {\n                buffers.push(data.data);\n            }\n            postResponse(err, data, buffers);\n        }, fetchOptions);\n    };\n\n    function requestImageOffscreen(url, cb, fetchOptions) {\n        fetch(url, fetchOptions ? fetchOptions : {})\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => {\n                const blob=new Blob([arrayBuffer]);\n                return createImageBitmap(blob);\n            })\n            .then(bitmap => {\n                cb(null, {data:bitmap});\n            }).catch(err => {\n                console.error('error when loading tile:', url);\n                console.error(err);\n                cb(err);\n            });\n    }\n}"}));var Du={attribution:null,minZoom:null,maxZoom:null,visible:!0,opacity:1,globalCompositeOperation:null,renderer:"canvas",debugOutline:"#0f0",cssFilter:null,forceRenderOnMoving:!1,forceRenderOnZooming:!1,forceRenderOnRotating:!1,collision:!1,collisionScope:"layer",hitDetect:!$t.mobile,maskClip:!0},Fu=function(i){function g(g,m){var _,b;return m&&(b=m.canvas,delete m.canvas),(_=i.call(this,m)||this)._canvas=b,_.setId(g),m&&(_.setZIndex(m.zIndex),m.mask&&_.setMask(gu.fromJSON(m.mask))),_.proxyOptions(),_}tn(g,i);var m=g.prototype;return m.load=function(){if(!this.getMap())return this;if(this.onLoad()){this._initRenderer();var i=this.getZIndex();H(i)||this._renderer&&(this._renderer.setZIndex(i),this.isCanvasRender()||this._renderer.render()),this.onLoadEnd()}return this},m.getId=function(){return this._id},m.setId=function(i){var g=this._id;return H(i)||(i+=""),this._id=i,this.fire("idchange",{type:"idchange",target:this,old:g,new:i}),this},m.addTo=function(i){return i.addLayer(this),this},m.setZIndex=function(i){return this._zIndex=i,H(i)?delete this.options.zIndex:this.options.zIndex=i,this.map&&this.map._sortLayersByZIndex(),this._renderer&&this._renderer.setZIndex(i),this.fire("setzindex",{type:"setzindex",target:this,zIndex:i}),this},m.getZIndex=function(){return this._zIndex||0},m.getMinZoom=function(){var i=this.getMap(),g=this.options.minZoom;return i?Math.max(i.getMinZoom(),g||0):g},m.getMaxZoom=function(){var i=this.getMap(),g=this.options.maxZoom;return i?Math.min(i.getMaxZoom(),H(g)?1/0:g):g},m.getOpacity=function(){return this.options.opacity},m.setOpacity=function(i){return this.config("opacity",i),this.fire("setopacity",{type:"setopacity",target:this,opacity:i}),this},m.isCanvasRender=function(){var i=this._getRenderer();return i&&i instanceof Lu},m.getMap=function(){return this.map?this.map:null},m.getProjection=function(){var i=this.getMap();return i?i.getProjection():null},m.bringToFront=function(){var i=this._getLayerList();if(!i.length)return this;var g=i[i.length-1];if(1===i.length||g===this)return this;var m=g.getZIndex();return this.setZIndex(m+1),this},m.bringToBack=function(){var i=this._getLayerList();if(!i.length)return this;var g=i[0];if(1===i.length||g===this)return this;var m=g.getZIndex();return this.setZIndex(m-1),this},m.show=function(){var i=this;if(!this.options.visible){this.options.visible=!0;var g=this.getRenderer();g&&g.show();var m=this.getMap();g&&m&&m.getRenderer()?m.getRenderer().callInNextFrame((function(){m.getRenderer().callInNextFrame((function(){i.fire("show")}))})):this.fire("show")}return this},m.hide=function(){var i=this;if(this.options.visible){this.options.visible=!1;var g=this.getRenderer();g&&g.hide();var m=this.getMap();g&&m&&m.getRenderer()?m.getRenderer().callInNextFrame((function(){m.getRenderer().callInNextFrame((function(){i.fire("hide")}))})):this.fire("hide")}return this},m.isVisible=function(){var i=this.options.opacity;if(W(i)&&i<=0)return!1;var g=this.map;if(g){var m=g.getZoom(),_=this.options.minZoom,b=this.options.maxZoom;if(!H(b)&&b<m||!H(_)&&_>m)return!1}return H(this.options.visible)&&(this.options.visible=!0),this.options.visible},m.remove=function(){if(this.map){var i=this.map.getRenderer();this.map.removeLayer(this),i&&i.setToRedraw()}else this.fire("remove");return this},m.getMask=function(){return this._mask},m.setMask=function(i){if(!("Point"===i.type&&i._isVectorMarker()||"Polygon"===i.type||"MultiPolygon"===i.type))throw new Error("Mask for a layer must be a marker with vector marker symbol or a Polygon(MultiPolygon).");if(i._bindLayer(this),"Point"===i.type?i.updateSymbol({markerLineColor:"rgba(0, 0, 0, 0)",markerFillOpacity:0}):i.setSymbol({lineColor:"rgba(0, 0, 0, 0)",polygonOpacity:0}),this._mask=i,i&&i.toGeoJSON)try{this._maskGeoJSON=i.toGeoJSON()}catch(i){delete this._maskGeoJSON,console.error(i)}if(this.options.mask=i.toJSON(),!this.getMap()||this.getMap().isZooming())return this;var g=this._getRenderer();return g&&g.setToRedraw&&this._getRenderer().setToRedraw(),this},m.removeMask=function(){if(delete this._mask,delete this._maskGeoJSON,delete this.options.mask,!this.getMap()||this.getMap().isZooming())return this;var i=this._getRenderer();return i&&i.setToRedraw&&this._getRenderer().setToRedraw(),this},m.onLoad=function(){return!0},m.onLoadEnd=function(){},m.isLoaded=function(){return!!this._loaded},m.getCollisionIndex=function(){if("layer"===this.options.collisionScope)return this._collisionIndex||(this._collisionIndex=new va),this._collisionIndex;var i=this.getMap();return i?i.getCollisionIndex():null},m.clearCollisionIndex=function(){return"layer"===this.options.collisionScope&&this._collisionIndex&&this._collisionIndex.clear(),this},m.getRenderer=function(){return this._getRenderer()},m.onConfig=function(i){if(i&&Object.keys&&Object.keys(i).length>0&&H(i.animation)){if(this._optionsHook&&Re(this._optionsHook)&&this._optionsHook(i),this._silentConfig)return;var g=this.getRenderer();if(g&&g.setToRedraw&&g.setToRedraw(),"attribution"in i){var m=this.getMap();m&&m.attributionControl&&m.attributionControl._update&&m.attributionControl._update()}}},m.onAdd=function(){},m.onRendererCreate=function(){},m.onCanvasCreate=function(){},m.onRemove=function(){},m._bindMap=function(i,g){i&&(this.parent=i,this.map=i.isMap?i:i.getMap(),H(g)||this.setZIndex(g),this._switchEvents("on",this),this.onAdd(),this.fire("add"))},m._initRenderer=function(){var i=this.options.renderer;if(this.constructor.getRendererClass&&i){var g=this.getMap().getRenderer();g.isWebGL()?i="gl":g.isWebGPU()&&(i="gpu");var m=this.constructor.getRendererClass(i);if(!m)throw new Error("Invalid renderer for Layer("+this.getId()+"):"+i);this._renderer=new m(this),this._renderer.layer=this,this._renderer.setZIndex(this.getZIndex()),this._switchEvents("on",this._renderer),this._renderer.onAdd&&this._renderer.onAdd(),this.onRendererCreate(),this.fire("renderercreate",{type:"renderercreate",target:this,renderer:this._renderer})}},m._doRemove=function(){this._loaded=!1,this._switchEvents("off",this),this.onRemove(),this._renderer&&(this._switchEvents("off",this._renderer),this._renderer.remove(),delete this._renderer),delete this.map,delete this._collisionIndex},m._switchEvents=function(i,g){g&&g.getEvents&&this.getMap()&&this.getMap()[i](g.getEvents(),g)},m._getRenderer=function(){return this._renderer},m._getLayerList=function(){if(!this.map)return[];var i=+!!this.map.getBaseLayer();return this.map.getLayers().slice(i)},m._getMask2DExtent=function(){if(!this._mask||!this.getMap())return null;var i=this._mask._getMaskPainter();return i?i.get2DExtent():null},m.toJSON=function(i){return{type:"Layer",id:this.getId(),options:i||this.config()}},g.fromJSON=function(i){if(!i)return null;var m=i.type,_=g.getJSONClass(m);if(!_||!_.fromJSON)throw new Error("unsupported layer type:"+m);return _.fromJSON(i)},m.identify=function(i,g){},m.identifyAtPoint=function(i,g){},g}(ll(Za(bh(Ya))));Fu.mergeOptions(Du);var Nu=Fu.prototype.fire;Fu.prototype.fire=function(i,g){return"layerload"===i&&(this._loaded=!0),this.map&&(g||(g={type:null,target:null}),g.type=i,g.target=this,this.map._onLayerEvent(g)),Nu.apply(this,arguments),["show","hide"].indexOf(i)>-1&&this.fire("visiblechange",Object.assign({},g,{visible:this.options.visible})),this};var Hu=new pl(0,0),Bu=new un(0,0),zu=["centerCross","fog","fogColor","debugSky"],Vu={maxVisualPitch:70,maxPitch:80,centerCross:!1,zoomable:!0,zoomInCenter:!1,zoomOrigin:null,zoomAnimation:!m,zoomAnimationDuration:330,tileBackgroundLimitPerFrame:3,panAnimation:!m,panAnimationDuration:600,rotateAnimation:!m,enableInfoWindow:!0,hitDetect:!$t.mobile,hitDetectLimit:5,fpsOnInteracting:25,layerCanvasLimitOnInteracting:-1,maxZoom:null,minZoom:null,maxExtent:null,limitExtentOnMaxExtent:!1,fixCenterOnResize:!0,checkSize:!0,checkSizeInterval:1e3,renderer:["canvas","gl","gpu"],cascadePitches:[10,60],renderable:!0,clickTimeThreshold:280,stopRenderOnOffscreen:!0,preventWheelScroll:!0,preventTouch:!0,supportPluginEvent:!0,switchDragButton:!1,mousemoveThrottleTime:48,mousemoveThrottleEnable:!0,maxFPS:0,debug:!1,cameraFarUndergroundInMeter:2e3,onlyWebGL1:!1,forceRedrawPerFrame:!1,preserveDrawingBuffer:!0,extensions:[],optionalExtensions:["ANGLE_instanced_arrays","OES_element_index_uint","OES_standard_derivatives","OES_vertex_array_object","OES_texture_half_float","OES_texture_half_float_linear","OES_texture_float","OES_texture_float_linear","WEBGL_depth_texture","EXT_shader_texture_lod","EXT_frag_depth","EXT_texture_filter_anisotropic","WEBGL_compressed_texture_astc","WEBGL_compressed_texture_etc","WEBGL_compressed_texture_etc1","WEBGL_compressed_texture_pvrtc","WEBGL_compressed_texture_s3tc","WEBGL_compressed_texture_s3tc_srgb"]},Uu=function(i){function g(m,_){var b;if(!_)throw new Error("Invalid options when creating map.");if(!_.center)throw new Error("Invalid center when creating map.");var T=I({},_),P=T.zoom;delete T.zoom;var H=new pl(T.center);delete T.center;var W=T.baseLayer;delete T.baseLayer;var q=T.layers;return delete T.layers,(b=i.call(this,T)||this).isMap=!0,b.VERSION=g.VERSION,Object.defineProperty(b,"id",{value:gn(),writable:!1}),b._loaded=!1,b._initContainer(m),b._panels={},b._baseLayer=null,b._layers=[],b._zoomLevel=P,b._center=H,b.setSpatialReference(T.spatialReference||T.view),b._mapViewPoint=new un(0,0),b._initRenderer(),b._updateMapSize(b._getContainerDomSize()),W&&b.setBaseLayer(W),q&&b.addLayer(q),b.setMaxExtent(T.maxExtent),b._Load(),b.proxyOptions(),b}tn(g,i),g.addOnLoadHook=function(i,...g){var m="function"==typeof i?i:function(){this[i].call(this,...g)};return this.prototype._onLoadHooks=this.prototype._onLoadHooks||[],this.prototype._onLoadHooks.push(m),this};var _=g.prototype;return _.isLoaded=function(){return!!this._loaded},_.getContainer=function(){return this._containerDOM},_.getSpatialReference=function(){return this._spatialReference},_.setSpatialReference=function(i){var g=this.options.spatialReference;return this._loaded&&uu.equals(g,i)||this._updateSpatialReference(i,g),this},_._updateSpatialReference=function(i,g){ye(i)&&(i=uu.getPreset(i)),i=I({},i),this._center=this.getCenter(),this.options.spatialReference=i,this._spatialReference=new uu(i);var m=this._spatialReference.getProjection();return this.options.spatialReference&&Re(this.options.spatialReference.projection)&&(this.options.spatialReference.projection=m.code),this._resetMapStatus(),ph.is(m.code)&&(this._originLng=m.centralMeridian,this._altitudeOriginDirty=!0),this._fireEvent("spatialreferencechange",{old:g,new:I({},this.options.spatialReference)}),this},_.onConfig=function(i){var g=i.spatialReference||i.view;if(H(g)||this._updateSpatialReference(g,null),"canvas"===this.options.renderer){for(var m=!1,_=0,b=zu.length;_<b;_++){if(!H(i[zu[_]])){m=!0;break}}if(!m)return this}var T=this.getRenderer();return T&&T.setToRedraw(),this},_.getProjection=function(){return this._spatialReference?this._spatialReference.getProjection():null},_.getFullExtent=function(){return this._spatialReference?this._spatialReference.getFullExtent():null},_.setCursor=function(i){return delete this._cursor,this._trySetCursor(i),this._cursor=i,this},_.resetCursor=function(){return this.setCursor(null)},_.getCenter=function(){if(!this._loaded||!this._prjCenter)return this._center;var i=this.getProjection().unproject(this._prjCenter);return i.x=Math.round(1e8*i.x)/1e8,i.y=Math.round(1e8*i.y)/1e8,this.centerAltitude&&(i.z=this.centerAltitude),i},_.setCenter=function(i,g){if(!i)return this;i=new pl(i),g&&(i=this._getCenterByPadding(i,this.getZoom(),g));var m=this.getProjection().project(i);return this._verifyExtent(m)||this.options.limitExtentOnMaxExtent?this._loaded?(this.onMoveStart(),this._setPrjCenter(m),this.onMoveEnd(this._parseEventFromCoord(this.getCenter())),this):(this._center=i,this):this},_.getSize=function(){return H(this.width)||H(this.height)?this._getContainerDomSize():new ir(this.width,this.height)},_.getContainerExtent=function(){var i=this.height,g=this.getPitch(),m=this.options.maxVisualPitch;return m&&g>m&&(i=this._getVisualHeight(m)),new kl(0,this.height-i,this.width,this.height)},_._getVisualHeight=function(i){i=i||.01;var g=(90-this.getPitch())*Math.PI/180,m=this.getFov()*Math.PI/180;i*=Math.PI/180;var _=this.cameraCenterDistance/this.getGLScale(),b=Math.tan(m/2),T=_*b/(1/Math.tan(i)-b)/Math.sin(i),P=_*(Math.sin(g)*T/(_+Math.cos(g)*T));return this.height/2+P},_.getExtent=function(){return this.pointToExtent(this.get2DExtent())},_.getProjExtent=function(){var i=this.get2DExtent();return new Pl(this._pointToPrj(i.getMin()),this._pointToPrj(i.getMax()))},_.getPrjExtent=function(){return this.getProjExtent()},_.getMaxExtent=function(){return this.options.maxExtent?new Pl(this.options.maxExtent,this.getProjection()):null},_.setMaxExtent=function(i){if(i){var g=new Pl(i,this.getProjection());this.options.maxExtent=g;var m=this.getProjection();this._prjMaxExtent=g.convertTo((function(i){return m.project(i)})),this._verifyExtent(this._getPrjCenter())||(this._loaded?this._panTo(this._prjMaxExtent.getCenter()):this._center=m.unproject(this._prjMaxExtent.getCenter()))}else delete this.options.maxExtent,delete this._prjMaxExtent;return this},_.getZoom=function(){return this._zoomLevel},_.getZoomForScale=function(i,g,m){var _=this.getZoom();if(H(g)&&(g=_),1===i&&g===_)return _;var b=this._getResolution(g),T=this.getZoomFromRes(b/i);if(m)return T;var P=1e-6;return this.getSpatialReference().getZoomDirection()<0?Math.ceil(T-P):Math.floor(T+P)},_.getZoomFromRes=function(i){var g=this._getResolutions(),m=this._getResolution(this.getMinZoom()),_=this._getResolution(this.getMaxZoom());if(m<=_){if(i<=m)return this.getMinZoom();if(i>=_)return this.getMaxZoom()}else{if(i>=m)return this.getMinZoom();if(i<=_)return this.getMaxZoom()}for(var b=g.length,T=0;T<b-1;T++)if(g[T]){var P=g[T+1]-g[T],I=i-g[T];if(Sn(P)===Sn(I)&&Math.abs(P)>=Math.abs(I))return T+I/P}return b-1},_.setZoom=function(i,g={animation:!0}){return isNaN(i)||H(i)||(i=+i,this._loaded&&this.options.zoomAnimation&&g.animation?this._zoomAnimation(i):this._zoom(i)),this},_.getMaxZoom=function(){return H(this.options.maxZoom)?this.getMaxNativeZoom():this.options.maxZoom},_.setMaxZoom=function(i){var g=this.getMaxNativeZoom();return i>g&&(i=g),null!==i&&i<this._zoomLevel&&(this.setZoom(i),i=+i),this.options.maxZoom=i,this},_.getMinZoom=function(){return H(this.options.minZoom)?this._spatialReference.getMinZoom():this.options.minZoom},_.setMinZoom=function(i){if(null!==i){i=+i;var g=this._spatialReference.getMinZoom();i<g&&(i=g),i>this._zoomLevel&&this.setZoom(i)}return this.options.minZoom=i,this},_.getMaxNativeZoom=function(){var i=this.getSpatialReference();return i?i.getMaxZoom():null},_.getGLRes=function(){if(this._glRes)return this._glRes;var i=this.getSpatialReference().getFullExtent();return this._glRes=(i.right-i.left)/Math.pow(2,19),this._glRes},_.getGLScale=function(i){return H(i)&&(i=this.getZoom()),this._getResolution(i)/this.getGLRes()},_.zoomIn=function(){return this.setZoom(this.getZoom()+1)},_.zoomOut=function(){return this.setZoom(this.getZoom()-1)},_.isZooming=function(){return!!this._zooming},_.isInteracting=function(){return this.isZooming()||this.isMoving()||this.isRotating()},_.setCenterAndZoom=function(i,g){return H(g)||this._zoomLevel===g?this.setCenter(i):(this.setCenter(i),this.setZoom(g,{animation:!1})),this},_._getPaddingSize=function(i={}){return i.paddingLeft||i.paddingTop||i.paddingRight||i.paddingBottom?{width:(i.paddingLeft||0)+(i.paddingRight||0),height:(i.paddingTop||0)+(i.paddingBottom||0)}:null},_.getFitZoom=function(i,g,m){var _=this;if(!(i&&i instanceof Pl))return this._zoomLevel;if(i.xmin===i.xmax&&i.ymin===i.ymax)return this.getMaxZoom();var b=this.getSize(),T=this._getPaddingSize(m);if(T){var P={width:b.width-(T.width||0),height:b.height-(T.height||0)};b=new ir(P.width,P.height)}var I=i.convertTo((function(i){return _.coordToPoint(i)})),H=I.getWidth(),W=I.getHeight(),q=b.width/H,$=b.height/W,ye=this.getSpatialReference().getZoomDirection()<0?Math.max(q,$):Math.min(q,$);return this.getZoomForScale(ye,null,g)},_.getView=function(){return{center:this.getCenter().toArray(),zoom:this.getZoom(),pitch:this.getPitch(),bearing:this.getBearing()}},_._validateView=function(i){if(i&&$(i)){if(W(i.bearing)){var g=i.bearing;(g%=360)>180&&(g=-180+Math.abs(g-180)),g<-180&&(g=180-Math.abs(g+180)),i.bearing=g}W(i.pitch)&&(i.pitch=Math.max(0,i.pitch),i.pitch=Math.min(this.options.maxPitch,i.pitch));var m=this.getMaxZoom();W(i.zoom)&&(i.zoom=Math.max(0,i.zoom),i.zoom=Math.min(m,i.zoom))}},_.setView=function(i){return i?(this._validateView(i),i.center&&this.setCenter(i.center),null===i.zoom||isNaN(+i.zoom)||this.setZoom(+i.zoom,{animation:!1}),null===i.pitch||isNaN(+i.pitch)||this.setPitch(+i.pitch),null===i.bearing||isNaN(+i.bearing)||this.setBearing(+i.bearing),this):this},_.getResolution=function(i){return this._getResolution(i)},_.getScale=function(i){var g=H(i)?this.getZoom():i,m=this._getResolution(this.getMaxNativeZoom());return this._getResolution(g)/m},_._getCenterByPadding=function(i,g,m){var _=this.coordinateToPoint(i,g),{paddingLeft:b=0,paddingRight:T=0,paddingTop:P=0,paddingBottom:I=0}=m||{},H=0,W=0;(b||T)&&(H=(T-b)/2),(P||I)&&(W=(P-I)/2);var q=new un({x:_.x+H,y:_.y+W});return this.pointToCoordinate(q,g)},_.fitExtent=function(i,g,m,_){var b=this;if(m=m||{},!i)return this;var T=new Pl(i),P=this.getFitZoom(T,m.isFraction||!1,m)+(g||0),I=T.convertTo((function(i){return b.coordToPoint(i)})),H=this.pointToCoord(I.getCenter());return this._getPaddingSize(m)&&(H=this._getCenterByPadding(H,P,m)),void 0===m.animation||m.animation?this._animateTo({center:H,zoom:P},{duration:m.duration||this.options.zoomAnimationDuration,easing:m.easing||"out"},_):this.setCenterAndZoom(H,P)},_.getBaseLayer=function(){return this._baseLayer},_.setBaseLayer=function(i){var g=!1;if(this._baseLayer&&(g=!0,this._fireEvent("baselayerchangestart"),this._baseLayer.remove()),!i)return delete this._baseLayer,this._fireEvent("baselayerchangeend"),this._fireEvent("setbaselayer"),this;return this._baseLayer=i,i._bindMap(this,-1),this._baseLayer.on("layerload",(function(){this._fireEvent("baselayerload"),g&&(g=!1,this._fireEvent("baselayerchangeend"))}),this),this._loaded&&this._baseLayer.load(),this._fireEvent("setbaselayer"),this},_.removeBaseLayer=function(){return this._baseLayer&&(this._baseLayer.remove(),delete this._baseLayer,this._fireEvent("baselayerremove")),this},_.getLayers=function(i){return this._getLayers((function(g){return!(g===this._baseLayer||g.getId().indexOf(Qn)>=0)&&(!i||i(g))}))},_.getLayer=function(i){if(!i)return null;var g=this._layerCache?this._layerCache[i]:null;if(g)return g;var m=this.getBaseLayer();return m&&m.getId()===i?m:null},_.addLayer=function(i,...g){if(!i)return this;Array.isArray(i)||(i=[i]),g&&g.length&&(i=i.concat(g)),this._layerCache||(this._layerCache={});for(var m=this._layers,_=0,b=i.length;_<b;_++){var T=i[_],P=T.getId();if(H(P))throw new Error("Invalid id for the layer: "+P);if(T.getMap()!==this){if(this._layerCache[P])throw new Error("Duplicate layer id in the map: "+P);this._layerCache[P]=T,T._bindMap(this),m.push(T),this._loaded&&T.load()}}return this._sortLayersByZIndex(),this._fireEvent("addlayer",{layers:i}),this},_.removeLayer=function(i){if(!i)return this;if(!Array.isArray(i))return this.removeLayer([i]);for(var g=[],m=0,_=i.length;m<_;m++){var b=i[m];if(b instanceof Fu||(b=this.getLayer(b)),b){var T=b.getMap();if(T&&T===this){g.push(b),this._removeLayer(b,this._layers),this._loaded&&b._doRemove();var P=b.getId();this._layerCache&&delete this._layerCache[P]}}}if(g.length>0){var I=this.getRenderer();I&&("canvas"===this.options.renderer?I.setLayerCanvasUpdated():I.setToRedraw()),this.once("frameend",(function(){g.forEach((function(i){i.fire("remove")}))}))}return this._fireEvent("removelayer",{layers:i}),this},_._findTerrainLayer=function(){if(Gu(this._baseLayer))return this._baseLayer;for(var i=this._getLayers()||[],g=0;g<i.length;g++){var m=i[g];if(Gu(m))return m}return null},_.sortLayers=function(i){if(!i||!Array.isArray(i))return this;for(var g=[],m=Number.MAX_VALUE,_=0,b=i.length;_<b;_++){var T=i[_];if(ye(i[_])&&(T=this.getLayer(T)),!(T instanceof Fu&&T.getMap()&&T.getMap()===this))throw new Error("It must be a layer added to this map to order.");T.getZIndex()<m&&(m=T.getZIndex()),g.push(T)}for(var P=0,I=g.length;P<I;P++)g[P].setZIndex(m+P);return this},_.toDataURL=function(i){i||(i={});var g=i.mimeType;g||(g="image/png");var m=i.save,_=this._getRenderer();if(_&&_.toDataURL){var b=i.fileName;b||(b="export");var T=_.toDataURL(g,i.quality||.92);if(m&&T){var P;if("undefined"!=typeof Blob&&"undefined"!=typeof atob){var I=Hn(T.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/,""),g);P=URL.createObjectURL(I)}else P=T;var H=document.createElement("a");H.download=b,H.href=P,document.body.appendChild(H),H.click(),document.body.removeChild(H)}return T}return null},_.coordToPoint=function(i,g,m){return this.coordinateToPoint(i,g,m)},_.coordToPointAtRes=function(i,g,m){return this.coordinateToPointAtRes(i,g,m)},_.pointToCoord=function(i,g,m){return this.pointToCoordinate(i,g,m)},_.pointAtResToCoord=function(i,g,m){return this.pointAtResToCoordinate(i,g,m)},_.coordToViewPoint=function(i,g,m){return this.coordinateToViewPoint(i,g,m)},_.viewPointToCoord=function(i,g){return this.viewPointToCoordinate(i,g)},_.coordToContainerPoint=function(i,g,m){return this.coordinateToContainerPoint(i,g,m)},_.containerPointToCoord=function(i,g){return this.containerPointToCoordinate(i,g)},_.containerPointToViewPoint=function(i,g){return g?g.set(i.x,i.y):g=i.copy(),g._sub(this.getViewPoint())},_.viewPointToContainerPoint=function(i,g){return g?g.set(i.x,i.y):g=i.copy(),g._add(this.getViewPoint())},_.checkSize=function(i){var g=P()-this._initTime<1500&&0===this.width||0===this.height,m=this._getContainerDomSize(),_=this.height,b=this.width;if(!i&&m.width===b&&m.height===_)return this;Vr(this._containerDOM);var T=this.getCenter();if(this.options.fixCenterOnResize)this._updateMapSize(m);else{var I=this._getVisualHeight(this.getPitch()),H=new un(0,this.height-I),W=this._containerPointToPrj(H);this._updateMapSize(m);var q=this._getVisualHeight(this.getPitch()),$=new un(0,this.height-q);this._setPrjCoordAtContainerPoint(W,$),this._mapViewCoord=this._getPrjCenter()}return(g||(0===m.width||0===m.height||0===b||0===_))&&(this._eventSilence=!0,this.setCenter(T),delete this._eventSilence),this._fireEvent("resize"),this},_.locate=function(i,g,m){return this.getProjection()._locate(new pl(i),g,m)},_.getMainPanel=function(){var i=this._getRenderer();return i?i.getMainPanel():null},_.getPanels=function(){return this._panels},_.remove=function(){var i=this;if(this.isRemoved())return this;this._fireEvent("removestart"),[this._animPlayer,this._mapAnimPlayer].forEach((function(g){g&&g.finish&&i._stopAnim(g)})),this._removeDomEvents(),this._clearHandlers(),this.removeBaseLayer();for(var g=this.getLayers(),m=0;m<g.length;m++)g[m].remove();return this._getRenderer()&&this._getRenderer().remove(),this._containerDOM.childNodes&&this._containerDOM.childNodes.length>0&&Array.prototype.slice.call(this._containerDOM.childNodes,0).filter((function(i){return"maptalks-wrapper"===i.className})).forEach((function(g){return i._containerDOM.removeChild(g)})),delete this._panels,delete this._containerDOM,delete this._renderer,this._fireEvent("removeend"),this._clearAllListeners(),this},_.isRemoved=function(){return!this._containerDOM},_.isMoving=function(){return!!this._moving},_.onMoveStart=function(i){this._mapAnimPlayer&&this._stopAnim(this._mapAnimPlayer);var g=this._getPrjCenter();this._originCenter&&!this._verifyExtent(g)||(this._originCenter=g),this._moving=!0,this._trySetCursor("move"),this._fireEvent("movestart",this._parseEvent(i?i.domEvent:null,"movestart"))},_.onMoving=function(i){this._fireEvent("moving",this._parseEvent(i?i.domEvent:null,"moving")),this._limitMaxExtent()},_.onMoveEnd=function(i){(this._moving=!1,this._suppressRecenter||this._recenterOnTerrain(),this._trySetCursor("default"),this._fireEvent("moveend",i&&i.domEvent?this._parseEvent(i.domEvent,"moveend"):i),this._verifyExtent(this._getPrjCenter())||!this._originCenter||this.options.limitExtentOnMaxExtent)||this._panTo(this._originCenter);this._limitMaxExtent()},_.onDragRotateStart=function(i){this._dragRotating=!0,this._fireEvent("dragrotatestart",this._parseEvent(i?i.domEvent:null,"dragrotatestart"))},_.onDragRotating=function(i){this._fireEvent("dragrotating",this._parseEvent(i?i.domEvent:null,"dragrotating"))},_.onDragRotateEnd=function(i){this._dragRotating=!1,this._fireEvent("dragrotateend",this._parseEvent(i?i.domEvent:null,"dragrotateend"))},_.isDragRotating=function(){return!!this._dragRotating},_.isOffscreen=function(i,g=0){var{width:m,height:_}=this,b=m+g,T=_+g,{xmin:P,ymin:I,xmax:H,ymax:W}=i;return Array.isArray(i)&&([P,I,H,W]=i),H<g||P>=b||W<g||I>T},_.getRenderer=function(){return this._getRenderer()},_.getDevicePixelRatio=function(){return this.options.devicePixelRatio||$t.devicePixelRatio||1},_.setDevicePixelRatio=function(i){return W(i)&&i>0&&i!==this.options.devicePixelRatio&&(this.options.devicePixelRatio=i,this.checkSize(!0)),this},_._initContainer=function(i){var g,_;if(ye(i)){if(this._containerDOM=document.getElementById(i),!this._containerDOM)throw new Error("Invalid container when creating map: '"+i+"'")}else this._containerDOM=i,m&&(this.CanvasClass=this._containerDOM.constructor);if((null===(_=null===(g=this._containerDOM)||void 0===g?void 0:g.childNodes)||void 0===_?void 0:_.length)>0){var b=this._containerDOM.childNodes[0];if(b instanceof HTMLElement&&b.classList.contains("maptalks-wrapper"))throw new Error("Container is already loaded with another map instance, use map.remove() to clear it.")}},_._trySetCursor=function(i){return this._cursor||this._priorityCursor||(i||(i="default"),this._setCursorToPanel(i)),this},_._setPriorityCursor=function(i){if(i)this._priorityCursor=i,this._setCursorToPanel(i);else{var g=!1;this._priorityCursor&&(g=!0),delete this._priorityCursor,g&&this.setCursor(this._cursor)}return this},_._setCursorToPanel=function(i){var g=this.getMainPanel();g&&g.style&&g.style.cursor!==i&&(g.style.cursor=i)},_._removeLayer=function(i,g){if(i&&g){var m=g.indexOf(i);m>-1&&g.splice(m,1)}},_._sortLayersByZIndex=function(){if(this._layers){for(var i=0,g=this._layers.length;i<g;i++){var m=this._layers[i];m._order=i,m.sortLayersByZIndex&&m.sortLayersByZIndex()}this._layers.sort((function(i,g){var m=i.getZIndex()-g.getZIndex();return 0===m?i._order-g._order:m}))}},_._fireEvent=function(i,g){if(!this._eventSilence){"_"!==i[0]&&this.fire("_"+i,g),this.fire(i,g)}},_._Load=function(){this._resetMapStatus(),this.options.pitch&&(this.setPitch(this.options.pitch),delete this.options.pitch),this.options.bearing&&(this.setBearing(this.options.bearing),delete this.options.bearing),delete this._glRes,this._loadAllLayers(),this._getRenderer().onLoad(),this._loaded=!0,this._callOnLoadHooks(),this._initTime=P()},_._initRenderer=function(){var i=this.options.renderer;Array.isArray(i)||(i=[i]);for(var m=0;m<i.length;m++){var _=g.getRendererClass(i[m]);if(_){this._renderer=new _(this),this._renderer.load();break}}if(!this._renderer)throw new Error("Invalid map.options.renderer: "+this.options.renderer)},_._getRenderer=function(){return this._renderer},_._loadAllLayers=function(){this._baseLayer&&this._baseLayer.load(),this._eachLayer((function(i){i&&i.load()}),this.getLayers())},_._getLayers=function(i){for(var g=this._baseLayer?[this._baseLayer].concat(this._layers):this._layers,m=[],_=0;_<g.length;_++)i&&!i.call(this,g[_])||m.push(g[_]);return m},_._eachLayer=function(i,...g){if(!(arguments.length<2)){g&&!Array.isArray(g)&&(g=[g]);for(var m=[],_=0,b=g.length;_<b;_++)m=m.concat(g[_]);for(var T=0,P=m.length;T<P;T++)i.call(i,m[T])}},_._onLayerEvent=function(i){i&&"idchange"===i.type&&(delete this._layerCache[i.old],this._layerCache[i.new]=i.target)},_._resetMapStatus=function(){var i=this.getMaxZoom(),g=this.getMinZoom(),m=this._spatialReference.getMaxZoom(),_=this._spatialReference.getMinZoom();(H(i)||-1===i||i>m)&&this.setMaxZoom(m),(H(g)||-1===g||g<_)&&this.setMinZoom(_),(i=this.getMaxZoom())<(g=this.getMinZoom())&&this.setMaxZoom(g),(H(this._zoomLevel)||this._zoomLevel>i)&&(this._zoomLevel=i),this._zoomLevel<g&&(this._zoomLevel=g),delete this._prjCenter,delete this._glRes;var b=this.getProjection();this._prjCenter=b.project(this._center),this._prjCenter.z=this._center.z,this._calcMatrices();var T=this._getRenderer();T&&T.resetContainer()},_.setContainerDomRect=function(i){this._containerDomContentRect=i},_._getContainerDomSize=function(){if(!this._containerDOM)return null;var i,g,m=this._containerDOM;if(this._containerDomContentRect)return new ir(i=this._containerDomContentRect.width,g=this._containerDomContentRect.height);var _=m;if(H(_.width)||H(_.height)){if(H(m.clientWidth)||H(m.clientHeight))throw new Error("can not get size of container");i=parseInt(m.clientWidth+"",0),g=parseInt(m.clientHeight+"",0)}else{i=_.width,g=_.height;var b=this.getDevicePixelRatio();1!==b&&m.layer&&(i/=b,g/=b)}return new ir(i,g)},_._updateMapSize=function(i){this.width=i.width,this.height=i.height;var g=this._getRenderer();return g&&g.updateMapSize(i),this._calcMatrices(),this},_._getPrjCenter=function(){return this._prjCenter},_._setPrjCenter=function(i){this._prjCenter=i,this.isInteracting()&&!this.isMoving()&&(this._mapViewCoord=i),this._calcMatrices()},_._setPrjCoordAtContainerPoint=function(i,g){if(!this.centerAltitude&&g.x===this.width/2&&g.y===this.height/2)return this;var m=this._containerPointToPoint(g)._sub(this._prjToPoint(this._getPrjCenter())),_=this._pointToPrj(this._prjToPoint(i)._sub(m));return this._setPrjCenter(_),this},_._setPrjCoordAtOffsetToCenter=function(i,g){var m=this._pointToPrj(this._prjToPoint(i)._sub(g));return this._setPrjCenter(m),this},_._verifyExtent=function(i){if(!i)return!1;var g=this._prjMaxExtent;return!g||g.contains(i)},_._limitMaxExtent=function(){var i=this;if(this._limitMaxExtenting||!this.options.limitExtentOnMaxExtent)return this;var g=this._prjMaxExtent,m=this.getMaxExtent();if(!g||!m)return this;var _=g.toArray().map((function(g){return i.prjToContainerPoint(g)})),b=Bo();Go(_,b);var{width:T,height:P}=this.getSize(),I=[0,0,T,P];if(Zo(I,b))return this;if(Zo(b,I))return this;var H=0,W=0,q=0,$=0,ye=0,Re=0,Be=Math.abs,[Ge,je,Xe,Ze]=b;if(Ge>0&&Xe>T&&(H=q=Be(Ge)),Ge<0&&Xe<T&&(H=q=-Be(Ge)),Ge<0&&Xe<T&&(H=$=-Be(T-Xe)),Ge>0&&Xe>T&&(H=$=Be(T-Xe)),je>0&&Ze>P&&(W=ye=Be(je)),je<0&&Ze<P&&(W=ye=-Be(je)),je<0&&Ze<P&&(W=Re=-Be(P-Ze)),je>0&&Ze>P&&(W=Re=Be(P-Ze)),0!==q&&0!==$&&(H=q,Be($)<Be(q)&&(H=$)),0!==ye&&0!==Re&&(W=ye,Be(Re)<Be(ye)&&(W=Re)),0!==H||0!==W){var Ye=new un(T/2+H,P/2+W),Qe=this.containerPointToCoord(Ye);this._limitMaxExtenting=!0,this.setCenter(Qe),this._limitMaxExtenting=!1}return this},_._offsetCenterByPixel=function(i){var g=Bu.set(this.width/2-i.x,this.height/2-i.y),m=this._containerPointToPrj(g,Hu),_=Bu.set(this.width/2,this.height/2);this._setPrjCoordAtContainerPoint(m,_)},_.offsetPlatform=function(i){return i?(this._getRenderer().offsetPlatform(i),this._mapViewCoord=this._getPrjCenter(),this._mapViewPoint=this._mapViewPoint.add(i),this._mapViewPoint):this._mapViewPoint},_.getViewPoint=function(){var i=this.getViewPointFrameOffset(),g=this.offsetPlatform();return i&&(g=g.add(i)),g},_._resetMapViewPoint=function(){this._mapViewPoint=new un(0,0),this._mapViewCoord=this._getPrjCenter()},_._getResolution=function(i){return void 0!==i&&i!==this._zoomLevel||void 0===this._mapRes?(H(i)&&(i=this._zoomLevel),this._spatialReference.getResolution(i)):this._mapRes},_._getResolutions=function(){return this._spatialReference.getResolutions()},_._prjToPoint=function(i,g,m){g=H(g)?this.getZoom():g;var _=this._getResolution(g);return this._prjToPointAtRes(i,_,m)},_._prjToPointAtRes=function(i,g,m){return this._spatialReference.getTransformation().transform(i,g,m)},_._prjsToPointsAtRes=function(i,g,m=[]){for(var _=this._spatialReference.getTransformation(),b=[],T=0,P=i.length;T<P;T++){var I=_.transform(i[T],g,m[T]);b.push(I)}return b},_._pointToPrj=function(i,g,m){g=H(g)?this.getZoom():g;var _=this._getResolution(g);return this._pointToPrjAtRes(i,_,m)},_._pointToPrjAtRes=function(i,g,m){return this._spatialReference.getTransformation().untransform(i,g,m)},_._pointToPoint=function(i,g,m){return H(g)?(m?(m.x=i.x,m.y=i.y):m=i.copy(),m):this._pointAtResToPoint(i,this._getResolution(g),m)},_._pointAtResToPoint=function(i,g,m){return m?(m.x=i.x,m.y=i.y):m=i.copy(),m._multi(g/this._getResolution())},_._pointToPointAtRes=function(i,g,m){return m?(m.x=i.x,m.y=i.y):m=i.copy(),m._multi(this._getResolution()/g)},_._containerPointToPrj=function(i,g){return this._pointToPrj(this._containerPointToPoint(i,void 0,g),void 0,g)},_._callOnLoadHooks=function(){var i=g.prototype;if(i._onLoadHooks)for(var m=0,_=i._onLoadHooks.length;m<_;m++)i._onLoadHooks[m].call(this)},_._fixPrjOnWorldWide=function(i){var g=this.getProjection();if(g&&g.fullExtent&&i){var{left:m,bottom:_,top:b,right:T}=g.fullExtent||{};W(m)&&(i.x=Math.max(m,i.x)),W(T)&&(i.x=Math.min(T,i.x)),W(_)&&(i.y=Math.max(_,i.y)),W(b)&&(i.y=Math.min(b,i.y))}return this},_.toJSON=function(i){i||(i={});var g={jsonVersion:this.JSON_VERSION,version:this.VERSION,extent:this.getExtent().toJSON()};g.options=this.config(),g.options.center=this.getCenter(),g.options.zoom=this.getZoom(),g.options.bearing=this.getBearing(),g.options.pitch=this.getPitch();var m=this.getBaseLayer();(H(i.baseLayer)||i.baseLayer)&&m&&(g.baseLayer=m.toJSON(i.baseLayer));var _={};i.clipExtent&&(_.clipExtent=!0===i.clipExtent?this.getExtent():i.clipExtent);var b=[];if(H(i.layers)||i.layers&&!Array.isArray(i.layers)){for(var T=this.getLayers(),P=0,W=T.length;P<W;P++)if(T[P].toJSON){var q=I({},$(i.layers)?i.layers:{},_);b.push(T[P].toJSON(q))}g.layers=b}else if(kn(i.layers)){for(var ye=i.layers,Re=0;Re<ye.length;Re++){var Be=ye[Re],Ge=this.getLayer(Be.id);if(Ge.toJSON){var je=I({},Be.options,_);b.push(Ge.toJSON(je))}}g.layers=b}else g.layers=[];return g},g.fromJSON=function(i,m,_){if(!i||!m)return null;_||(_={});var b=new g(i,m.options);if(H(_.baseLayer)||_.baseLayer){var T=Fu.fromJSON(m.baseLayer);T&&b.setBaseLayer(T)}if(H(_.layers)||_.layers){for(var P=[],I=m.layers,W=0;W<I.length;W++){var q=Fu.fromJSON(I[W]);P.push(q)}b.addLayer(P)}return b},g}(hl(Za(bh(Ya))));function Gu(i){return i&&i.queryTerrainAtPoint&&i.getTerrainLayer&&i.getTerrainLayer()}Uu.mergeOptions(Vu);var ju=function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g}($a),Wu=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.addHooks=function(){this.target&&this.target.on("_dblclick",this._onDoubleClick,this)},m.removeHooks=function(){this.target&&this.target.off("_dblclick",this._onDoubleClick,this)},m._onDoubleClick=function(i){var g=this.target;if(g.options.doubleClickZoom){var m=g.getZoom(),_=i.domEvent.shiftKey?Math.ceil(m)-1:Math.floor(m)+1;g._zoomAnimation(_,i.containerPoint)}},g}(ju);Uu.mergeOptions({doubleClickZoom:!0}),Uu.addOnLoadHook("addHandler","doubleClickZoom",Wu);var qu=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.addHooks=function(){var i=this.target;if(i){var g=i.getPanels().mapWrapper||i.getContainer();this._dragHandler=new dl(g,{cancelOn:this._cancelOn.bind(this),rightclick:!0}),this._dragHandler.on("mousedown",this._onMouseDown,this).on("dragstart",this._onDragStart,this).on("dragging",this._onDragging,this).on("dragend",this._onDragEnd,this).enable()}},m.removeHooks=function(){this._dragHandler.off("mousedown",this._onMouseDown,this).off("dragstart",this._onDragStart,this).off("dragging",this._onDragging,this).off("dragend",this._onDragEnd,this),this._dragHandler.remove(),delete this._dragHandler},m._cancelOn=function(i){return!(!this.target.isZooming()&&!this._ignore(i))},m._ignore=function(i){return!!i&&(i.domEvent&&(i=i.domEvent),this.target._ignoreEvent(i))},m._onMouseDown=function(i){delete this.startDragTime,delete this._mode;var g=this.target.options.switchDragButton;g&&"touchstart"===i.domEvent.type||i.domEvent.button===(g?0:2)||i.domEvent.ctrlKey?(this.target.options.dragRotate||this.target.options.dragPitch)&&(this._mode="rotatePitch"):this.target.options.dragPan&&(this._mode="move"),this.target._stopAnim(this.target._mapAnimPlayer),Nr(i.domEvent)},m._onDragStart=function(i){this.startDragTime=P(),"move"===this._mode?this._moveStart(i):"rotatePitch"===this._mode&&this._rotateStart(i)},m._onDragging=function(i){"move"===this._mode?this._moving(i):"rotatePitch"===this._mode&&this._rotating(i)},m._onDragEnd=function(i){"move"===this._mode?this._moveEnd(i):"rotatePitch"===this._mode&&this._rotateEnd(i),delete this.startDragTime,delete this.startBearing},m._start=function(i){this.preX=i.mousePos.x,this.preY=i.mousePos.y,this.startX=this.preX,this.startY=this.preY,this._startPrjCenter=this.target._getPrjCenter().copy()},m._moveStart=function(i){delete this.startContainerPoint,this._start(i);var g=this.target;g.onMoveStart(i);var m=Ur(g._getActualEvent(i.domEvent),g.getContainer());this.startPrjCoord=g.queryPrjCoordAtContainerPoint(m),g._isContainerPointOutOfMap(m)&&void 0===this.startPrjCoord.z&&(this.startContainerPoint=m)},m._moving=function(i){if(this.startDragTime){var g=this.target,m=Ur(g._getActualEvent(i.domEvent),g.getContainer());if(this.startContainerPoint){var _=m._sub(this.startContainerPoint);m.set(g.width/2+_.x,g.height/2+_.y)}var b=g._containerPointToPoint(m,void 0,void 0,this.startPrjCoord.z)._sub(g._prjToPoint(g._getPrjCenter()));g._setPrjCoordAtOffsetToCenter(this.startPrjCoord,b),g.onMoving(i)}},m._moveEnd=function(i){if(this.startDragTime){var g="touchend"===i.domEvent.type,m=this.target,_=P()-this.startDragTime,b=i.mousePos.x-this.startX,T=i.mousePos.y-this.startY,I=m._getPrjCenter(),H=I.sub(this._startPrjCenter);if(this._clear(),m.options.panAnimation&&!i.interupted&&m._verifyExtent(m._getPrjCenter())&&_<280&&Math.abs(T)+Math.abs(b)>5){_*=5;var W=I.add(H._multi(g?5:2.8));m._panTo(W,{duration:g?3*_:2*_,easing:m.options.dragPanEasing||"outExpo"})}else m.onMoveEnd(i)}},m._rotateStart=function(i){this._start(i),delete this._rotateMode,this.startBearing=this.target.getBearing(),this.target.onDragRotateStart(i),this._db=0},m._rotating=function(i){var g=this.target,m=i.mousePos.x,_=i.mousePos.y,b=g.getPitch(),T=g.getBearing(),P=Math.abs(m-this.preX),I=Math.abs(_-this.preY);if(this._rotateMode||(this._rotateMode=g.options.dragRotatePitch?"rotate_pitch":P>I?"rotate":P<I?"pitch":"rotate"),!("pitch"===this._rotateMode&&0===b&&I<10)){if(this._rotateMode.indexOf("rotate")>=0&&g.options.dragRotate){var H=.15,W=0;W=g.options.dragPitch||P>I?-.15*(this.preX-m):m>g.width/2?H*(this.preY-_):-.15*(this.preY-_);var q=g.getBearing()+W;this._db=this._db||0,this._db+=W,g._setBearing(q)}this._rotateMode.indexOf("pitch")>=0&&g.options.dragPitch&&g._setPitch(g.getPitch()+.15*(this.preY-_)),this.preX=m,this.preY=_,g.getBearing()===T&&g.getPitch()===b||g.onDragRotating(i)}},m._rotateEnd=function(i){var g=this.target,m=g.getBearing();this._clear();var _=P()-this.startDragTime;if(g.onDragRotateEnd(i),g.options.rotateAnimation&&Math.abs(m-this.startBearing)>20&&("rotate"===this._rotateMode||"rotate_pitch"===this._rotateMode)&&!i.interupted&&_<400){var b=g.getBearing();g._animateTo({bearing:b+this._db/1.5},{easing:"outQuint",duration:1600})}},m._clear=function(){delete this.startPrjCoord,delete this.preX,delete this.preY,delete this.startX,delete this.startY},g}(ju);Uu.mergeOptions({draggable:!0,dragPan:!0,dragRotatePitch:!0,dragRotate:!0,dragPitch:!0}),Uu.addOnLoadHook("addHandler","draggable",qu);var Xu="mousedown mouseup mousemove click dblclick contextmenu touchstart touchmove touchend mouseout",Zu={mousemove:["mousemove","mouseover","mouseout","mouseenter"],touchend:["touchend","click"]},$u=function(i){return i&&i.getLayer&&i.on&&i.fire},Yu=function(i,g,m){if(i._onEvent)return i._onEvent(g,m);var _=i.getLayer();return _&&_.fireGeoEvent?_.fireGeoEvent(i,g,m):null},Qu=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.addHooks=function(){var i=this.target,g=i.getPanels().allLayers||i.getContainer();Jr(g,Xu,this._identifyGeometryEvents,this)},m.removeHooks=function(){var i=this.target,g=i.getPanels().allLayers||i.getContainer();Kr(g,Xu,this._identifyGeometryEvents)},m._identifyGeometryEvents=function(i,g){var m=this.target;if(!m.isInteracting()&&!m._ignoreEvent(i)){var _=null,b=g||i.type;if(ei(b)&&!T.isTest&&m.options.mousemoveThrottleEnable&&ti(this,m.options.mousemoveThrottleTime))Hr(i);else{var I="mousedown"===b||"touchstart"===b&&i.touches&&1===i.touches.length;if(I)this._mouseDownTime=P();else if(("click"===b||"touchend"===b)&&this._mouseDownTime){var H=this._mouseDownTime;if(delete this._mouseDownTime,P()-H>300){if("click"===b)return}else"touchend"===b&&(_="click")}var W=i.touches&&i.touches.length>0?i.touches[0]:i.changedTouches&&i.changedTouches.length>0?i.changedTouches[0]:i;if(W){var q=Ur(W,m.getContainer());"touchstart"===b&&m.options.preventTouch&&Nr(i);for(var $=null,ye=this.target.getRenderer().getTopElements(),Re=I&&2!==i.button,Be=0;Be<ye.length;Be++)if(ye[Be].hitTest(q)){var Ge=ye[Be].options.cursor;if(Ge&&($=Ge),Re||ye[Be].events&&ye[Be].events.indexOf(b)>=0){var je={target:m,type:b,domEvent:i,containerPoint:q};if(Re)return m._setPriorityCursor($),void ye[Be].mousedown(je);ye[Be].onEvent(je)}}var Xe=m._getLayers((function(i){return!(!i.identify||!i.options.geometryEvents)}));if(Xe.length){var Ze={includeInternals:!0,filter:function(g){if(g instanceof gu){var m=g._getEventTypeToFire(i);return"mousemove"===b?(!$&&g.options.cursor&&($=g.options.cursor),!0):!(!g.listens(m)&&!g.listens(_))}return!!$u(g)},count:1,onlyVisible:m.options.onlyVisibleGeometryEvents,containerPoint:q,layers:Xe,eventTypes:Zu[b]||[b],domEvent:i},Ye=function(g){var T=this,P=!0,I=function(){return T._prevOverGeos&&T._prevOverGeos.geos||[]},H=function(g=[],m=[]){if(g&&g.length>0)for(var _=g.length-1;_>=0;_--){var b=g[_];$u(b)&&(-1===m.indexOf(b)&&(P=Yu(b,i,"mouseout")))}};if("mouseout"===b){var W=I();this._prevOverGeos={geos:[],geomap:{}},H(W,[])}else if("mousemove"===b){var q={};if(g.length>0)for(var ye=g.length-1;ye>=0;ye--){var Re=g[ye];if($u(Re)){var Be=(Xe=Re)._getInternalId?Xe._getInternalId():Xe.getId?Xe.getId():null;q[Be]=Re,Yu(Re,i),this._prevOverGeos&&this._prevOverGeos.geomap[Be]||Yu(Re,i,"mouseenter"),P=Yu(Re,i,"mouseover")}}m._setPriorityCursor($);var Ge=I();this._prevOverGeos={geos:g,geomap:q},H(Ge,g)}else{if(!g||!g.length)return;for(var je=g.length-1;je>=0;je--)if($u(g[je])){P=Yu(g[je],i),_&&Yu(g[je],i,_);break}}var Xe;!1===P&&Hr(i)}.bind(this);ei(b)?this._queryIdentifyTimeout=m.getRenderer().callInNextFrame((function(){m.isInteracting()||m.identifyAtPoint(Ze,Ye)})):m.identifyAtPoint(Ze,Ye)}}}}},g}(ju);Uu.mergeOptions({geometryEvents:!0,onlyVisibleGeometryEvents:!0}),Uu.addOnLoadHook("addHandler","geometryEvents",Qu);var Ju=4.000244140625,Ku=1/450,ef=function(i){function g(g){var m;return(m=i.call(this,g)||this)._thisScrollZoom=m._scrollZoom.bind(m),m._thisCheckIfEndZoom=m._checkIfEndZoom.bind(m),m._wheelZoomRate=Ku,m._defaultZoomRate=.01,m._delta=0,m}tn(g,i);var m=g.prototype;return m.addHooks=function(){Lr(this.target._containerDOM,"wheel",this._onWheelScroll,this)},m.removeHooks=function(){Dr(this.target._containerDOM,"wheel",this._onWheelScroll)},m._currentZoomCanScroll=function(i){if(W(i)){var g=this.target,m=g.getZoom(),_=g.getMinZoom(),b=g.getMaxZoom();if(m===_&&i>0)return!1;if(m===b&&i<0)return!1}return!0},m._onWheelScroll=function(i){var g=this.target;if(g.options.preventWheelScroll&&(Nr(i),Hr(i)),g._ignoreEvent(i)||!g.options.zoomable)return!1;var m=g.getContainer(),_=g._checkZoomOrigin(Ur(i,m));return g.options.seamlessZoom?(this._zooming||(this._trackPadSuspect=0,this._ensureTrackpad=!1),this._seamless(i,_)):this._interval(i,_)},m._seamless=function(i,g){var m=i.deltaMode===window.WheelEvent.DOM_DELTA_LINE?60*i.deltaY:i.deltaY;if(m%Ju!==0&&(this._ensureTrackpad||(Math.abs(m)<60?this._trackPadSuspect++:this._trackPadSuspect=0,this._trackPadSuspect>=2&&(this._ensureTrackpad=!0)),this._ensureTrackpad&&(m*=14)),i.shiftKey&&m&&(m/=4),this._lastWheelEvent=i,H(this._delta)&&(this._delta=0),this._delta-=m,this._currentZoomCanScroll(m)){if(!this._zooming&&this._delta){var _=this.target;this._zoomOrigin=g,_.onZoomStart(null,g)}this._start()}},m._start=function(){this._delta&&(this._zooming=!0,this._active||(this.target.getRenderer().callInNextFrame(this._thisScrollZoom),this._active=!0))},m._scrollZoom=function(){if(this._active=!1,this._delta){var i=Math.abs(this._delta)>Ju?this._wheelZoomRate:this._defaultZoomRate,g=2/(1+Math.exp(-Math.abs(this._delta*i)));this._delta<0&&0!==g&&(g=1/g);var m=this.target,_=m.getZoom(),b=m.getZoomForScale(g,_,!0);this._delta=0,m.onZooming(b,this._zoomOrigin),this._scrollTime=performance.now(),m.getRenderer().callInNextFrame(this._thisCheckIfEndZoom)}},m._checkIfEndZoom=function(){if(this._zooming){var i=this.target;performance.now()-this._scrollTime>210?(this._zooming=!1,i.onZoomEnd(i.getZoom(),this._zoomOrigin)):i.getRenderer().callInNextFrame(this._thisCheckIfEndZoom)}},m._interval=function(i,g){var m=this,_=this.target;if(this._zooming)return this._requesting++,!1;this._requesting=0;var b=(i.deltaY?-1*i.deltaY:i.wheelDelta?i.wheelDelta:i.detail)>0?1:-1;i.detail&&(b*=-1);var T=_.getZoom(),P=T+b;if((P=_._checkZoom(b>0?Math.ceil(P):Math.floor(P)))===T)return!1;this._zooming=!0,this._delta||(_.onZoomStart(null,g),this._origin=g,this._delta=b,this._startZoom=_.getZoom());return _._animateTo({zoom:P-1*this._delta/2,around:this._origin},{continueOnViewChanged:!0,easing:"linear",duration:90,wheelZoom:!0},(function(g){"finished"===g.state.playState?m._requesting<1||Math.abs(P-m._startZoom)>2||P===_.getMaxZoom()||P===_.getMinZoom()?(_._animateTo({zoom:P,around:m._origin},{continueOnViewChanged:!0,duration:100},(function(i){"running"!==i.state.playState&&(delete m._zooming,delete m._requesting)})),delete m._startZoom,delete m._origin,delete m._delta,m._requesting=0):H(m._requesting)||(delete m._zooming,m._onWheelScroll(i)):"running"!==g.state.playState&&(delete m._zooming,delete m._requesting)})),!1},g}(ju);Uu.mergeOptions({scrollWheelZoom:!0,seamlessZoom:!0}),Uu.addOnLoadHook("addHandler","scrollWheelZoom",ef);var tf=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.addHooks=function(){Lr(this.target.getContainer(),"touchstart",this._onTouchStart,this)},m.removeHooks=function(){Dr(this.target.getContainer(),"touchstart",this._onTouchStart)},m._onTouchStart=function(i){var g=this.target;if(i.touches&&!(i.touches.length<2)){var m=g.getContainer(),_=Ur(i.touches[0],m),b=Ur(i.touches[1],m);this.preY=_.y,this._startP1=_,this._startP2=b,this._startDist=_.distanceTo(b),this._startVector=_.sub(b),this._startZoom=g.getZoom(),this._startBearing=g.getBearing(),Kr(document,"touchmove",this._onTouchMove),Kr(document,"touchend",this._onTouchEnd),Lr(document,"touchmove",this._onTouchMove,this),Lr(document,"touchend",this._onTouchEnd,this),g.options.preventTouch&&Nr(i),g._fireEvent("touchactstart")}},m._onTouchMove=function(i){var g=this.target;if(i.touches&&!(i.touches.length<2)){var m=g.getContainer(),_=Ur(i.touches[0],m),b=Ur(i.touches[1],m),T=_.sub(this._startP1),P=b.sub(this._startP2),I=_.sub(b),H=_.distanceTo(b)/this._startDist,W=180*I.angleWith(this._startVector)/Math.PI,q=.4*((this.preY||_.y)-_.y);this.preY=_.y;var $={domEvent:i,mousePos:[_,b]};if(this.mode||(g.options.touchRotate&&Math.abs(W)>8?this.mode=g.options.touchZoomRotate?"rotate_zoom":"rotate":g.options.touchPitch&&T.y*P.y>0&&Math.abs(T.y)>10&&Math.abs(P.y)>10?this.mode="pitch":g.options.zoomable&&g.options.touchZoom&&Math.abs(1-H)>.15&&(this.mode=g.options.touchZoomRotate&&g.options.touchRotate?"rotate_zoom":"zoom"),this._startTouching($)),"zoom"===this.mode||"rotate_zoom"===this.mode){this._scale=H;var ye=g._getResolution(this._startZoom)/H,Re=g.getZoomFromRes(ye);g.onZooming(Re,this._Origin)}"rotate"===this.mode||"rotate_zoom"===this.mode?(g._setBearing(this._startBearing+W),g.onDragRotating($)):"pitch"===this.mode&&(g._setPitch(g.getPitch()+q),g.onDragRotating($)),g._fireEvent("touchactinging")}},m._startTouching=function(i){var g=this.target;if("zoom"===this.mode||"rotate_zoom"===this.mode){var m=g.getSize();this._Origin=new un(m.width/2,m.height/2),g.onZoomStart(null,this._Origin)}"rotate"!==this.mode&&"pitch"!==this.mode&&"rotate_zoom"!==this.mode||g.onDragRotateStart(i)},m._onTouchEnd=function(i){delete this.preY;var g=this.target;if(Kr(document,"touchmove",this._onTouchMove),Kr(document,"touchend",this._onTouchEnd),"zoom"===this.mode||"rotate_zoom"===this.mode){var m=this._scale,_=g._getResolution(this._startZoom)/m,b=g.getZoomFromRes(_);g.onZoomEnd(b,this._Origin)}"pitch"!==this.mode&&"rotate"!==this.mode&&"rotate_zoom"!==this.mode||g.onDragRotateEnd({domEvent:i}),delete this.mode,g._fireEvent("touchactend")},g}(ju);Uu.mergeOptions({touchGesture:!0,touchZoom:!0,touchPitch:!0,touchRotate:!0,touchZoomRotate:!1}),Uu.addOnLoadHook("addHandler","touchGesture",tf);var nf="__anim_player",rf={outExpo:function(i){return 1===i?1:1-Math.pow(2,-10*i)},outQuint:function(i){return 1-Math.pow(1-i,5)},in:function(i){return Math.pow(i,2)},out:function(i){return 1-rf.in(1-i)},inAndOut:function(i){return 3*i*i-2*i*i*i},linear:function(i){return i},upAndDown:function(i){return i<.5?rf.inAndOut(2*i):1-rf.inAndOut(2*(i-.5))}},of=Jt((function(i,g){this.state=i,this.styles=g}),[{key:"playState",get:function(){return this.state.playState}},{key:"symbol",get:function(){return this.styles.symbol}}]),sf=function(){function i(i,g,m,_){this._animation=i,this.options=g,this._onFrame=m,this.playState="idle",this.ready=!0,this.finished=!1,this.target=_}var g=i.prototype;return g._prepare=function(){var i=this.options,g=i.speed||i.duration;ye(g)&&((g=af.speed[g])||(g=+g)),g||(g=af.speed.normal),this.duration=g,this._framer=i.framer||af._requestAnimFrame.bind(af)},g.play=function(){if("idle"!==this.playState&&"paused"!==this.playState||this.target&&this.target[nf])return this;this.target&&(this.target[nf]=1),"idle"===this.playState&&(this.currentTime=0,this._prepare());var i=P();if(!this.startTime){var g=this.options;this.startTime=g.startTime?g.startTime:i}return this._playStartTime=Math.max(i,this.startTime),"paused"===this.playState&&(this._playStartTime-=this.currentTime),this.playState="running",this._run(),this},g.pause=function(){return"paused"===this.playState||(this.playState="paused",this._run()),this},g.cancel=function(){return"idle"===this.playState||(this.playState="idle",this.finished=!1,this._run()),this},g.finish=function(){return"finished"===this.playState||(this.playState="finished",this.finished=!0,this._run()),this},g.reverse=function(){},g._run=function(){var i=this,g=this._onFrame,m=P(),_=m-this._playStartTime;if(this.options.repeat&&_>=this.duration&&(this._playStartTime=m,_=0),"running"===this.playState){var b=this._animation(_,this.duration);this.playState=b.state.playState,"running"!==this.playState&&this.target&&delete this.target[nf],"idle"===this.playState?this.startTime>m&&setTimeout(this._run.bind(this),this.startTime-m):"running"===this.playState?(this.currentTime=_,g&&g(b),this._framer((function(){"running"===i.playState&&i._run()}))):"finished"===this.playState&&(this.finished=!0,g&&g(b))}else if(this.target&&delete this.target[nf],g){"finished"===this.playState?_=this.duration:"idle"===this.playState&&(_=0);var T=this._animation(_,this.duration);T.state.playState=this.playState,g(T)}},i}(),af={speed:{slow:2e3,normal:1e3,fast:500},_resolveStyles:function(i){if(!i)return null;function g(i){if(!Array.isArray(i))return af._resolveStyles(i);for(var g=[],m=[],_=[],b=0;b<i.length;b++){var T=af._resolveStyles(i[b]);T&&(g.push(T[0]),m.push(T[1]),_.push(T[2]))}return g.length?[g,m,_]:null}function m(i){var g,m=i;Array.isArray(i)||(m=W(i)?[0,i]:i instanceof un||i instanceof pl?[new(g=i.constructor)(0,0),i]:[i,i]);var _=m[0],b=m[1];return W(_)&&W(b)?_===b?null:[_,b-_,b]:Array.isArray(_)&&W(_[0])||_ instanceof pl||_ instanceof un?(Array.isArray(_)?(_=new pl(_),b=new pl(b)):(_=new(g=_.constructor)(_),b=new g(b)),_.equals(b)?null:[_,b.sub(_),b]):[_,b,b]}var _,b={},T={},P={};for(var I in i)if(i.hasOwnProperty(I)){var q=i[I];if(!q)continue;if(Array.isArray(q)&&(H(q[0])||H(q[1])))continue;var $=void 0;_=q,($=!Array.isArray(_)&&_.constructor===Object||Array.isArray(_)&&_[0].constructor===Object?g(q):m(q))&&(T[I]=$[0],b[I]=$[1],P[I]=$[2])}return[T,b,P]},framing:function(i,g){var m,_,b,T;g||(g={}),(m=Re(g.easing)?g.easing:g.easing?rf[g.easing]:rf.linear)&&Re(m)||(m=rf.linear),(i=af._resolveStyles(i))&&(b=i[0],_=i[1],T=i[2]);var P=function(i,g,m){if(!g||!m)return null;var _={};for(var b in m)if(m.hasOwnProperty(b)){if(g[b]===T[b]){_[b]=g[b];continue}var I=g[b],H=m[b];if(W(H))_[b]=I+i*H;else if(Array.isArray(H)){for(var q=[],$=0;$<H.length;$++)q.push(P(i,I[$],H[$]));_[b]=q}else{_[b]=H.constructor===Object?P(i,I,H):I instanceof un||I instanceof pl?I.add(H.multi(i)):H}}return _};return function(i,g){var I,H;if(i<0)I={playState:"idle",delta:0},H=b;else if(i<g){var W=m(i/g);I={playState:"running",delta:W},H=P(W,b,_)}else I={playState:"finished",delta:1},H=T;return I.startStyles=b,I.destStyles=T,I.progress=i,I.remainingMs=g-i,new of(I,H)}},_requestAnimFrame:function(i){this._frameQueue||(this._frameQueue=[]),this._frameQueue.push(i),this._a()},_a:function(){this._animationFrameId||(this._animationFrameId=ln(af._frameFn))},_run:function(){if(this._frameQueue.length){var i=this._frameQueue;this._frameQueue=[];for(var g=0,m=i.length;g<m;g++)i[g]();this._frameQueue.length?this._animationFrameId=ln(af._frameFn):delete this._animationFrameId}},animate:function(i,g,m,_){g||(g={});var b=af.framing(i,g);return new sf(b,g,m,_)},_frameFn:function(){}};af._frameFn=af._run.bind(af);var lf=af.animate,hf=Object.freeze({__proto__:null,Animation:af,Easing:rf,Frame:of,Player:sf,animate:lf}),cf={exports:{}};!function(i){!function(){function g(i,g,m){var _=g.x,b=g.y,T=m.x-_,P=m.y-b;if(0!==T||0!==P){var I=((i.x-_)*T+(i.y-b)*P)/(T*T+P*P);I>1?(_=m.x,b=m.y):I>0&&(_+=T*I,b+=P*I)}return(T=i.x-_)*T+(P=i.y-b)*P}function m(i,_,b,T,P){for(var I,H=T,W=_+1;W<b;W++){var q=g(i[W],i[_],i[b]);q>H&&(I=W,H=q)}H>T&&(I-_>1&&m(i,_,I,T,P),P.push(i[I]),b-I>1&&m(i,I,b,T,P))}function _(i,g){var _=i.length-1,b=[i[0]];return m(i,0,_,g,b),b.push(i[_]),b}function b(i,g,m){if(i.length<=2)return i;var b=void 0!==g?g*g:1;return i=m?i:function(i,g){for(var m,_,b,T,P,I=i[0],H=[I],W=1,q=i.length;W<q;W++)T=void 0,P=void 0,(T=(_=m=i[W]).x-(b=I).x)*T+(P=_.y-b.y)*P>g&&(H.push(m),I=m);return I!==m&&H.push(m),H}(i,b),i=_(i,b)}i.exports=b,i.exports.default=b}()}(cf);var uf=Io(cf.exports),ff="not find Geometry' Projection. please add Geometry to Layer and add Layer to Map",df=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.animateShow=function(i={},g){var m=this;this._showPlayer&&this._showPlayer.finish(),Re(i)&&(g=i={});var _=this.getCoordinates();if(0!==_.length){this._animIdx=0,this._animLenSoFar=0,this.show();var b=!!this.getShell?this.getShell().concat(this.getShell()[0]):_,T=this._getProjection();if(T){var P=T.projectCoords(b,this.options.antiMeridian);this._prjAniShowCenter=this._getPrjExtent().getCenter(),this._aniShowCenter=T.unproject(this._prjAniShowCenter);var I=i.duration||1e3,H=i.easing||"out";this.setCoordinates([]);var W=0;P.length&&(P[0]._distance=0);for(var q=1;q<P.length;q++){var $=P[q].distanceTo(P[q-1]);P[q]._distance=$,W+=$}this._tempCoord=new pl(0,0),this._tempPrjCoord=new un(0,0);var ye=this._showPlayer=af.animate({t:I},{duration:I,easing:H},(function(i){if(m.getMap()){var T=m._drawAnimShowFrame(i.styles.t,I,W,b,P);"finished"===i.state.playState&&(delete m._showPlayer,delete m._aniShowCenter,delete m._prjAniShowCenter,delete m._animIdx,delete m._animLenSoFar,delete m._animTailRatio,delete m._tempCoord,delete m._tempPrjCoord,m.setCoordinates(_)),g&&g(i,T)}else if("finished"!==ye.playState&&(ye.finish(),g)){var H=m.getCoordinates();g(i,H[H.length-1])}}),this);return setTimeout((function(){ye.play()}),1),ye}console.error(ff)}},m._drawAnimShowFrame=function(i,g,m,_,b){if(0===i)return _[0];var T,P,I=i/g*m,H=0;for(T=this._animIdx+1,P=b.length;T<P&&!(this._animLenSoFar+(H=b[T]._distance)>I);T++)this._animLenSoFar+=H;if(this._animIdx=T-1,this._animIdx>=P-1)return this.setCoordinates(_),_[_.length-1];var W=this._animIdx,q=b[W],$=b[W+1],ye=(I-this._animLenSoFar)/H;this._animTailRatio=ye;var Re=q.y+($.y-q.y)*ye;this._tempPrjCoord.x=q.x+($.x-q.x)*ye,this._tempPrjCoord.y=Re;var Be=this._tempPrjCoord,Ge=_[W],je=_[W+1],Xe=Ge.y+(je.y-Ge.y)*ye,Ze=(Ge.z||0)+((je.z||0)-(Ge.z||0))*ye;this._tempCoord.x=Ge.x+(je.x-Ge.x)*ye,this._tempCoord.y=Xe,this._tempCoord.z=Ze;var Ye=this._tempCoord,Qe=!!this.getShell;if(!Qe&&this.options.smoothness>0){for(var Je=[],Ke=[],et=0;et<=this._animIdx;et++)Je.push(_[et]),Ke.push(b[et]);Je.push(Ye,Ye),Ke.push(Be,Be),this.setCoordinates(Je),this._setPrjCoordinates(Ke)}else{var tt=_.slice(0,this._animIdx+1);tt.push(Ye);var at=b.slice(0,this._animIdx+1);at.push(Be),Qe?(this.setCoordinates([this._aniShowCenter].concat(tt)),this._setPrjCoordinates([this._prjAniShowCenter].concat(at))):(this.setCoordinates(tt),this._setPrjCoordinates(at))}return Ye},m._getCenterInExtent=function(i,g,m){var _=this.getExtent();if(!i.intersects(_))return null;var b=m(g,i);if(0===b.length)return null;var[T,P,I]=[0,0,0];b.forEach((function(i){Array.isArray(i)?i.forEach((function(i){i.point&&(i=i.point),T+=i.x,P+=i.y,I++})):(i.point&&(i=i.point),T+=i.x,P+=i.y,I++)}));var H=new pl(T,P)._multi(1/I);return H.count=I,H},m._getPath2DPoints=function(i,g,m){if(!kn(i))return[];var _=this.getMap(),b=!g&&this._shouldSimplify(),T=this.options.simplifyTolerance*_._getResolution(),P=Array.isArray(i[0]);if(delete this._simplified,b&&!P){var I=i.length;i=uf(i,T,!1),this._simplified=i.length<I}if(m||(m=_._getResolution()),Array.isArray(i)){var H=[],W="_glPt";if(!Array.isArray(i[0]))return H=Wn(i,W),_._prjsToPointsAtRes(i,m,H);for(var q=[],$=0,ye=i.length;$<ye;$++){var Re=i[$];H=Wn(Re,W);var Be=_._prjsToPointsAtRes(Re,m,H);q.push(Be)}return q}return _._prjToPointAtRes(i,m)},m._shouldSimplify=function(){var i=this.getLayer();return i&&i.options.enableSimplify&&!i.options.enableAltitude&&this.options.enableSimplify&&!this._showPlayer},m._setPrjCoordinates=function(i){this._prjCoords=i,this.onShapeChanged()},m._getPrjCoordinates=function(){return this._verifyProjection(),!this._prjCoords&&this._getProjection()&&(this._prjCoords=this._projectCoords(this._coordinates)),this._prjCoords},m._updateCache=function(){this._clearCache(),this._getProjection()&&this._prjCoords&&(this._coordinates=this._unprojectCoords(this._getPrjCoordinates()))},m._clearProjection=function(){this._prjCoords=null,i.prototype._clearProjection.call(this)},m._projectCoords=function(i){var g=this._getProjection();return g?g.projectCoords(i,this.options.antiMeridian):[]},m._unprojectCoords=function(i){var g=this._getProjection();return g?g.unprojectCoords(i):[]},m._computeCenter=function(){var i=this._coordinates;if(!kn(i))return null;for(var g=0,m=0,_=0,b=i.length,T=0;T<b;T++)i[T]&&W(i[T].x)&&W(i[T].y)&&(g+=i[T].x,m+=i[T].y,_++);return new pl(g/_,m/_)},m._computeExtent=function(i){var g=this._coordinates;if(!kn(g))return null;var m=[g];return this.hasHoles&&this.hasHoles()&&m.push.call(m,...this.getHoles()),this._coords2Extent(m,this._getProjection())},m._computePrjExtent=function(i){var g=[this._getPrjCoordinates()];return this.hasHoles&&this.hasHoles()&&g.push.call(g,...this._getPrjHoles()),this._coords2Extent(g)},m._get2DLength=function(){for(var i=this._getPath2DPoints(this._getPrjCoordinates(),!0),g=0,m=1,_=i.length;m<_;m++)g+=i[m].distanceTo(i[m-1]);return g},m._hitTestTolerance=function(){var g,m=this._getInternalSymbol(),_=0;if(Array.isArray(m)){g=0;for(var b=0;b<m.length;b++)W(m[b].lineWidth)&&m[b].lineWidth>g&&(g=m[b].lineWidth),W(m[b].lineStrokeWidth)&&(_=Math.max(_,m[b].lineStrokeWidth))}else g=m.lineWidth,_=m.lineStrokeWidth||0;return g+=2*_,i.prototype._hitTestTolerance.call(this)+(W(g)?g/2:1.5)},m._coords2Extent=function(i,g){if(!i||0===i.length||Array.isArray(i[0])&&0===i[0].length)return null;for(var m=new Pl(g),_=0,b=i.length;_<b;_++)for(var T=0,P=i[_].length;T<P;T++)m._combine(i[_][T]);return m},g}(gu);df.mergeOptions({smoothness:!1,enableClip:!0,enableSimplify:!0,simplifyTolerance:2,symbol:{lineColor:"#000",lineWidth:2,lineOpacity:1,polygonFill:"#fff",polygonOpacity:1,opacity:1}});var pf="Polygon",gf=function(i){function g(g,m){var _;return(_=i.call(this,m)||this).type="Polygon",g&&_.setCoordinates(g),_}tn(g,i);var m=g.prototype;return m.getOutline=function(){return this._getPainter()?new g(this.getExtent().toArray(),{symbol:{lineWidth:1,lineColor:"6b707b"}}):null},m.setCoordinates=function(i){if(!i)return this._coordinates=null,this._holes=null,this._projectRings(),this;var g=pl.toCoordinates(i),m=g.length;if(Array.isArray(g[0]))if(this._coordinates=this._trimRing(g[0]),m>1){for(var _=[],b=1;b<m;b++)g[b]&&_.push(this._trimRing(g[b]));this._holes=_}else this._holes=null;else this._coordinates=this._trimRing(g);return this._projectRings(),this},m.getCoordinates=function(){if(!this._coordinates)return[];for(var i=this.getHoles(),g=[this._copyAndCloseRing(this._coordinates)],m=0,_=i.length;m<_;m++)g.push(this._copyAndCloseRing(i[m]));return g},m.getCenterInExtent=function(i){return this._getCenterInExtent(i,this.getShell(),Kh)},m.getShell=function(){return this._coordinates||[]},m.getHoles=function(){return this._holes||[]},m.hasHoles=function(){return this.getHoles().length>0},m._projectRings=function(){this.getMap()?(this._prjCoords=this._projectCoords(this._coordinates),this._prjHoles=this._projectCoords(this._holes),this.onShapeChanged()):this.onShapeChanged()},m._setPrjCoordinates=function(i){this._prjCoords=i,this.onShapeChanged()},m._cleanRing=function(i){for(var g=i.length-1;g>=0;g--)i[g]||i.splice(g,1)},m._checkRing=function(i){if(this._cleanRing(i),!i||!kn(i))return!1;var g=i[i.length-1],m=!0;return i[0].x===g.x&&i[0].y===g.y||(m=!1),m},m._trimRing=function(i){var g=this._checkRing(i);return kn(i)&&g&&i.splice(i.length-1,1),i},m._copyAndCloseRing=function(i){i=i.slice(0);var g=this._checkRing(i);return kn(i)&&!g?(i.push(i[0].copy()),i):i},m._getPrjShell=function(){return this.getJSONType()===pf?this._getPrjCoordinates():(this._verifyProjection(),this._getProjection()&&!this._prjShell&&(this._prjShell=this._projectCoords(this._getShell?this._getShell():this.getShell())),this._prjShell)},m._getPrjHoles=function(){var i=this._getProjection();return this._verifyProjection(),i&&!this._prjHoles&&(this._prjHoles=this._projectCoords(this.getHoles())),this._prjHoles},m._computeGeodesicLength=function(i){var g=this.getCoordinates();if(!kn(g))return 0;for(var m=0,_=0,b=g.length;_<b;_++)m+=i.measureLength(g[_]);return m},m._computeGeodesicArea=function(i){var g=this.getCoordinates();if(!kn(g))return 0;for(var m=i.measureArea(g[0]),_=1,b=g.length;_<b;_++)m-=i.measureArea(g[_]);return m},m._updateCache=function(){i.prototype._updateCache.call(this),this._prjHoles&&(this._holes=this._unprojectCoords(this._getPrjHoles()))},m._clearCache=function(){return delete this._prjShell,i.prototype._clearCache.call(this)},m._clearProjection=function(){this._prjHoles&&(this._prjHoles=null),this._prjShell&&(this._prjShell=null),i.prototype._clearProjection.call(this)},g}(df);function mf(i){return function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.getCoordinates=function(){return this._coordinates},m.setCoordinates=function(i){var g=i instanceof pl?i:new pl(i);if(this._translateRotatePivot(g),this._coordinates=g,!this.getMap())return this._dirtyCoords=!0,this.onPositionChanged(),this;var m=this._getProjection();return this._setPrjCoordinates(m.project(this._coordinates)),this},m._getCenter2DPoint=function(i){var g=this.getMap();if(!g)return null;var m=this._getPrjCoordinates();return m?(i||(i=g._getResolution()),g._prjToPointAtRes(m,i)):null},m._getPrjCoordinates=function(){var i=this._getProjection();return this._verifyProjection(),!this._pcenter&&i&&this._coordinates&&(this._pcenter=i.project(this._coordinates)),this._pcenter},m._setPrjCoordinates=function(i){this._pcenter=i,this.onPositionChanged()},m._updateCache=function(){this._clearCache();var i=this._getProjection();this._pcenter&&i&&(this._coordinates=i.unproject(this._pcenter))},m._clearProjection=function(){this._pcenter=null,i.prototype._clearProjection.call(this)},m._computeCenter=function(){return this._coordinates?this._coordinates.copy():null},g}(i)}gf.registerJSONType(pf);var Af=new kl,yf=function(i){function g(g,m){var _;return(_=i.call(this,m)||this).isPoint=!0,_.type="Point",g&&_.setCoordinates(g),_}tn(g,i);var m=g.prototype;return m.getOutline=function(){var i=this.getCoordinates(),m=this.getContainerExtent(),_=this.getMap().coordToContainerPoint(i);return new g(i,{symbol:{markerType:"square",markerWidth:m.getWidth(),markerHeight:m.getHeight(),markerLineWidth:1,markerLineColor:"6b707b",markerFill:"rgba(0, 0, 0, 0)",markerDx:m.xmin-(_.x-m.getWidth()/2),markerDy:m.ymin-(_.y-m.getHeight()/2)}})},m.setSymbol=function(g){return delete this._fixedExtent,i.prototype.setSymbol.call(this,g)},m._getSizeSymbol=function(i){for(var g,m={},_=!1,b=!1,T=0;T<Zh.length;T++){var P=i[Zh[T]];H(P)||(!_&&Ii(P)&&(_=!0,b=!0),m[Zh[T]]=P)}for(var I=0;I<$h.length;I++){var W=i[$h[I]];H(W)||(!_&&Ii(W)&&(_=!0),m[$h[I]]=W)}return _?(g=Qi(m,this),b&&(g._dynamic=!0)):g=m,g},m._setExternSymbol=function(g){return this._symbol||delete this._fixedExtent,i.prototype._setExternSymbol.call(this,g)},m._isDynamicSize=function(){return this._sizeSymbol&&this._sizeSymbol._dynamic},m._getFixedExtent=function(){if(this._fixedExtent&&!this._isDynamicSize())return this._fixedExtent;this._fixedExtent=this._fixedExtent||new kl,this._fixedExtent.set(null,null,null,null);var i=this._sizeSymbol;if(!i)return this._fixedExtent;var g=this.getLayer()&&this.getLayer().getRenderer(),m=g&&g.resources,_=this.getTextDesc();if(Array.isArray(i)){Af.set(1/0,1/0,-1/0,-1/0);for(var b=0;b<i.length;b++)i[b]&&this._fixedExtent._combine(Uh(Af,i[b],m,_&&_[b]))}else this._fixedExtent=Uh(this._fixedExtent,i,m,_);return this._fixedExtent},m._isVectorMarker=function(){var i=this._getInternalSymbol();return!Array.isArray(i)&&Wh(i)},m._canEdit=function(){var i=this._getInternalSymbol();return!Array.isArray(i)&&(Wh(i)||qh(i)||jh(i))},m._containsPoint=function(g,m){var _=this.getContainerExtent();return m&&(_=_.expand(m)),!!_.contains(g)&&(!this.options.hitTestForEvent||i.prototype._containsPoint.call(this,g,m))},m._computeExtent=function(){return _f.call(this,"getCenter")},m._computePrjExtent=function(){return _f.call(this,"_getPrjCoordinates")},m._computeGeodesicLength=function(){return 0},m._computeGeodesicArea=function(){return 0},m._getSprite=function(i,g){return this._getPainter()?this._getPainter().getSprite(i,g):new Jc(this).getSprite(i,g)},g}(mf(gu));function _f(i){var g=this[i]();return g?new Pl(g,g,this._getProjection()):null}yf.mergeOptions({symbol:{markerType:"path",markerPath:[{path:"M8 23l0 0 0 0 0 0 0 0 0 0c-4,-5 -8,-10 -8,-14 0,-5 4,-9 8,-9l0 0 0 0c4,0 8,4 8,9 0,4 -4,9 -8,14z M3,9 a5,5 0,1,0,0,-0.9Z",fill:"#DE3333"}],markerPathWidth:16,markerPathHeight:23,markerWidth:24,markerHeight:34},hitTestForEvent:!1,collision:!0}),yf.registerJSONType("Marker");var vf=function(i){function g(g,m){var _;return(_=i.call(this,m)||this).type="LineString",g&&_.setCoordinates(g),_}tn(g,i);var m=g.prototype;return m.getOutline=function(){return gf.prototype.getOutline.call(this)},m.setCoordinates=function(i){return i?(this._coordinates=pl.toCoordinates(i),this.getMap()?this._setPrjCoordinates(this._projectCoords(this._coordinates)):this.onShapeChanged(),this):(this._coordinates=null,this._setPrjCoordinates(null),this)},m.getCoordinates=function(){return this._coordinates||[]},m.getCenterInExtent=function(i){return this._getCenterInExtent(i,this.getCoordinates(),Qh)},m._computeGeodesicLength=function(i){return i.measureLength(this.getCoordinates())},m._computeGeodesicArea=function(){return 0},g}(df);vf.mergeOptions({arrowStyle:null,arrowPlacement:"vertex-last"}),vf.registerJSONType("LineString");var xf=new kl,bf=function(i){function g(g,m){var _;return(_=i.call(this,m)||this).type="GeometryCollection",_._lastUndoEditIndex=0,_._lastRedoEditIndex=0,_.setGeometries(g),_}tn(g,i);var m=g.prototype;return m.getContainerExtent=function(i){var g=i||new kl;return this.forEach((function(i){g._combine(i.getContainerExtent(xf))})),g},m.setGeometries=function(i){for(var g=this._checkGeometries(i||[]),m=this._getSymbol(),_=this.config(),b=this.getProperties(),T=g.length-1;T>=0;T--)g[T]._initOptions(_),g[T]._setParent(this),g[T]._setEventParent(this),m&&g[T].setSymbol(m),b&&g[T].setProperties(b);return this._geometries=g,this.getLayer()&&(this._bindGeometriesToLayer(),this.onShapeChanged()),this},m.getGeometries=function(){return this._geometries||[]},m.forEach=function(i,g){for(var m=this.getGeometries(),_=0,b=m.length;_<b;_++)m[_]&&(g?i.call(g,m[_],_):i(m[_],_));return this},m.filter=function(i,m){if(!i)return new g;var _=[],b=Re(i),T=b?i:Fi(i);return this.forEach((function(i){var g=b?i:qi(i);(m?T.call(m,g):T(g))&&_.push(i)}),this),new g(_)},m.translate=function(i){if(!i)return this;if(this.isEmpty())return this;var g=arguments;return this.forEach((function(i){i&&i.translate&&i.translate.apply(i,g)})),this},m.isEmpty=function(){return!kn(this.getGeometries())},m.remove=function(){return this.forEach((function(i){i._unbind()})),gu.prototype.remove.apply(this,arguments)},m.show=function(){return this.options.visible=!0,this.forEach((function(i){i.show()})),this},m.hide=function(){return this.options.visible=!1,this.forEach((function(i){i.hide()})),this},m.onConfig=function(i){this.forEach((function(g){g.config(i)}))},m.getSymbol=function(){var g=i.prototype.getSymbol.call(this);if(!g){var m=[],_=!1;this.forEach((function(i){i.getSymbol()&&!_&&(_=!0),m.push(i.getSymbol())})),_&&(g={children:m})}return g},m.setSymbol=function(i){var g=this;if(i&&i.children)this._symbol=null,this.forEach((function(m,_){m._eventSymbolProperties=g._eventSymbolProperties,m.setSymbol(i.children[_])}));else{var m=this._prepareSymbol(i);this._symbol=m,this.forEach((function(i){i._eventSymbolProperties=g._eventSymbolProperties,i.setSymbol(m)}))}return this.onSymbolChanged(),this},m._setExternSymbol=function(i){return i=this._prepareSymbol(i),this._externSymbol=i,this.forEach((function(g){g._setExternSymbol(i)})),this.onSymbolChanged(),this},m._bindLayer=function(){i.prototype._bindLayer.apply(this,arguments),this._bindGeometriesToLayer()},m._bindGeometriesToLayer=function(){var i=this.getLayer();this.forEach((function(g){g._bindLayer(i)}))},m._checkGeometries=function(i){for(var g=[],m=0,_=(i=Array.isArray(i)?i:[i]).length;m<_;m++){var b=i[m];b&&(this._checkGeo(b)?Tf(b)?T.isTest||console.error(b," is GeometryCollection sub class,it Cannot be placed in GeometryCollection"):g.push(b):console.error("The geometry added to collection is invalid. Index: "+m))}return g},m._checkGeo=function(i){return i instanceof gu},m._updateCache=function(){this._clearCache(),this.isEmpty()||this.forEach((function(i){i&&i._updateCache&&i._updateCache()}))},m._removePainter=function(){this._painter&&this._painter.remove(),delete this._painter,this.forEach((function(i){i._removePainter()}))},m._computeCenter=function(i){if(!i||this.isEmpty())return null;for(var g=0,m=0,_=0,b=this.getGeometries(),T=0,P=b.length;T<P;T++)if(b[T]){var I=b[T]._computeCenter(i);I&&(g+=I.x,m+=I.y,_++)}return 0===_?null:new pl(g/_,m/_)},m._containsPoint=function(i,g){if(this.isEmpty())return!1;delete this._pickGeometryIndex;for(var m=this.getGeometries(),_=0,b=m.length;_<b;_++)if(m[_]._containsPoint(i,g))return this._pickGeometryIndex=_,!0;return!1},m._hitTestTolerance=function(){for(var i=this.getGeometries(),g=0,m=0,_=i.length;m<_;m++){var b=i[m]._hitTestTolerance();g=Math.max(g,b)}return g},m._computeExtent=function(i){return wf.call(this,i,"_computeExtent")},m._computePrjExtent=function(i){return wf.call(this,i,"_computePrjExtent")},m._computeGeodesicLength=function(i){if(!i||this.isEmpty())return 0;for(var g=this.getGeometries(),m=0,_=0,b=g.length;_<b;_++)g[_]&&(m+=g[_]._computeGeodesicLength(i));return m},m._computeGeodesicArea=function(i){if(!i||this.isEmpty())return 0;for(var g=this.getGeometries(),m=0,_=0,b=g.length;_<b;_++)g[_]&&(m+=g[_]._computeGeodesicArea(i));return m},m._exportGeoJSONGeometry=function(){var i=[];if(!this.isEmpty())for(var g=this.getGeometries(),m=0,_=g.length;m<_;m++)g[m]&&i.push(g[m]._exportGeoJSONGeometry());return{type:"GeometryCollection",geometries:i}},m._toJSON=function(i){i=I({},i);var g,m={type:"Feature",geometry:{type:"GeometryCollection",geometries:this.getGeometries().filter((function(i){return i&&i._toJSON})).map((function(i){var g=i._toJSON();return g.subType?g:i._exportGeoJSONGeometry()}))}},_=this.getId();return H(_)||(m.id=_),(H(i.properties)||i.properties)&&(g=this._exportProperties()),m.properties=g,i.feature=m,i},m._clearProjection=function(){if(!this.isEmpty())for(var i=this.getGeometries(),g=0,m=i.length;g<m;g++)i[g]&&i[g]._clearProjection()},m._getConnectPoints=function(){var i=this.getExtent();return[new pl(i.xmin,i.ymax),new pl(i.xmax,i.ymin),new pl(i.xmin,i.ymin),new pl(i.xmax,i.ymax)]},m._getExternalResources=function(){if(this.isEmpty())return[];for(var i,g,m=this.getGeometries(),_=[],b={},T=0,P=m.length;T<P;T++)if(m[T])for(var I=0,H=(i=no(m[T]._getInternalSymbol())).length;I<H;I++)b[g=i[I].join()]||(_.push(i[I]),b[g]=1);return _},m.startEdit=function(i){var g=this;if(this.isEmpty())return this;i||(i={}),i.symbol&&(this._originalSymbol=this.getSymbol(),this.setSymbol(i.symbol)),this._draggbleBeforeEdit=this.options.draggable,this.config("draggable",!1),this._recordVisible();for(var m=this.getGeometries(),_=0,b=m.length;_<b;_++)m[_].startEdit(i);this._editing=!0;var T=this.getLayer();return T&&"canvas"===T.options.renderer&&this.hide(),setTimeout((function(){g.fire("editstart")}),1),this},m.endEdit=function(){if(this.isEmpty())return this;this._recoveryVisible();for(var i=this.getGeometries(),g=0,m=i.length;g<m;g++)i[g].endEdit();return this._originalSymbol&&(this.setSymbol(this._originalSymbol),delete this._originalSymbol),this._editing=!1,this.show(),this.config("draggable",this._draggbleBeforeEdit),this.fire("editend"),this},m.isEditing=function(){return!!this._editing},m.undoEdit=function(){if(this.isEmpty())return this;this._recoveryVisible();for(var i=this.getGeometries(),g=this._lastUndoEditIndex;g<i.length;g++)if(!i[g].undoEditcheck()){i[g].undoEdit(),this._lastUndoEditIndex=g;break}return g===i.length&&(this._lastUndoEditIndex=0),this.fire("undoedit"),this},m.redoEdit=function(){if(this.isEmpty())return this;this._recoveryVisible();for(var i=this.getGeometries(),g=this._lastRedoEditIndex;g<i.length;g++)if(!i[g].redoEditcheck()){i[g].redoEdit(),this._lastRedoEditIndex=g;break}return g===i.length&&(this._lastRedoEditIndex=0),this.fire("redoedit"),this},m.undoEditcheck=function(){for(var i=this.getGeometries(),g=0;g<i.length;g++)if(!i[g].undoEditcheck())return!1;return!0},m.redoEditcheck=function(){for(var i=this.getGeometries(),g=0;g<i.length;g++)if(!i[g].redoEditcheck())return!1;return!0},g}(gu);function wf(i,g){if(this.isEmpty())return null;for(var m=new Pl,_=this.getGeometries(),b=0,T=_.length;b<T;b++)if(_[b]){var P=_[b][g](i);P&&m._combine(P)}return m}function Tf(i){return i instanceof bf}bf.registerJSONType("GeometryCollection");var Sf=function(i){function g(g,m,_,b){var T;return(T=i.call(this,null,b)||this).GeometryType=g,T.type=m,T._initData(_),T}tn(g,i);var m=g.prototype;return m.getCoordinates=function(){for(var i=[],g=this.getGeometries(),m=0,_=g.length;m<_;m++){var b=g[m];i.push(b.getShell&&"Polygon"!==b.getJSONType()?[b.getShell()]:b.getCoordinates())}return i},m.setCoordinates=function(i){for(var g=[],m=0,_=(i=i||[]).length;m<_;m++){var b=new this.GeometryType(i[m],this.config());g.push(b)}return this.setGeometries(g),this},m._initData=function(i){(i=i||[]).length&&(i[0]instanceof this.GeometryType?this.setGeometries(i):this.setCoordinates(i))},m._checkGeo=function(i){return i instanceof this.GeometryType},m._exportGeoJSONGeometry=function(){var i=this.getCoordinates(),g=pl.toNumberArrays(i);return{type:this.getType(),coordinates:g}},m._toJSON=function(i){return{feature:this.toGeoJSON(i)}},g}(bf),Mf=function(i){function g(g,m){return i.call(this,yf,"MultiPoint",g,m)||this}return tn(g,i),g.prototype.findClosest=function(i){if(!i)return null;var g=this.getCoordinates(),m=null,_=1/0;return g.forEach((function(g){var b=function(i,g){var m=g.x-i.x,_=g.y-i.y;return Math.sqrt(m*m+_*_)}(g,i);b<_&&(m=g,_=b)})),m},g}(Sf);Mf.registerJSONType("MultiPoint");var Cf=function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g.prototype.getCenterInExtent=function(i){var g=this.getGeometries(),[m,_,b]=[0,0,0];return g.forEach((function(g){var T=g.getCenterInExtent(i);T&&(m+=T.x*T.count,_+=T.y*T.count,b+=T.count)})),0===b?null:new pl(m,_)._multi(1/b)},g}(Sf),Pf=function(i){function g(g,m){return i.call(this,vf,"MultiLineString",g,m)||this}return tn(g,i),g}(Cf);Pf.registerJSONType("MultiLineString");var If=function(i){function g(g,m){return i.call(this,gf,"MultiPolygon",g,m)||this}return tn(g,i),g}(Cf);If.registerJSONType("MultiPolygon");var kf,Of={Marker:yf,LineString:vf,Polygon:gf,MultiPoint:Mf,MultiLineString:Pf,MultiPolygon:If},Ef="geojson-fetch-worker-page-async",Rf=function(i){function g(){return i.call(this,Ef)||this}tn(g,i);var m=g.prototype;return m._sendMsg=function(i,g,m){var _=this;this.send(i,[],(function(b,T){b?m(b):_._pageFeatures(i,T,g,m)}),i.workerId)},m._fetchGeoJSON=function(i,g,m=[],_){var b=I({},g);b.type="fetchdata",b.url=i,this._sendMsg(b,m,_)},m._pageFeatures=function(i,g,m,_){if(m.push(g),0!==g.length){var b=I({},i);b.type="pagefeatures",this._sendMsg(b,m,_)}else _(null,m)},g}(Mu);Os(Ef,(function(){return"\nfunction (exports) {\n    const resultMap = {};\n\n    function handleResult(msg, postResponse) {\n        const data = msg.data || {};\n        const { taskId } = data;\n        const features = resultMap[taskId];\n        if (!features) {\n            postResponse('not find geojson dataset the taskId:' + taskId);\n            return;\n        }\n        if (features.length === 0) {\n            delete resultMap[taskId];\n            postResponse(null, []);\n            return;\n        }\n        const pageSize = data.pageSize || 2000;\n        const pageFeatures = features.slice(0, pageSize);\n        resultMap[taskId] = features.slice(pageSize, Infinity);\n        postResponse(null, pageFeatures);\n    }\n    //worker init\n    exports.initialize = function () {\n        // console.log(\"geojson fetch init\");\n    };\n    //recive message\n    exports.onmessage = function (msg, postResponse) {\n        const { taskId, type, url } = msg.data || {};\n        if (!taskId) {\n            postResponse('not find task id for get geojson dataset,taskId=' + taskId);\n            return;\n        }\n        if (type === 'fetchdata') {\n            if (!url) {\n                postResponse('url is null,url=' + url);\n                return;\n            }\n            fetch(url).then(res => res.json()).then(geojson => {\n                let features;\n                if (Array.isArray(geojson)) {\n                    features = geojson;\n                } else if (geojson.features) {\n                    features = geojson.features;\n                } else {\n                    features = [geojson];\n                }\n                resultMap[taskId] = features;\n                handleResult(msg, postResponse);\n            }).catch(errror => {\n                postResponse(errror.message);\n            });\n        } else if (type === 'pagefeatures') {\n            handleResult(msg, postResponse);\n        } else {\n            postResponse('not support task type:' + type);\n        }\n    };\n}"}));var Lf={toGeometry:function(i,g,m){var _;if(ye(i)&&(i=An(i)),Array.isArray(i)){_=[];for(var b=0,T=i.length;b<T;b++){var P=Lf._convert(i[b],g);Array.isArray(P)?yn(_,P):_.push(P)}}else _=Lf._convert(i,g);return m&&Re(m)&&Array.isArray(_)?_.filter(m):_},toGeometryAsync:function(i,g,m,_){return ye(i)&&(i=An(i)),new Promise((function(b){var T=[];if(i&&(Array.isArray(i)||Array.isArray(i.features))){var P=W(m)?Math.round(m):2e3,I=i.features||i,H=Math.ceil(I.length/P),q=1;Gs({count:H,run:function(){var i=I.slice((q-1)*P,q*P),m=Lf.toGeometry(i,g,_);return q++,m}}).then((function(i){for(var g=0,m=i.length;g<m;g++){var _=i[g];_&&(Array.isArray(_)?yn(T,_):T.push(_))}b(T)}))}else{var $=Lf.toGeometry(i,g);b($)}}))},_convert:function(i,g){if(!i||H(i.type))return null;var m=i.type;if("Feature"===m){var _=Lf._convert(i.geometry);return _?(_.setId(i.id),_.setProperties(i.properties),g&&g(_),_):null}if("FeatureCollection"===m){var b=i.features;return b?Lf.toGeometry(b,g):null}if(["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon"].indexOf(m)>=0){var T=new Of["Point"===m?"Marker":m](i.coordinates);return g&&g(T),T}if("GeometryCollection"===m){var P=i.geometries;if(!kn(P)){var I=new bf;return g&&g(I),I}for(var W=[],q=P.length,$=0;$<q;$++)W.push(P[$].subType?gu.getJSONClass(P[$].subType).fromJSON(P[$]):Lf._convert(P[$]));var ye=new bf(W);return g&&g(ye),ye}return null},_isGeoJSON:function(i){if(!i)return!1;if(i=i||{},Array.isArray(i)&&i.length)return Lf.isGeoJSON(i[0]);var g=i.type;if(!g)return!1;if(-1===Kn.indexOf(g))return!1;var{features:m,geometries:_,geometry:b,coordinates:T}=i;if(T&&Array.isArray(T))return!0;if(Array.isArray(_))return!0;if(Array.isArray(m))return!0;if(b){var P=b.coordinates;if(P&&Array.isArray(P))return!0}return!1},fetch:function(i,g=2e3){return new Promise((function(m,_){if(i&&ye(i)){var b=I({pageSize:2e3},{pageSize:g});i=Zn(i),kf||(kf=new Rf);var T=kf.workers.length,P=Math.floor(Math.random()*T);P=Math.min(T-1,P),b.workerId=P,b.taskId=mn(),kf._fetchGeoJSON(i,b,[],(function(i,g){if(i)_(i);else{var b=[];g.forEach((function(i){for(var g=0,m=i.length;g<m;g++)b.push(i[g])})),m({type:"FeatureCollection",features:b})}}))}else _("url is error,It should be string")}))}},Df=function(i){function g(g,m,_){var b;return b=i.call(this,null,_)||this,g&&b.setCoordinates(g),b._radius=m,b}tn(g,i),g.fromJSON=function(i){var m=i.feature,_=new g(i.coordinates,i.radius,i.options);return _.setProperties(m.properties),_};var m=g.prototype;return m.getRadius=function(){return this._radius},m.setRadius=function(i){return this._radius=i,this.onShapeChanged(),this},m.getShell=function(){for(var i,g,m,_=this._getMeasurer(),b=this.getCoordinates(),T=this.options.numberOfShellPoints,P=this.getRadius(),I=[],H=0,W=T-1;H<W;H++){i=360*H/W*Math.PI/180,g=P*Math.cos(i),m=P*Math.sin(i);var q=_.locate(b,g,m);q.z=b.z,I.push(q)}return I.push(I[0]),I},m.getHoles=function(){return[]},m.animateShow=function(){return this.show()},m._containsPoint=function(g,m){var _=this.getMap();if(_.getPitch())return i.prototype._containsPoint.call(this,g,m);var b=_._pointToContainerPoint(this._getCenter2DPoint()),T=this.getSize(),P=this._hitTestTolerance()+(m||0),I=b.add(T.width/2,T.height/2);return nc(g,b,I,P)},m._computePrjExtent=function(i){var g=this._getMinMax(i);if(!g)return null;var m=this._getPrjCoordinates(),_=g.map((function(g){return i.project(g)})),b=_[1].x-m.x,T=_[3].y-m.y;return new Pl(m.add(_[0].x-m.x,_[2].y-m.y),m.add(b,T))},m._computeExtent=function(i){var g=this._getMinMax(i);return g?new Pl(g[0].x,g[2].y,g[1].x,g[3].y,this._getProjection()):null},m._getMinMax=function(i){if(!i||!this._coordinates||H(this._radius))return null;var g=this._radius;return[i.locate(this._coordinates,-g,0),i.locate(this._coordinates,g,0),i.locate(this._coordinates,0,g),i.locate(this._coordinates,0,-g)]},m._computeGeodesicLength=function(){return H(this._radius)?0:2*Math.PI*this._radius},m._computeGeodesicArea=function(){return H(this._radius)?0:Math.PI*Math.pow(this._radius,2)},m._exportGeoJSONGeometry=function(){return{type:"Polygon",coordinates:pl.toNumberArrays([this.getShell()])}},m._toJSON=function(i){var g=this.getCenter(),m=I({},i);m.geometry=!1;var _=this.toGeoJSON(m);return _.geometry={type:"Polygon"},{feature:_,subType:"Circle",coordinates:g.toArray(),radius:this.getRadius()}},g}(mf(gf));function Ff(i){return i*i*i*i}Df.mergeOptions({numberOfShellPoints:60}),Df.registerJSONType("Circle");var Nf=function(i){function g(g,m,_,b){var T;return T=i.call(this,null,b)||this,g&&T.setCoordinates(g),T.width=m,T.height=_,T}tn(g,i),g.fromJSON=function(i){var m=i.feature,_=new g(i.coordinates,i.width,i.height,i.options);return _.setProperties(m.properties),_};var m=g.prototype;return m.getWidth=function(){return this.width},m.setWidth=function(i){return this.width=i,this.onShapeChanged(),this},m.getHeight=function(){return this.height},m.setHeight=function(i){return this.height=i,this.onShapeChanged(),this},m.getShell=function(){return this.isRotated()?this.getRotatedShell():this._getShell()},m._getShell=function(){var i,g,m,_,b=this._getMeasurer(),T=this.getCoordinates(),P=this.options.numberOfShellPoints-1,I=this.getWidth(),H=this.getHeight(),W=[],q=Math.pow(I/2,2)*Math.pow(H/2,2),$=Math.pow(I/2,2),ye=Math.pow(H/2,2),Re=[];if(Math.max(I/H,H/I)>2){var{fs:Be,sum:Ge}=function(i){for(var g=[],m=[],_=0;_<i;_++)m.push(Ff(_/i));var b=m.map((function(i){return i})).reverse(),T=[];yn(T,m,b,m,b);for(var P=0,I=0,H=T.length;I<H;I+=4)g.push(T[I]),P+=T[I];return{fs:g,sum:P}}(P),je=360/Ge,Xe=0;H>I&&(Xe=90);for(var Ze=0,Ye=0,Qe=Be.length;Ye<Qe;Ye++)Re.push((Ze+=je*Be[Ye])+Xe)}else for(var Je=0;Je<P;Je++){Re.push(360*Je/P)}this.options.debug&&console.log(Re);for(var Ke=0;Ke<Re.length;Ke++){g=(i=Re[Ke])*Math.PI/180,m=Math.sqrt(q/($*Math.pow(Math.tan(g),2)+ye)),_=Math.sqrt(q/(ye*Math.pow(1/Math.tan(g),2)+$)),i>90&&i<270&&(m*=-1),i>180&&i<360&&(_*=-1);var et=b.locate(T,m,_);et.z=T.z,W.push(et)}return W.push(W[0].copy()),W},m._getPrjShell=function(){var g=i.prototype._getPrjShell.call(this);return this._rotatePrjCoordinates(g)},m.getHoles=function(){return[]},m.animateShow=function(){return this.show()},m._containsPoint=function(g,m){var _=this.getMap();if(_.isTransforming())return i.prototype._containsPoint.call(this,g,m);var b=_.getProjection(),T=this._hitTestTolerance()+(m||0),P=b.projectCoords([this._coordinates,_.locate(this._coordinates,this.getWidth()/2,this.getHeight()/2)],this.options.antiMeridian);return nc(g,_.prjToContainerPoint(P[0]),_.prjToContainerPoint(P[1]),T)},m._computePrjExtent=function(){return this.isRotated()?this._computeRotatedPrjExtent():Df.prototype._computePrjExtent.apply(this,arguments)},m._computeExtent=function(){return Df.prototype._computeExtent.apply(this,arguments)},m._getMinMax=function(i){if(!i||!this._coordinates||H(this.width)||H(this.height))return null;var g=this.getWidth(),m=this.getHeight();return[i.locate(this._coordinates,-g/2,0),i.locate(this._coordinates,g/2,0),i.locate(this._coordinates,0,-m/2),i.locate(this._coordinates,0,m/2)]},m._computeGeodesicLength=function(){return H(this.width)||H(this.height)?0:2*Math.PI*(this.width>this.height?this.width:this.height)/2-4*Math.abs(this.width-this.height)},m._computeGeodesicArea=function(){return H(this.width)||H(this.height)?0:Math.PI*this.width*this.height/4},m._exportGeoJSONGeometry=function(){return{type:"Polygon",coordinates:pl.toNumberArrays([this.getShell()])}},m._toJSON=function(i){var g=I({},i),m=this.getCenter();g.geometry=!1;var _=this.toGeoJSON(g);return _.geometry={type:"Polygon"},{feature:_,subType:"Ellipse",coordinates:m.toArray(),width:this.getWidth(),height:this.getHeight()}},g}(mf(gf));Nf.mergeOptions({numberOfShellPoints:81}),Nf.registerJSONType("Ellipse");var Hf=function(i){function g(g,m,_,b){var T;return T=i.call(this,null,b)||this,g&&T.setCoordinates(g),T._width=m,T._height=_,T}tn(g,i),g.fromJSON=function(i){var m=i.feature,_=new g(i.coordinates,i.width,i.height,i.options);return _.setProperties(m.properties),_};var m=g.prototype;return m.getCoordinates=function(){return this._coordinates},m.setCoordinates=function(i){var g=i instanceof pl?i:new pl(i);if(this._translateRotatePivot(g),this._coordinates=g,!this._coordinates||!this.getMap())return this.onPositionChanged(),this;var m=this._getProjection();return this._setPrjCoordinates(m.project(this._coordinates)),this},m.getWidth=function(){return this._width},m.setWidth=function(i){return this._width=i,this.onShapeChanged(),this},m.getHeight=function(){return this._height},m.setHeight=function(i){return this._height=i,this.onShapeChanged(),this},m.getShell=function(){return this.isRotated()?this.getRotatedShell():this._getShell()},m._getShell=function(){var i=this._getMeasurer(),g=this._coordinates,m=this.getMap(),_=1,b=-1;if(m){var T=m.getFullExtent();T.left>T.right&&(_=-1),T.bottom>T.top&&(b=1)}var P=[];P.push(g);var I=i.locate(g,_*this._width,0);I.z=g.z,P.push(I);var H=i.locate(g,_*this._width,b*this._height);H.z=g.z,P.push(H);var W=i.locate(g,0,b*this._height);return P.push(W),W.z=g.z,P.push(g),P},m.getHoles=function(){return[]},m.animateShow=function(){return this.show()},m._getPrjCoordinates=function(){var i=this._getProjection();return this._verifyProjection(),!this._pnw&&i&&this._coordinates&&(this._pnw=i.project(this._coordinates)),this._pnw},m._setPrjCoordinates=function(i){this._pnw=i,this.onPositionChanged()},m._getPrjShell=function(){var g=i.prototype._getPrjShell.call(this),m=this._getProjection();if(!m.isSphere())return this._rotatePrjCoordinates(g);for(var _=m.getSphereExtent(),b=_.sx,T=_.sy,P=this._getProjection().getCircum(),I=g[0],H=1,W=g.length;H<W;H++){var q=g[H],$=0,ye=0;b*(I.x-q.x)>0&&($=P.x*b),T*(I.y-q.y)<0&&(ye=P.y*T),g[H]._add($,ye)}return this._rotatePrjCoordinates(g)},m._updateCache=function(){this._clearCache();var i=this._getProjection();this._pnw&&i&&(this._coordinates=i.unproject(this._pnw))},m._clearProjection=function(){this._pnw=null,i.prototype._clearProjection.call(this)},m._computeCenter=function(i){return i.locate(this._coordinates,this._width/2,-this._height/2)},m._containsPoint=function(g,m){var _=this.getMap();if(_.isTransforming())return i.prototype._containsPoint.call(this,g,m);var b=H(m)?this._hitTestTolerance():m,T=_._getResolution()*b,P=this._getPrjExtent().expand(T),I=_._containerPointToPrj(g);return P.contains(I)},m._computePrjExtent=function(i){if(this.isRotated())return this._computeRotatedPrjExtent();var g=this._getSouthEast(i);if(!g)return null;var m=i.projectCoords([new pl(this._coordinates.x,g.y),new pl(g.x,this._coordinates.y)],this.options.antiMeridian);return new Pl(m[0],m[1])},m._computeExtent=function(i){var g=this._getSouthEast(i);return g?new Pl(this._coordinates,g,this._getProjection()):null},m._getSouthEast=function(i){if(!i||!this._coordinates||H(this._width)||H(this._height))return null;var g=this.getWidth(),m=-this.getHeight();if(i.fullExtent){var _=i.fullExtent;g*=_.right>_.left?1:-1,m*=_.top>_.bottom?1:-1}var b=i.locate(this._coordinates,g,0),T=i.locate(this._coordinates,0,m);return b.y=T.y,b},m._computeGeodesicLength=function(){return H(this._width)||H(this._height)?0:2*(this._width+this._height)},m._computeGeodesicArea=function(){return H(this._width)||H(this._height)?0:this._width*this._height},m._exportGeoJSONGeometry=function(){return{type:"Polygon",coordinates:pl.toNumberArrays([this.getShell()])}},m._toJSON=function(i){var g=I({},i),m=this.getCoordinates();g.geometry=!1;var _=this.toGeoJSON(g);return _.geometry={type:"Polygon"},{feature:_,subType:"Rectangle",coordinates:m.toArray(),width:this.getWidth(),height:this.getHeight()}},g}(gf);Hf.registerJSONType("Rectangle");var Bf=function(i){function g(g,m,_,b,T){var P;return(P=i.call(this,g,m,T)||this).startAngle=_,P.endAngle=b,P}tn(g,i),g.fromJSON=function(i){var m=i.feature,_=new g(i.coordinates,i.radius,i.startAngle,i.endAngle,i.options);return _.setProperties(m.properties),_};var m=g.prototype;return m.getStartAngle=function(){return this.startAngle},m.setStartAngle=function(i){return this.startAngle=i,this.onShapeChanged(),this},m.getEndAngle=function(){return this.endAngle},m.setEndAngle=function(i){return this.endAngle=i,this.onShapeChanged(),this},m._correctAngles=function(){var i=this.getStartAngle(),g=this.getEndAngle();if(g<i)return console.error("The ending angle should be greater than the starting angle ",i,g),[0,0];return g-i>360?(console.error("The difference between the end angle and the start angle is greater than 360 degrees ",i,g),[0,0]):(i<0&&(i+=360,g+=360),[i,g])},m.getShell=function(){return this.isRotated()?this.getRotatedShell():this._getShell()},m._getShell=function(){for(var i,g,m,[_,b]=this._correctAngles(),T=this._getMeasurer(),P=this.getCoordinates(),I=this.options.numberOfShellPoints-2,H=this.getRadius(),W=[P.copy()],q=b-_,$=0;$<I;$++){i=(q*$/(I-1)+_)*Math.PI/180,g=H*Math.cos(i),m=H*Math.sin(i);var ye=T.locate(P,g,m);ye.z=P.z,W.push(ye)}return W.push(P.copy()),W},m.getRotateOffsetAngle=function(){return 90},m._getPrjShell=function(){var g=i.prototype._getPrjShell.call(this);return this._rotatePrjCoordinates(g)},m._computePrjExtent=function(){return this.isRotated()?this._computeRotatedPrjExtent():Df.prototype._computePrjExtent.apply(this,arguments)},m._containsPoint=function(i,g){return gu.prototype._containsPoint.call(this,i,g)},m._computeGeodesicLength=function(){if(H(this._radius))return 0;var[i,g]=this._correctAngles();return 2*Math.PI*this._radius*Math.abs(i-g)/360+2*this._radius},m._computeGeodesicArea=function(){if(H(this._radius))return 0;var[i,g]=this._correctAngles();return Math.PI*Math.pow(this._radius,2)*Math.abs(i-g)/360},m._toJSON=function(i){var g=I({},i),m=this.getCenter();g.geometry=!1;var _=this.toGeoJSON(g);return _.geometry={type:"Polygon"},{feature:_,subType:"Sector",coordinates:m.toArray(),radius:this.getRadius(),startAngle:this.getStartAngle(),endAngle:this.getEndAngle()}},g}(Df);Bf.mergeOptions({numberOfShellPoints:60}),Bf.registerJSONType("Sector");var zf=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m._arc=function(i,g,m){var _=this.options.arcDegree;0===_&&(_=1);for(var b=_*Math.PI/180,T=1,P=g.length;T<P;T++)Va._arcBetween(i,g[T-1],g[T],b),Va._stroke(i,m)},m._quadraticCurve=function(i,g){if(g.length<=2)Va._path(i,g);else{var m,_;for(m=2,_=g.length;m<_;m+=2)i.quadraticCurveTo(g[m-1].x,g[m-1].y,g[m].x,g[m].y);if((m-=1)<_)for(;m<_;m++)i.lineTo(g[m].x,g[m].y)}},m._bezierCurve=function(i,g){if(g.length<=3)Va._path(i,g);else{var m,_;for(m=1,_=g.length;m+2<_;m+=3)i.bezierCurveTo(g[m].x,g[m].y,g[m+1].x,g[m+1].y,g[m+2].x,g[m+2].y);if(m<_)for(;m<_;m++)i.lineTo(g[m].x,g[m].y)}},m._getCurveArrowPoints=function(i,g,m,_,b,T){var P,I=g.length;for(P=T;P<I;P+=T){var H=this._getArrowShape(g[P-1],g[P],m,_,b);H&&i.push(H)}if((P-=T)<I-1)for(P+=1;P<I;P++){var W=this._getArrowShape(g[P-1],g[P],m,_,b);W&&i.push(W)}},g}(vf);zf.mergeOptions({enableSimplify:!1,enableClip:!1});var Vf=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m._toJSON=function(i){return{feature:this.toGeoJSON(i),subType:"ArcCurve"}},m._paintOn=function(i,g,m){i.beginPath(),this._arc(i,g,m),Va._stroke(i,m),this._paintArrow(i,g,m)},g.fromJSON=function(i){var m=i.feature,_=new g(m.geometry.coordinates,i.options);return _.setProperties(m.properties),_},g}(zf);Vf.registerJSONType("ArcCurve"),Vf.mergeOptions({arcDegree:90});var Uf=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i),g.fromJSON=function(i){var m=i.feature,_=new g(m.geometry.coordinates,i.options);return _.setProperties(m.properties),_};var m=g.prototype;return m._toJSON=function(i){return{feature:this.toGeoJSON(i),subType:"CubicBezierCurve"}},m._paintOn=function(i,g,m){i.beginPath(),i.moveTo(g[0].x,g[0].y),this._bezierCurve(i,g),Va._stroke(i,m),this._paintArrow(i,g,m)},m._getArrowPoints=function(i,g,m,_,b){return this._getCurveArrowPoints(i,g,m,_,b,3)},g}(zf);Uf.registerJSONType("CubicBezierCurve");var Gf=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i),g.fromJSON=function(i){var m=i.feature,_=new g(m.geometry.coordinates,i.options);return _.setProperties(m.properties),_};var m=g.prototype;return m._toJSON=function(i){return{feature:this.toGeoJSON(i),subType:"QuadBezierCurve"}},m._paintOn=function(i,g,m){i.beginPath(),i.moveTo(g[0].x,g[0].y),this._quadraticCurve(i,g,m),Va._stroke(i,m),this._paintArrow(i,g,m)},m._getArrowPoints=function(i,g,m,_,b){return this._getCurveArrowPoints(i,g,m,_,b,2)},g}(zf);Gf.registerJSONType("QuadBezierCurve");var jf={textFaceName:"monospace",textSize:12,textLineSpacing:8,textWrapCharacter:"\n",textHorizontalAlignment:"middle",textVerticalAlignment:"middle"},Wf={markerType:"square",markerLineColor:"#000",markerLineWidth:2,markerLineOpacity:1,markerFill:"#fff",markerOpacity:1},qf=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.getContent=function(){return this._content},m.setContent=function(i){var g=this._content;return this._content=cr(i),this._refresh(),this._fireEvent("contentchange",{old:g,new:i}),this},m.onAdd=function(){this._refresh()},m.toJSON=function(){var g=i.prototype.toJSON.call(this);return delete g.symbol,g},m.setSymbol=function(g){if(this._refreshing||!g)return i.prototype.setSymbol.call(this,g);var m=this._parseSymbol(g);if(this.setTextStyle){var _=this.getTextStyle()||{};_.symbol=m[0],this.setTextStyle(_)}else this.setTextSymbol&&this.setTextSymbol(m[0]);if(this.setBoxStyle){var b=this.getBoxStyle()||{};b.symbol=m[1],this.setBoxStyle(b)}else this.setBoxSymbol&&this.setBoxSymbol(m[1]);return this},m._parseSymbol=function(i){var g={},m={};for(var _ in i)Ge(i,_)&&(0===_.indexOf("text")?g[_]=i[_]:m[_]=i[_]);return[g,m]},m._getTextSize=function(i){return wr(this._content,i).size},m._getInternalSymbol=function(){return this._symbol},m._getDefaultTextSymbol=function(){return I({},jf)},m._getDefaultBoxSymbol=function(){return I({},Wf)},m._getDefaultPadding=function(){return[12,8]},g}(yf),Xf=function(i){function g(g,m,_,b,T={}){var P;return(P=i.call(this,m,T)||this)._content=cr(g),P._width=H(_)?100:_,P._height=H(b)?40:b,T.boxSymbol&&P.setBoxSymbol(T.boxSymbol),T.textStyle&&P.setTextStyle(T.textStyle),P._refresh(),P}tn(g,i);var m=g.prototype;return m.getWidth=function(){return this._width},m.setWidth=function(i){return this._width=i,this._refresh(),this},m.getHeight=function(){return this._height},m.setHeight=function(i){return this._height=i,this._refresh(),this},m.getBoxSymbol=function(){return I({},this.options.boxSymbol)},m.setBoxSymbol=function(i){return this.options.boxSymbol=i?I({},i):i,this.getSymbol()&&this._refresh(),this},m.getTextStyle=function(){return this.options.textStyle?I({},this.options.textStyle):null},m.setTextStyle=function(i){return this.options.textStyle=i?I({},i):i,this.getSymbol()&&this._refresh(),this},g.fromJSON=function(i){var m=i.feature,_=new g(i.content,m.geometry.coordinates,i.width,i.height,i.options);return _.setProperties(m.properties),_.setId(m.id),i.symbol&&_.setSymbol(i.symbol),_},m._toJSON=function(i){return{feature:this.toGeoJSON(i),width:this.getWidth(),height:this.getHeight(),subType:"TextBox",content:this._content}},m._refresh=function(){var i,g,m=this.getTextStyle()||{},_=m.padding||[12,8];if(Ii(this._width)){var b=(i=JSON.parse(JSON.stringify(this._width))).stops;if(b)for(var T=0;T<b.length;T++)b[T][1]=b[T][1]-2*_[0]}else i=this._width-2*_[0];if(Ii(this._height)){var P=(g=JSON.parse(JSON.stringify(this._height))).stops;if(P)for(var H=0;H<P.length;H++)P[H][1]=P[H][1]-2*_[1]}else g=this._height-2*_[1];var W=I({},m.symbol||this._getDefaultTextSymbol(),this.options.boxSymbol||this._getDefaultBoxSymbol(),{textName:this._content,markerWidth:this._width,markerHeight:this._height,textHorizontalAlignment:"middle",textVerticalAlignment:"middle",textMaxWidth:i,textMaxHeight:g});m.wrap&&!W.textWrapWidth&&(W.textWrapWidth=i);var q,$=m.horizontalAlignment;if(W.textDx=W.markerDx||0,Ii(this._width)){var ye=(q=JSON.parse(JSON.stringify(this._width))).stops;if(ye)for(var Re=0;Re<ye.length;Re++)ye[Re][1]=ye[Re][1]/2-_[0],"left"===$&&(ye[Re][1]*=-1)}else q=W.markerWidth/2-_[0],"left"===$&&(q*=-1);"left"===$?(W.textHorizontalAlignment="right",W.textDx=q):"right"===$&&(W.textHorizontalAlignment="left",W.textDx=q);var Be,Ge=m.verticalAlignment;if(W.textDy=W.markerDy||0,Ii(this._height)){var je=(Be=JSON.parse(JSON.stringify(this._height))).stops;if(je)for(var Xe=0;Xe<je.length;Xe++)je[Xe][1]=je[Xe][1]/2-_[1],"top"===Ge&&(je[Xe][1]*=-1)}else Be=W.markerHeight/2-_[1],"top"===Ge&&(Be*=-1);"top"===Ge?(W.textVerticalAlignment="bottom",W.textDy=Be):"bottom"===Ge&&(W.textVerticalAlignment="top",W.textDy=Be),this._refreshing=!0,this.updateSymbol(W),delete this._refreshing},m.startEdit=function(g){var m=this._getCompiledSymbol();if(Ii(this._width)){var _=m.markerWidth;this._oldWidth=this._width,this.setWidth(_)}if(Ii(this._height)){var b=m.markerHeight;this._oldHeight=this._height,this.setHeight(b)}return i.prototype.startEdit.call(this,g)},m.endEdit=function(){var g=this.getMap(),m=g&&g.getZoom();if(this._oldWidth){for(var _=this._width/Oi(this._oldWidth)(m),b=this._oldWidth.stops,T=0;T<b.length;T++)b[T][1]*=_;this.setWidth(this._oldWidth),delete this._oldWidth}if(this._oldHeight){for(var P=this._height/Oi(this._oldHeight)(m),I=this._oldHeight.stops,H=0;H<I.length;H++)I[H][1]*=P;this.setHeight(this._oldHeight),delete this._oldHeight}return i.prototype.endEdit.call(this)},g}(qf);Xf.mergeOptions({textStyle:{wrap:!0,padding:[12,8],verticalAlignment:"middle",horizontalAlignment:"middle"},boxSymbol:null}),Xf.registerJSONType("TextBox");var Zf=function(i){function g(g,m,_={}){var b;return(b=i.call(this,m,_)||this)._content=cr(g),_.textSymbol&&b.setTextSymbol(_.textSymbol),_.boxStyle&&b.setBoxStyle(_.boxStyle),b._refresh(),b}tn(g,i);var m=g.prototype;return m.getBoxStyle=function(){return this.options.boxStyle?I({},this.options.boxStyle):null},m.setBoxStyle=function(i){return this.options.boxStyle=i?I({},i):i,this._refresh(),this},m.getTextSymbol=function(){return I({},this._getDefaultTextSymbol(),this.options.textSymbol)},m.setTextSymbol=function(i){return this.options.textSymbol=i?I({},i):i,this._refresh(),this},g.fromJSON=function(i){var m=i.feature,_=new g(i.content,m.geometry.coordinates,i.options);return _.setProperties(m.properties),_.setId(m.id),i.symbol&&_.setSymbol(i.symbol),_},m._canEdit=function(){return!1},m._toJSON=function(i){return{feature:this.toGeoJSON(i),subType:"Label",content:this._content}},m._refresh=function(){var i=I({},this.getTextSymbol(),{textName:this._content}),g=this.getBoxStyle();if(g){I(i,g.symbol);var m=this._getBoxSize(i),_=m[1],b=g.padding||this._getDefaultPadding(),T=m[0];i.markerWidth=T.width,i.markerHeight=T.height;var P=i.textDx||0,H=i.textDy||0,W=_r(_,i.textHorizontalAlignment,i.textVerticalAlignment)._add(P,H),q=g.horizontalAlignment||"middle";i.markerDx=W.x,"left"===q?i.markerDx+=i.markerWidth/2-b[0]:"right"===q?i.markerDx-=i.markerWidth/2-_.width-b[0]:i.markerDx+=_.width/2;var $=g.verticalAlignment||"middle";i.markerDy=W.y,"top"===$?i.markerDy+=i.markerHeight/2-b[1]:"bottom"===$?i.markerDy-=i.markerHeight/2-_.height-b[1]:i.markerDy+=_.height/2}this._refreshing=!0,this.updateSymbol(i),delete this._refreshing},m._getBoxSize=function(i){i.markerType||(i.markerType="square");var g,m,_=this.getBoxStyle(),b=this._getTextSize(i),T=_.padding||this._getDefaultPadding();return g=b.width+2*T[0],m=b.height+2*T[1],_.minWidth&&(!g||g<_.minWidth)&&(g=_.minWidth),_.minHeight&&(!m||m<_.minHeight)&&(m=_.minHeight),[new ir(g,m),b]},g}(qf);Zf.mergeOptions({boxStyle:null,textSymbol:null}),Zf.registerJSONType("Label");var $f=function(i){return function(i){function g(...g){return i.call(this,...g)||this}tn(g,i),g._hasConnectors=function(i){return!H(i.__connectors)&&i.__connectors.length>0},g._getConnectors=function(i){return i.__connectors};var m=g.prototype;return m.getConnectSource=function(){return this._connSource},m.setConnectSource=function(i){var g=this._connTarget;return this.onRemove(),this._connSource=i,this._connTarget=g,this.onAdd(),this},m.getConnectTarget=function(){return this._connTarget},m.setConnectTarget=function(i){var g=this._connSource;return this.onRemove(),this._connSource=g,this._connTarget=i,this._updateCoordinates(),this._registerEvents(),this},m._updateCoordinates=function(){var i=this.getMap();if(!i&&this._connSource&&(i=this._connSource.getMap()),!i&&this._connTarget&&(i=this._connTarget.getMap()),i&&this._connSource&&this._connTarget){for(var g,m,_=this._connSource._getConnectPoints(),b=this._connTarget._getConnectPoints(),T=0,P=this.getCoordinates(),I=0,H=_.length;I<H;I++)for(var W=_[I],q=0,$=b.length;q<$;q++){var ye=b[q],Re=i.computeLength(W,ye);0===I&&0===q?(g=W,m=ye,T=Re):Re<T&&(g=W,m=ye)}kn(P)&&P[0].equals(g)&&P[1].equals(m)||this.setCoordinates([g,m])}},m.onAdd=function(){this._registerEvents(),this._updateCoordinates()},m.onRemove=function(){if(this._connSource&&(this._connSource.__connectors&&xn(this,this._connSource.__connectors),this._connSource.off("dragging positionchange",this._updateCoordinates,this).off("remove",this.onRemove,this),this._connSource.off("dragstart mousedown mouseover",this._showConnect,this),this._connSource.off("dragend mouseup mouseout",this.hide,this),this._connSource.off("show",this._showConnect,this).off("hide",this.hide,this),delete this._connSource),this._connTarget&&(xn(this,this._connTarget.__connectors),this._connTarget.off("dragging positionchange",this._updateCoordinates,this).off("remove",this.onRemove,this),this._connTarget.off("show",this._showConnect,this).off("hide",this.hide,this),delete this._connTarget),!(this._connSource instanceof gu&&this._connTarget instanceof gu)){var i=this.getMap();i&&i.off("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange",this._updateCoordinates,this)}},m._showConnect=function(){this._connSource&&this._connTarget&&this._connSource.isVisible()&&this._connTarget.isVisible()&&(this._updateCoordinates(),this.show())},m._registerEvents=function(){if(this._connSource&&this._connTarget){this._connSource.__connectors||(this._connSource.__connectors=[]),this._connTarget.__connectors||(this._connTarget.__connectors=[]),this._connSource.__connectors.push(this),this._connTarget.__connectors.push(this),this._connSource.on("dragging positionchange",this._updateCoordinates,this).on("remove",this.remove,this),this._connTarget.on("dragging positionchange",this._updateCoordinates,this).on("remove",this.remove,this),this._connSource.on("show",this._showConnect,this).on("hide",this.hide,this),this._connTarget.on("show",this._showConnect,this).on("hide",this.hide,this);var i=this.options.showOn;if(this.hide(),"moving"===i?(this._connSource.on("dragstart",this._showConnect,this).on("dragend",this.hide,this),this._connTarget.on("dragstart",this._showConnect,this).on("dragend",this.hide,this)):"click"===i?(this._connSource.on("mousedown",this._showConnect,this).on("mouseup",this.hide,this),this._connTarget.on("mousedown",this._showConnect,this).on("mouseup",this.hide,this)):"mouseover"===i?(this._connSource.on("mouseover",this._showConnect,this).on("mouseout",this.hide,this),this._connTarget.on("mouseover",this._showConnect,this).on("mouseout",this.hide,this)):this._showConnect(),!(this._connSource instanceof gu&&this._connTarget instanceof gu)){var g=this.getMap();g&&g.on("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange",this._updateCoordinates,this)}}},g}(i)},Yf={showOn:"always"},Qf=function(i){function g(g,m,_){var b;return b=i.call(this,null,_)||this,1===arguments.length&&(_=g,g=null,m=null),b._connSource=g,b._connTarget=m,b}return tn(g,i),g}($f(vf));Qf.mergeOptions(Yf),Qf.registerJSONType("ConnectorLine");var Jf=function(i){function g(g,m,_){var b;return b=i.call(this,null,_)||this,1===arguments.length&&(_=g,g=null,m=null),b._connSource=g,b._connTarget=m,b}return tn(g,i),g}($f(Vf));function Kf(i){return i&&i instanceof gu}Jf.mergeOptions(Yf),Jf.registerJSONType("ArcConnectorLine");var ed=[],td=function(i){function g(g,m,_){var b;m&&!Kf(m)&&!Array.isArray(m)&&Kn.indexOf(m.type)<0&&(_=m,m=null),(b=i.call(this,g,_)||this)._maxZIndex=0,b._minZIndex=0,b._initCache(),m&&b.addGeometry(m);var T=b.options.style;return T&&b.setStyle(T),b}tn(g,i);var m=g.prototype;return m.getAltitude=function(){return 0},m.getGeometryById=function(i){return H(i)||""===i?null:this._geoMap[i]?this._geoMap[i]:null},m.getGeometries=function(i,g){if(!i)return this._geoList.slice(0);for(var m,_=[],b=0,T=this._geoList.length;b<T;b++)m=this._geoList[b],(g?i.call(g,m):i(m))&&_.push(m);return _},m.getFirstGeometry=function(){return this._geoList.length?this._geoList[0]:null},m.getLastGeometry=function(){var i=this._geoList.length;return 0===i?null:this._geoList[i-1]},m.getCount=function(){return this._geoList.length},m.getExtent=function(){if(0===this.getCount())return null;var i=new Pl(this.getProjection());return this.forEach((function(g){i._combine(g.getExtent())})),i},m.forEach=function(i,g){for(var m=this._geoList.slice(0),_=0,b=m.length;_<b;_++)g?i.call(g,m[_],_):i(m[_],_);return this},m.filter=function(i,g){var m=[],_=Re(i),b=_?i:Fi(i);return this.forEach((function(i){var T=_?i:qi(i);(g?b.call(g,T):b(T))&&m.push(i)}),this),m},m.isEmpty=function(){return!this._geoList.length},m.addGeometry=function(i,g){if(!i)return this;if("FeatureCollection"===i.type)return this.addGeometry(Lf.toGeometry(i),g);if(!Array.isArray(i)){var m=arguments.length,_=arguments[m-1];return i=Array.prototype.slice.call(arguments,0,m-1),g=_,_&&$(_)&&("type"in _||Kf(_))&&(i.push(_),g=!1),this.addGeometry(i,g)}if(0===i.length)return this;var b;this._initCache(),g&&(b=new Pl),this._toSort=this._maxZIndex>0;for(var T=[],P=0,W=i.length;P<W;P++){var q=i[P];if(!q||!Lf._isGeoJSON(q)&&!Kf(q))throw new Error("Invalid geometry to add to layer("+this.getId()+") at index:"+P);if(!q.getLayer||q.getLayer()!==this){if(!Kf(q)&&(q=gu.fromJSON(q),Array.isArray(q)))for(var ye=0,Be=q.length;ye<Be;ye++)this._add(q[ye],b,P),T.push(q[ye]);if(!q)throw new Error("Invalid geometry to add to layer("+this.getId()+") at index:"+P);Array.isArray(q)||(this._add(q,b,P),T.push(q))}}var Ge=this.getMap();if(Ge&&(this._getRenderer().onGeometryAdd(T),b&&!H(b.xmin))){var je=b.getCenter(),Xe=Ge.getFitZoom(b);if($(g)){var Ze=Re(g.step)?g.step:function(){};Ge.animateTo({center:je,zoom:Xe},I({duration:Ge.options.zoomAnimationDuration,easing:"out"},g),Ze)}else!0===g&&Ge.setCenterAndZoom(je,Xe)}return this.fire("addgeo",{type:"addgeo",target:this,geometries:i}),this},m.getGeoMinZIndex=function(){return this._minZIndex},m.getGeoMaxZIndex=function(){return this._maxZIndex},m._add=function(i,g,m){this._toSort||(this._toSort=0!==i.getZIndex()),this._updateZIndex(i.getZIndex());var _=i.getId();if(!H(_)){if(!H(this._geoMap[_]))throw new Error("Duplicate geometry id in layer("+this.getId()+"):"+_+", at index:"+m);this._geoMap[_]=i}var b=gn();i._setInternalId(b),this._geoList.push(i),this.onAddGeometry(i),i._bindLayer(this),i.onAdd&&i.onAdd(),g&&g._combine(i.getExtent()),i._fireEvent("add",{layer:this}),this._cookedStyles&&this._styleGeometry(i)},m.removeGeometry=function(i){if(!Array.isArray(i))return this.removeGeometry([i]);for(var g=i.length-1;g>=0;g--)i[g]instanceof gu||(i[g]=this.getGeometryById(i[g])),i[g]&&this===i[g].getLayer()&&i[g].remove();return this},m.clear=function(){this._clearing=!0,this.forEach((function(i){i.remove()})),this._geoMap={};var i=this._geoList;this._geoList=[];var g=this._getRenderer();return g&&(g.onGeometryRemove(i),g.clearImageData&&(g.clearImageData(),delete g._lastGeosToDraw)),this._clearing=!1,this.fire("clear"),this},m.onRemoveGeometry=function(i){if(i&&!this._clearing&&(this===i.getLayer()&&!H(i._getInternalId()))){var g=i.getId();H(g)||delete this._geoMap[g];var m=this._findInList(i);m>=0&&this._geoList.splice(m,1),this._getRenderer()&&this._getRenderer().onGeometryRemove([i])}},m.getStyle=function(){return this.options.style?this.options.style:null},m.setStyle=function(i){return this.options.style=i,i=uo(i),this._cookedStyles=Xi(i),this.forEach((function(i){this._styleGeometry(i)}),this),this.fire("setstyle",{type:"setstyle",target:this,style:i}),this},m._styleGeometry=function(i){if(!this._cookedStyles)return!1;for(var g=qi(i),m=0,_=this._cookedStyles.length;m<_;m++)if(!0===this._cookedStyles[m].filter(g))return i._setExternSymbol(this._cookedStyles[m].symbol),!0;return!1},m.removeStyle=function(){return this.options.style?(delete this.options.style,delete this._cookedStyles,this.forEach((function(i){i._setExternSymbol(null)}),this),this.fire("removestyle"),this):this},m.onAddGeometry=function(i){this.getStyle()&&this._styleGeometry(i)},m.hide=function(){for(var i=0,g=this._geoList.length;i<g;i++)this._geoList[i].onHide();return Fu.prototype.hide.call(this)},m._initCache=function(){this._geoList||(this._geoList=[],this._geoMap={})},m._updateZIndex=function(...i){this._maxZIndex=Math.max(this._maxZIndex,Math.max(...i)),this._minZIndex=Math.min(this._minZIndex,Math.min(...i))},m._sortGeometries=function(){var i=this;this._toSort&&(this._maxZIndex=0,this._minZIndex=0,this._geoList.sort((function(g,m){return i._updateZIndex(g.getZIndex(),m.getZIndex()),i._compare(g,m)})),this._toSort=!1)},m._compare=function(i,g){return i.getZIndex()===g.getZIndex()?i._getInternalId()-g._getInternalId():i.getZIndex()-g.getZIndex()},m._findInList=function(i){var g=this._geoList.length;if(0===g)return-1;this._sortGeometries();for(var m,_=0,b=g-1;_<=b;){if(m=Math.floor((_+b)/2),this._geoList[m]===i)return m;this._compare(this._geoList[m],i)>0?b=m-1:_=m+1}return-1},m.onGeometryEvent=function(i){return this._onGeometryEvent(i)},m._onGeometryEvent=function(i){if(i&&i.target){var g=i.type;"idchange"===g?this._onGeometryIdChange(i):"zindexchange"===g?this._onGeometryZIndexChange(i):"positionchange"===g?this._onGeometryPositionChange(i):"shapechange"===g?this._onGeometryShapeChange(i):"symbolchange"===g?this._onGeometrySymbolChange(i):"show"===g?this._onGeometryShow(i):"hide"===g?this._onGeometryHide(i):"propertieschange"===g&&this._onGeometryPropertiesChange(i)}},m._onGeometryIdChange=function(i){if(i.new!==i.old||!this._geoMap[i.old]||this._geoMap[i.old]!==i.target){if(!H(i.new)){if(this._geoMap[i.new])throw new Error("Duplicate geometry id in layer("+this.getId()+"):"+i.new);this._geoMap[i.new]=i.target}H(i.old)||i.new===i.old||delete this._geoMap[i.old]}},m._onGeometryZIndexChange=function(i){i.old!==i.new&&(this._updateZIndex(i.new),this._toSort=!0,this._getRenderer()&&this._getRenderer().onGeometryZIndexChange(i))},m._onGeometryPositionChange=function(i){this._getRenderer()&&this._getRenderer().onGeometryPositionChange(i)},m._onGeometryShapeChange=function(i){this._getRenderer()&&this._getRenderer().onGeometryShapeChange(i)},m._onGeometrySymbolChange=function(i){this._getRenderer()&&this._getRenderer().onGeometrySymbolChange(i)},m._onGeometryShow=function(i){this._getRenderer()&&this._getRenderer().onGeometryShow(i)},m._onGeometryHide=function(i){this._getRenderer()&&this._getRenderer().onGeometryHide(i)},m._onGeometryPropertiesChange=function(i){this._getRenderer()&&this._getRenderer().onGeometryPropertiesChange(i)},m._hasGeoListeners=function(i){if(!i)return!1;Array.isArray(i)||(ed[0]=i,i=ed);for(var g=this.getGeometries()||[],m=0,_=g.length;m<_;m++){var b=g[m];if(b){if(b.options.cursor)return!0;for(var T=0,P=i.length;T<P;T++){if(b.listens(i[T])>0)return!0}}}return!1},m._getRenderer=function(){return i.prototype._getRenderer.call(this)},g}(Fu);td.mergeOptions({drawImmediate:!1,geometryEvents:!0,geometryEventTolerance:1});var nd=function(i){function g(m,_,b={}){var T;return _&&!Kf(_)&&!Array.isArray(_)&&Kn.indexOf(_.type)<0&&(b=_,_=null),T=i.call(this,m,b)||this,b.sceneConfig={depthFunc:T.options.depthFunc||"always"},T._markerLayer=new g.markerLayerClazz(m+"_____________marker",b),T._lineLayer=new g.lineLayerClazz(m+"_____________line",b),T._polygonLayer=new g.polygonLayerClazz(m+"_____________polygon",b),_&&T.addGeometry(_),T}tn(g,i),g.setLayerClass=function(i,m,_){g.markerLayerClazz=i,g.lineLayerClazz=m,g.polygonLayerClazz=_};var m=g.prototype;return m.bringToFront=function(){return this._polygonLayer.bringToFront(),this._lineLayer.bringToFront(),this._markerLayer.bringToFront(),this},m.addGeometry=function(i){Array.isArray(i)||(i=[i]),yn(this._geoList,i);for(var g=0;g<i.length;g++)this._markerLayer.isVectorLayer||i[g]instanceof yf||i[g]instanceof Mf?this._markerLayer.addGeometry(i[g]):i[g]instanceof vf||i[g]instanceof Pf?this._lineLayer.addGeometry(i[g]):(i[g]instanceof gf||i[g]instanceof If)&&this._polygonLayer.addGeometry(i[g])},m.removeGeometry=function(i){Array.isArray(i)||(i=[i]);for(var g=0;g<i.length;g++)this._geoList.splice(i[g],1),this._markerLayer.isVectorLayer||i[g]instanceof yf||i[g]instanceof Mf?this._markerLayer.removeGeometry(i[g]):i[g]instanceof vf||i[g]instanceof Pf?this._lineLayer.removeGeometry(i[g]):(i[g]instanceof gf||i[g]instanceof If)&&this._polygonLayer.removeGeometry(i[g])},m._onRemoveDrawToolGeo=function(i){for(var g=i.geometries,m=0;m<g.length;m++)g[m]&&this._geoList.splice(g[m],1)},m.onRemove=function(){return this._geoList=[],this._markerLayer.off("removegeo",this._onRemoveDrawToolGeo,this),this._lineLayer.off("removegeo",this._onRemoveDrawToolGeo,this),this._polygonLayer.off("removegeo",this._onRemoveDrawToolGeo,this),this._markerLayer.remove(),this._lineLayer.remove(),this._polygonLayer.remove(),delete this._markerLayer,delete this._lineLayer,delete this._polygonLayer,i.prototype.onRemove.call(this)},m.onAdd=function(){var g=this.getMap();return this._polygonLayer.addTo(g),this._lineLayer.addTo(g),this._markerLayer.addTo(g),this._markerLayer.on("removegeo",this._onRemoveDrawToolGeo,this),this._lineLayer.on("removegeo",this._onRemoveDrawToolGeo,this),this._polygonLayer.on("removegeo",this._onRemoveDrawToolGeo,this),i.prototype.onAdd.call(this)},m.getRenderer=function(){return this._getRenderer()},m._getRenderer=function(){return this._markerLayer.getRenderer()},g}(td);nd.mergeOptions({renderer:null});var rd="_map_tool",id=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.addTo=function(i){return i?(this._map=i,i[rd]&&i[rd].disable(),this.onAdd&&this.onAdd(),this.enable(),i[rd]=this,this._fireEvent("add"),this):this},m.getMap=function(){return this._map},m.enable=function(){return!this._map||this._enabled||(this._enabled=!0,this._switchEvents("off"),this._registerEvents(),this.onEnable&&this.onEnable(),this._fireEvent("enable")),this},m.disable=function(){return this._enabled&&this._map?(this._enabled=!1,this._switchEvents("off"),this.onDisable&&this.onDisable(),this._fireEvent("disable"),this):this},m.isEnabled=function(){return!!this._enabled},m.remove=function(){return this._map?(this.disable(),this._map&&(delete this._map[rd],delete this._map),this._fireEvent("remove"),this):this},m._registerEvents=function(){this._switchEvents("on")},m._switchEvents=function(i){var g=this.getEvents();g&&this._map[i](g,this)},m._fireEvent=function(i,g){g||(g={}),this.fire(i,g)},g}(Za(Ya)),od={symbol:{lineColor:"#000",lineWidth:2,lineOpacity:1,polygonFill:"#fff",polygonOpacity:.3},doubleClickZoom:!1,mode:null,once:!1,autoPanAtEdge:!1,ignoreMouseleave:!0,blockGeometryEvents:!1,zIndex:Number.MAX_VALUE,enableAltitude:!0,interactive:!0,transformCoordinate:null},sd={},ad=function(i){function g(g){var m;return(m=i.call(this,g)||this).id=gn(),m._checkMode(),m._events={click:m._clickHandler,"mousemove touchmove":m._mouseMoveHandler,dblclick:m._doubleClickHandler,"mousedown touchstart":m._mouseDownHandler,"mouseup touchend":m._mouseUpHandler,mousemove:m._mouseMoveHandler,mousedown:m._mouseDownHandler,mouseup:m._mouseUpHandler},m}tn(g,i),g.registerMode=function(i,g){sd[i.toLowerCase()]=g},g.getRegisterMode=function(i){return sd[i.toLowerCase()]},g.getAllRegisterMode=function(){return Object.assign({},sd)};var m=g.prototype;return m.getMode=function(){return this.options.mode?this.options.mode.toLowerCase():null},m.setMode=function(i){return this._geometry&&(this._geometry.remove(),delete this._geometry),this._clearStage(),this._switchEvents("off"),this.options.mode=i,this._checkMode(),this.isEnabled()&&(this._switchEvents("on"),this._restoreMapCfg(),this._saveMapCfg()),this},m.getSymbol=function(){var i=this.options.symbol;return co(i||this.options.symbol)},m.setSymbol=function(i){return i?(this.options.symbol=i,this._geometry&&this._geometry.setSymbol(i),this):this},m.getCurrentGeometry=function(){return this._geometry},m.onAdd=function(){this._checkMode()},m.onEnable=function(){this._saveMapCfg(),this._drawToolLayer=this._getDrawLayer(),this._clearStage(),this._loadResources();var i=this.getMap();return this.options.autoPanAtEdge&&(this._mapAutoPanAtEdge=i.options.autoPanAtEdge,this._mapAutoPanAtEdge||i.config({autoPanAtEdge:!0})),this._geometryEvents=i.options.geometryEvents,this.options.blockGeometryEvents&&i.config("geometryEvents",!1),this},m.onDisable=function(){var i=this.getMap();return this._restoreMapCfg(),this.endDraw({ignoreEndEvent:!0}),this._map&&(i.removeLayer(this._getDrawLayer()),this.options.autoPanAtEdge&&(this._mapAutoPanAtEdge||i.config({autoPanAtEdge:!1}))),this.options.blockGeometryEvents&&i.config("geometryEvents",this._geometryEvents),this},m.undo=function(){var i=this._getRegisterMode();if(!this._shouldRecordHistory(i.action)||!this._historyPointer)return this;var g=this._clickCoords.slice(0,--this._historyPointer);return i.update(this.getMap().getProjection(),g,this._geometry),this},m.redo=function(){var i=this._getRegisterMode();if(!this._shouldRecordHistory(i.action)||H(this._historyPointer)||this._historyPointer===this._clickCoords.length)return this;var g=this._clickCoords.slice(0,++this._historyPointer);return i.update(this.getMap().getProjection(),g,this._geometry),this},m._shouldRecordHistory=function(i){return Array.isArray(i)&&"click"===i[0]&&"mousemove"===i[1]&&"dblclick"===i[2]},m._checkMode=function(){this._getRegisterMode()},m._saveMapCfg=function(){var i=this.getMap();this._mapDoubleClickZoom=i.options.doubleClickZoom,i.config({doubleClickZoom:this.options.doubleClickZoom});for(var g=this._getRegisterMode().action,m=!1,_=0;_<g.length;_++)if(g[_].indexOf("mousedown")>=0||g[_].indexOf("touchstart")>=0){m=!0;break}if(m){var b=this.getMap();this._mapDraggable=b.options.draggable,b.config({draggable:!1})}},m._restoreMapCfg=function(){var i=this.getMap();i.config({doubleClickZoom:this._mapDoubleClickZoom}),H(this._mapDraggable)||i.config("draggable",this._mapDraggable),delete this._mapDraggable,delete this._mapDoubleClickZoom},m._loadResources=function(){var i=no(this.getSymbol());i.length>0&&this._drawToolLayer.getRenderer().loadResources(i)},m._getProjection=function(){return this._map.getProjection()},m._getRegisterMode=function(){var i=this.getMode(),m=g.getRegisterMode(i);if(!m)throw new Error(i+" is not a valid mode of DrawTool.");return m},m.getEvents=function(){var i=this._getRegisterMode().action,g={};if(Array.isArray(i)){for(var m=0;m<i.length;m++)g[i[m]]=this._events[i[m]];return g}return null},m._mouseDownHandler=function(i){(null==i?void 0:i.coordinate)&&this._createGeometry(i)},m._mouseUpHandler=function(i){(null==i?void 0:i.coordinate)&&this.endDraw(i)},m._copyMapEventOnSnapTo=function(i,g){var m=this.getMap();return m?Object.assign({},i,{containerPoint:m.prjToContainerPoint(g)}):i},m._clickHandler=function(i){if(null==i?void 0:i.coordinate){if(!this.options.interactive)return this;i.enableAltitude=this.options.enableAltitude;var g=this.getMap(),m=this._getRegisterMode();if(this._clickCoords&&this._clickCoords.length){var _=this._clickCoords.length,b=g._pointToPrj(i.point2d);if(this._clickCoords[_-1].equals(b))return}if(this._geometry){var T=g._pointToPrj(i.point2d);H(this._historyPointer)||(this._clickCoords=this._clickCoords.slice(0,this._historyPointer));var P,I=this._geometry.snapTo;if(I&&Re(I)){var W=this._getSnapResult(I,i.containerPoint);if(P=this._copyMapEventOnSnapTo(i,T=W.prjCoord),this._clickCoords=this._clickCoords.concat(W.effectedVertex),this._clickCoords[this._clickCoords.length-1].equals(T))return}if(this._clickCoords.push(T),this._historyPointer=this._clickCoords.length,i.drawTool=this,m.update(g.getProjection(),this._clickCoords,this._geometry,P||i),"point"===this.getMode())return void this.endDraw(i);this._fireEvent(this._clickCoords.length<=1?"drawstart":"drawvertex",i),m.clickLimit&&m.clickLimit===this._historyPointer&&this.endDraw(i)}else this._createGeometry(i)}},m._createGeometry=function(i){var g=this.getMode(),m=this.getMap(),_=this._getRegisterMode(),b=m._pointToPrj(i.point2d),T=this.getSymbol();if(!this._geometry){this._fireEvent("drawprepare",i),this._clickCoords=[b],i.drawTool=this,this._geometry=_.create(this.getMap().getProjection(),this._clickCoords,i),T&&"point"!==g?this._geometry.setSymbol(T):this.options.hasOwnProperty("symbol")&&this._geometry.setSymbol(this.options.symbol),this._addGeometryToStage(this._geometry),this._fireEvent("drawstart",i);var P=this._geometry.snapTo;if(P&&Re(P)){var I=this._getSnapResult(P,i.containerPoint),H=this.getMap();if(H&&I){var W=I.prjCoord;this._clickCoords=[W],this._geometry._firstClick&&(this._geometry._firstClick=W);var q=this._copyMapEventOnSnapTo(i,W);_.update(H.getProjection(),this._clickCoords,this._geometry,q)}}}"point"===g&&"mousemove"!==i.type&&this.endDraw(i)},m._mouseMoveHandler=function(i){if(null==i?void 0:i.coordinate){if(!this.options.interactive)return this;i.enableAltitude=this.options.enableAltitude;var g=this.getMap();if(g&&!g.isInteracting())if("point"!==this.getMode()||this._geometry){if(this._geometry){var m=this._getMouseContainerPoint(i);if(this._isValidContainerPoint(m)){var _,b=g._pointToPrj(i.point2d),T=[],P=this._geometry.snapTo;if(P&&Re(P)){var I=this._getSnapResult(P,m);T=I.effectedVertex,_=this._copyMapEventOnSnapTo(i,b=I.prjCoord)}var H=g.getProjection();i.drawTool=this;var W=this._getRegisterMode();if(this._shouldRecordHistory(W.action)){var q=this._clickCoords.slice(0,this._historyPointer);if(q&&q.length>0&&b.equals(q[q.length-1]))return;W.update(H,q.concat(T,[b]),this._geometry,_||i)}else W.update(H,b,this._geometry,_||i);this._fireEvent("mousemove",i)}}}else this._createGeometry(i)}},m._doubleClickHandler=function(i){if(null==i?void 0:i.coordinate){if(!this.options.interactive)return this;if(i.enableAltitude=this.options.enableAltitude,this._geometry){var g=this._getMouseContainerPoint(i);if(this._isValidContainerPoint(g)){var m=this._getRegisterMode(),_=this._clickCoords;if(_&&!(_.length<2)){var b=this.getMode();if(!(b&&b.indexOf("polygon")>-1&&_.length<3)){for(var T=this.getMap().getProjection(),P=[_[0]],I=1,H=_.length;I<H;I++)_[I].x===_[I-1].x&&_[I].y===_[I-1].y||P.push(_[I]);P.length<2||this._geometry&&this._geometry instanceof gf&&P.length<3||(i.drawTool=this,m.update(T,P,this._geometry,i),this.endDraw(i))}}}}}},m._addGeometryToStage=function(i){this._getDrawLayer().addGeometry(i)},m.endDraw=function(i){if(!this._geometry||this._ending)return this;this._ending=!0;var g=this._geometry;return this._clearStage(),i=i||{},this._geometry=g,i.ignoreEndEvent||this._fireEvent("drawend",i),delete this._geometry,this.options.once&&this.disable(),delete this._ending,delete this._historyPointer,this._vertexes&&(this._vertexes=[]),this},m._clearStage=function(){this._getDrawLayer().clear(),delete this._geometry,delete this._clickCoords},m._getMouseContainerPoint=function(i){var g=this._getRegisterMode().action;return(g[0].indexOf("mousedown")>=0||g[0].indexOf("touchstart")>=0)&&Hr(i.domEvent),i.containerPoint},m._isValidContainerPoint=function(i){var g=this._map.getSize();return!(i.x<0||i.y<0)&&!(i.x>g.width||i.y>g.height)},m._getSnapResult=function(i,g){var m=this.getMap(),_=[];if(this.options.edgeAutoComplete){_.push(m.prjToContainerPoint(this._clickCoords[(this._historyPointer||1)-1]));var b=this._clickCoords[(this._historyPointer||1)-2];b&&_.push(m.prjToContainerPoint(b))}var T=i(g,_),P=m._containerPointToPrj(g=(T.effectedVertex?T.point:T)||g);return T.effectedVertex&&(T.effectedVertex=T.effectedVertex.map((function(i){return m._containerPointToPrj(i)}))),{prjCoord:P,effectedVertex:T.effectedVertex||[]}},m._getDrawLayer=function(){var i=Qn+"drawtool"+this.id,g=this._map.getLayer(i);return g||(g=new nd(i,{enableSimplify:!1,enableAltitude:this.options.enableAltitude,zIndex:this.options.zIndex}),this._map.addLayer(g)),this._pushLayers(g),g},m._fireEvent=function(i,g){g||(g={}),g=I({},g),this._geometry&&(g.geometry=this._getRegisterMode().generate(this._geometry,{drawTool:this}),g.tempGeometry=this._geometry),id.prototype._fireEvent.call(this,i,g)},m._pushLayers=function(i){var g=this;return i?(Array.isArray(i)||(i=[i]),this._layers=this._layers||[],i.forEach((function(i){-1===g._layers.indexOf(i)&&g._layers.push(i)})),this):this},m._outLayers=function(i){var g=this;return i?(Array.isArray(i)||(i=[i]),this._layers=this._layers||[],i.forEach((function(i){for(var m=0,_=g._layers.length;m<_;m++)if(i===g._layers[m]){g._layers.splice(m,1);break}})),this):this},m.setLayerZIndex=function(i){return W(i)?(this.options.zIndex=i,this._layers=this._layers||[],this._layers.forEach((function(g){g&&g.setZIndex&&g.setZIndex(i)})),this):this},m.addCoordinate=function(i){if(!this.isEnabled())return this;var g=this.getMap();if(!g)return this;i=new pl(i);var m=g._parseEventFromCoord(i);return this._clickHandler(m),this},m.getTempGeometry=function(){return this._geometry},g}(id);ad.mergeOptions(od);var ld=function(i){function g(g){var m;return(m=i.call(this,g)||this).drawTool=new ad({mode:"boxZoom",ignoreMouseleave:!1}),m}tn(g,i);var m=g.prototype;return m.addHooks=function(){this.target.on("_mousedown",this._onMouseDown,this)},m.removeHooks=function(){this.target.off("_mousedown",this._onMouseDown,this),this.drawTool.isEnabled()&&this.drawTool.remove()},m._onMouseDown=function(i){this.target.options.boxZoom&&i.domEvent.shiftKey&&this.drawTool.setSymbol(this.target.options.boxZoomSymbol).on("drawend",this._boxZoom,this).addTo(this.target)},m._boxZoom=function(i){var g=this.target;this.drawTool.remove();var m=i.geometry,_=m.getCenter(),b=m.getSymbol(),T=new Pl(_,g.locateByPoint(_,b.markerWidth,b.markerHeight),g.getProjection()),P=g.getFitZoom(T);g._animateTo({center:T.getCenter(),zoom:P})},g}(ju);Uu.mergeOptions({boxZoom:!0,boxZoomSymbol:{markerType:"rectangle",markerLineWidth:3,markerLineColor:"#1bbc9b",markerLineDasharray:[10,5],markerFillOpacity:.1,markerFill:"#1bbc9b",markerWidth:1,markerHeight:1}}),Uu.addOnLoadHook("addHandler","boxZoom",ld);var hd=30,cd=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.addHooks=function(){this.target&&this.target.on("_mousemove",this._onMouseMove,this)},m.removeHooks=function(){this.target&&this.target.off("_mousemove",this._onMouseMove,this)},m._onMouseMove=function(i){var g=this.target;if(g.options.autoPanAtEdge){var{containerPoint:m}=i,_=g.getContainerExtent();if(_){var b,{x:T,y:P}=m,{xmax:I,ymax:H}=_;T<hd&&(b=[Math.abs(T-hd),0]),P<hd&&(b=[0,Math.abs(P-hd)]),T+hd>I&&(b=[-Math.abs(T+hd-I),0]),P+hd>H&&(b=[0,-Math.abs(P+hd-H)]),b&&g.panBy(b,{duration:1})}}},g}(ju);function ud(i,g){var m=i.bearing,_=g.getBearing();return!(_>=0&&m>180)&&!(_<=0&&m<-180)}function fd(i,g){var m=i.bearing,_=g.getBearing();_>=0&&m<0&&(i.bearing=180-Math.abs(m)+180),_<=0&&m>0&&(i.bearing=-180-(180-Math.abs(m))),_>=0&&m>0&&(i.bearing=-180-(180-Math.abs(m))),_<=0&&m<0&&(i.bearing=180-Math.abs(m)+180)}function dd(i,g,m){return i*(1-m)+g*m}Uu.mergeOptions({autoPanAtEdge:!1}),Uu.addOnLoadHook("addHandler","autoPanAtEdge",cd),Uu.include({animateTo:function(i,g={},m){var _=this;(i=I({},this.getView(),i)).bearing=i.bearing%360,Re(g)&&(m=g,g={}),g.counterclockwise&&fd(i,this),ud(i,this)&&this._validateView(i);var b=this.getProjection(),T=this.getView(),P={},W=!0;for(var q in i)if(Ge(i,q)&&!H(i[q])&&("prjCenter"===q||!H(T[q])))if(W=!1,"center"===q){var $=new pl(T[q]),ye=new pl(i[q]);$.equals(ye)||(P.center=[$,ye])}else if("prjCenter"===q){var Be=new pl(this._getPrjCenter()),je=new pl(i[q]);Be.equals(je)||(P.prjCenter=[Be,je])}else T[q]!==i[q]&&"around"!==q&&(P[q]=[T[q],i[q]]);if(W)return null;this._animPlayer&&(this._isInternalAnimation?"running"===this._animPlayer.playState&&(this._animPlayer.pause(),this._prevAnimPlayer=this._animPlayer):(delete this._prevAnimPlayer,this._stopAnim(this._animPlayer)));var Xe=i.around||null,Ze=this._getRenderer(),Ye=this._animPlayer=af.animate(P,{easing:g.easing||"out",duration:g.duration||this.options.zoomAnimationDuration,framer:function(i){Ze.callInNextFrame(i)},repeat:g.repeat},(function(i){if(_.isRemoved())Ye.finish();else{if("running"===Ye.playState){if(i.styles.center)_._setPrjCenter(b.project(i.styles.center)),_.onMoving(_._parseEventFromCoord(_.getCenter()));else if(i.styles.prjCenter){_._setPrjCenter(i.styles.prjCenter),_.onMoving(_._parseEventFromCoord(_.getCenter()))}H(i.styles.zoom)||_.onZooming(i.styles.zoom,Xe),H(i.styles.pitch)||_._setPitch(i.styles.pitch),H(i.styles.bearing)||_._setBearing(i.styles.bearing),_._fireEvent("animating")}else"paused"===Ye.playState&&Ye!==_._mapAnimPlayer||(Ye._interupted||(P.center?_._setPrjCenter(b.project(P.center[1])):P.prjCenter&&_._setPrjCenter(P.prjCenter[1]),H(P.pitch)||_._setPitch(P.pitch[1]),H(P.bearing)||_._setBearing(P.bearing[1])),_._endAnim(Ye,P,Xe,g));m&&m(i)}}),this);return this._startAnim(P,Xe),Ye},_animateTo:function(i,g={},m){return this._mapAnimPlayer&&this._stopAnim(this._mapAnimPlayer),this._isInternalAnimation=!0,this._mapAnimPlayer=this.animateTo(i,g,m),delete this._isInternalAnimation,this._mapAnimPlayer},flyTo:function(i,g={},m){var _=this;(i=I({},this.getView(),i)).bearing=i.bearing%360,g.counterclockwise&&fd(i,this),ud(i,this)&&this._validateView(i),this._animPlayer&&(this._isInternalAnimation?"running"===this._animPlayer.playState&&(this._animPlayer.pause(),this._prevAnimPlayer=this._animPlayer):(delete this._prevAnimPlayer,this._stopAnim(this._animPlayer))),Re(g)&&(m=g,g={}),g=I({curve:1.42},g);var b=this;function T(i,g){return b.getResolution(g)/b.getResolution(i)}var P=i.around||new un(this.width/2,this.height/2),H=this.getMinZoom(),W=this.getMaxZoom(),q=this.getProjection(),$=this.getView(),ye=$.zoom,Be=$.bearing,Ge=$.pitch,je="zoom"in i?Pn(+i.zoom,H,W):ye,Xe="bearing"in i?+i.bearing:Be,Ze="pitch"in i?+i.pitch:Ge,Ye=q.project(i.center&&new pl(i.center)||this.getCenter()),Qe=T(je,ye),Je=q.project(this.getCenter()),Ke=Ye.sub(Je),et=g.curve,tt=Math.max(this.width,this.height),at=tt/Qe,ht=Ke.mag();if("minZoom"in g){var gt=Pn(Math.min(g.minZoom,ye,je),H,W),yt=tt/T(gt,ye);et=Math.sqrt(yt/ht*2)}var vt=et*et;function xt(i){var g=(at*at-tt*tt+(i?-1:1)*vt*vt*ht*ht)/(2*(i?at:tt)*vt*ht);return Math.log(Math.sqrt(g*g+1)-g)}function bt(i){return(Math.exp(i)-Math.exp(-i))/2}function Tt(i){return(Math.exp(i)+Math.exp(-i))/2}var Mt=xt(0),Pt=function(i){return Tt(Mt)/Tt(Mt+et*i)},It=function(i){return tt*((Tt(Mt)*function(i){return bt(i)/Tt(i)}(Mt+et*i)-bt(Mt))/vt)/ht},Et=(xt(1)-Mt)/et;if(Math.abs(ht)<1e-6||!isFinite(Et)){if(Math.abs(tt-at)<1e-6)return this.animateTo(i,g,m);var Lt=at<tt?-1:1;Et=Math.abs(Math.log(at/tt))/et,It=function(){return 0},Pt=function(i){return Math.exp(Lt*et*i)}}var Dt=this._getRenderer(),Ft=this._animPlayer=af.animate({k:[0,1]},{easing:g.easing||"out",duration:g.duration||8,framer:function(i){Dt.callInNextFrame(i)}},(function(b){if(_.isRemoved())Ft.finish();else{var T=b.styles.k,I=T*Et,H=1/Pt(I),W={};if(i.center){var q=1===T?Ye:Je.add(Ke.multi(It(I)));W.prjCenter=[Ye,q]}if(ye!==je){var $=1===T?je:_.getZoomForScale(H,ye,!0);W.zoom=[ye,$]}if(Ge!==Ze){var Re=dd(Ge,Ze,T);W.pitch=[Ze,Re]}if(Be!==Xe){var Qe=dd(Be,Xe,T);W.bearing=[Xe,Qe]}if("running"===Ft.playState){if(W.prjCenter)_._setPrjCenter(W.prjCenter[1]),_.onMoving(_._parseEventFromCoord(_.getCenter()));W.zoom&&_.onZooming(W.zoom[1],P),W.pitch&&_._setPitch(W.pitch[1]),W.bearing&&_._setBearing(W.bearing[1]),_._fireEvent("animating")}else"paused"===Ft.playState&&Ft!==_._mapAnimPlayer||(Ft._interupted||(W.prjCenter&&_._setPrjCenter(W.prjCenter[1]),W.pitch&&_._setPitch(W.pitch[1]),W.bearing&&_._setBearing(W.bearing[1])),_._endAnim(Ft,W,P,g));m&&m(b)}}),{});return this._startAnim({center:i.center,zoom:i.zoom!==ye,pitch:Ze!==Ge,bearing:Xe!==Be},P),this},isAnimating:function(){return!!this._animPlayer},isRotating:function(){return this.isDragRotating()||!!this._animRotating},_endAnim:function(i,g,m,_){delete this._animRotating;var b,T=i._interupted?"animateinterrupted":"animateend";if(i===this._animPlayer&&delete this._animPlayer,i===this._mapAnimPlayer&&delete this._mapAnimPlayer,g.center)b=i._interupted?this.getCenter():g.center[1],this.onMoveEnd(this._parseEventFromCoord(b));else if(g.prjCenter){var P;P=i._interupted?this._getPrjCenter():g.prjCenter[1];var I=this._parseEventFromCoord(this.getProjection().unproject(P));I.point2d=this._prjToPoint(P),this.onMoveEnd(I)}H(g.zoom)||(i._interupted?this.onZoomEnd(this.getZoom()):_.wheelZoom?this.onZooming(g.zoom[1],m):this.onZoomEnd(g.zoom[1])),T&&this._fireEvent(T),H(g.pitch)||this.getPitch()||this.getRenderer().setToRedraw(),_.wheelZoom||this._resumePrev(i)},_startAnim:function(i,g){this._animPlayer&&((i.center||i.prjCenter)&&this.onMoveStart(),i.zoom&&!this.isZooming()&&this.onZoomStart(i.zoom[1],g),(i.pitch||i.bearing)&&(this._animRotating=!0),this._fireEvent("animatestart"),this._animPlayer.play())},_stopAnim:function(i){i&&(delete this._animRotating,"finished"!==i.playState&&(i._interupted=!0,i.cancel()),i===this._animPlayer&&delete this._animPlayer,i===this._mapAnimPlayer&&delete this._mapAnimPlayer)},_resumePrev:function(i){if(this._prevAnimPlayer){var g=this._prevAnimPlayer;"paused"!==g.playState&&delete this._prevAnimPlayer,i!==g&&(this._animPlayer=g,g.play())}}});var pd=[60,120];function gd(i){i.stopPropagation(),i.preventDefault()}var md=["dragstart","dragenter","dragend","dragleave","dragover"].join(" ").toString(),Ad="mousedown mouseup mouseover mouseout mouseenter mouseleave mousemove click dblclick contextmenu keypress touchstart touchmove touchend drop ";function yd(i,g,m){var _=g[0],b=g[1],T=g[2],P=1/(m[3]*_+m[7]*b+m[11]*T+m[15]);return i[0]=(m[0]*_+m[4]*b+m[8]*T+m[12])*P,i[1]=(m[1]*_+m[5]*b+m[9]*T+m[13])*P,i[2]=(m[2]*_+m[6]*b+m[10]*T+m[14])*P,i}Uu.include({_registerDomEvents:function(){var i=this._panels.mapWrapper||this._containerDOM;Lr(i,Ad,this._handleDOMEvent,this),Lr(i,md,gd,this)},_removeDomEvents:function(){var i=this._panels.mapWrapper||this._containerDOM;Dr(i,Ad,this._handleDOMEvent),Dr(i,md,gd)},_handleDOMEvent:function(i){if(i&&"drop"===i.type){i.stopPropagation(),i.preventDefault();var g=this._parseEvent(i,i.type);return g=I({},g,{dataTransfer:i.dataTransfer}),void this._fireEvent(i.type,g)}var m=this.options.clickTimeThreshold,_=i.type;if(!ei(_)||T.isTest||!this.options.mousemoveThrottleEnable||!ti(this,this.options.mousemoveThrottleTime)){var b="mousedown"===_||"touchstart"===_&&(!i.touches||1===i.touches.length);b&&(this._domMouseDownTime=P(),this._domMouseDownView=this.getView());var H="contextmenu"===_&&function(i){if(!i._domMouseDownView)return!0;var g=i.getView(),m=i._domMouseDownView;return g.bearing!==m.bearing||g.pitch!==m.pitch}(this);if("contextmenu"===_){Nr(i);var W=this._domMouseDownTime;P()-W<=m&&!H&&this._fireDOMEvent(this,i,"dom:"+i.type)}else this._fireDOMEvent(this,i,"dom:"+i.type);if(!this._ignoreEvent(i)){var q,$=!1;if(b)this._mouseDownTime=P();else if("click"===_||"touchend"===_||"contextmenu"===_){if(!this._mouseDownTime)return;var ye=this._mouseDownTime;if(delete this._mouseDownTime,P()-ye>m){if("click"===_||"contextmenu"===_)return}else if("contextmenu"===_){if(H)return}else"touchend"===_&&($=!0)}$&&(this._clickTime&&P()-this._clickTime<=m?(delete this._clickTime,q="dblclick",this._fireDOMEvent(this,i,"dom:dblclick")):(this._clickTime=P(),q="click",this._fireDOMEvent(this,i,"dom:click"))),this._ignoreEvent(i)||(this._fireDOMEvent(this,i,_),q&&this._fireDOMEvent(this,i,q))}}},_ignoreEvent:function(i){if(!i||!this._panels.control)return!1;var g,m=i.srcElement||i.target;if(m)for(;m&&m!==this._containerDOM;){if(m.className&&m.className.indexOf&&(m.className.indexOf("maptalks-control")>=0||m.className.indexOf("maptalks-ui")>=0&&g&&!g.eventsPropagation))return!0;g=m,m=m.parentNode}return!1},_isEventOutMap:function(i){var g=Ur(this._getActualEvent(i),this._containerDOM);return this._isContainerPointOutOfMap(g)},_isContainerPointOutOfMap:function(){var i=[0,0,0],g=[0,0,0],m=new ws(i,g),_=[0,0,0];return function(b){var T=this.getPitch();if(T>pd[0]&&T<pd[1]){if(this.getContainerPointRay(i,g,b,0,.5),m.setFromTo(i,g),!m.intersectGround(_))return!0;if(m.distanceToGround()<=0)return!0}return!1}}(),_wrapTerrainData:function(i){this.options.queryTerrainInMapEvents&&i.containerPoint&&!i.terrain&&(i.terrain=this._queryTerrainInfo(i.containerPoint))},_parseEvent:function(i,g){if(!i)return null;var m={domEvent:i};if("keypress"!==g){var _=this._getActualEvent(i);if(_&&void 0!==_.clientX){var b=Ur(_,this._containerDOM);m=I(m,{containerPoint:b,viewPoint:this.containerPointToViewPoint(b)}),this._isContainerPointOutOfMap(b)||(m=I(m,{coordinate:this.containerPointToCoord(b),point2d:this._containerPointToPoint(b)}))}}return this._wrapTerrainData(m),m},_parseEventFromCoord:function(i){var g=this.coordToContainerPoint(i);return{coordinate:i,containerPoint:g,viewPoint:this.containerPointToViewPoint(g),point2d:this.coordToPoint(i)}},_getActualEvent:function(i){return i.touches&&i.touches.length>0?i.touches[0]:i.changedTouches&&i.changedTouches.length>0?i.changedTouches[0]:i},_fireDOMEvent:function(i,g,m){var _=this;if(!this.isRemoved()){var b=this._parseEvent(g,m);if(b.coordinate||"keypress"===m||-1!==m.indexOf("dom:")){this._wrapTerrainData(b);var T=function(){_._fireEvent(b.domEvent&&b.domEvent._cancelBubble?"_"+m:m,b)};ei(m)?this.options.mousemoveThrottleEnable?this.getRenderer().callInNextFrame((function(){T()})):T():this._fireEvent(m,b)}}},_getEventParams:function(i){var g=this,m={domEvent:i},_=i.touches&&i.touches.length>0?i.touches[0]:i.changedTouches&&i.changedTouches.length>0?i.changedTouches[0]:i;if(_){var b=Ur(_,g.getContainer());m.coordinate=g.containerPointToCoordinate(b),m.containerPoint=b,m.viewPoint=g.containerPointToViewPoint(b),m.point2d=g._containerPointToPoint(b)}return this._wrapTerrainData(m),m}}),Uu.addOnLoadHook("_registerDomEvents"),Uu.mergeOptions({queryTerrainInMapEvents:!0}),Uu.include({isFullScreen:function(){var i=document;return!!(i.webkitIsFullScreen||i.mozFullScreen||i.msFullscreenElement||i.fullscreenElement)},requestFullScreen:function(i){return this._fireEvent("fullscreenstart"),this._requestFullScreen(i||this._containerDOM),this._fireEvent("fullscreenend"),this},cancelFullScreen:function(){return this._cancelFullScreen(),this._fireEvent("cancelfullscreen"),this},_requestFullScreen:function(i){if(i.requestFullscreen)i.requestFullscreen();else if(i.mozRequestFullScreen)i.mozRequestFullScreen();else if(i.webkitRequestFullScreen)i.webkitRequestFullScreen();else if(i.msRequestFullScreen)i.msRequestFullScreen();else{var g="fullscreen=1,status=no,resizable=yes,top=0,left=0,scrollbars=no,titlebar=no,menubar=no,location=no,toolbar=no,z-look=yes,width="+(screen.availWidth-8)+",height="+(screen.availHeight-45);null!==window.open(location.href,"_blank",g)&&(window.opener=null,window.close())}},_cancelFullScreen:function(){var i=document;if(document.exitFullscreen)document.exitFullscreen();else if(i.mozCancelFullScreen)i.mozCancelFullScreen();else if(i.webkitCancelFullScreen)i.webkitCancelFullScreen();else{null!==window.open(location.href,"_blank","fullscreen=no,status=yes,resizable=yes,scrollbars=no,titlebar=no,menubar=yes,location=yes,toolbar=yes,z-look=yes")&&(window.opener=null,window.close())}}}),Uu.include({panTo:function(i,g={},m){if(!i)return this;if(Re(g)&&(m=g,g={}),i=new pl(i),void 0===g.animation||g.animation){var _=this.getProjection().project(i);return this._panAnimation(_,g.duration,m)}return this.setCenter(i),this},_panTo:function(i,g={}){return void 0===g.animation||g.animation?this._panAnimation(i,g.duration):(this.onMoveStart(),this._setPrjCenter(i),this.onMoveEnd(this._parseEventFromCoord(this.getCenter())),this)},panBy:function(i,g={},m){if(!i)return this;if(Re(g)&&(m=g,g={}),i=new un(i),this.getContainerExtent().ymin>0&&i.y>30){var _=i.y;i.y=30,i.x=30*i.x/_,console.warn("offset is limited to panBy when pitch is above maxPitch")}if(void 0===g.animation||g.animation){i=i.multi(-1);var b=this._containerPointToPrj(new un(this.width/2+i.x,this.height/2+i.y));this._panAnimation(b,g.duration,m)}else{this.onMoveStart(),this._offsetCenterByPixel(i);var T=this.containerPointToCoord(new un(this.width/2,this.height/2));this.onMoveEnd(this._parseEventFromCoord(T))}return this},_panAnimation:function(i,g,m){return this._animateTo({prjCenter:i},{duration:g||this.options.panAnimationDuration},m)}}),Uu.include({computeLength:function(i,g){if(!this.getProjection())return null;var m=new pl(i),_=new pl(g);return m.equals(_)?0:this.getProjection().measureLength(m,_)},computeGeometryLength:function(i){return i._computeGeodesicLength(this.getProjection())},computeGeometryArea:function(i){return i._computeGeodesicArea(this.getProjection())},identify:function(i,g){var m=new pl((i=i||{}).coordinate);return this._identify(i,g,(function(g){return g.identify(m,i)}))},identifyAtPoint:function(i,g){var m=i.includeInternals,_=i.tolerance,b=new un((i=i||{}).containerPoint),T=this.containerPointToCoord(b);return this._identify(i,g,(function(g){var b,P=i.containerPoint;if(m&&!H(g.options.geometryEventTolerance)&&(i.tolerance=i.tolerance||0,i.tolerance+=g.options.geometryEventTolerance),g._hasGeoListeners&&m&&i.eventTypes.indexOf("mousemove")>=0&&!g._hasGeoListeners(i.eventTypes))return[];(b=g.identifyAtPoint?g.identifyAtPoint(P,i):T&&g.identify?g.identify(T,i):[],m&&(H(_)?delete i.tolerance:i.tolerance=_),b&&b.length)||(g.fire("identifyempty",i),g.getLayers&&Re(g.getLayers)&&(g.getLayers()||[]).filter((function(i){return i})).forEach((function(g){g.fire("identifyempty",i)})));return b}))},_identify:function(i,g,m){var _=i.layers;if(!kn(_))return this;for(var b=i.eventTypes,T=[],P=0,I=_.length;P<I;P++)ye(_[P])?T.push(this.getLayer(_[P])):T.push(_[P]);b&&(T=T.filter((function(i){return!i._hasGeoListeners||i._hasGeoListeners(b)})));for(var W=[],q=T.length-1;q>=0&&!(i.count&&W.length>=i.count);q--){var $=T[q];if($&&$.getMap()&&(i.includeInvisible||$.isVisible())&&(i.includeInternals||!($.getId().indexOf(Qn)>=0))){var Re=m($),Be=$.getId();if(Re)if(Array.isArray(Re)){for(var Ge=0;Ge<Re.length;Ge++)Re[Ge]&&!Re[Ge].getLayer&&H(Re[Ge].layer)&&(Re[Ge].layer=Be);yn(W,Re)}else!Re.getLayer&&H(Re.layer)&&(Re.layer=Be),W.push(Re)}}return g.call(this,W),this}}),Uu.include({_zoom:function(i,g){this.options.zoomable&&!this.isZooming()&&(g=this._checkZoomOrigin(g),i=this._checkZoom(i),this.onZoomStart(i,g),this._frameZoom=this.getZoom(),this.onZoomEnd(i,g))},_zoomAnimation:function(i,g,m){this.options.zoomable&&!this.isZooming()&&(i=this._checkZoom(i),this.getZoom()!==i&&(g=this._checkZoomOrigin(g),this._startZoomAnim(i,g,m)))},_checkZoomOrigin:function(i){return(!i||this.options.zoomInCenter||this._isContainerPointOutOfMap(i))&&(i=new un(this.width/2,this.height/2)),this.options.zoomOrigin&&(i=new un(this.options.zoomOrigin)),i},_startZoomAnim:function(i,g,m){H(m)&&(m=1);var _=this._getResolution(this._startZoomVal)/this._getResolution(i),b=this.options.zoomAnimationDuration*Math.abs(_-m)/Math.abs(_-1);this._frameZoom=this._startZoomVal,this._animateTo({zoom:i,around:g},{continueOnViewChanged:!0,duration:b})},onZoomStart:function(i,g){this.options.zoomable&&!this.isZooming()&&(this._mapAnimPlayer&&this._stopAnim(this._mapAnimPlayer),delete this.cameraZenithDistance,this._zooming=!0,this._startZoomVal=this.getZoom(),this._startZoomCoord=g&&this._containerPointToPrj(g),this._fireEvent("zoomstart",{from:this._startZoomVal,to:i}))},onZooming:function(i,g,m){if(this.options.zoomable&&this._frameZoom!==i){H(m)&&(m=1),this._zoomTo(i,g);var _=this.getResolution(i),b=this.getResolution(this._startZoomVal)/_/m,T=this._startZoomCoord&&this.prjToContainerPoint(this._startZoomCoord,this._startZoomVal),P=this.getViewPoint();if(!this.isRotating()&&T&&g&&!T.equals(g)&&1!==b){var I=this.getPitch(),W=T._sub(g)._multi(1/(1-b));I&&(W.y/=Math.cos(I*Math.PI/180)),g=g.add(W)}var q=g&&g.x||this.width/2,$=g&&g.y||this.height/2,ye={view:[b,0,0,b,(q-P.x)*(1-b),($-P.y)*(1-b)]},Re=this.getDevicePixelRatio();ye.container=[b,0,0,b,q*Re*(1-b),$*Re*(1-b)],this._fireEvent("zooming",{from:this._startZoomVal,to:i,origin:new un(q,$),matrix:ye}),this._frameZoom=i}},onZoomEnd:function(i,g){if(this.options.zoomable){var m=this._startZoomVal;this._zoomTo(i,g),this._zooming=!1,this._getRenderer().onZoomEnd(),this._suppressRecenter||this._recenterOnTerrain(),this._fireEvent("zoomend",{from:m,to:i}),this._verifyExtent(this._getPrjCenter())||this.options.limitExtentOnMaxExtent||this._panTo(this._prjMaxExtent.getCenter())}},_zoomTo:function(i,g){if(this._zoomLevel=i,this._calcMatrices(),g&&this._startZoomCoord){var m=this._containerPointToPoint(g)._sub(this._prjToPoint(this._getPrjCenter()));this._setPrjCoordAtOffsetToCenter(this._startZoomCoord,m)}},_checkZoom:function(i){var g=this.getMaxZoom(),m=this.getMinZoom();return i<m&&(i=m),i>g&&(i=g),i}});var _d,vd=Math.PI/180,xd=new pl(0,0),bd=new un(0,0),wd=[0,-1,0],Td=[];function Sd(){return Mo(new Array(16))}Uu.include({getFov:function(){return this._fov||(this._fov=.6435011087932844),this._fov/vd},setFov:function(i){if(this.isZooming())return this;if(i=Math.max(.01,Math.min(60,i)),this._fov===i)return this;var g=this.getFov();return this._fov=i*vd,this._calcMatrices(),this._renderLayers(),this._fireEvent("fovchange",{from:g,to:this.getFov()}),this},getBearing:function(){return this._angle?-this._angle/vd:0},setBearing:function(i){var g={bearing:i};return this._validateView(g),this._mapAnimPlayer&&this._stopAnim(this._mapAnimPlayer),this._setBearing(g.bearing)},_setBearing:function(i){if($t.ie9)throw new Error("map can't rotate in IE9.");var g=-Cn(i,-180,180)*vd;if(this._angle===g)return this;var m=this.getBearing();return this._fireEvent("rotatestart",{from:m,to:g}),this._angle=g,this._calcMatrices(),this._renderLayers(),this._fireEvent("rotate",{from:m,to:g}),this._fireEvent("rotateend",{from:m,to:g}),this},getPitch:function(){return this._pitch?this._pitch/Math.PI*180:0},setPitch:function(i){var g={pitch:i};return this._validateView(g),this._mapAnimPlayer&&this._stopAnim(this._mapAnimPlayer),this._setPitch(g.pitch)},_setPitch:function(i){if($t.ie9)throw new Error("map can't tilt in IE9.");var g=Pn(i,0,this.options.maxPitch)*vd;if(this._pitch===g)return this;var m=this.getPitch();return this._fireEvent("pitchstart",{from:m,to:g}),this._pitch=g,this._calcMatrices(),this._renderLayers(),this._fireEvent("pitch",{from:m,to:g}),this._fireEvent("pitchend",{from:m,to:g}),this},setCameraMovements:function(i,g){var m=this;if(!Array.isArray(i)||!i.length)return this;if(i.forEach((function(i){m._validateView(i)})),this.setView({center:i[0].center,zoom:i[0].zoom,pitch:i[0].pitch,bearing:i[0].bearing}),1===i.length)return this;var _=1,b=function(T){if("finished"===T.state.playState){++_===i.length-1&&(b=null);var P=i[_];P.duration=P.timestamp-i[_-1].timestamp,g&&g.autoRotate&&(P.bearing=function(i,g){var m=Xe(i[0]),_=Xe(g[0]),b=Xe(i[1]),T=Xe(g[1]),P=Math.sin(_-m)*Math.cos(T),I=Math.cos(b)*Math.sin(T)-Math.sin(b)*Math.cos(T)*Math.cos(_-m);return Ze(Math.atan2(P,I))}(i[_-1].center,P.center)),m._setCameraMovement(P,b)}};2===i.length&&(b=null);var T=this.getBearing();this._setCameraMovement(Object.assign({bearing:T,duration:i[_].timestamp-i[_-1].timestamp},i[_]),b);return{play:function(){m._animPlayer.play()},pause:function(){m._animPlayer.pause()},cancel:function(){m._animPlayer.cancel()},finish:function(){m._animPlayer.finish()},reverse:function(){m._animPlayer.reverse()}}},_setCameraMovement:function(i,g){this.animateTo({zoom:i.zoom,center:i.center,pitch:i.pitch,bearing:i.bearing},{duration:i.duration,easing:"out"},g)},lookAt:function(i){var{coordinates:g,bearing:m,pitch:_,distance:b}=i;if(g=i.center||g,Array.isArray(g)&&(g=new pl(g)),!g.z&&!b)return this.setCenter(g);var T=this.getGLRes();m=H(m)?this.getBearing():m;var P=(_=H(_)?this.getPitch():_)*vd,I=m*vd;if(b){var W=b*Math.sin(P),q=Math.sin(P)*b,$=q*Math.sin(I),ye=q*Math.cos(I);W*=this._meterToGLPoint,q=this.distanceToPointAtRes($,ye,T).mag(),b=Math.sqrt(q*q+W*W)}var Re=this.coordToPointAtRes(g,T);Re.z=0,g.z&&(Re.z=g.z*this._meterToGLPoint);var Be=b||this.cameraToGroundDistance||this.cameraToCenterDistance,Ge=Math.sin(P)*Be,je=Be*Math.cos(P),Xe=Re.x-Ge*Math.sin(I),Ze=Re.y-Ge*Math.cos(I),Ye=new un([Xe,Ze,je+Re.z]),Qe=this.pointAtResToCoord(Ye,T);return Qe.z=Ye.z/this._meterToGLPoint,this.setCameraOrientation({position:Qe.toArray(),bearing:m,pitch:_})},setCameraOrientation:function(i){var{position:g}=i;this._validateView(i);var{pitch:m,bearing:_}=i;m=m||0,_=_||0;var{zoom:b,cameraToGroundDistance:T}=this.getFitZoomForCamera(g,m),P=Math.sin(m*vd)*T,I=Cn(_,-180,180)*vd,H=this.getGLRes(),W=new pl(g[0],g[1]),q=this.coordToPointAtRes(W,H),$=new un(0,0);$.x=q.x+P*Math.sin(I),$.y=q.y+P*Math.cos(I);var ye=this._pointToPrjAtRes($,this.getGLRes());return this._setPrjCenter(ye),this.setView({bearing:_,pitch:m,zoom:b}),this},setCameraPosition:function(i){var g=this.getGLRes(),m=this.coordToPointAtRes(i,g);m.z=this.altitudeToPoint(i.z||0,g);var _=this.getCenter(),b=this.coordToPointAtRes(_,g);b.z=this.altitudeToPoint(_.z,g);var T=rs([],m.toArray(),b.toArray());return es(this.cameraUp||[0,0,0],0,0,1),this._pitch=ds(T,this.cameraUp),es(Td,T[0],T[1],0),this._angle=-ds(Td,wd),this._zoomLevel=this.getFitZoomForCamera(i,this._pitch).zoom,this._calcMatrices(),this},getFitZoomForCamera:function(i,g){W(g)||(g=0);var m=Array.isArray(i)?i[2]||0:i.z||0,_=(this.centerAltitude||0)*this._meterToGLPoint,b=(m*this._meterToGLPoint-_)/Math.cos(g*vd);return{zoom:this.getFitZoomForAltitude(b+_),cameraToGroundDistance:b}},getFitZoomForAltitude:function(i){var g=i*this._getFovRatio()*2/(this.height||1)*this.getGLRes();return this.getZoomFromRes(g)},isTransforming:function(){return!!(this._pitch||this._angle||this._terrainLayer)},getFrustumAltitude:function(){return this._frustumAltitude},_calcFrustumAltitude:function(){var i=90-this.getPitch(),g=this.getFov()/2,m=this.cameraPosition?this.cameraPosition[2]:0;if(g<=i)return m;g=Math.PI*g/180;var _=new un(this.cameraPosition).distanceTo(new un(this.cameraLookAt)),b=m*Math.tan(2*g);return m+Math.tan(g)*(_+b)},_pointToContainerPoint:function(i,g,m=0,_){var b=this._getResolution(g);return this._pointAtResToContainerPoint(i,b,m,_)},_pointAtResToContainerPoint:function(i,g,m=0,_){_||(_=new un(0,0)),i=this._pointAtResToPoint(i,g,_);var b,T=this.isTransforming();return T||m||(b=this._prjToPoint(this._getPrjCenter(),void 0,xd)),this._toContainerPoint(_,T,m,b),_},_pointsAtResToContainerPoints:function(i,g,m=[],_=[]){var b=this.getPitch(),T=this.getBearing(),P=g/this._getResolution();if(0===b&&0===T&&!lc(m)){var{xmin:I,ymin:H,xmax:W,ymax:q}=this.get2DExtent();if(W>I&&q>H){for(var{width:$,height:ye}=this.getSize(),Re=(W-I)/$,Be=(q-H)/ye,Ge=0,je=i.length;Ge<je;Ge++)if(i[Ge]){var Xe=_[Ge];Xe.x=i[Ge].x,Xe.y=i[Ge].y,Xe._multi(P),Xe.x=(Xe.x-I)*Re,Xe.y=ye-(Xe.y-H)*Be}else _[Ge]=null;return _}}for(var Ze=Array.isArray(m),Ye=this.isTransforming(),Qe=this._prjToPoint(this._getPrjCenter(),void 0,xd),Je=0,Ke=i.length;Je<Ke;Je++)if(i[Je]){var et=_[Je];et.x=i[Je].x,et.y=i[Je].y,et._multi(P),this._toContainerPoint(et,Ye,Ze?m[Je]||0:m,Qe)}else _[Je]=null;return _},_toContainerPoint:function(){var i=[0,0,0];return function(g,m,_,b){var T=this.width/2,P=this.height/2;if(m||_){this._altitudeScale||(this._altitudeScale=this.altitudeToPoint(100,this.getGLRes())/100);var I=this._glScale;es(i,g.x*I,g.y*I,_*this._altitudeScale);var H=this._projIfBehindCamera(i,this.cameraPosition,this.cameraForward);yd(H,H,this.projViewMatrix),g.x=H[0]*T+T,g.y=-H[1]*P+P}else g._sub(b.x,b.y),g.set(g.x,-g.y),g._add(T,P)}}(),_projIfBehindCamera:function(){var i=new Array(3),g=new Array(3),m=new Array(3);return function(_,b,T){rs(i,_,b);var P=ls(T,i);return P<=0&&(hs(g,T,1.01*P),ts(_,b,rs(m,i,g))),_}}(),_containerPointToPoint:function(i,g,m,_){var b=this._getResolution(g);return this._containerPointToPointAtRes(i,b,m,_)},_containerPointToPointAtRes:function(){var i=[0,0,0],g=[0,0,0];return function(m,_,b,T){if(this.isTransforming()){this.getContainerPointRay(i,g,m);var P=i[0],I=g[0],H=i[1],W=g[1],q=i[2],$=g[2],ye=T?this.altitudeToPoint(T,_)*this._glScale:0,Re=q===$?ye:(ye-q)/($-q),Be=Mn(P,I,Re),Ge=Mn(H,W,Re);return b?(b.x=Be,b.y=Ge):b=new un(Be,Ge),b._multi(1/this._glScale),this._getResolution()===_?b:this._pointToPointAtRes(b,_,b)}var je=this._prjToPointAtRes(this._getPrjCenter(),_,b),Xe=this._getResolution()/_;return je._add(Xe*(m.x-this.width/2),-(Xe*(m.y-this.height/2)))}}(),getContainerPointRay:function(){var i=[0,0,0],g=[0,0,0,1],m=[0,0,0,1];return function(_,b,T,P=0,I=1){var H=this.width/2||1,W=this.height/2||1;es(i,(T.x-H)/H,(W-T.y)/W,0),es(g,i[0],i[1],P),es(m,i[0],i[1],I),g[3]=m[3]=1,yd(_,g,this.projViewMatrixInverse),yd(b,m,this.projViewMatrixInverse)}}(),_calcMatrices:(_d=Sd(),function(){delete this._mapRes,delete this._mapGlRes,delete this._mapExtent2D,delete this._mapGlExtent2D;var i=this.getSize(),g=i.width||1,m=i.height||1;this._glScale=this.getGLScale();var _=this._getCameraWorldMatrix(),b=this.getFov()*Math.PI/180,T=this._getCameraFar(b,this.getPitch());this.cameraFar=T,this.cameraNear=this.cameraCenterDistance/20;var P=this.projMatrix||Sd();_o(P,b,g/m,this.cameraNear,T),this.projMatrix=P,this.viewMatrix=So(this.viewMatrix||Sd(),_),this.projViewMatrix=To(this.projViewMatrix||Sd(),P,this.viewMatrix),this._calcCascadeMatrixes(),this.projViewMatrixInverse=To(this.projViewMatrixInverse||Sd(),_,So(_d,P)),this.domCssMatrix=this._calcDomMatrix(),this._frustumAltitude=this._calcFrustumAltitude(),this._mapRes=this._getResolution(),this._mapGlRes=this.getGLRes(),this._mapExtent2D=this.get2DExtent(),this._mapGlExtent2D=this.get2DExtentAtRes(this._mapGlRes)}),_getCameraFar:function(i,g){var m=this.cameraCenterDistance=fs(this.cameraPosition,this.cameraLookAt),_=m/this._meterToGLPoint;g=(g=Math.min(g,85))*Math.PI/180;var b=_+this.options.cameraFarUndergroundInMeter/Math.cos(g);return Math.max(b*this._meterToGLPoint,5*m)},_calcCascadeMatrixes:function(){var i=Sd();function g(g,m,_){var b=this.width,T=this.height,P=this.getFov()*Math.PI/180,I=this._getCameraFar(P,m),H=this.cameraCenterDistance;return I=H+(I-H)/Math.cos((90-m)*Math.PI/180)*Math.cos((90-g)*Math.PI/180),_o(i,P,b/T,.1,I),To(_,i,this.viewMatrix)}return function(){var i=this.getPitch(),m=this.options.cascadePitches[0],_=this.options.cascadePitches[1],b=this.cascadeFrustumMatrix0=this.cascadeFrustumMatrix0||Sd(),T=this.cascadeFrustumMatrix1=this.cascadeFrustumMatrix1||Sd();i>m?g.call(this,i,m,b):Co(this.cascadeFrustumMatrix0,this.projViewMatrix),i>_?g.call(this,i,_,T):Co(this.cascadeFrustumMatrix1,this.cascadeFrustumMatrix0)}}(),_calcDomMatrix:function(){var i=Sd(),g=Sd(),m=[1,-1,1],_=[0,0,0];return function(){var b=this.width||1,T=this.height||1,P=.5/Math.tan(this._fov/2)*T;return xo(i,this.projMatrix,m),vo(i,i,es(_,0,0,-P)),this._pitch&&bo(i,i,this._pitch),this._angle&&wo(i,i,this._angle),Mo(g),xo(g,g,es(_,b/2,-T/2,1)),To(this.domCssMatrix||Sd(),g,i)}}(),_getFovZ:function(i){var g=this.getGLScale(i),m=this._getFovRatio();return g*(this.height||1)/2/m},_getCameraWorldMatrix:function(){var i={};return function(){var g=this.getGLRes();this._meterToGLPoint||(this._meterToGLPoint=this.altitudeToPoint(100,g)/100);var m=this._prjToPointAtRes(this._prjCenter,g,bd),_=this.getCenter().z,b=(void 0!==_?_:this.centerAltitude||0)*this._meterToGLPoint;this.cameraLookAt=es(this.cameraLookAt||[0,0,0],m.x,m.y,b);var T=this.getPitch()*vd,P=this.getBearing()*vd,I=this._getFovZ(),H=(void 0===this.cameraZenithDistance?I:this.cameraZenithDistance)-b;this.cameraToGroundDistance=H;var W=H*Math.cos(T),q=Math.sin(T)*H,$=m.x-q*Math.sin(P),ye=m.y-q*Math.cos(P);this.cameraPosition=es(this.cameraPosition||[0,0,0],$,ye,W+b),this.cameraToCenterDistance=I,this.cameraUp=this.cameraUp||[0,0,0],this.cameraUp=this._getCameraUp(this.cameraUp,this.cameraLookAt,this.cameraPosition,T,P);var Re=this.cameraWorldMatrix=this.cameraWorldMatrix||Sd();!function(i,g,m,_){var b=[0,0,0],T=[0,0,0],P=[0,0,0];rs(P,g,m),0===os(P)&&(P[2]=1),ss(P,P),cs(b,_,P),0===os(P)&&(1===Math.abs(_[2])?P[0]+=1e-4:P[2]+=1e-4,ss(P,P),cs(b,_,P)),ss(b,b),cs(T,P,b),i[0]=b[0],i[4]=T[0],i[8]=P[0],i[1]=b[1],i[5]=T[1],i[9]=P[1],i[2]=b[2],i[6]=T[2],i[10]=P[2]}(Re,this.cameraPosition,this.cameraLookAt,this.cameraUp);var Be=this.cameraForward||[0,0,0];return rs(Be,this.cameraLookAt,this.cameraPosition),this.cameraForward=ss(Be,Be),function(i,g){var m,_=g[0],b=g[4],T=g[8],P=g[1],I=g[5],H=g[9],W=g[2],q=g[6],$=g[10],ye=_+I+$;ye>0?(m=.5/Math.sqrt(ye+1),i.w=.25/m,i.x=(q-H)*m,i.y=(T-W)*m,i.z=(P-b)*m):_>I&&_>$?(m=2*Math.sqrt(1+_-I-$),i.w=(q-H)/m,i.x=.25*m,i.y=(b+P)/m,i.z=(T+W)/m):I>$?(m=2*Math.sqrt(1+I-_-$),i.w=(T-W)/m,i.x=(b+P)/m,i.y=.25*m,i.z=(H+q)/m):(m=2*Math.sqrt(1+$-_-I),i.w=(P-b)/m,i.x=(T+W)/m,i.y=(H+q)/m,i.z=.25*m)}(i,Re),function(i,g){var m=i,_=g.x,b=g.y,T=g.z,P=g.w,I=_+_,H=b+b,W=T+T,q=_*I,$=_*H,ye=_*W,Re=b*H,Be=b*W,Ge=T*W,je=P*I,Xe=P*H,Ze=P*W;m[0]=1-(Re+Ge),m[4]=$-Ze,m[8]=ye+Xe,m[1]=$+Ze,m[5]=1-(q+Ge),m[9]=Be-je,m[2]=ye-Xe,m[6]=Be+je,m[10]=1-(q+Re),m[3]=0,m[7]=0,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1}(Re,i),function(i,g){var m=i;m[12]=g[0],m[13]=g[1],m[14]=g[2]}(Re,this.cameraPosition),Re}}(),_getCameraUp:function(){var i=[0,0,0],g=[0,0,0],m=[0,0,0];return function(_,b,T,P,I){es(m,0,0,1),0===P?es(m,Math.sin(I),Math.cos(I),0):P===Math.PI&&es(m,-Math.sin(I),-Math.cos(I),0);var H=rs(i,b,T);ss(H,H);var W=cs(g,H,m);return cs(_,W,H)}}(),updateCenterAltitude:function(){this.getRenderer().setToRedraw(),!this.centerAltitude&&this._hasAltitudeLayer()&&(this.centerAltitude=0),this._recenterOnTerrain()},_recenterOnTerrain:function(){if(void 0!==this.centerAltitude){var i=this._queryTerrainByProjCoord(this._prjCenter);H(i)&&this._hasAltitudeLayer()&&(i=this.centerAltitude);var g=i>0&&i||0,m=this.getPitch()*vd,_=this.getBearing()*vd,b=(g-this.centerAltitude)*this._meterToGLPoint,T=this._getFovZ(),P=(void 0===this.cameraZenithDistance?T:this.cameraZenithDistance)-this.centerAltitude*this._meterToGLPoint-b/Math.cos(m),I=this.cameraPosition,W=Math.sin(m)*P,q=bd;q.x=I[0]+W*Math.sin(_),q.y=I[1]+W*Math.cos(_);var $=g*this._meterToGLPoint;this.cameraZenithDistance=(I[2]-$)/Math.cos(m)+$,this.centerAltitude=g;var ye=this.pointAtResToCoordinate(q,this.getGLRes(),xd);this._eventSilence=!0,this._suppressRecenter=!0,this.setCenter(ye),delete this._suppressRecenter,delete this._eventSilence,H(i)&&delete this.centerAltitude}},_queryTerrainByProjCoord:function(i){for(var g=this._getLayers(),m=0;m<g.length;m++)if(g[m].queryTerrainByProjCoord)return g[m].queryTerrainByProjCoord(i)[0];return 0},_hasAltitudeLayer:function(){for(var i=this._getLayers(),g=0;g<i.length;g++)if(i[g].getTerrainLayer&&i[g].getTerrainLayer())return!0;return!1},_queryTerrainInfo:function(i){if(i){var g=this._findTerrainLayer();if(!g)return null;var m=g.queryTerrainAtPoint(i);if(m)return{coordinate:m,altitude:m.z}}return null},_query3DTilesInfo:function(i){for(var g=this._getLayers()||[],m=0;m<g.length;m++){var _=g[m];if(i&&_&&_.query3DTilesAtPoint){var b=_.query3DTilesAtPoint(i);if(b)return{coordinate:b,altitude:b.z};break}}return null},queryPrjCoordAtContainerPoint:function(i){var g=this._query3DTilesInfo(i);if(g||(g=this._queryTerrainInfo(i)),g){var m=this.getProjection().project(g.coordinate);return m.z=g.altitude,m}return this._isContainerPointOutOfMap(i)&&(i=new un(this.width/2,this.height/2)),this._containerPointToPrj(i)},_getFovRatio:function(){var i=this.getFov();return Math.tan(i/2*vd)},_renderLayers:function(){this.isInteracting()||this._getLayers().forEach((function(i){if(i){var g=i._getRenderer();g&&g.setToRedraw&&g.setToRedraw()}}))}}),Uu.include({_onViewChange:function(i){this._viewHistory||(this._viewHistory=[],this._viewHistoryPointer=0);for(var g=this._getCurrentView(),m=this._viewHistory.length-1;m>=0;m--)if(Un(i,this._viewHistory[m]))return this._viewHistoryPointer=m,void this._fireViewChange(g,i);this._viewHistoryPointer<this._viewHistory.length-1&&this._viewHistory.splice(this._viewHistoryPointer+1),this._viewHistory.push(i);var _=this.options.viewHistoryCount;_>0&&this._viewHistory.length>_&&this._viewHistory.splice(0,this._viewHistory.length-_),this._viewHistoryPointer=this._viewHistory.length-1,this._fireViewChange(g,i)},zoomToPreviousView:function(i={}){if(!this.hasPreviousView())return null;var g=this._viewHistory[--this._viewHistoryPointer];return this._zoomToView(g,i),g},hasPreviousView:function(){return!(!this._viewHistory||0===this._viewHistoryPointer)},zoomToNextView:function(i={}){if(!this.hasNextView())return null;var g=this._viewHistory[++this._viewHistoryPointer];return this._zoomToView(g,i),g},hasNextView:function(){return!(!this._viewHistory||this._viewHistoryPointer===this._viewHistory.length-1)},_zoomToView:function(i,g){var m=this,_=this.getView();g.animation?this._animateTo(i,{duration:g.duration},(function(g){"finished"===g.state.playState&&m._fireViewChange(_,i)})):(this.setView(i),this._fireViewChange(_,i))},getViewHistory:function(){return this._viewHistory},_fireViewChange:function(i,g){this._fireEvent("viewchange",{old:i,new:g}),this._insertUICollidesQueue()},_getCurrentView:function(){return this._viewHistory?this._viewHistory[this._viewHistoryPointer]:null}}),Uu.mergeOptions({viewHistory:!0,viewHistoryCount:10});var Md=new va;Uu.include({getCollisionIndex:function(){return this._collisionIndex||this.createCollisionIndex(),this._collisionIndex||this.createCollisionIndex()},createCollisionIndex:function(){return this.clearCollisionIndex(),this._collisionIndex=new va,this._collisionIndex},clearCollisionIndex:function(){return this.collisionFrameTime=0,this._collisionIndex&&this._collisionIndex.clear(),this},_insertUICollidesQueue:function(){return this._uiCollidesQueue||(this._uiCollidesQueue=[]),this._uiCollidesQueue.push(1),this},uiCollides:function(){if(!this.uiList||0===this.uiList.length||!this._uiCollidesQueue||0===this._uiCollidesQueue.length)return this;var i=Md;i.clear();for(var g=this.uiList,m=0,_=g.length;m<_;m++){var b=g[m],{collisionBufferSize:T,collision:P}=b.options;if(P){var I=b.getDOM();if(b.isVisible()&&I&&I.getBoundingClientRect){b.bbox||(b.bbox=[0,0,0,0]);var H=I.getBoundingClientRect(),{x:W,y:q}=H,{width:$,height:ye}=H;if(0===$||0===ye){var Re=b.getSize();Re&&($=Re.width,ye=Re.height)}var Be=W+$+T,Ge=q-T,je=q+ye+T;b.bbox[0]=W-T,b.bbox[1]=Ge,b.bbox[2]=Be,b.bbox[3]=je,i.collides(b.bbox)?b._collidesEffect(!1):(i.insertBox(b.bbox),b._collidesEffect(!0))}}else b._collidesEffect(!0)}return this._uiCollidesQueue=[],this},_addUI:function(i){return this.uiList||(this.uiList=[]),this.uiList.indexOf(i)>-1?this:(this.uiList.push(i),this._sortUI())},_sortUI:function(){return this.uiList=this.uiList||[],this.uiList=this.uiList.sort((function(i,g){return g.options.collisionWeight-i.options.collisionWeight})),this},_removeUI:function(i){if(!this.uiList)return-1;var g=this.uiList.indexOf(i);return g<0||this.uiList.splice(g,1),g}});var Cd,Pd=new pl(0,0);Uu.include({coordinateToPoint:function(i,g,m){var _=this._getResolution(g);return this.coordinateToPointAtRes(i,_,m)},coordinateToPointAtRes:function(){var i=new pl(0,0);return function(g,m,_){var b=this.getProjection().project(g,i);return this._prjToPointAtRes(b,m,_)}}(),pointToCoordinate:function(){var i=new pl(0,0);return function(g,m,_){var b=this._pointToPrj(g,m,i);return this.getProjection().unproject(b,_)}}(),pointAtResToCoordinate:function(){var i=new pl(0,0);return function(g,m,_){var b=this._pointToPrjAtRes(g,m,i);return this.getProjection().unproject(b,_)}}(),coordinateToViewPoint:function(){var i=new pl(0,0);return function(g,m,_){return this._prjToViewPoint(this.getProjection().project(g,i),m,_)}}(),viewPointToCoordinate:function(){var i=new pl(0,0);return function(g,m){return this.getProjection().unproject(this._viewPointToPrj(g,i),m)}}(),coordinateToContainerPoint:function(i,g,m){var _=this._getResolution(g);return this.coordinateToContainerPointAtRes(i,_,m)},coordinateToContainerPointAtRes:function(){var i=new pl(0,0);return function(g,m,_){var b=this.getProjection().project(g,i);return this._prjToContainerPointAtRes(b,m,_,b.z)}}(),coordinatesToContainerPoints:function(i,g){var m=this._getResolution(g);return this.coordinatesToContainerPointsAtRes(i,m)},coordinatesToContainerPointsAtRes:function(i,g){for(var m=[],_=this._spatialReference.getTransformation(),b=g/this._getResolution(),T=this.getProjection(),P=new pl(0,0),I=this.isTransforming(),H=this._prjToPoint(this._getPrjCenter(),void 0,Pd),W=0,q=i.length;W<q;W++){var $=T.project(i[W],P),ye=_.transform($,g);ye=ye._multi(b),this._toContainerPoint(ye,I,i[W].z,H),m.push(ye)}return m},containerPointToCoordinate:function(){var i=new pl(0,0);return function(g,m){var _=this._containerPointToPrj(g,i);return this.getProjection().unproject(_,m)}}(),containerToExtent:function(){var i=new un(0,0),g=new un(0,0);return function(m){var _=new kl(this._containerPointToPoint(m.getMin(i),void 0,i),this._containerPointToPoint(m.getMax(g),void 0,g));return this._pointToExtent(_)}}(),distanceToPixel:function(){var i=new un(0,0),g=new un(0,0);return function(m,_,b){var T=this.getProjection();if(!T)return null;var P=this.getScale()/this.getScale(b),I=this.getCenter(),H=T.locate(I,m,_),W=this.coordToContainerPoint(I,void 0,i),q=this.coordToContainerPoint(H,void 0,g);return q._sub(W)._multi(P)._abs(),new ir(q.x,q.y)}}(),distanceToPoint:function(i,g,m,_){var b=this._getResolution(m);return this.distanceToPointAtRes(i,g,b,_)},distanceToPointAtRes:function(){var i=new un(0,0),g=new pl(0,0);return function(m,_,b,T,P){var I=this.getProjection();if(!I)return null;var H=T||this.getCenter(),W=I.locate(H,m,_,g),q=this.coordToPointAtRes(H,b,i),$=this.coordToPointAtRes(W,b,P);return $._sub(q)._abs(),$}}(),altitudeToPoint:function(){var i=new pl(0,40),g=new un(0,0);return function(m=0,_,b){this._altitudeOriginDirty&&(i.x=this._originLng,this._altitudeOriginDirty=!1);var T=this.distanceToPointAtRes(m,m,_,b||i,g),P=this.options.heightFactor;return P&&1!==P&&(T.x*=P,T.y*=P),T.x*Math.sign(m)}}(),pointAtResToAltitude:(Cd=new pl(0,40),function(i=0,g,m){return this.pointAtResToDistance(i,0,g,m||Cd)*Math.sign(i)}),pixelToDistance:function(){var i=new pl(0,0),g=new pl(0,0),m=new pl(0,0),_=new pl(0,0);return function(b,T){var P=this.getProjection();if(!P)return null;var I=this.getFullExtent(),H=I.top>I.bottom?-1:1,W=i.set(this.width/2,this.height/2),q=g.set(this.width/2+b,this.height/2+H*T),$=this.containerPointToCoord(W,m),ye=this.containerPointToCoord(q,_);return P.measureLength($,ye)}}(),pointToDistance:function(i,g,m){var _=this.getResolution(m);return this.pointAtResToDistance(i,g,_)},pointAtResToDistance:function(){var i=new un(0,0),g=new pl(0,0),m=new pl(0,0),_=new pl(0,0);return function(b,T,P,I){var H=this.getProjection();if(!H)return null;var W=I?H.project(I,g):this._getPrjCenter(),q=this._prjToPointAtRes(W,P,i);q._add(b,T);var $=this.pointAtResToCoord(q,P,m),ye=I||H.unproject(W,_);return ye.z=0,$.z=0,H.measureLength(ye,$)}}(),locateByPoint:function(){var i=new un(0,0);return function(g,m,_){var b=this.coordToContainerPoint(g,void 0,i);return this.containerPointToCoord(b._add(m,_))}}(),_get2DExtent:function(i,g){var m;if(void 0!==i&&i!==this._zoomLevel||!this._mapExtent2D||(m=this._mapExtent2D),m)return g?(g.set(m.xmin,m.ymin,m.xmax,m.ymax),g):m.copy();var _=this._getResolution(i);return this._get2DExtentAtRes(_,g)},get2DExtent:function(i,g){return this._get2DExtent(i,g)},_get2DExtentAtRes:function(){var i=new un(0,0);return function(g,m){var _=this;return g===this._mapGlRes&&this._mapGlExtent2D?this._mapGlExtent2D:this.getContainerExtent().convertTo((function(m){return _._containerPointToPointAtRes(m,g,i)}),m)}}(),get2DExtentAtRes:function(i,g){return this._get2DExtentAtRes(i,g)},pointToExtent:function(i){return this._pointToExtent(i)},_pointToExtent:function(){var i=new pl(0,0),g=new pl(0,0);return function(m){var _=m.getMin(),b=m.getMax(),T=this.getFullExtent(),[P,I]=!T||T.left<=T.right?[_.x,b.x]:[b.x,_.x],[H,W]=!T||T.top>T.bottom?[b.y,_.y]:[_.y,b.y],q=_.set(P,W),$=b.set(I,H);return new Pl(this.pointToCoord(q,void 0,i),this.pointToCoord($,void 0,g),this.getProjection())}}(),getViewPointFrameOffset:function(){var i=new un(0,0);return function(){if(this.isZooming())return null;var g=this._getPrjCenter();return this._mapViewCoord&&!this._mapViewCoord.equals(g)?this._prjToContainerPoint(this._mapViewCoord)._sub(this._prjToContainerPoint(g,void 0,i)):null}}(),_viewPointToPrj:function(){var i=new un(0,0);return function(g,m){return this._containerPointToPrj(this.viewPointToContainerPoint(g,i),m)}}(),viewPointToPrj:function(i,g){return this._viewPointToPrj(i,g)},_prjToContainerPoint:function(i,g,m,_){var b=this._getResolution(g);return this._prjToContainerPointAtRes(i,b,m,_)},prjToContainerPoint:function(i,g,m,_){return this._prjToContainerPoint(i,g,m,_)},_prjToContainerPointAtRes:function(){var i=new un(0,0);return function(g,m,_,b){return this._pointAtResToContainerPoint(this._prjToPointAtRes(g,m,i),m,b||0,_)}}(),prjToContainerPointAtRes:function(i,g,m,_){return this.prjToContainerPointAtRes(i,g,m,_)},_prjToViewPoint:function(){var i=new un(0,0);return function(g,m,_){var b=this._prjToContainerPoint(g,void 0,i,_);return this.containerPointToViewPoint(b,m)}}(),prjToViewPoint:function(i,g,m){return this._prjToViewPoint(i,g,m)},_viewPointToPoint:function(){var i=new un(0,0);return function(g,m,_){return this._containerPointToPoint(this.viewPointToContainerPoint(g,i),m,_)}}(),viewPointToPoint:function(i,g,m){return this._viewPointToPoint(i,g,m)},_pointToViewPoint:function(){var i=new pl(0,0);return function(g,m,_){return this._prjToViewPoint(this._pointToPrj(g,m,i),_)}}(),pointToViewPoint:function(i,g,m){return this._pointToViewPoint(i,g,m)}});var Id={distancetool:{start:"起点",units:{mile:" 英里",feet:" 英尺",kilometer:" 公里",meter:" 米"}},areatool:{units:{mile:" 平方英里",feet:" 平方英尺",kilometer:" 平方公里",meter:" 平方米"}}},kd={distancetool:{start:"Inicio",units:{mile:" mi",feet:" ft",kilometer:" km",meter:" m"}},areatool:{units:{mile:" mi²",feet:" ft²",kilometer:" km²",meter:" m²"}}},Od={distancetool:{start:"Start",units:{mile:" mi",feet:" ft",kilometer:" km",meter:" m"}},areatool:{units:{mile:" mi²",feet:" ft²",kilometer:" km²",meter:" m²"}}},Ed=function(i){function g(g){var m;return(m=i.call(this,"Translator: "+g)||this).name="TranslatorError",m}return tn(g,i),g}(an(Error)),Rd=function(i){function g(g){var m;return(m=i.call(this)||this).languages={"zh-CN":Id,"es-MX":kd,"en-US":Od},m.setLang(g||"zh-CN"),m}tn(g,i);var m=g.prototype;return m.setLang=function(i){var g=this.languages[i];if(!g)throw new Ed("Setted Lang does not exist");this.nodes=g},m._validateNestedProps=function(i){i.forEach((function(i){if(""===i)throw new Ed('Any of sides of a dot "." cannot be empty')}))},m.translate=function(i=null){if(null==i)throw new Ed("Missing parameter textNode");if("string"!=typeof i)throw new Ed("Param passed has to be a String");if(!i.includes("."))return this.nodes[i];var g=i.split(".");if(g.length>3)throw new Ed("Translate function can only access through 3 nested properties, trying to access -> "+g.length);this._validateNestedProps(g);try{var m=null;switch(g.length){case 2:m=this.nodes[g[0]][g[1]];break;case 3:m=this.nodes[g[0]][g[1]][g[2]]}return m}catch(i){throw new Ed("Unable to find the text translated in lang json"+i.message)}},g}(Ya),Ld=function(i){function g(g){var m;return(m=i.call(this,g)||this).on("enable",m._afterEnable,m).on("disable",m._afterDisable,m),m._measureLayers=[],m.translator=new Rd(m.options.language),m}tn(g,i);var m=g.prototype;return m.clear=function(){if(kn(this._measureLayers))for(var i=0;i<this._measureLayers.length;i++)this._measureLayers[i].remove();return delete this._lastMeasure,delete this._lastVertex,this._outLayers(this._measureLayers),this._measureLayers=[],this},m.getMeasureLayers=function(){return this._measureLayers},m.getLastMeasure=function(){return this._lastMeasure?this._lastMeasure:0},m.undo=function(){i.prototype.undo.call(this);var g=this._historyPointer;if(g!==this._vertexes.length)for(var m=g;m<this._vertexes.length;m++)this._vertexes[m].label&&this._vertexes[m].label.remove(),this._vertexes[m].marker.remove();return this},m.redo=function(){i.prototype.redo.call(this);var g=this._historyPointer-1;return this._vertexes[g]&&(this._vertexes[g].marker.getLayer()||(this._vertexes[g].label&&this._vertexes[g].label.addTo(this._measureMarkerLayer),this._vertexes[g].marker.addTo(this._measureMarkerLayer))),this},m._formatLabelContent=function(i){var g=this.options.formatLabelContent;return g&&Re(g)?g.call(this,i)+"":null},m._measure=function(i){var g,m=this.getMap();i instanceof gu?g=m.computeGeometryLength(i):Array.isArray(i)&&(g=m.getProjection().measureLength(i)),this._lastMeasure=g;var _=this._formatLabelContent(g);if(_)return _;var b=[this.translator.translate("distancetool.units.meter"),this.translator.translate("distancetool.units.kilometer"),this.translator.translate("distancetool.units.feet"),this.translator.translate("distancetool.units.mile")],T="",P=this.options.decimalPlaces;return this.options.metric&&(T+=g<1e3?g.toFixed(P)+b[0]:(g/1e3).toFixed(P)+b[1]),this.options.imperial&&(T.length>0&&(T+="\n"),T+=(g*=3.2808399)<5280?g.toFixed(P)+b[2]:(g/5280).toFixed(P)+b[3]),T},m._registerMeasureEvents=function(){this.on("drawstart",this._msOnDrawStart,this).on("drawvertex",this._msOnDrawVertex,this).on("mousemove",this._msOnMouseMove,this).on("drawend",this._msOnDrawEnd,this)},m._afterEnable=function(){this._registerMeasureEvents()},m._afterDisable=function(){this.off("drawstart",this._msOnDrawStart,this).off("drawvertex",this._msOnDrawVertex,this).off("mousemove",this._msOnMouseMove,this).off("drawend",this._msOnDrawEnd,this)},m._msOnDrawStart=function(i){var g=this.getMap(),m=gn(),_="distancetool_"+m,b="distancetool_markers_"+m,T=this.options.zIndex,P=this.options.enableAltitude;g.getLayer(_)?(this._measureLineLayer=g.getLayer(_),this._measureMarkerLayer=g.getLayer(b)):(this._measureLineLayer=new nd(_,{zIndex:T,enableAltitude:P}).addTo(g),this._measureMarkerLayer=new nd(b,{zIndex:T,enableAltitude:P}).addTo(g)),this._measureLayers.push(this._measureLineLayer),this._measureLayers.push(this._measureMarkerLayer),this._pushLayers([this._measureLineLayer,this._measureMarkerLayer]);var I=this._getFirstCoordinate()||i.coordinate,H=new yf(I.copy(),{symbol:this.options.vertexSymbol}),W=this.translator.translate("distancetool.start"),q=new Zf(W,I.copy(),this.options.labelOptions);this._lastVertex=q,this._addVertexMarker(H,q)},m._msOnMouseMove=function(i){var g=this._measure(this._msGetCoordsToMeasure(i));if(!this._tailMarker){var m=co(this.options.vertexSymbol);m.markerWidth/=2,m.markerHeight/=2,this._tailMarker=new yf(i.coordinate,{symbol:m}).addTo(this._measureMarkerLayer),this._tailLabel=new Zf(g,i.coordinate,this.options.labelOptions).addTo(this._measureMarkerLayer)}var _=this._getLasttCoordinate()||i.coordinate;this._tailMarker.setCoordinates(_.copy()),this._tailLabel.setContent(g),this._tailLabel.setCoordinates(_.copy())},m._msGetCoordsToMeasure=function(i){return i.geometry.getCoordinates().concat([i.coordinate])},m._msOnDrawVertex=function(i){var g=this._getLasttCoordinate()||i.coordinate,m=i.geometry,_=new yf(g.copy(),{symbol:this.options.vertexSymbol}),b=this._measure(m),T=new Zf(b,g.copy(),this.options.labelOptions);this._addVertexMarker(_,T),this._lastVertex=T},m._addVertexMarker=function(i,g){this._vertexes||(this._vertexes=[]),void 0!==this._historyPointer&&this._vertexes.length>this._historyPointer-1&&(this._vertexes.length=this._historyPointer-1),this._vertexes.push({label:g,marker:i}),this._measureMarkerLayer.addGeometry(i),g&&this._measureMarkerLayer.addGeometry(g)},m._msOnDrawEnd=function(i){if(this._clearTailMarker(),i.geometry.getCoordinates().length<2)return this._lastMeasure=0,void this._clearMeasureLayers();var g=this._lastVertex.getSize();g||(g=new ir(10,10)),this._addClearMarker(this._lastVertex.getCoordinates(),this._lastVertex._getPrjCoordinates(),g.width);var m=i.geometry.copy();m.setCoordinates(i.geometry.getCoordinates()),m.addTo(this._measureLineLayer),this._lastMeasure=m.getLength()},m._addClearMarker=function(i,g,m){var _=this.options.clearButtonSymbol,b={markerDx:(_.markerDx||0)+m,textDx:(_.textDx||0)+m};Array.isArray(_)&&(b=_.map((function(i){return i?{markerDx:(i.markerDx||0)+m,textDx:(i.textDx||0)+m}:null}))),_=co(_,b);var T=new yf(i,{symbol:_}),P=this._measureLineLayer,I=this._measureMarkerLayer,H=this._getDrawLayer?this._getDrawLayer():null;T.on("click",(function(){return P.remove(),I.remove(),H&&H.remove(),!1}),this),T.addTo(this._measureMarkerLayer)},m._clearTailMarker=function(){this._tailMarker&&(this._tailMarker.remove(),delete this._tailMarker),this._tailLabel&&(this._tailLabel.remove(),delete this._tailLabel)},m._clearMeasureLayers=function(){this._measureLineLayer.remove(),this._measureMarkerLayer.remove()},m._getFirstCoordinate=function(){return this._geometry?(this._geometry.getCoordinates()||[])[0]:null},m._getLasttCoordinate=function(){if(!this._geometry)return null;var i=this._geometry.getCoordinates()||[];return i[i.length-1]},g}(ad);Ld.mergeOptions({formatLabelContent:null,decimalPlaces:2,mode:"LineString",language:"zh-CN",metric:!0,imperial:!1,symbol:{lineColor:"#000",lineWidth:3,lineOpacity:1},vertexSymbol:{markerType:"ellipse",markerFill:"#fff",markerLineColor:"#000",markerLineWidth:3,markerWidth:11,markerHeight:11},labelOptions:{textSymbol:{textFaceName:"monospace",textLineSpacing:1,textHorizontalAlignment:"right",textDx:15},boxStyle:{padding:[6,2],symbol:{markerType:"square",markerFill:"#fff",markerFillOpacity:.9,markerLineColor:"#b4b3b3"}}},clearButtonSymbol:[{markerType:"square",markerFill:"#fff",markerLineColor:"#b4b3b3",markerLineWidth:2,markerWidth:15,markerHeight:15,markerDx:20},{markerType:"x",markerWidth:10,markerHeight:10,markerDx:20}]});var Dd=function(i){function g(g){var m;return(m=i.call(this,g)||this).translator=new Rd(m.options.language),m._measureLayers=[],m}tn(g,i);var m=g.prototype;return m._measure=function(i){var g,m=this.getMap();i instanceof gu?g=m.computeGeometryArea(i):Array.isArray(i)&&(g=m.getProjection().measureArea(i)),this._lastMeasure=g;var _=this._formatLabelContent(g);if(_)return _;var b=[this.translator.translate("areatool.units.meter"),this.translator.translate("areatool.units.kilometer"),this.translator.translate("areatool.units.feet"),this.translator.translate("areatool.units.mile")],T="",P=this.options.decimalPlaces;if(this.options.metric&&(T+=g<1e6?g.toFixed(P)+b[0]:(g/1e6).toFixed(P)+b[1]),this.options.imperial){g*=Math.pow(3.2808399,2),T.length>0&&(T+="\n");var I=27878400;T+=g<I?g.toFixed(P)+b[2]:(g/I).toFixed(P)+b[3]}return T},m._msGetCoordsToMeasure=function(i){return i.geometry.getShell().concat([i.coordinate])},m._msOnDrawVertex=function(i){var g=this._getLasttCoordinate()||i.coordinate,m=new yf(g.copy(),{symbol:this.options.vertexSymbol});this._measure(i.geometry),this._lastVertex=m,this._addVertexMarker(m)},m._msOnDrawEnd=function(i){var g;this._clearTailMarker();var m=this.getMap();if(i.point2d)g=m._pointToPrj(i.point2d);else{var _=i.geometry._getPrjCoordinates()||[];g=(_=_.slice(0,_.length-1))[_.length-1]}if(i.geometry.getShell().length<3)return this._lastMeasure=0,void this._clearMeasureLayers();var b=this._measure(i.geometry),T=this._getLasttCoordinate(),P=new Zf(b,T.copy(),this.options.labelOptions).addTo(this._measureMarkerLayer).getSize();P||(P=new ir(10,10)),this._addClearMarker(T.copy(),g,P.width);var I=i.geometry.copy();I.setCoordinates(i.geometry.getCoordinates()),I.addTo(this._measureLineLayer),this._lastMeasure=I.getArea()},g}(Ld);function Fd(i,g,m){var _,b,T=Array.isArray(g);if(T||(g=[g]),m&&m.drawTool&&m.drawTool.options&&(b=m.drawTool.options.transformCoordinate),b&&Re(b))_=g.map((function(g){return i.unproject(g)})),_=_.map((function(i){return b(i,m)||i}));else{if(!m||!m.target||!m.target._queryTerrainInfo)return _=g.map((function(g){return i.unproject(g)})),T?_:_[0];var P=m.target,I=m.enableAltitude;_=g.map((function(g){if(I){var m=P.prjToContainerPoint(g),_=P._queryTerrainInfo(m);if(_&&_.coordinate)return _.coordinate}return i.unproject(g)}))}return T?_:_[0]}Dd.mergeOptions({mode:"Polygon",symbol:{lineColor:"#000000",lineWidth:2,lineOpacity:1,lineDasharray:"",polygonFill:"#ffffff",polygonOpacity:.5},language:"zh-CN"});var Nd={create:function(i,g,m){var _=Fd(i,g[0],m),b=new Df(_,0);return b._firstClick=g[0],b},update:function(i,g,m,_){var b=m.getCenter();m._firstClick&&(b=Fd(i,m._firstClick,_));var T=m.getMap(),P=Fd(i,Array.isArray(g)?g[g.length-1]:g,_),I=T.computeLength(b,P);m.setRadius(I)},generate:function(i){return i}};ad.registerMode("circle",I({clickLimit:2,action:["click","mousemove","click"]},Nd)),ad.registerMode("freeHandCircle",I({action:["mousedown touchstart","mousemove touchmove","mouseup touchend"]},Nd));var Hd={create:function(i,g,m){var _=Fd(i,g[0],m);return new Nf(_,0,0)},update:function(i,g,m,_){var b=m.getMap(),T=m.getCenter(),P=Fd(i,Array.isArray(g)?g[g.length-1]:g,_),I=b.computeLength(T,new pl({x:P.x,y:T.y})),H=b.computeLength(T,new pl({x:T.x,y:P.y}));m.setWidth(2*I),m.setHeight(2*H)},generate:function(i){return i}};ad.registerMode("ellipse",I({clickLimit:2,action:["click","mousemove","click"]},Hd)),ad.registerMode("freeHandEllipse",I({action:["mousedown touchstart","mousemove touchmove","mouseup touchend"]},Hd));var Bd={create:function(i,g){var m=new gf([]);return m._firstClick=g[0],m},update:function(i,g,m,_){var b=m.getMap(),T=_.containerPoint,P=b.prjToContainerPoint(m._firstClick),I=[[P.x,P.y],[T.x,P.y],[T.x,T.y],[P.x,T.y]].map((function(i){return b._containerPointToPrj(new un(i))})),H=Fd(i,I,_);m.setCoordinates(H)},generate:function(i){return i}};ad.registerMode("rectangle",I({clickLimit:2,action:["click","mousemove","click"]},Bd)),ad.registerMode("freeHandRectangle",I({action:["mousedown touchstart","mousemove touchmove","mouseup touchend"]},Bd)),ad.registerMode("point",{clickLimit:1,action:["click","mousemove"],create:function(i,g,m){var _=Fd(i,g[0],m);return new yf(_)},generate:function(i){return i},update:function(i,g,m,_){if(Array.isArray(g)&&(g=g[g.length-1]),!g)return m;var b=Fd(i,g,_);return m.setCoordinates(b),m}});var zd={create:function(i,g,m){var _=Fd(i,g,m),b=new vf(_);return b.setCoordinates(_),b},update:function(i,g,m,_){var b,T=m.getSymbol();Array.isArray(g)?b=g:(b=m._drawPrjs||[]).push(g),m._drawPrjs=b;var P=Fd(i,b,_);m.setCoordinates(P);var I=m.getLayer();if(I){var H=I.getGeometryById("polygon");if(!H&&b.length>=3){if(H=new gf([P],{id:"polygon",zIndex:-1}),T){var W=co(T,{lineOpacity:0});H.setSymbol(W)}H.addTo(I)}H&&H.setCoordinates([P])}},generate:function(i){var g=new gf(i.getCoordinates(),{symbol:i.getSymbol(),properties:i.getProperties()});return g._projCode=i._projCode,g}};ad.registerMode("polygon",I({action:["click","mousemove","dblclick"]},zd)),ad.registerMode("freeHandPolygon",I({action:["mousedown touchstart","mousemove touchmove","mouseup touchend"]},zd));var Vd={create:function(i,g,m){var _=Fd(i,g,m),b=new vf(_);return b.setCoordinates(_),b},update:function(i,g,m,_){var b;Array.isArray(g)?b=g:(b=m._drawPrjs||[]).push(g),m._drawPrjs=b;var T=Fd(i,b,_);m.setCoordinates(T)},generate:function(i){return i}};ad.registerMode("linestring",I({action:["click","mousemove","dblclick"]},Vd)),ad.registerMode("freeHandLinestring",I({action:["mousedown touchstart","mousemove touchmove","mouseup touchend"]},Vd)),ad.registerMode("arccurve",{action:["click","mousemove","dblclick"],create:function(i,g){var m=g.map((function(g){return i.unproject(g)})),_=new Vf(m);return _._setPrjCoordinates(g),_},update:Vd.update,generate:function(i){return i}}),ad.registerMode("quadbeziercurve",{action:["click","mousemove","dblclick"],create:function(i,g){var m=g.map((function(g){return i.unproject(g)})),_=new Gf(m);return _._setPrjCoordinates(g),_},update:Vd.update,generate:function(i){return i}}),ad.registerMode("cubicbeziercurve",{action:["click","mousemove","dblclick"],create:function(i,g){var m=g.map((function(g){return i.unproject(g)})),_=new Uf(m);return _._setPrjCoordinates(g),_},update:Vd.update,generate:function(i){return i}}),ad.registerMode("boxZoom",{action:["mousedown","mousemove","mouseup"],create:function(i,g){var m=i.unproject(g=g[0]),_=new yf(m);return _._firstClick=g,_},update:function(i,g,m,_){var b=m.getMap(),T=b.prjToContainerPoint(m._firstClick),P=_.containerPoint;g=b._containerPointToPrj(new pl(Math.min(T.x,P.x),Math.min(T.y,P.y)));var I=i.unproject(g);m.setCoordinates(I)._setPrjCoordinates(g),m.updateSymbol({markerWidth:Math.abs(T.x-P.x),markerHeight:Math.abs(T.y-P.y)})},generate:function(i){return i}});var Ud=["collision","collisionBufferSize","collisionWeight","collisionFadeIn"],Gd=function(i){function g(g){var m;return(m=i.call(this,g)||this).proxyOptions(),m}tn(g,i);var m=g.prototype;return m._appendCustomClass=function(i){if(!i)return console.warn("dom is null:",i),this;if(this.options.cssName){var g=this.options.cssName;Array.isArray(g)||(g=[g]),g.forEach((function(g){i.classList.add(g)}))}return this},m.onAdd=function(){},m.onRemove=function(){},m.onDomRemove=function(){},m.getEvents=function(){return{}},m.getOwnerEvents=function(){return{}},m.buildOn=function(){return null},m.addTo=function(i){return this._owner=i,this._switchEvents("on"),this.onAdd&&this.onAdd(),this.fire("add"),this},m.getMap=function(){return this._owner?this._owner.getBaseLayer?this._owner:this._owner.getMap():null},m._collides=function(){var i=this.getMap();return i?(i._addUI(this),i._insertUICollidesQueue(),this):this},m._collidesEffect=function(i){var g=this.getDOM();if(!g)return this;if(g.style.visibility=i?"visible":"hidden",!g.classList||!g.classList.add)return this;if(!this.options.collisionFadeIn)return this;var m="mtk-ui-fadein",_=g.classList.contains(m);return i&&!_?g.classList.add(m):!i&&_&&g.classList.remove(m),this},m.show=function(i){var g=this,m=this.getMap();if(!m)return this;this.options.visible=!0,(i=i||this._coordinate||this._owner.getCenter())instanceof pl||(i=new pl(i));var _=this.isVisible();this._onlyUpdatePosition||this.fire("showstart");var b,T=this._getUIContainer();this._coordinate=i,this._onlyUpdatePosition||this._removePrevDOM(),this._mapEventsOn||this._switchMapEvents("on"),(b=this._onlyUpdatePosition?this.__uiDOM:this.__uiDOM=this.buildOn()).eventsPropagation=this.options.eventsPropagation,this._observerDomSize(b);var P=this.options.zIndex;if(!b)return this._onlyUpdatePosition||this.fire("showend"),this._collides(),this.setZIndex(P),this;this._onlyUpdatePosition||this._measureSize(b),this._singleton()&&(b._uiComponent=this,m[this._uiDomKey()]=b),this._setPosition(),b.style[Ir]=null,this._onlyUpdatePosition||T.appendChild(b);var I=this._getAnimation();if(_&&(I.ok=!1),I.ok&&(I.fade&&(b.style.opacity="0"),I.scale)){if(this.getTransformOrigin){var H=this.getTransformOrigin();b.style[Pr]=H}b.style[Cr]=this._toCSSTranslate(this._pos)+" scale(0)"}this.isSupportZoomFilter()||(b.style.display=""),this.options.eventsToStop&&Jr(b,this.options.eventsToStop,Hr);var W=I.transition;return I.ok&&W&&(W&&(b.style[Ir]=W),I.fade&&(b.style.opacity="1"),I.scale&&(b.style[Cr]=this._toCSSTranslate(this._pos)+" scale(1)")),this._onlyUpdatePosition||this.fire("showend"),this._collides(),clearTimeout(this._autoPanId),this.options.autoPan&&(this._autoPanId=setTimeout((function(){g._autoPan()}),32)),this.setZIndex(P),this},m.hide=function(){var i=this;if(!this.getDOM())return this;this._onDomMouseout&&this._onDomMouseout(),this.options.visible=!1;var g=this._getAnimation(),m=this.getDOM();return this.options.animationOnHide||(g.ok=!1),g.ok?(m.style[Ir]=g.transition,setTimeout((function(){m.style.display="none",i.fire("hide")}),this.options.animationDuration)):(m.style.display="none",this.fire("hide")),g.fade&&(m.style.opacity="0"),g.scale&&(m.style[Cr]=this._toCSSTranslate(this._pos)+" scale(0)"),this._switchMapEvents("off"),this._collides(),this},m.isVisible=function(){if(!this.options.visible)return!1;var i=this.getDOM();return this.getMap()&&i&&i.parentNode&&"none"!==i.style.display},m.remove=function(){if(delete this._mapEventsOn,!this._owner)return this;var i=this.getMap();return i&&i._removeUI(this),this.hide(),this._switchEvents("off"),this.onRemove&&this.onRemove(),!this._singleton()&&this.__uiDOM&&this._removePrevDOM(),delete this._owner,this.fire("remove"),this._collides(),this},m.getSize=function(){return this._domContentRect&&this._size&&(this._size.width=this._domContentRect.width,this._size.height=this._domContentRect.height),this._size?this._size.copy():null},m.getOwner=function(){return this._owner},m.getDOM=function(){return this.__uiDOM},m.setZIndex=function(i){if(!W(i))return this;var g=this.getDOM();return g?(g.style.zIndex=i+"",i!==this.options.zIndex&&(this.options.zIndex=i),this):this},m._roundPoint=function(i){return this.options.roundPoint&&(i=i._round()),i},m.getPosition=function(){if(!this.getMap())return null;var i=this._roundPoint(this._getViewPoint());if(this.getOffset){var g=this._roundPoint(this.getOffset());g&&i._add(g)}return i},m._getAnimation=function(){for(var i={fade:!1,scale:!1,ok:!1,transition:""},g=this.options.animation?this.options.animation.split(","):[],m=0;m<g.length;m++){var _=sr(g[m]);"fade"===_?i.fade=!0:"scale"===_&&(i.scale=!0)}var b=null;return i.fade&&(b="opacity "+this.options.animationDuration+"ms"),i.scale&&(b=b?b+",":"",b+=Cr+" "+this.options.animationDuration+"ms"),i.transition=b,i.ok=null!==b,i},m._getViewPoint=function(){var i=0,g=this._coordinate||{};if(W(g.z)?i=g.z:this._owner&&this._owner.getAltitude&&(W(i=this._owner.getAltitude()||0)||(i=0)),this._owner.getLayer){var m=this._owner.getLayer();m&&m.isVectorLayer&&(W(i=this._owner._getAltitude()||0)||(i=0))}var _=this._meterToPoint(this._coordinate,i);return this.getMap().coordToViewPoint(this._coordinate,void 0,_)._add(this.options.dx,this.options.dy)},m._meterToPoint=function(i,g){return g},m._autoPan=function(){var i=this.getMap(),g=this.getDOM();if(g&&i&&!i.isMoving()){var m=this._getViewPoint()._round(),_=i.width,b=i.height,T=i.getContainer();if(g&&T&&g.getBoundingClientRect){var P=T.getBoundingClientRect(),I=P.left,H=P.top,W=50,q=g.getBoundingClientRect(),$=0,ye=0,{left:Re,right:Be,top:Ge,bottom:je}=q,{width:Xe,height:Ze}=q;if(Re-=I,Be-=I,Ge-=H,je-=H,Xe>0&&Ze>0){if(Re<W&&($=W-Re),0===$&&Be+W>_&&($=-(Be+W-_)),Ge<W&&(ye=W-Ge),0===ye&&je+W>b&&(ye=-(je+W-b)),0!==$||0!==ye)i.getPitch()>40&&0!==ye&&this._coordinate?i.animateTo({center:this._coordinate},{duration:i.options.panAnimationDuration}):i.panBy([Math.ceil($),Math.ceil(ye)]);return}}var Ye=i.viewPointToContainerPoint(m),Qe=this.getOffset(),Je=Ye.add(Qe),Ke=i.viewPointToPrj(m),et=parseInt(g.clientWidth+""),tt=parseInt(g.clientHeight+""),at=0,ht=0;if(Je.x<0?at=50-Je.x:Je.x+et>_&&(at=-(Je.x+et-_)-50),Je.y-tt<0?ht=Math.abs(Je.y-tt)+50:Je.y+tt>b&&(ht=b-(Je.y+tt)-50),et>=_&&(at=_/2-Ye.x),0!==ht||0!==at){var gt=Ye.add(at,ht),yt=i._containerPointToPoint(gt)._sub(i._prjToPoint(i._getPrjCenter())),vt=i._pointToPrj(i._prjToPoint(Ke).sub(yt));i._panAnimation(vt)}}},m._measureSize=function(i){var g=this._getUIContainer();i.style.position="absolute";var m=i.style.bottom?"bottom":"top";if(i.style.display="",g.appendChild(i),i.getBoundingClientRect){var _=i.getBoundingClientRect();this._size=new ir(_.width,_.height)}else this._size=new ir(i.clientWidth,i.clientHeight);return i.style.display="none",i.style.left="0px",i.style[m]="0px",this._size},m._removePrevDOM=function(){this.onDomRemove&&this.onDomRemove();var i=this.options.eventsToStop;if(this._singleton()){var g=this.getMap(),m=this._uiDomKey();if(g[m]){i&&Kr(g[m],i,Hr);var _=g[m]._uiComponent;_&&_!==this&&_.isVisible()&&_.fire("hide"),Rr(g[m]),_&&!this.hideDom&&_._switchMapEvents("off"),delete g[m]}delete this.__uiDOM}else this.__uiDOM&&(i&&Kr(this.__uiDOM,i,Hr),Rr(this.__uiDOM),delete this.__uiDOM);this._resizeObserver&&(this._resizeObserver.disconnect(),delete this._resizeObserver,delete this._domContentRect)},m._uiDomKey=function(){return"__ui_"+this._getClassName()},m._singleton=function(){return this.options.single},m._getUIContainer=function(){return this.getMap().getPanels().ui},m._getClassName=function(){return"UIComponent"},m._switchMapEvents=function(i){var g=this.getMap();if(g){this._mapEventsOn="on"===i;var m=this._getDefaultEvents();if(this.getEvents&&I(m,this.getEvents()),m)for(var _ in m)m.hasOwnProperty(_)&&g[i](_,m[_],this)}},m._switchEvents=function(i){var g=this._getOwnerEvents();if(this._owner)for(var m in g)g.hasOwnProperty(m)&&this._owner[i](m,g[m],this)},m._getDefaultEvents=function(){return{"zooming rotate pitch":this.onEvent,zoomend:this.onZoomEnd,moving:this.onMoving,moveend:this.onMoving,resize:this.onResize}},m._getOwnerEvents=function(){var i={};return this._owner&&this._owner instanceof gu&&(i.positionchange=this.onGeometryPositionChange,i.symbolchange=this._updatePosition),this.getOwnerEvents&&I(i,this.getOwnerEvents()),i},m.onGeometryPositionChange=function(i){if(this._owner&&this.isVisible()){this._onlyUpdatePosition=!0;var g=i.target,m=g.getCenter();if(g._getAltitude){var _=g._getAltitude();W(_)&&(m.z=_)}this.show(m),this._onlyUpdatePosition=!1}},m.onMoving=function(){this.isVisible()&&this.getMap().isTransforming()&&this._updatePosition()},m.onEvent=function(){this.isVisible()&&this._updatePosition()},m.onZoomEnd=function(){this.isVisible()&&this._setPosition()},m.onResize=function(){this.isVisible()&&this._setPosition()},m.onDomSizeChange=function(){this.isVisible()&&(this._setPosition(),this._collides())},m._updatePosition=function(){return this.getMap()?(this.getMap()._getRenderer().callInNextFrame(this._setPosition.bind(this)),this):this},m._setPosition=function(){var i=this.getDOM();if(i){i.style[Ir]=null;var g=this.getPosition();this._pos=g,i.style[Cr]=this._toCSSTranslate(g)+" scale(1)"}},m._toCSSTranslate=function(i){if(!i)return"";if($t.any3d){var g=this.getMap(),m=g?g.getBearing():0,_=g?g.getPitch():0,b="";return this.options.pitchWithMap&&_&&(b+=" rotateX("+Math.round(_)+"deg)"),this.options.rotateWithMap&&m&&(b+=" rotateZ("+Math.round(-m)+"deg)"),"translate3d("+Math.round(i.x)+"px,"+Math.round(i.y)+"px, 0px)"+b}return"translate("+Math.round(i.x)+"px,"+Math.round(i.y)+"px)"},m._observerDomSize=function(i){var g=this;return i&&$t.resizeObserver&&!this._resizeObserver?(this._resizeObserver=new ResizeObserver((function(i){if(i.length){var m=i[0].borderBoxSize;g._domContentRect=m&&m.length?{width:m[0].inlineSize,height:m[0].blockSize}:i[0].contentRect}else delete g._domContentRect;g.onDomSizeChange&&g.onDomSizeChange()})),this._resizeObserver.observe(i),this):this},m.isSupportZoomFilter=function(){return!1},m.onConfig=function(i){var g=!1;if(i)for(var m=0,_=Ud.length;m<_;m++){if(Ud[m]in i){g=!0;break}}if(this._updatePosition(),g){this._collides();var b=this.getMap();b&&b._sortUI&&b._sortUI()}return this},g.isSupport=function(i){return!!(i&&Re(i.on)&&Re(i.off)&&Re(i.getCenter))},m._bindDomEvents=function(i,g){if(i){var m=this._getDomEvents()||{},_="on"===g?Jr:Kr;for(var b in m)"on"===g&&Kr(i,b,m[b]),_(i,b,m[b],this)}},m._getDomEvents=function(){return{mouseover:this._onDomMouseover,mouseout:this._onDomMouseout}},m._configMapPreventWheelScroll=function(i){var g=this.getMap();g&&this.options.enableSrollbar&&(this.options.eventsPropagation||(g.options.preventWheelScroll=i))},m._onDomMouseover=function(){this._configMapPreventWheelScroll(!1),this.fire("mouseover")},m._onDomMouseout=function(){this._configMapPreventWheelScroll(!0),this.fire("mouseout")},g}(Za(Ya));Gd.mergeOptions({eventsPropagation:!1,eventsToStop:null,dx:0,dy:0,autoPan:!1,autoPanDuration:600,single:!0,animation:"scale",animationOnHide:!1,animationDuration:500,pitchWithMap:!1,rotateWithMap:!1,visible:!0,roundPoint:!1,collision:!1,collisionBufferSize:2,collisionWeight:0,collisionFadeIn:!1,zIndex:0,enableSrollbar:!0});var jd="mousedown mouseup mouseenter mouseover mouseout mousemove click dblclick contextmenu keypress touchstart touchmove touchend",Wd=function(i){function g(g,m){var _;return(_=i.call(this,m)||this)._markerCoord=new pl(g),_}tn(g,i);var m=g.prototype;return m._getClassName=function(){return"UIMarker"},m.setCoordinates=function(i){if(!i)return this;if(!(i instanceof pl))try{i=new pl(i)}catch(i){return console.error(i),this}return this._markerCoord=i,this.fire("positionchange"),this.isVisible()&&(this._onlyUpdatePosition=!0,this._coordinate=this._markerCoord,this._setPosition(),this._collides(),this._onlyUpdatePosition=!1),this},m.getCoordinates=function(){return this._markerCoord},m.getCenter=function(){return this.getCoordinates()},m.getAltitude=function(){var i=this.getCoordinates()||{};return W(i.z)?i.z:this.options.altitude||0},m.setAltitude=function(i){return W(i)&&this._markerCoord&&(this._markerCoord.z=i,this._updatePosition&&(this._updatePosition(),this._collides())),this},m.setContent=function(i){var g=this.options.content;return this.options.content=i,this.fire("contentchange",{old:g,new:i}),this.isVisible()&&this.show(),this},m.getContent=function(){return this.options.content},m.onAdd=function(){if(this._owner&&!this._owner.isMap){var i=this._owner;throw new Error("UIMarker Can only be added to the map, but owner is:"+i.getJSONType&&i.getJSONType())}return this.show(),this},m.show=function(){return i.prototype.show.call(this,this._markerCoord)},m.flash=function(i,g,m,_){return jn.call(this,i,g,m,_)},m.buildOn=function(){var i,g=this.getDOM();this._bindDomEvents(g,"off");var m=this.options.content,_=ye(m);return _||Re(m)?(i=Or("div"),_?i.innerHTML=this.options.content:m.bind(this)(i)):i=this.options.content,this.options.containerClass&&(i.className=this.options.containerClass),this._registerDOMEvents(i),this._bindDomEvents(i,"on"),this._appendCustomClass(i),i},m.getOffset=function(){var i=this.getSize(),g=-i.width/2,m=-i.height/2,{horizontalAlignment:_,verticalAlignment:b}=this.options;return"left"===_?g=-i.width:"right"===_&&(g=0),"top"===b?m=-i.height:"bottom"===b&&(m=0),new un(g,m)},m.getTransformOrigin=function(){return"center center"},m.onDomRemove=function(){var i=this.getDOM();this._removeDOMEvents(i)},m.isDragging=function(){return!!this.draggable&&this.draggable.isDragging()},m._registerDOMEvents=function(i){Jr(i,jd,this._onDomEvents,this)},m._onDomEvents=function(i,g){var m=this.getMap()._parseEvent(i,i.type);if("mousedown"===(g=g||i.type)&&(this._mousedownEvent=i),"mouseup"===g&&(this._mouseupEvent=i),("click"!==g||!this._mouseClickPositionIsChange())&&("touchstart"===g&&(this._touchstartTime=P()),this.fire(g,m),"touchend"===g&&$t.touch)){var _=this.getMap().options.clickTimeThreshold||280;P()-this._touchstartTime<_&&this._onDomEvents(i,"click")}},m._removeDOMEvents=function(i){Kr(i,jd,this._onDomEvents)},m._mouseClickPositionIsChange=function(){var{x:i,y:g}=this._mousedownEvent||{},{x:m,y:_}=this._mouseupEvent||{};return i!==m||g!==_},m._getConnectPoints=function(){var i=this.getMap(),g=i.coordToContainerPoint(this.getCoordinates()),m=this.getSize(),_=m.width,b=m.height;return[i.containerPointToCoordinate(g.add(-_/2,0)),i.containerPointToCoordinate(g.add(_/2,0)),i.containerPointToCoordinate(g.add(0,b/2)),i.containerPointToCoordinate(g.add(0,-b/2))]},m._getViewPoint=function(){var i=0;if(this._owner){var g=this.getAltitude();g>0&&(i=this._meterToPoint(this._coordinate,g))}return this.getMap().coordToViewPoint(this._coordinate,void 0,i)._add(this.options.dx,this.options.dy)},m._getDefaultEvents=function(){return I({},i.prototype._getDefaultEvents.call(this),{"zooming zoomend":this.onZoomFilter})},m._setPosition=function(){this.onZoomFilter(),i.prototype._setPosition.call(this)},m.onZoomFilter=function(){var i=this.getDOM();i&&(this.isVisible()||"none"===i.style.display?this.isVisible()&&"none"===i.style.display&&(i.style.display=""):i.style.display="none")},m.isVisible=function(){var i=this.getMap();if(!i)return!1;if(!this.options.visible)return!1;var g=i.getZoom(),{minZoom:m,maxZoom:_}=this.options;return!(!H(m)&&g<m||!H(_)&&g>_)&&(this.getDOM()&&!0)},m.isSupportZoomFilter=function(){return!0},g}(hl(Gd));Wd.mergeOptions({containerClass:null,eventsPropagation:!0,draggable:!1,single:!1,content:null,altitude:0,minZoom:0,maxZoom:null,horizontalAlignment:"middle",verticalAlignment:"middle"});var qd=$t.touch?"touchstart mousedown":"mousedown",Xd=function(i){function g(g){return i.call(this,g)||this}tn(g,i);var m=g.prototype;return m.addHooks=function(){this.target.on(qd,this._startDrag,this)},m.removeHooks=function(){this.target.off(qd,this._startDrag,this)},m._startDrag=function(i){var g=i.domEvent;g.touches&&g.touches.length>1||2===g.button||this.isDragging()||(this.target.on("click",this._endDrag,this),this._lastCoord=i.coordinate,this._lastPoint=i.containerPoint,this._prepareDragHandler(),this._dragHandler.onMouseDown(i.domEvent),this.target.fire("dragstart",i))},m._prepareDragHandler=function(){this._dragHandler=new dl(this.target.getDOM(),{cancelOn:this._cancelOn.bind(this),ignoreMouseleave:!0}),this._dragHandler.on("mousedown",this._onMouseDown,this),this._dragHandler.on("dragging",this._dragging,this),this._dragHandler.on("mouseup",this._endDrag,this),this._dragHandler.enable()},m._cancelOn=function(i){var g=(i.srcElement||i.target).tagName.toLowerCase();return"button"===g||"input"===g||"select"===g||"option"===g||"textarea"===g},m._onMouseDown=function(i){Hr(i.domEvent)},m._dragging=function(i){var g=this.target,m=g.getMap()._parseEvent(i.domEvent),_=m.domEvent;if(!(_.touches&&_.touches.length>1))if(this._isDragging){var b=m.coordinate,T=m.containerPoint;this._lastCoord||(this._lastCoord=b),this._lastPoint||(this._lastPoint=T);var P=b.sub(this._lastCoord),I=T.sub(this._lastPoint);this._lastCoord=b,this._lastPoint=T,this.target.setCoordinates(this.target.getCoordinates().add(P)),m.coordOffset=P,m.pointOffset=I,g.fire("dragging",m)}else this._isDragging=!0},m._endDrag=function(i){var g=this.target,m=g.getMap();if(this._dragHandler&&(g.off("click",this._endDrag,this),this._dragHandler.disable(),delete this._dragHandler),delete this._lastCoord,delete this._lastPoint,this._isDragging=!1,m){var _=m._parseEvent(i.domEvent);g&&g._mouseClickPositionIsChange&&g._mouseClickPositionIsChange()&&g.fire("dragend",_)}},m.isDragging=function(){return!!this._isDragging},g}($a);Wd.addInitHook("addHandler","draggable",Xd);var Zd=/\{ *([\w_]+) *\}/g,$d={containerClass:"maptalks-msgBox",autoPan:!0,autoCloseOn:null,autoOpenOn:"click",width:"auto",minHeight:120,custom:!1,title:null,content:null,enableTemplate:!1},Yd=new ir(0,0),Qd=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m._getClassName=function(){return"InfoWindow"},m.addTo=function(g){return g instanceof gu&&(g.getInfoWindow()&&g.getInfoWindow()!==this&&g.removeInfoWindow(),g._infoWindow=this),i.prototype.addTo.call(this,g)},m.setContent=function(i){var g=this.options.content;return this.options.content=i,this.fire("contentchange",{old:g,new:i}),this.isVisible()&&this.show(this._coordinate),this},m.getContent=function(){return this.options.content},m.setTitle=function(i){var g=i;return this.options.title=i,this.fire("contentchange",{old:g,new:i}),this.isVisible()&&this.show(this._coordinate),this},m.getTitle=function(){return this.options.title},m.buildOn=function(){var i=this,g=Re(this.options.content),m=ye(this.options.content);if(this.options.custom){var _,b=this.getDOM();if(this._bindDomEvents(b,"off"),m||g){var T=Or("div");m?(T.innerHTML=this.options.content,this._replaceTemplate(T)):this.options.content.bind(this)(T),_=T}else this._replaceTemplate(this.options.content),_=this.options.content;return this._bindDomEvents(_,"on"),this._appendCustomClass(_),_}this._bindDomEvents(this.getDOM(),"off");var P=Or("div");this.options.containerClass&&(P.className=this.options.containerClass);var I=this._getWindowWidth();P.style.width=W(I)?I+"px":"auto",P.style.bottom="0px";var H='<em class="maptalks-ico"></em>';this.options.title&&(H+="<h2>"+this.options.title+"</h2>"),P.innerHTML=H+='<a href="javascript:void(0);" class="maptalks-close">×</a><div class="maptalks-msgContent"></div>',this._replaceTemplate(P);var q=P.querySelector(".maptalks-msgContent");return m||g?m?q.innerHTML=this.options.content:this.options.content.bind(this)(q):q.appendChild(this.options.content),this._onCloseBtnClick=function(g){i.options.eventsPropagation||(Nr(g),Hr(g)),i.hide()},Lr(P.querySelector(".maptalks-close"),"click touchend",this._onCloseBtnClick),g||this._replaceTemplate(q),this._bindDomEvents(P,"on"),this._appendCustomClass(P),P},m._replaceTemplate=function(i){var g=this._owner;if(this.options.enableTemplate&&g&&g.getProperties&&i&&i.innerHTML){var m=g.getProperties()||{};if($(m))i.innerHTML=i.innerHTML.replace(Zd,(function(i,g){return m[g]}))}return this},m.getTransformOrigin=function(){return this.getSize().width/2+"px bottom"},m.getOffset=function(){var i=this.getSize(),g=new un(-i.width/2,0);this.options.custom?g._sub(0,i.height):g._sub(4,12);var m=this.getOwner();if(m instanceof yf||m instanceof Mf){var _,b;if(m instanceof yf)_=m._getPainter(),b=m.getSize();else{var T=m.getGeometries();if(!T||!T.length)return g;_=T[0]._getPainter(),b=T[0].getSize()}if(b||(b=Yd),_){var P=_.getFixedExtent();g._add(P.xmax-b.width/2,P.ymin)}else g._add(0,-b.height)}return g},m.show=function(g){return this.getMap()&&this.getMap().options.enableInfoWindow?i.prototype.show.call(this,g):this},m.getEvents=function(){if(!this.options.autoCloseOn)return null;var i={};return i[this.options.autoCloseOn]=this.hide,i},m.getOwnerEvents=function(){var i=this.getOwner();if(!this.options.autoOpenOn||!i)return null;var g={};return g[this.options.autoOpenOn]=this._onAutoOpen,g},m.onRemove=function(){this._onDomMouseout(),this.onDomRemove()},m.onDomRemove=function(){this._onCloseBtnClick&&(Dr(this.getDOM().childNodes[2],"click touchend",this._onCloseBtnClick),delete this._onCloseBtnClick)},m._onAutoOpen=function(i){var g=this,m=this.getOwner();setTimeout((function(){m instanceof yf||m instanceof Gd?g.show(m.getCoordinates()):m instanceof Mf?g.show(m.findClosest(i.coordinate)):m instanceof vf||m instanceof Pf?(g.getMap().getScale()>=8&&(i.coordinate=g._rectifyMouseCoordinte(m,i.coordinate)),g.show(i.coordinate)):g.show(i.coordinate)}),1)},m._rectifyMouseCoordinte=function(i,g){var m=this;return i instanceof vf?this._rectifyLineStringMouseCoordinate(i,g).coordinate:i instanceof Pf?i.getGeometries().map((function(i){return m._rectifyLineStringMouseCoordinate(i,g)})).sort((function(i,g){return i.dis-g.dis}))[0].coordinate:g},m._rectifyLineStringMouseCoordinate=function(i,g){for(var m=this.getMap(),_=i.getCoordinates()||[],b=m.getGLRes(),T=_.map((function(i){var g=m.coordToPointAtRes(i,b);return m._pointAtResToContainerPoint(g,b,i.z||0)})),P=m.coordToContainerPoint(g),I=1/0,H=-1,W=0,q=T.length;W<q;W++){var $=P.distanceTo(T[W]);$<I&&(I=$,H=W)}for(var ye=[H-1,H,H+1].filter((function(i){return i>=0&&i<=T.length-1})),Re=ye.map((function(i){return T[i]})),Be=[],{width:Ge,height:je}=m.getSize(),Xe=0,Ze=Re.length-1;Xe<Ze;Xe++){var Ye=Xe,Qe=Re[Xe],Je=Re[Xe+1];if(Qe.x===Je.x)for(var Ke=Math.max(0,Math.min(Qe.y,Je.y)),et=Math.min(je,Math.max(Qe.y,Je.y)),tt=Ke;tt<=et;tt++)Be.push({point:new un(Qe.x,tt),coordinateIndex:Ye});else for(var at=(Je.y-Qe.y)/(Je.x-Qe.x),ht=Math.max(0,Math.min(Qe.x,Je.x)),gt=Math.min(Ge,Math.max(Qe.x,Je.x)),yt=ht;yt<=gt;yt++){Be.push({point:new un(yt,at*(yt-Qe.x)+Qe.y),coordinateIndex:Ye})}}for(var vt,xt=1/0,bt=-1,Tt=-1,Mt=0,Pt=Be.length;Mt<Pt;Mt++){var{point:It,coordinateIndex:Et}=Be[Mt],Lt=P.distanceTo(It);Lt<xt&&(xt=Lt,bt=Mt,Tt=Et,vt=It)}if(bt<0)return{dis:xt,coordinate:g};var Dt=Re[Tt],Ft=Dt.distanceTo(Re[Tt+1]),Ht=vt.distanceTo(Dt)/Ft,Bt=ye.map((function(i){return _[i]})),zt=Bt[Tt],Vt=Bt[Tt+1],Ut=zt.x,Gt=zt.y,jt=zt.z||0;return{dis:xt,coordinate:new pl(Ut+(Vt.x-Ut)*Ht,Gt+(Vt.y-Gt)*Ht,jt+((Vt.z||0)-jt)*Ht)}},m._getWindowWidth=function(){var i=this.options.width;return i||(i=$d.width),i},g}(Gd);Qd.mergeOptions($d);var Jd="remove hide shapechange positionchange dragend animatestart",Kd=function(i){function g(g,m={}){var _;return(_=i.call(this,m)||this)._content=g,_}tn(g,i);var m=g.prototype;return m._getClassName=function(){return"ToolTip"},m.addTo=function(m){if(g.isSupport(m))return m.on("mousemove",this.onMouseMove,this),m.on("mouseout",this.onMouseOut,this),m.on(Jd,this.hideDom,this),i.prototype.addTo.call(this,m);throw new Error("Invalid geometry or UIMarker the tooltip is added to.")},m.setStyle=function(i){return this.options.containerClass=i,this},m.getStyle=function(){return this.options.containerClass},m.getContent=function(){return this._content},m.buildOn=function(){var i=Or("div"),g=this.options||{};g.height&&(i.style.height=g.height+"px"),g.width&&(i.style.width=g.width+"px");var m=g.containerClass||g.cssName;return!m&&g.height&&(i.style.lineHeight=g.height+"px"),Re(this._content)?this._content.bind(this)(i):i.innerHTML='<div class="'+m+'">'+this._content+"</div>",this._appendCustomClass(i),i},m.onMouseOut=function(){clearTimeout(this._timeout),this.isVisible()&&this._removePrevDOM(),this._switchMapEvents("off")},m.onMouseMove=function(i){var g=this;clearTimeout(this._timeout);var m=this.getMap();if(m){var _=m.locateByPoint(i.coordinate,-5,25);0===this.options.showTimeout?this.show(_):this._timeout=setTimeout((function(){m&&g.show(_)}),this.options.showTimeout)}},m.onRemove=function(){clearTimeout(this._timeout),this._owner&&(this._owner.off("mousemove",this.onMouseMove,this),this._owner.off("mouseout",this.onMouseOut,this),this._owner.off(Jd,this.hideDom,this))},m.hideDom=function(){this.hide()},m.onEvent=function(){return i.prototype.onEvent.call(this),this.hideDom(),this},m._getViewPoint=function(){return this.getMap().coordToViewPoint(this._coordinate,void 0,0)._add(this.options.dx,this.options.dy)},g}(Gd);Kd.mergeOptions({width:0,height:0,animation:"fade",containerClass:"maptalks-tooltip",showTimeout:400});var ep=function(i){function g(g){return i.call(this,g)||this}tn(g,i);var m=g.prototype;return m._getClassName=function(){return"Menu"},m.addTo=function(i){return i._menu&&i._menu!==this&&i.removeMenu(),i._menu=this,this._owner=i,Gd.prototype.addTo.apply(this,[i])},m.setItems=function(i){return this.options.items=i,this},m.getItems=function(){return this.options.items||[]},m.buildOn=function(){var i;if(this.options.custom)if(ye(this.options.items)){var g=Or("div");g.innerHTML=this.options.items,this._appendCustomClass(g),i=g}else i=this.options.items;else{i=Or("div"),this.options.containerClass&&Wr(i,this.options.containerClass),i.style.width=this._getMenuWidth()+"px";var m=this._createMenuItemDom();i.appendChild(m),Jr(i,"contextmenu",Nr),this._appendCustomClass(i)}return i&&(this._bindDomEvents(i,"off"),this._bindDomEvents(i,"on")),i},m.getOffset=function(){if(!this.getMap())return null;var i=this.getMap().getSize(),g=this.getMap().viewPointToContainerPoint(this._getViewPoint()),m=this.getSize(),_=0,b=0;return g.x+m.width>i.width&&(_=-m.width),g.y+m.height>i.height&&(b=-m.height),new un(_,b)},m.getTransformOrigin=function(){var i=this.getOffset()._multi(-1);return i.x+"px "+i.y+"px"},m.getEvents=function(){return{"_zoomstart _zoomend _movestart _dblclick _click":this._removePrevDOM}},m._createMenuItemDom=function(){var i=this,g=this.getMap(),m=Or("ul");Wr(m,"maptalks-menu-items");var _,b,T=this.getItems();function P(m){return function(_){var b=g._parseEvent(_,"click");b.target=i,b.owner=i._owner,b.index=m,!1!==this._callback(b)&&(i.hide(),i._owner&&i._owner.fire("closemenu"))}}for(var I=0,H=T.length;I<H;I++){if("-"===(_=T[I])||"_"===_)Wr(b=Or("li"),"maptalks-menu-splitter");else{b=Or("li");var W=_.item;Re(W)&&(W=W({owner:this._owner,index:I})),b.innerHTML=W,b._callback=_.click,Jr(b,"click",P(I))}m.appendChild(b)}var q=this.options.maxHeight||0;return q>0&&Gr(m,"max-height: "+q+"px; overflow-y: auto;"),m},m._getMenuWidth=function(){return this.options.width||160},g}(Gd);ep.mergeOptions({containerClass:"maptalks-menu",animation:null,animationDelay:10,animationOnHide:!1,autoPan:!1,width:160,maxHeight:0,custom:!1,items:[]});var tp={setMenu:function(i){return this._menuOptions=i,this._menu?this._menu._setOptions(i):(this.off("contextmenu",this._defaultOpenMenu,this),this.on("contextmenu",this._defaultOpenMenu,this)),this},getMenu:function(){return this._menu},openMenu:function(i){var g=this instanceof Uu?this:this.getMap();return i||(i=this.getCenter()),this._menu?this._menu.show(i):this._menuOptions&&g&&(this._bindMenu(),this._menu.show(i)),this.fire("openmenu",{coordinate:i}),this},setMenuItems:function(i){return this._menuOptions||(this._menuOptions={}),Array.isArray(i)&&(this._menuOptions.custom=!1),this._menuOptions.items=i,this.setMenu(this._menuOptions),this},getMenuItems:function(){return this._menu?this._menu.getItems():this._menuOptions&&this._menuOptions.items||[]},closeMenu:function(){return this._menu&&this._menu.hide(),this.fire("closemenu",{}),this},removeMenu:function(){return this.off("contextmenu",this._defaultOpenMenu,this),this._unbindMenu(),delete this._menuOptions,this.fire("removemenu",{}),this},_bindMenu:function(){return this._menuOptions?(this._menu=new ep(this._menuOptions),this._menu.addTo(this),this):this},_unbindMenu:function(){return this._menu&&(this.closeMenu(),this._menu.remove(),delete this._menu),this},_defaultOpenMenu:function(i){return this.openMenu(i.coordinate),!1}};Uu.include(tp),gu.include(tp);var np=Object.freeze({__proto__:null,InfoWindow:Qd,Menu:ep,Menuable:tp,ToolTip:Kd,UIComponent:Gd,UIMarker:Wd}),rp=function(i){function g(g){return g&&g.position&&!ye(g.position)&&(g.position=I({},g.position)),i.call(this,g)||this}tn(g,i);var m=g.prototype;return m._appendCustomClass=function(i){if(!i)return console.warn("dom is null:",i),this;if(this.options.cssName){var g=this.options.cssName;Array.isArray(g)||(g=[g]),g.forEach((function(g){i.classList.add(g)}))}return this},m.onAdd=function(){},m.onRemove=function(){},m.addTo=function(i){if(this.remove(),!i.options.control)return this;this._map=i;var g=i.getPanels().control;return this.__ctrlContainer=Or("div"),Gr(this.__ctrlContainer,"position:absolute;overflow:visible;"),this.update(),g.appendChild(this.__ctrlContainer),this.onAdd&&this.onAdd(),this.fire("add",{dom:g}),this},m.update=function(){return this.__ctrlContainer.innerHTML="",this._controlDom=this.buildOn(this.getMap()),this._controlDom&&(this._updatePosition(),this.__ctrlContainer.appendChild(this._controlDom)),this},m.getMap=function(){return this._map},m.getPosition=function(){return I({},this._parse(this.options.position))},m.setPosition=function(i){return this.options.position=ye(i)?i:I({},i),this._updatePosition(),this},m.getContainerPoint=function(){var i,g,m=this.getPosition(),_=this.getMap().getSize();return H(m.left)?H(m.right)||(i=_.width-parseInt(m.right+"")):i=parseInt(m.left+""),H(m.top)?H(m.bottom)||(g=_.height-parseInt(m.bottom+"")):g=parseInt(m.top+""),new un(i,g)},m.getContainer=function(){return this.__ctrlContainer},m.getDOM=function(){return this._controlDom},m.show=function(){return this.__ctrlContainer.style.display="",this},m.hide=function(){return this.__ctrlContainer.style.display="none",this},m.isVisible=function(){return this.__ctrlContainer&&""===this.__ctrlContainer.style.display},m.remove=function(){return this._map?(Rr(this.__ctrlContainer),this.onRemove&&this.onRemove(),delete this._map,delete this.__ctrlContainer,delete this._controlDom,this.fire("remove"),this):this},m._parse=function(i){var m=i;return ye(i)&&(m=g.positions[m]),m},m._updatePosition=function(){var i=this.getPosition();for(var g in i||(i={top:20,left:20}),this.__ctrlContainer&&Object.assign(this.__ctrlContainer.style,{top:null,bottom:null,right:null,left:null}),i)if(i.hasOwnProperty(g)){var m=i[g]||0;W(m)&&(m+="px"),this.__ctrlContainer.style[g]=m}this.fire("positionchange",{position:I({},i)})},m.onConfig=function(i){i&&"position"in i&&this._updatePosition()},g}(Za(Ya));rp.positions={"top-left":{top:20,left:20},"top-right":{top:20,right:20},"bottom-left":{bottom:20,left:20},"bottom-right":{bottom:20,right:20}},Uu.mergeOptions({control:!0}),Uu.include({addControl:function(i){return this._containerDOM.getContext||i.addTo(this),this},removeControl:function(i){return i&&i.getMap()===this?(i.remove(),this):this}});var ip="addlayer removelayer setbaselayer baselayerremove",op=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(){return this._attributionContainer=Or("div"),this._attributionContainer.className="maptalks-attribution",this._appendCustomClass(this._attributionContainer),this._update(),this._attributionContainer},m.getContent=function(){return this.options.content},m.setContent=function(i){return this.options.content=i,this._update(),this},m.onAdd=function(){this.getMap().on(ip,this._update,this)},m.onRemove=function(){this.getMap().off(ip,this._update,this)},m._updateContent=function(){var i=this._attributionContainer,g=this.options.content||"";return i&&(i.innerHTML="",ye(g)?i.innerHTML=g:g instanceof HTMLElement&&i.appendChild(i)),this},m._update=function(){if(this.options.custom)this._updateContent();else{var i=this.getMap();if(i){var g=i._getLayers((function(i){return!!i.options.attribution})).reverse().map((function(i){return i.options.attribution})),m=this.options.content+(g.length>0?" - "+g.join(", "):"");this._attributionContainer.innerHTML='<span style="padding:0px 4px">'+m+"</span>"}}},g}(rp);op.mergeOptions({position:{bottom:0,left:0},content:'<a href="http://maptalks.org" target="_blank">maptalks</a>',custom:!1}),Uu.mergeOptions({attribution:!0}),Uu.addOnLoadHook((function(){var i=this.options.attribution||this.options.attributionControl;i&&(this.attributionControl=new op(i),this.addControl(this.attributionControl))}));var sp=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(i){var g=this._getCompass();return this._appendCustomClass(g),this._compass=g,this._registerDomEvents(),i.on("resize moving moveend zooming zoomend rotate rotateend dragrotating dragrotateend viewchange",this._rotateCompass,this),g},m.onAdd=function(){this._rotateCompass()},m._getCompass=function(){return Or("div","maptalks-compass")},m._registerDomEvents=function(){Jr(this._compass,"click",this._resetView,this)},m._rotateCompass=function(){var i=this.getMap().getBearing().toFixed(1),g=parseFloat(i);g<=180&&(g*=-1),g!==this._bearing&&(this._bearing=g,Gr(this._compass,"transform: rotate("+this._bearing+"deg);"))},m.onRemove=function(){this.getMap().off("resize moving moveend zooming zoomend rotate rotateend dragrotating dragrotateend viewchange",this._rotateCompass,this),delete this._compass,delete this._bearing},m._resetView=function(){this.getMap().animateTo({bearing:0})},g}(rp);sp.mergeOptions({position:{top:120,left:20}}),Uu.mergeOptions({compassControl:!1}),Uu.addOnLoadHook((function(){this.options.compassControl&&(this.compassControl=new sp(this.options.compassControl),this.addControl(this.compassControl))}));var ap=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(){var i=this.container=Or("div",this.options.containerClass),g=this.panel=Or("div","panel"),m=this.button=Or("button");return i.appendChild(m),i.appendChild(g),this._appendCustomClass(i),i},m.onAdd=function(){Jr(this.button,"mouseover",this._show,this),Jr(this.panel,"mouseleave",this._hide,this)},m.onRemove=function(){this.panel&&(Kr(this.button,"mouseover",this._show),Kr(this.panel,"mouseleave",this._hide),Rr(this.panel),Rr(this.button),delete this.panel,delete this.button,delete this.container)},m._show=function(){jr(this.container,"shown")||(Wr(this.container,"shown"),this._createPanel())},m._hide=function(i){this.panel.contains(i.toElement||i.relatedTarget)||qr(this.container,this.options.containerClass)},m._createPanel=function(){this.panel.innerHTML="";var i=Or("ul");this.panel.appendChild(i),this._renderLayers(this.getMap(),i)},m._renderLayers=function(i,g){var m=this,_=i.getBaseLayer(),b=i.getLayers(),T=b.length;if(_){var P=_.layers||[_],I=Or("li","group"),H=Or("ul"),W=Or("label");W.innerHTML=this.options.baseTitle,I.appendChild(W);for(var q=0,$=P.length;q<$;q++){this._isExcluded(P[q])&&(H.appendChild(this._renderLayer(P[q],!0)),I.appendChild(H),g.appendChild(I))}}if(T){var ye=Or("li","group"),Re=Or("ul"),Be=Or("label"),Ge=Or("input");Ge.type="checkbox",Ge.checked=!0,Be.innerHTML=this.options.overlayTitle,ye.appendChild(Ge),ye.appendChild(Be);for(var je=function(i){var g=i.target.checked,m=i.target.parentNode;if(m){var _=m.getElementsByTagName("ul")[0];if(_){var b=function(i){var m=i._layer;m&&m[g?"show":"hide"]()},T=function(i){var m=i._layer,_=i.childNodes[0];_&&(_.checked=g),m&&m[g?"show":"hide"]()};b(m),_.childNodes.forEach((function(i){T(i);var g=i.getElementsByTagName("ul")[0];g&&(b(i),g.childNodes.forEach((function(i){T(i)})))}))}}},Xe=function(){var i=b[Ze];if(m._isExcluded(i)){if(i.getLayers){var g=Or("li","group"),_=Or("ul"),T=Or("label"),P=Or("input");T.innerHTML=i.getId(),P.type="checkbox",P.checked=i.isVisible(),P.onchange=je,g.appendChild(P),g.appendChild(T),g.appendChild(_),g._layer=i,Re.appendChild(g),(i.getLayers()||[]).forEach((function(i){_.appendChild(m._renderLayer(i,!1,P.checked))}))}else Re.appendChild(m._renderLayer(i));i&&!i.isVisible()&&(Ge.checked=!1)}},Ze=0;Ze<T;Ze++)Xe();ye.appendChild(Re),g.appendChild(ye),Ge.onchange=je}},m._isExcluded=function(i){var g=i.getId(),m=this.options.excludeLayers;return!(m.length&&m.indexOf(g)>=0)},m._renderLayer=function(i,g,m=!0){var _=this,b=Or("li","layer"),T=Or("label"),P=Or("input"),I=this.getMap(),H=i.options.visible;i.options.visible=!0;var W=i.isVisible();i.options.visible=H,b.className="layer";var q=P;return g?(q.type="radio",q.name="base"):q.type="checkbox",q.checked=H&&W,m||(q.checked=!1),W||q.setAttribute("disabled","disabled"),q.onchange=function(g){if("radio"===g.target.type){var m=I.getBaseLayer(),b=m.layers;if(b)for(var T=0,P=b.length;T<P;T++){var H=b[T];H[H===i?"show":"hide"]()}else m.isVisible()||m.show();I._fireEvent("setbaselayer")}else i[g.target.checked?"show":"hide"]();_.fire("layerchange",{target:i})},b.appendChild(P),T.innerHTML=i.getId(),b.appendChild(T),b._layer=i,b},g}(rp);ap.mergeOptions({position:"top-right",baseTitle:"Base Layers",overlayTitle:"Layers",excludeLayers:[],containerClass:"maptalks-layer-switcher"}),Uu.mergeOptions({layerSwitcherControl:!1}),Uu.addOnLoadHook((function(){this.options.layerSwitcherControl&&(this.layerSwitcherControl=new ap(this.options.layerSwitcherControl),this.addControl(this.layerSwitcherControl))}));var lp=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(){var i=this.options.size;this.options.maximize||(i=[0,0]);var g=Or("div");this._appendCustomClass(g);var m=this.mapContainer=Or("div");m.style.width=i[0]+"px",m.style.height=i[1]+"px",m.className=this.options.containerClass;var _=this.button=Or("div");return _.className=this.options.buttonClass,g.appendChild(m),g.appendChild(_),g},m.onAdd=function(){this.options.maximize&&this._createOverview(),this.getMap().on("resize moving zooming rotate dragrotating viewchange",this._update,this).on("setbaselayer",this._updateBaseLayer,this).on("spatialreferencechange",this._updateSpatialReference,this),Jr(this.button,"click",this._onButtonClick,this),this._updateButtonText()},m.onRemove=function(){this.getMap().off("resize moving zooming rotate dragrotating viewchange",this._update,this).off("setbaselayer",this._updateBaseLayer,this).off("spatialreferencechange",this._updateSpatialReference,this),this._overview&&(this._overview.remove(),delete this._overview,delete this._perspective),Kr(this.button,"click",this._onButtonClick)},m.maxmize=function(){var i=this.options.size,g=this.mapContainer;return g.style.width=i[0]+"px",g.style.height=i[1]+"px",this._createOverview(),this},m.minimize=function(){this._overview&&this._overview.remove(),delete this._overview,delete this._perspective;var i=this.mapContainer;return i.style.width="0px",i.style.height="0px",this},m.getOverviewMap=function(){return this._overview},m._onButtonClick=function(){this._overview?this.minimize():this.maxmize(),this._updateButtonText()},m._updateButtonText=function(){this.button.innerHTML=this._overview?"-":"+"},m._createOverview=function(){var i=this.getMap(),g=this.mapContainer,m=i.config();I(m,{center:i.getCenter(),zoom:this._getOverviewZoom(),zoomAnimationDuration:150,pitch:0,bearing:0,scrollWheelZoom:!1,checkSize:!1,doubleClickZoom:!1,touchZoom:!1,control:!1,draggable:!1,maxExtent:null}),this._overview=new Uu(g,m),this._updateBaseLayer(),this._perspective=new gf(this._getPerspectiveCoords(),{draggable:!0,cursor:"move",symbol:this.options.symbol}).on("dragend",this._onDragEnd,this),new nd("perspective_layer",this._perspective).addTo(this._overview),this.fire("load")},m._getOverviewZoom=function(){var i=this.getMap(),g=i.getZoom(),m=i.getMinZoom(),_=this.options.level;if(_>0){for(var b=_;b>0;b--)if(g-b>=m)return g-b}else for(var T=_;T<0;T++)if(g-T>=m)return g-T;return g},m._onDragEnd=function(){var i=this._perspective.getCenter();this._overview.setCenter(i),this.getMap().panTo(i)},m._getPerspectiveCoords=function(){var i=this.getMap(),g=i.getProjection();return i.getContainerExtent().toArray().map((function(m){if(g){var _=i._containerPointToPrj(m);return i._fixPrjOnWorldWide(_),g.unproject(_)}return i.containerPointToCoordinate(m)}))},m._update=function(){if(this._overview){Vr(this._overview.getContainer());var i=this._getPerspectiveCoords();this._perspective.setCoordinates(i),this._overview.setCenterAndZoom(this.getMap().getCenter(),this._getOverviewZoom())}},m._updateSpatialReference=function(){if(this._overview){var i=this.getMap();this._overview.setSpatialReference(i.options.spatialReference)}},m._updateBaseLayer=function(){if(this._overview){var i=this.getMap().getBaseLayer();if(i){var g=i.layers,m=0;if(g)for(var _=0,b=g.length;_<b;_++){if(g[_].isVisible()){m=_;break}}var T=i.toJSON(),P=null;g?(P=T.layers[m].options).visible=!0:P=T.options,this._overview.setMinZoom(P.minZoom||null).setMaxZoom(P.maxZoom||null),delete P.minZoom,delete P.maxZoom,delete T.options.canvas,T.options.visible=!0,T.options.renderer="canvas";var I=Fu.fromJSON(T);for(var H in i)Re(i[H])&&i.hasOwnProperty(H)&&i[H]!==i.constructor.prototype[H]&&(I[H]=i[H]);this._overview.setBaseLayer(I)}else this._overview.setBaseLayer(null)}},g}(rp);lp.mergeOptions({level:4,position:{right:1,bottom:1},size:[300,200],maximize:!0,symbol:{lineWidth:3,lineColor:"#1bbc9b",polygonFill:"#1bbc9b",polygonOpacity:.4},containerClass:"maptalks-overview",buttonClass:"maptalks-overview-button"}),Uu.mergeOptions({overviewControl:!1}),Uu.addOnLoadHook((function(){this.options.overviewControl&&(this.overviewControl=new lp(this.options.overviewControl),this.addControl(this.overviewControl))}));var hp=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(){var i,g=this;if(this.options.custom)ye(this.options.content)?((i=Or("div")).innerHTML=this.options.content,this._appendCustomClass(i)):i=this.options.content;else{if(i=Or("div","maptalks-panel"),this._appendCustomClass(i),this.options.closeButton){var m=Or("a","maptalks-close");m.innerText="×",m.href="javascript:;",m.onclick=function(){i.style.display="none",g.fire("close")},i.appendChild(m)}var _=Or("div","maptalks-panel-content");ye(this.options.content)?_.innerHTML=this.options.content:_.appendChild(this.options.content),i.appendChild(_)}return this.draggable=new dl(i,{cancelOn:this._cancelOn.bind(this),ignoreMouseleave:!0}),this.draggable.on("dragstart",this._onDragStart,this).on("dragging",this._onDragging,this).on("dragend",this._onDragEnd,this),this.options.draggable&&this.draggable.enable(),i},m.update=function(){return this.draggable&&(this.draggable.disable(),delete this.draggable),rp.prototype.update.call(this)},m.setContent=function(i){var g=this.options.content;return this.options.content=i,this.fire("contentchange",{old:g,new:i}),this.isVisible()&&this.update(),this},m.getContent=function(){return this.options.content},m._cancelOn=function(i){var g=(i.srcElement||i.target).tagName.toLowerCase();return"button"===g||"input"===g||"select"===g||"option"===g||"textarea"===g},m._onDragStart=function(i){this._startPos=i.mousePos,this._startPosition=I({},this.getPosition()),this.fire("dragstart",i)},m._onDragging=function(i){var g=i.mousePos.sub(this._startPos),m=this._startPosition,_=this.getPosition();H(_.top)||(_.top=parseInt(m.top)+g.y),H(_.bottom)||(_.bottom=parseInt(m.bottom)-g.y),H(_.left)||(_.left=parseInt(m.left)+g.x),H(_.right)||(_.right=parseInt(m.right)-g.x),this.setPosition(_),this.fire("dragging",i)},m._onDragEnd=function(i){delete this._startPos,delete this._startPosition,this.fire("dragend",i)},m._getConnectPoints=function(){var i=this.getMap(),g=this.getContainerPoint(),m=this.getDOM(),_=parseInt(m.clientWidth+""),b=parseInt(m.clientHeight+"");return[i.containerPointToCoordinate(g.add(_/2,0)),i.containerPointToCoordinate(g.add(_,b/2)),i.containerPointToCoordinate(g.add(_/2,b)),i.containerPointToCoordinate(g.add(0,b/2))]},g}(rp);hp.mergeOptions({position:"top-right",draggable:!0,custom:!1,content:"",closeButton:!0});var cp=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(){var i=this._getReset();return this._appendCustomClass(i),this._reset=i,this._registerDomEvents(),i},m.onAdd=function(){this._view=this.options.view?this.options.view:this.getMap().getView()},m.setView=function(i){this._view=i},m._getReset=function(){return Or("div","maptalks-reset")},m._registerDomEvents=function(){Jr(this._reset,"click",this._resetView,this)},m.onRemove=function(){delete this._reset,delete this._view},m._resetView=function(){this.getMap().setView(this._view)},g}(rp);cp.mergeOptions({position:{top:156,left:20},view:null}),Uu.mergeOptions({resetControl:!1}),Uu.addOnLoadHook((function(){this.options.resetControl&&(this.resetControl=new cp(this.options.resetControl),this.addControl(this.resetControl))}));var up="zoomend moving moveend",fp=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(i){return this._map=i,this._scaleContainer=Or("div",this.options.containerClass),this._addScales(),i.on(up,this._update,this),this._map.isLoaded()&&this._update(),this._appendCustomClass(this._scaleContainer),this._scaleContainer},m.onRemove=function(){this.getMap().off(up,this._update,this)},m._addScales=function(){var i="border: 2px solid #000000;border-top: none;line-height: 1.1;padding: 0px;color: #000000;font-size: 11px;text-align:center;white-space: nowrap;overflow: hidden;-moz-box-sizing: content-box;box-sizing: content-box;background: #fff; background: rgba(255, 255, 255, 0);";this.options.metric&&(this._mScale=Er("div",this.options.containerClass?null:i,this._scaleContainer)),this.options.imperial&&(this._iScale=Er("div",this.options.containerClass?null:i,this._scaleContainer))},m._update=function(){var i=this._map.pixelToDistance(this.options.maxWidth,0);this._updateScales(i)},m._updateScales=function(i){this.options.metric&&i&&this._updateMetric(i),this.options.imperial&&i&&this._updateImperial(i)},m._updateMetric=function(i){var g=this._getRoundNum(i);this._updateScale(this._mScale,g<1e3?g+" m":g/1e3+" km",g/i)},m._updateImperial=function(i){var g,m,_,b=3.2808399*i;b>5280?(m=this._getRoundNum(g=b/5280),this._updateScale(this._iScale,m+" mile",m/g)):(_=this._getRoundNum(b),this._updateScale(this._iScale,_+" feet",_/b))},m._updateScale=function(i,g,m){i.style.width=Math.round(this.options.maxWidth*m)+"px",i.innerHTML=g},m._getRoundNum=function(i){var g=Math.pow(10,(Math.floor(i)+"").length-1),m=i/g;return g*(m=m>=10?10:m>=5?5:m>=3?3:m>=2?2:1)},g}(rp);fp.mergeOptions({position:"bottom-left",maxWidth:100,metric:!0,imperial:!1,containerClass:null}),Uu.mergeOptions({scaleControl:!1}),Uu.addOnLoadHook((function(){this.options.scaleControl&&(this.scaleControl=new fp(this.options.scaleControl),this.addControl(this.scaleControl))}));var dp=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(i){this._map=i;var g=Or("div"),m=Or("ul","maptalks-toolbar-hx");g.appendChild(m),Wr(g,this.options.vertical?"maptalks-toolbar-vertical":"maptalks-toolbar-horizonal");var _=this;function b(i,g,m,b){var T=_._getItems()[g];return function(_){return Hr(_),i({target:T,index:g,childIndex:m,dom:b})}}var T=this.options.items;if(kn(T))for(var P=0,I=T.length;P<I;P++){var H=T[P],W=Or("li");if(28!==this.options.height&&(W.style.lineHeight=this.options.height+"px"),W.style.height=this.options.height+"px",W.style.cursor="pointer",$r(H.item)){W.style.textAlign="center";var q=Yr("div",H.item);W.innerHTML='<div style="margin-top:'+(this.options.height-q.height)/2+'px;">'+H.item+"</div>"}else W.innerHTML=H.item;if(H.click&&Jr(W,"click",b(H.click,P,null,W)),kn(H.children)){var $=this._createDropMenu(P);W.appendChild($),W._menu=$,Jr(W,"mouseover",(function(){this._menu.style.display=""})),Jr(W,"mouseout",(function(){this._menu.style.display="none"}))}m.appendChild(W)}return this._appendCustomClass(g),g},m._createDropMenu=function(i){var g=this;function m(i,m,_){var b=g._getItems()[m].children[_];return function(g){return Hr(g),i({target:b,index:m,childIndex:_})}}var _=Or("div","maptalks-dropMenu"),b=this._getItems(),T=b.length,P=Or("ul"),I=b[i].children;i===T-1&&I&&(_.style.cssText="right: 0px;",P.style.cssText="right: 0px;position: absolute;",this.options.reverseMenu&&(P.style.bottom="0")),_.appendChild(Or("em","maptalks-ico"));for(var H=0,W=0,q=I.length;W<q;W++){var $=pr(I[W].item,"12px");$.width>H&&(H=$.width)}for(var ye=0,Re=I.length;ye<Re;ye++){var Be=I[ye],Ge=Or("li");Ge.innerHTML='<a href="javascript:;">'+Be.item+"</a>",Ge.style.cursor="pointer",Ge.style.width=H+24+"px",Jr(Ge.childNodes[0],"click",m(Be.click,i,ye)),P.appendChild(Ge)}if(this.options.vertical){var je=H<95?95:H;this.options.reverseMenu?_.style.right=-(je+20+2)+"px":_.style.left=-(je+20+2)+"px"}else this.options.reverseMenu?_.style.bottom="28px":_.style.top="29px";return _.appendChild(P),_.style.display="none",_},m._getItems=function(){return this.options.items||[]},g}(rp);dp.mergeOptions({height:28,vertical:!1,position:"top-right",reverseMenu:!1,items:[]});var pp=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.buildOn=function(i){var g=this.options,m=Or("div","maptalks-zoom");if(this._appendCustomClass(m),g.zoomLevel){var _=Or("span","maptalks-zoom-zoomlevel"),b=Or("span","maptalks-zoom-zoomlevel-text");_.appendChild(b),m.appendChild(_),this._levelDOM=b}var T=Or("div","maptalks-zoom-slider"),P=Or("a","maptalks-zoom-zoomin");P.href="javascript:;",T.appendChild(P),this._zoomInButton=P;var I=Or("a","maptalks-zoom-zoomout");return I.href="javascript:;",T.appendChild(I),this._zoomOutButton=I,m.appendChild(T),i.on("_zoomend _zooming _zoomstart _spatialreferencechange",this._update,this),this._update(),this._registerDomEvents(),m},m.onRemove=function(){this.getMap().off("_zoomend _zooming _zoomstart _spatialreferencechange",this._update,this)},m._update=function(){this._updateText()},m._updateText=function(){if(this._levelDOM){var i=this.getMap().getZoom();q(i)||(i=Math.floor(10*i)/10),this._levelDOM.innerHTML=i+""}},m._registerDomEvents=function(){this._zoomInButton&&Jr(this._zoomInButton,"click",this._onZoomInClick,this),this._zoomOutButton&&Jr(this._zoomOutButton,"click",this._onZoomOutClick,this)},m._onZoomInClick=function(i){Nr(i),this.getMap().zoomIn()},m._onZoomOutClick=function(i){Nr(i),this.getMap().zoomOut()},g}(rp);pp.mergeOptions({position:"top-left",zoomLevel:!0,seamless:!1}),Uu.mergeOptions({zoomControl:!1}),Uu.addOnLoadHook((function(){this.options.zoomControl&&(this.zoomControl=new pp(this.options.zoomControl),this.addControl(this.zoomControl))}));var gp=Object.freeze({__proto__:null,Attribution:op,Compass:sp,Control:rp,LayerSwitcher:ap,Overview:lp,Panel:hp,Reset:cp,Scale:fp,Toolbar:dp,Zoom:pp}),mp=function(){function i(i,g,m,_){Array.isArray(i)?(this.scale={x:i[0],y:i[1]},this.origin={x:i[2],y:i[3]}):(this.scale={x:i,y:g},this.origin={x:m,y:_})}return i.getDefault=function(i){var g=i.code.toLowerCase();return"baidu"===g?"baidu":g==="EPSG:4326".toLowerCase()||g==="EPSG:4490".toLowerCase()?"tms-global-geodetic":"identity"===g?[1,-1,0,0]:"web-mercator"},i}(),Ap=6378137*Math.PI;I(mp,{"web-mercator":new mp([1,-1,-Ap,Ap]),"tms-global-mercator":new mp([1,1,-Ap,-Ap]),"tms-global-geodetic":new mp([1,1,-180,-90]),baidu:new mp([1,1,0,0])});for(var yp=function(){function i(i,g,m,_){this.map=i,this.tileSize=_,this.fullExtent=m,this.prepareTileInfo(g,m),this._xScale=m.right>=m.left?1:-1,this._yScale=m.top>=m.bottom?1:-1;var b=i.getGLRes();this._pointOrigin=i._prjToPointAtRes(new un(this.tileSystem.origin),b),this._glRes=b}var g=i.prototype;return g.prepareTileInfo=function(i,g){if(ye(i)?i=mp[i.toLowerCase()]:Array.isArray(i)&&(i=new mp(i)),!i)throw new Error("Invalid TileSystem");this.tileSystem=i,this.transformation=new Ol([g.right>g.left?1:-1,g.top>g.bottom?-1:1,i.origin.x,i.origin.y])},g._getTileNum=function(i,g){var m=this.tileSystem,_=this.tileSize,b=Math.floor(1e-7*m.scale.x+i.x/(_.width*g)),T=Math.ceil(1e-7*m.scale.y+i.y/(_.height*g));return{x:m.scale.x*b,y:m.scale.y*T}},g.getTileIndex=function(i,g,m){var _=this.tileSystem,b=this.transformation.transform(i,1),T=this._getTileNum(b,g);return _.scale.x<0&&(T.x-=1),_.scale.y>0&&(T.y-=1),this.getNeighorTileIndex(T.x,T.y,0,0,g,m)},g.getNeighorTileIndex=function(i,g,m,_,b,T){var P=this.tileSystem,I=i+P.scale.x*m,H=g-P.scale.y*_,W=!1,q=I,$=H,ye=this._getTileFullIndex(b);return T&&(!0!==T&&"x"!==T||(ye.xmax===ye.xmin?I=ye.xmin:I<ye.xmin?(I=ye.xmax-(ye.xmin-I)%(ye.xmax-ye.xmin))===ye.xmax&&(I=ye.xmin):I>=ye.xmax&&(I=ye.xmin+(I-ye.xmin)%(ye.xmax-ye.xmin))),!0!==T&&"y"!==T||(ye.ymax===ye.ymin?H=ye.ymin:H>=ye.ymax?H=ye.ymin+(H-ye.ymin)%(ye.ymax-ye.ymin):H<ye.ymin&&(H=ye.ymax-(ye.ymin-H)%(ye.ymax-ye.ymin))===ye.ymax&&(H=ye.ymin))),(I<ye.xmin||I>ye.xmax||H>ye.ymax||H<ye.ymin)&&(W=!0),{x:I,y:H,idx:q,idy:$,out:W}},g._getTileFullIndex=function(i){if(this._tileFullIndex||(this._tileFullIndex={}),this._tileFullIndex[i])return this._tileFullIndex[i];var g=this.fullExtent,m=this.transformation,_=this._getTileNum(m.transform(new pl(g.left,g.top),1),i),b=this._getTileNum(m.transform(new pl(g.right,g.bottom),1),i),T=this.tileSystem;return T.scale.x<0&&(_.x-=1,b.x-=1),T.scale.y>0&&(_.y-=1,b.y-=1),this._tileFullIndex[i]=new Pl(_,b,null),this._tileFullIndex[i]},g.getTilePrjNW=function(i,g,m,_){var b=this.tileSystem,T=this.tileSize,P=b.origin.y+this._yScale*b.scale.y*(g+(1===b.scale.y?1:0))*m*T.height,I=b.origin.x+this._xScale*b.scale.x*(i+(1===b.scale.x?0:1))*m*T.width;return _?(_.set(I,P),_):new pl(I,P)},g.getTilePointNW=function(i,g,m,_){var b=this._glRes/m,T=this.tileSystem,P=this.tileSize,I=this._pointOrigin.y*b+this._yScale*T.scale.y*(g+(1===T.scale.y?1:0))*P.height,H=this._pointOrigin.x*b+this._xScale*T.scale.x*(i+(1===T.scale.x?0:1))*P.width;return _?(_.set(H,I),_):new un(H,I)},g.getTilePrjSE=function(i,g,m,_){var b=this.tileSystem,T=this.tileSize,P=b.origin.y+this._yScale*b.scale.y*(g+(1===b.scale.y?0:1))*m*T.height,I=b.origin.x+this._xScale*b.scale.x*(i+(1===b.scale.x?1:0))*m*T.width;return _?(_.set(I,P),_):new pl(I,P)},g.getTilePointSE=function(i,g,m,_){var b=this._glRes/m,T=this.tileSystem,P=this.tileSize,I=this._pointOrigin.y*b+this._yScale*T.scale.y*(g+(1===T.scale.y?0:1))*P.height,H=this._pointOrigin.x*b+this._xScale*T.scale.x*(i+(1===T.scale.x?1:0))*P.width;return _?(_.set(H,I),_):new un(H,I)},g.getTilePrjExtent=function(i,g,m){var _=this.getTilePrjNW(i,g,m),b=this.getTilePrjSE(i,g,m);return new Pl(_,b)},i}(),_p=[],vp=0
/*!
  * Contains code from THREE.js
  * MIT License
  * https://github.com/mrdoob/three.js
  */;vp<6;vp++)_p[vp]=[];var xp=[];function bp(i,g,m){!function(i){var g=i,m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8],$=g[9],ye=g[10],Re=g[11],Be=g[12],Ge=g[13],je=g[14],Xe=g[15];Tp(_p[0],T-m,W-P,Re-q,Xe-Be),Tp(_p[1],T+m,W+P,Re+q,Xe+Be),Tp(_p[2],T+_,W+I,Re+$,Xe+Ge),Tp(_p[3],T-_,W-I,Re-$,Xe-Ge),Tp(_p[4],T-b,W-H,Re-ye,Xe-je),Tp(_p[5],T+b,W+H,Re+ye,Xe+je)}(i);for(var _=0;_<6;_++){var b=_p[_];if(xp[0]=b[0]>0?g[1][0]:g[0][0],xp[1]=b[1]>0?g[1][1]:g[0][1],xp[2]=b[2]>0?g[1][2]:g[0][2],Sp(b,xp)<0)return!1}return!0}var wp=1/6;function Tp(i,g,m,_,b){return i[0]=g*wp,i[1]=m*wp,i[2]=_*wp,i[3]=b*wp,i}function Sp(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]+i[3]}var Mp,Cp=new un(0,0),Pp="undefined"!=typeof Set,Ip=function(){function i(){this._table=Pp?new Set:{}}var g=i.prototype;return g.add=function(i){Pp?this._table.add(i):this._table[i]=!0},g.has=function(i){return Pp?this._table.has(i):this._table[i]},g.reset=function(){Pp?this._table.clear():this._table={}},i}(),kp={urlTemplate:null,subdomains:null,errorUrl:null,repeatWorld:!0,background:!0,loadingLimitOnInteracting:3,loadingLimit:0,placeholder:!1,crossOrigin:null,tileSize:[256,256],offset:[0,0],tileSystem:null,fadeAnimation:!m,fadeDuration:1e3/60*10,debug:!1,spatialReference:null,maxCacheSize:256,renderer:$t.webgl?"gl":"canvas",clipByPitch:!0,maxAvailableZoom:null,cascadeTiles:!0,zoomOffset:0,pyramidMode:1,decodeImageInWorker:!1,tileLimitPerFrame:0,tileStackStartDepth:7,tileStackDepth:6,awareOfTerrain:!0,bufferPixel:.5,mipmapTexture:!0,depthMask:!0,currentTilesFirst:!0,forceRenderOnMoving:!0,tileErrorScale:1},Op=/\{ *([\w_]+) *\}/g,Ep=new un(0,0),Rp=new un(0,0),Lp=new un(0,0),Dp=new un(0,0),Fp=new un(0,0),Np=new un(0,0),Hp=[[0,0,0],[0,0,0]],Bp=[0,0,0],zp=[0,0,0],Vp=[0,0,0],Up=function(i){function g(g,m){return i.call(this,g,m)||this}tn(g,i),g.fromJSON=function(i){return i&&"TileLayer"===i.type?new g(i.id,i.options):null};var m=g.prototype;return m.forceReload=function(){return this.fire("forcereloadstart"),this.clear(),this._renderer&&this._renderer.setToRedraw(),this.fire("forcereloadend"),this},m.getTileSize=function(i){if(this._tileSize)return this._tileSize;var g=this.options.tileSize;return W(g)&&(g=[g,g]),this._tileSize=new ir(g),this._tileSize},m.getTiles=function(i,g){var m,_=this;if(this._coordCache={},m=this._isPyramidMode()?this._getPyramidTiles(i,g):this._getCascadeTiles(i,g),!this._maskGeoJSON)return m;var b=0;return(m.tileGrids||[]).forEach((function(i){i.tiles=(i.tiles||[]).filter((function(i){return _._tileInMask(i)})),b+=i.tiles.length;var g=i.tiles.map((function(i){return i.parent}));i.parents=(i.parents||[]).filter((function(i){return g.indexOf(i.id)>-1}))})),m.count=b,m},m._isPyramidMode=function(){var i=this._spatialRef||this.getSpatialReference();return!this._disablePyramid&&!this._hasOwnSR&&this.options.pyramidMode&&i&&i.isPyramid()},m._getTileFullExtent=function(){if(this._tileFullExtent)return this._tileFullExtent;var i=this.getSpatialReference(),g=i.getFullExtent(),m=i.getResolution(0),_=this.getMap();return this._tileFullExtent=g.convertTo((function(i){return _._prjToPointAtRes(i,m,Cp)})),this._tileFullExtent},m._getRootNodes=function(i){var g=this.getMap();if(this._rootNodes){var{tiles:m,mapWidth:_,mapHeight:b}=this._rootNodes;if(g.width!==_||g.height!==b){for(var T=this._getRootError(),P=0;P<m.length;P++)m[P].error=T;this._rootNodes.mapWidth=g.width,this._rootNodes.mapHeight=g.height}for(var I=0;I<m.length;I++)m[I].offset[0]=i[0],m[I].offset[1]=i[1];return this._rootNodes}var H=this._spatialRef||this.getSpatialReference(),W=H.getResolution(0),q=this._getTileConfig(),$=H.getFullExtent(),{origin:ye,scale:Re}=q.tileSystem,Be=q.getTilePrjExtent(0,0,W),Ge=Be.getWidth(),je=Be.getHeight(),Xe=1e-5,Ze=Math.abs((ye.x-$.left)/Ge);Ze=Math.ceil(Ze-Xe);var Ye=Math.abs(($.right-ye.x)/Ge);Ye=Math.ceil(Ye-Xe);var Qe=Math.ceil(Math.abs($.top-ye.y)/je);Qe=Math.ceil(Qe-Xe);var Je=Math.ceil(Math.abs($.bottom-ye.y)/je);if((Ye+Ze)*((Je=Math.ceil(Je-Xe))+Qe)>32)return{status:0,error:"Too many root nodes"};for(var Ke=this._getRootError(),et=[],tt=-Ze;tt<Ye;tt++)for(var at=-Qe;at<Je;at++){var ht=Re.y<0?at:-(at+1);et.push(this.createTileNode(tt,ht,0,tt,ht,W,Ke))}return this._rootNodes={status:1,tiles:et,mapWidth:g.width,mapHeight:g.height},this._getRootNodes(i)},m.createTileNode=function(i,g,m,_,b,T,P,I,H,W){var q=this.map,$=this.options.zoomOffset;H||(H=this._getTileConfig().getTilePrjExtent(i,g,T).convertTo((function(i){return q._prjToPointAtRes(i,T,Cp)})));var ye=this._getTileOffset(m),Re=this.getTileUrl(i,g,m+$);return{parent:I,layer:this.getId(),x:i,y:g,z:m,idx:_,idy:b,res:T,extent2d:H,id:W||this._getTileId(i,g,m),url:li(Re),offset:ye,error:P,children:[]}},m._getRootError=function(){var i=this.getMap(),g=Xe(i.getFov()),m=i.width/i.height,_=i.cameraPosition[2],b=_*Math.tan(.5*g),T=b*m,P=Math.sqrt(_*_+b*b+T*T);return i._getFovZ(0)*(P/_)*(this._spatialRef||this.getSpatialReference()).getResolution(0)/i.getResolution(0)},m._getPyramidTiles=function(i,g){var m=this.map;isNaN(+i)&&(i=this._getTileZoom(m.getZoom()));var _,b=this._spatialRef||this.getSpatialReference(),T=Math.min(i,this.getMaxZoom(),this.getMaxAvailableZoom()||1/0),P=m.projViewMatrix,I=this._getTileFullExtent(),H=this._getTileOffset(0);if(this.options.repeatWorld){var W=m.getContainerExtent(),q=this._convertToExtent2d(W),$=b.getResolution(0)/m.getResolution();if(q.within(I.copy()._scale($))){var ye=this._getRootNodes(H);if(1!==ye.status)return console.warn(ye.error),this._disablePyramid=!0,this.getTiles(i,g);_=[...ye.tiles]}else{var Re=m.getPitch(),Be=m.options.cascadePitches[1],Ge=Math.floor(m._getVisualHeight(Be)),je=Re<=Be?W:new kl(0,m.height-Ge,m.width,m.height);this._visitedTiles=new Ip;var Xe=this._getTiles(0-this.options.zoomOffset,je,2,g&&g.getRenderer(),!0),Ze=this._getRootError()*Math.pow(2,this.options.zoomOffset);Xe.tiles.forEach((function(i){i.error=Ze})),_=Xe.tiles}}else{var Ye=this._getRootNodes(H);if(1!==Ye.status)return console.warn(Ye.error),this._disablePyramid=!0,this.getTiles(i,g);_=[...Ye.tiles]}for(var Qe=m.getGLRes(),Je={0:H},Ke=new kl,et=[],tt=[],at=g&&g.getRenderer();_.length>0;){var ht=_.pop();ht.z!==T?(Je[ht.z+1]||(Je[ht.z+1]=this._getTileOffset(ht.z+1)),this._splitNode(ht,P,_,et,tt,i,Ke,T,Je[ht.z+1],at,Qe)):(Ke._combine(ht.extent2d),et.push(ht))}return tt.sort(Gp),this._debugTile(et,"_getPyramidTiles"),{tileGrids:[{extent:Ke,count:et.length,tiles:et,parents:tt,offset:[0,0],zoom:i}],count:et.length}},m.isParentTile=function(i,g,m){var _=Math.max(this.getMinZoom(),i-this.options.tileStackStartDepth);return m.z>=_&&m.z<_+this.options.tileStackDepth&&m.z<g},m._splitNode=function(i,g,m,_,b,T,P,I,H,W,q){var $=i.z+1,ye=this._spatialRef||this.getSpatialReference(),{idx:Re,idy:Be}=i,Ge=W||this.getRenderer(),je=!1,Xe=[],Ze=ye.getResolution($)/q;this.tileInfoCache||(this.tileInfoCache=new Js(4*this.options.maxCacheSize));for(var Ye=0;Ye<4;Ye++){var Qe=Ye%2,Je=Ye>>1;i.children||(i.children=[]);var Ke=i.children[Ye];if(!Ke)Ke=this._getTileId((Re<<1)+Qe,(Be<<1)+Je,$),i.children[Ye]=Ke;var et=Ge.isTileCachedOrLoading(Ke),tt=et&&et.info;tt||(tt=this.tileInfoCache.get(Ke))||(tt=this._createChildNode(i,Qe,Je,H,Ke)),tt.error=i.error/2,tt.offset[0]=H[0],tt.offset[1]=H[1];var at=this._isTileVisible(tt,g,Ze,I,H);if(at===Mp.VISIBLE)je=!0;else{if(at===Mp.OUT_OF_FRUSTUM)continue;if(at===Mp.SCREEN_ERROR_TOO_SMALL&&$!==I)return _.push(i),void P._combine(i.extent2d)}Xe.push(tt)}$===I?je?yn(m,Xe):(_.push(i),P._combine(i.extent2d)):yn(m,Xe),this.isParentTile(T,I,i)&&b.push(i)},m._createChildNode=function(i,g,m,_,b){var T,{x:P,y:I,idx:H,idy:W,extent2d:q}=i,$=i.z+1,ye=(P<<1)+g,Re=(I<<1)+m,Be=(H<<1)+g,Ge=(W<<1)+m,je=q.getWidth()/2*2,Xe=q.getHeight()/2*2,Ze=2*q.xmin,Ye=2*q.ymax,Qe=2*q.ymin,Je=this._getTileConfig().tileSystem.scale.y;if(b=b||this._getTileId(Be,Ge,$),Je<0){var Ke=Ze+g*je,et=Ye-m*Xe;T=new kl(Ke,et-Xe,Ke+je,et)}else{var tt=Ze+g*je,at=Qe+m*Xe;T=new kl(tt,at,tt+je,at+Xe)}var ht=this.createTileNode(ye,Re,$,Be,Ge,i.res/2,i.error/2,i.id,T,b);return this.tileInfoCache.add(b,ht),ht},m._isTileVisible=function(i,g,m,_,b){if(0===i.z)return Mp.VISIBLE;if(!this._isTileInFrustum(i,g,m,b))return Mp.OUT_OF_FRUSTUM;var T=this.options.maxError;return H(T)&&(T=1),this._getScreenSpaceError(i,m,_,b)>=T?Mp.VISIBLE:Mp.SCREEN_ERROR_TOO_SMALL},m._isTileInFrustum=function(i,g,m,_){if(!this._zScale){var b=this.getMap(),T=b.getGLRes();this._zScale=b.altitudeToPoint(100,T)/100}var P=this.getRenderer(),{xmin:I,ymin:H,xmax:W,ymax:q}=i.extent2d;if(i.offset&&0!==i.offset[0]&&0!==i.offset[1]&&!Re(this.options.offset)){var[$,ye]=i.offset;I+=$,W+=$,H+=ye,q+=ye}return Hp[0][0]=(I-_[0])*m,Hp[0][1]=(H-_[1])*m,Hp[0][2]=(i.minAltitude||P&&P.avgMinAltitude||0)*this._zScale,Hp[1][0]=(W-_[0])*m,Hp[1][1]=(q-_[1])*m,Hp[1][2]=(i.maxAltitude||P&&P.avgMaxAltitude||0)*this._zScale,bp(g,Hp)},m._getScreenSpaceError=function(i,g,m,_){var b=i.error,T=this.map,{xmin:P,ymin:I,xmax:H,ymax:W}=i.extent2d;Bp[0]=(P-_[0])*g,Bp[1]=(I-_[1])*g,zp[0]=(H-_[0])*g,zp[1]=(W-_[1])*g;var q=function(i,g,m){var _=Math.max(i[0]-m[0],0,m[0]-g[0]),b=Math.max(i[1]-m[1],0,m[1]-g[1]),T=Math.max(i[2]-m[2],0,m[2]-g[2]);return Math.sqrt(_*_+b*b+T*T)}(Bp,zp,T.cameraPosition),$=Math.max(Math.abs(q),1e-7),ye=Math.abs(i.z-m),Re=b*(T.height<1e3||ye<=1?1:ye<=2?.7:.605)/$*this.options.tileErrorScale;return T.getPitch()<=60?1.45*Re:Re},m._getCascadeTiles=function(i,g){var m=this.getMap(),_=m.getPitch(),b=g&&g.getRenderer(),T=m.getContainerExtent(),P=[],I=0,W=this.getMinZoom(),q=m.options.cascadePitches[0],$=m.options.cascadePitches[1],ye=Math.floor(m._getVisualHeight($)),Re=H(i)?this._getTileZoom(m.getZoom()):i;if(this._visitedTiles=new Ip,!H(i)||!this.options.cascadeTiles||_<=q||!H(W)&&Re<=W){var Be=_<=$?T:new kl(0,m.height-ye,m.width,m.height),Ge=this._getTiles(Re,Be,2,b);return Ge&&(I+=Ge.tiles.length,P.push(Ge)),{tileGrids:P,count:I}}var je=Math.floor(m._getVisualHeight(q)),Xe=new kl(0,m.height-je,m.width,m.height),Ze=this._getTiles(Re,Xe,0,b);I+=Ze?Ze.tiles.length:0,P.push(Ze);var Ye,Qe,Je=Xe.ymin,Ke=m.getSpatialReference().getZoomDirection(),et=Ke;if(_>$){Re-et<=W&&(et=0);var tt=new kl(0,m.height-ye,m.width,Je);I+=(Ye=this._getTiles(Re-et,tt,1,b))?Ye.tiles.length:0,Je=tt.ymin,et+=4*Ke,P.push(Ye)}if(Re-et>=W){var at=new kl(0,T.ymin,m.width,Je);I+=(Qe=this._getTiles(Re-et,at,2,b))?Qe.tiles.length:0,P.push(Qe)}return Ye&&Qe&&(P[1]=Qe,P[2]=Ye),{tileGrids:P,count:I}},m.getTileUrl=function(i,g,m){var _=this.options.urlTemplate,b="",T=this.options.subdomains;if(T&&kn(T)){var P=(i+g)%T.length;P<0&&(P=0),b=T[P]}if(Re(_))return _(i,g,m,b);var H={x:i,y:g,z:m,s:b};return this.options.token&&(H.token=this.options.token),this.options.customTags&&I(H,this.options.customTags),_.replace(Op,(function(i,g){var m=H[g];if(void 0===m)throw new Error("No value provided for variable "+i);return"function"==typeof m&&(m=m(H)),m}))},m.clear=function(){return this._renderer&&this._renderer.clear(),this.tileInfoCache&&this.tileInfoCache.reset(),this.fire("clear"),this},m.toJSON=function(){return{type:this.getJSONType(),id:this.getId(),options:this.config()}},m.getSpatialReference=function(){var i=this.getMap();if(i&&(!this.options.spatialReference||uu.equals(this.options.spatialReference,i.options.spatialReference)))return i.getSpatialReference();if(this._sr)return this._sr;var g=this.options.spatialReference;if(ye(g)&&!(g=uu.getPreset(g)))throw new Error("Unsupported spatial reference: "+this.options.spatialReference+", possible values: "+uu.getAllPresets().join());return this._sr=new uu(g),this._srMinZoom=this._sr.getMinZoom(),this._srMaxZoom=this._sr.getMaxZoom(),this._hasOwnSR=this._sr.toJSON().projection!==i.getSpatialReference().toJSON().projection,this._sr},m.getMinZoom=function(){var i=this.options.minZoom||0;return(this._spatialRef||this.getSpatialReference())!==this.getMap().getSpatialReference()?Math.max(i,this._srMinZoom):i},m.getMaxZoom=function(){return(this._spatialRef||this.getSpatialReference())!==this.getMap().getSpatialReference()?Math.min(i.prototype.getMaxZoom.call(this),this._srMaxZoom):i.prototype.getMaxZoom.call(this)},m._getTileZoom=function(i){if(!this._hasOwnSR){var g=this.getMap().getResolution(i),m=this.getSpatialReference().getResolution(i);i+=Math.log(m/g)*Math.LOG2E}var _=this.getMaxAvailableZoom();return!H(_)&&i>_&&(i=_),q(i)||(i=Math.round(i)),i=Math.max(0,i)},m.getMaxAvailableZoom=function(){var i=this._spatialRef||this.getSpatialReference();return this.options.maxAvailableZoom||i&&i.getMaxZoom()},m._getTiles=function(i,g,m,_,b){var T=this.getMap(),P=i,I=T.projViewMatrix,W=T.getResolution(i)/T.getResolution(i-1)===.5;m<2&&(0===m&&W&&(P-=1),I=0===m?T.cascadeFrustumMatrix0:1===m?T.cascadeFrustumMatrix1:T.projViewMatrix);var q=P+this.options.zoomOffset,$=this._getTileOffset(P),ye=$[0]||$[1],Re={zoom:P,extent:null,offset:$,tiles:[]};if(q<0)return Re;if(!(T&&this.isVisible()&&T.width&&T.height))return Re;if(!b){var Be=this.getMinZoom(),Ge=this.getMaxZoom();if(!H(Be)&&P<Be||!H(Ge)&&P>Ge)return Re}var je=this._getTileConfig();if(!je)return Re;var Xe,Ze={zoom:$},Ye=(this._spatialRef||this.getSpatialReference()).getResolution(P);Xe=this._hasOwnSR?T.getGLScale(P):Ye/T.getGLRes();var Qe=!this._hasOwnSR&&this.options.repeatWorld,Je=this._convertToExtent2d(g),Ke=this._getMask2DExtent();if(Ke){var et=Ke.intersection(Je);if(!et)return Re;g=et.convertTo((function(i){return T._pointToContainerPoint(i,void 0,0,Cp)}))}var tt,at=T._containerPointToPrj(g.getCenter(),Ep),ht=T._prjToPoint(at,P,Rp);tt=this._project(ye?T._pointToPrj(ht._add($),P,Rp):at,Rp);var gt=T.getGLScale()/T.getGLScale(P);Lp.x=Je.xmin*gt,Lp.y=Je.ymax*gt,Dp.x=Je.xmax*gt,Dp.y=Je.ymin*gt;for(var yt=this._project(T._pointToPrj(Lp._add($),P,Lp),Lp),vt=this._project(T._pointToPrj(Dp._add($),P,Dp),Dp),xt=je.getTileIndex(tt,Ye,Qe),bt=je.getTileIndex(yt,Ye,Qe),Tt=je.getTileIndex(vt,Ye,Qe),Mt=Math.ceil(Math.abs(xt.idy-bt.idy)),Pt=Math.ceil(Math.abs(xt.idx-bt.idx)),It=Math.ceil(Math.abs(xt.idy-Tt.idy)),Et=Math.ceil(Math.abs(xt.idx-Tt.idx)),Lt=(Mt+It+1)*(Pt+Et+1),Dt=this.getTileSize(),Ft=this.getRenderer()||_,Ht=this._getTileConfig().tileSystem.scale,Bt=[],zt=new kl,Vt=new un(0,0),Ut=-Mt;Ut<=It;Ut++)for(var Gt=-Pt,jt=-1/0,Wt=!1;Gt>=jt&&Gt<=Et;){var qt=je.getNeighorTileIndex(xt.idx,xt.idy,Gt,Ut,Ye,Qe);jt===-1/0?Gt++:Gt--;var Xt=this._getTileId(qt.idx,qt.idy,P);if(!(qt.out||this._visitedTiles&&this._visitedTiles.has(Xt))){var Zt=Ft&&Ft.isTileCachedOrLoading(Xt);Zt&&(Zt=Zt.info);var $t=void 0;if(Zt){var{extent2d:Yt}=Zt;Vt.set(Yt.xmin,Yt.ymax),$t=Vt}else if(this._hasOwnSR){var Qt=je.getTilePrjNW(qt.x,qt.y,Ye);$t=T._prjToPoint(this._unproject(Qt,Dp),P)}else $t=je.getTilePointNW(qt.x,qt.y,Ye);var Jt=void 0,Kt=void 0;if(this._hasOwnSR){var en=void 0;if(this._hasOwnSR){var tn=je.getTilePrjSE(qt.x,qt.y,Ye);en=T._prjToPoint(this._unproject(tn,Dp),P,Dp)}else en=je.getTilePointSE(qt.x,qt.y,Ye);Jt=Math.ceil(Math.abs(en.x-$t.x)),Kt=Math.ceil(Math.abs(en.y-$t.y))}else Jt=Dt.width,Kt=Dt.height;var nn=Ht.x*(qt.idx-qt.x)*Jt,rn=Ht.y*(qt.idy-qt.y)*Kt;Zt||!nn&&!rn||$t._add(nn,rn);var on=Zt&&Zt.extent2d||new kl($t.x,$t.y-Kt,$t.x+Jt,$t.y);if(Lt<=4||Wt||this._isTileInExtent(I,on,$,Xe)){var sn=this._hasOwnSR?T._getResolution(P):Ye;this._visitedTiles&&0===m&&this._visitedTiles.add(Xt),W&&0===m?(this._splitTiles(I,Bt,Ft,qt,P+1,sn,on,nn,rn,Ze),zt._combine(on)):(Zt?(Zt.offset[0]=$[0],Zt.offset[1]=$[1]):Zt=this.createTileNode(qt.x,qt.y,P,qt.idx,qt.idy,sn,0,null,on,Xt),Bt.push(Zt),zt._combine(on)),jt===-1/0?(jt=Gt,Gt=Et):Wt||(Wt=!0)}}}if(Bt.length){var an=T._containerPointToPoint(g.getCenter(),P,Cp)._add($),ln=new un(0,0),hn=new un(0,0);Bt.sort((function(i,g){return ln.set((i.extent2d.xmin+i.extent2d.xmax)/2,(i.extent2d.ymin+i.extent2d.ymax)/2),hn.set((g.extent2d.xmin+g.extent2d.xmax)/2,(g.extent2d.ymin+g.extent2d.ymax)/2),ln.distanceTo(an)-hn.distanceTo(an)}))}return{offset:$,zoom:i,extent:zt,tiles:Bt}},m._convertToExtent2d=function(i){var g=this,m=this.getMap();return i.convertTo((function(i){if(i.y>0&&i.y<m.height){var _=(0===i.x?0:1)+i.y;g._coordCache[_]||(g._coordCache[_]=m._containerPointToPoint(i))}return m._containerPointToPoint(i,void 0,Cp)}))},m._splitTiles=function(i,g,m,_,b,T,P,I,H,W){var q=this._getTileConfig().tileSystem.scale.y,$=this.getMap().getGLScale(b),ye=Fp.set(2*P.xmin,q<0?2*P.ymax:2*P.ymin),Re=P.getWidth(),Be=P.getHeight(),Ge=2*_.idx,je=2*_.idy,Xe=2*_.x,Ze=2*_.y,Ye=this._checkAndAddTile(i,m,Ge,je,Xe,Ze,b,T,0,0,Re,Be,ye,$,W);Ye&&g.push(Ye),(Ye=this._checkAndAddTile(i,m,Ge,je,Xe,Ze,b,T,0,1,Re,Be,ye,$,W))&&g.push(Ye),(Ye=this._checkAndAddTile(i,m,Ge,je,Xe,Ze,b,T,1,0,Re,Be,ye,$,W))&&g.push(Ye),(Ye=this._checkAndAddTile(i,m,Ge,je,Xe,Ze,b,T,1,1,Re,Be,ye,$,W))&&g.push(Ye)},m._checkAndAddTile=function(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be){var Ge=this._getTileId(m+H,_+W,P);if(this._visitedTiles&&this._visitedTiles.has(Ge))return null;var je=Be[P];je||(je=Be[P]=this._getTileOffset(P));var Xe=this._getTileConfig().tileSystem.scale.y,Ze=new kl(ye.x+H*q,ye.y+Xe*W*$,ye.x+(H+1)*q,ye.y+Xe*(W+1)*$);if(!this._isSplittedTileInExtent(i,Ze,je,Re))return null;var Ye=I/2,Qe=g&&g.isTileCachedOrLoading(Ge);return Qe?Qe.info:this.createTileNode(b+H,T+W,P,m+H,m+T,Ye,0,null,Ze,Ge)},m._getTileOffset=function(...i){var g=this.options.offset;return g?(Re(g)&&(g=g.call(this,...i)),W(g)&&(g=[g,g]),g||[0,0]):[0,0]},m.getTileId=function(i,g,m,_){return this._getTileId(i,g,m,_)},m._getTileId=function(i,g,m,_){return(_||this.getId())+"_"+i+"_"+g+"_"+m},m._project=function(i,g){if(this._hasOwnSR){var m=this.getMap().getProjection();return(this._spatialRef||this.getSpatialReference()).getProjection().project(m.unproject(i,g),g)}return i},m._unproject=function(i,g){if(this._hasOwnSR){var m=this.getMap(),_=this._spatialRef||this.getSpatialReference(),b=m.getProjection(),T=_.getProjection();return b.project(T.unproject(i,g),g)}return i},m._initTileConfig=function(){var i=this.getMap(),g=this.getTileSize(),m=this.getSpatialReference(),_=m.getProjection(),b=m.getFullExtent();this._defaultTileConfig=new yp(i,mp.getDefault(_),b,g),this.options.hasOwnProperty("tileSystem")&&(this._tileConfig=new yp(i,this.options.tileSystem,b,g)),delete this._rootNodes,delete this._tileFullExtent,delete this._disablePyramid},m._getTileConfig=function(){return this._defaultTileConfig||this._initTileConfig(),this._tileConfig||this._defaultTileConfig},m._bindMap=function(g){return this._onSpatialReferenceChange(),i.prototype._bindMap.apply(this,arguments)},m._isTileInExtent=function(i,g,m,_){var b,T=this.getMap();if(i!==T.projViewMatrix){var P=g.getCenter(Np)._sub(m[0],m[1])._multi(_);es(Vp,P.x,P.y,0);var I=function(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[3]*_+m[7]*b+m[11]*T+m[15];return i[0]=(m[0]*_+m[4]*b+m[8]*T+m[12])/(P=P||1),i[1]=(m[1]*_+m[5]*b+m[9]*T+m[13])/P,i[2]=(m[2]*_+m[6]*b+m[10]*T+m[14])/P,i}(Vp,Vp,T.projViewMatrix);b=I[1]<0?T.projViewMatrix:i}else b=T.projViewMatrix;return Hp[0][0]=(g.xmin-m[0])*_,Hp[0][1]=(g.ymin-m[1])*_,Hp[1][0]=(g.xmax-m[0])*_,Hp[1][1]=(g.ymax-m[1])*_,bp(b,Hp)},m._isSplittedTileInExtent=function(i,g,m,_){var b=this.getMap();return Hp[0][0]=(g.xmin-m[0])*_,Hp[0][1]=(g.ymin-m[1])*_,Hp[1][0]=(g.xmax-m[0])*_,Hp[1][1]=(g.ymax-m[1])*_,bp(b.projViewMatrix,Hp)},m.getEvents=function(){return{spatialreferencechange:this._onSpatialReferenceChange}},m._onSpatialReferenceChange=function(){delete this._tileConfig,delete this._defaultTileConfig,delete this._sr,delete this._srMinZoom,delete this._hasOwnSR,delete this._rootNodes,this.tileInfoCache&&this.tileInfoCache.reset();var i=this.getRenderer();i&&i.clear()},m.getPolygonOffsetCount=function(){return 2},m.getPolygonOffset=function(){return this._polygonOffset||0},m.setPolygonOffset=function(i){return this._polygonOffset=i,this},m.getRenderer=function(){return i.prototype.getRenderer.call(this)},m._getTileBBox=function(i){var g=this.getMap();if(g){var m=i.extent2d,_=i.offset||[0,0];if(m){var b=i.res,[T,P]=_,{xmin:I,ymin:H,xmax:W,ymax:q}=m;W-=T,q-=P;var $=new un(I-=T,H-=P),ye=new un(W,q),Re=g.pointAtResToCoordinate($,b,Ep),Be=g.pointAtResToCoordinate(ye,b,Rp);return[Re.x,Re.y,Be.x,Be.y]}}},m._tileInMask=function(i){var g=this.getMask();if(!g)return!0;var m=g.type;if(!m||-1===m.indexOf("Polygon"))return!0;var _=this._maskGeoJSON;if(!_||!_.geometry)return!0;var{coordinates:b,type:T}=_.geometry;if(!b||!T)return!0;if(-1===T.indexOf("Polygon"))return!0;if(!_.bbox){var P=g.getExtent();if(!P)return!0;_.bbox=[P.xmin,P.ymin,P.xmax,P.ymax]}var I=this._getTileBBox(i);return!I||$o(I,this._maskGeoJSON)},m._debugTile=function(i,g,m){if(this.options.debugTile){if(Array.isArray(i)){for(var _=0;_<i.length;_++)i[_]&&this._debugTile(i[_],g+" at "+_,m);return}if(!i)return;var{x:b,y:T,z:P}=this.options.debugTile;i.x===b&&i.y===T&&i.z===P&&console.log("Debug Tile Found in TileLayer."+g+":",i)}},g}(Fu);function Gp(i,g){return i.z-g.z}Up.registerJSONType("TileLayer"),Up.mergeOptions(kp),function(i){i[i.OUT_OF_FRUSTUM=0]="OUT_OF_FRUSTUM",i[i.SCREEN_ERROR_TOO_SMALL=1]="SCREEN_ERROR_TOO_SMALL",i[i.VISIBLE=2]="VISIBLE"}(Mp||(Mp={}));var jp=new ir(256,256),Wp="show hide remove setzindex forcereloadstart";function qp(i){return Array.isArray(i)||(i=[i]),i}var Xp=function(i){function g(g,m,_){var b;return(b=i.call(this,g,_)||this).layers=m||[],b._checkChildren(),b.layerMap={},b._groupChildren=[],b}tn(g,i),g.fromJSON=function(i){if(!i||"GroupTileLayer"!==i.type)return null;var m=i.layers.map((function(i){return Fu.fromJSON(i)}));return new g(i.id,m,i.options)};var m=g.prototype;return m.getLayers=function(){return this.layers},m.addLayer=function(i=[]){var g=this;i=qp(i);var m=this.layers.length;return i.forEach((function(i){i instanceof Up&&(-1!==g.layers.indexOf(i)||g.layerMap[i.getId()]||g.layers.push(i))})),m!==this.layers.length&&(this._sortLayers(),this._refresh(),this._renderLayers()),this},m.removeLayer=function(i=[]){var g=this;i=qp(i);var m=this.layers.length;return i.forEach((function(i){if(i instanceof Up||(i=g.layerMap[i]),i instanceof Up){var m=g.layers.indexOf(i);m>=0&&(g.layers.splice(m,1),i._doRemove(),i.off(Wp,g._onLayerShowHide,g))}})),m!==this.layers.length&&(this._refresh(),this._renderLayers()),this},m.clearLayers=function(){var i=this;return this.layers.forEach((function(g){g._doRemove(),g.off(Wp,i._onLayerShowHide,i)})),this.layers=[],this._refresh(),this._renderLayers(),this},m.toJSON=function(){return{type:this.getJSONType(),id:this.getId(),layers:this.layers.map((function(i){return i.toJSON()})),options:this.config()}},m.getTileSize=function(i){var g=this.getLayer(i);return g?g.getTileSize():jp},m.getTiles=function(i,g){for(var m=this.layers,_=[],b=0,T=0,P=m.length;T<P;T++){var I=m[T];if(I&&I.options.visible&&I.isVisible()&&I.getMap()){var H=I.getTiles(i,g||this);H&&0!==H.count&&(b+=H.count,yn(_,H.tileGrids))}}return{count:b,tileGrids:_}},m.onAdd=function(){this._sortLayers(),this._refresh(),i.prototype.onAdd.call(this)},m.onRemove=function(){var g=this;this.layers.forEach((function(i){i._doRemove(),i.off(Wp,g._onLayerShowHide,g)})),this.layerMap={},this._groupChildren=[],i.prototype.onRemove.call(this)},m.getLayer=function(i){return this.getChildLayer(i)},m.getChildLayer=function(i){var g=this.layerMap[i];if(g)return g;for(var m=0;m<this._groupChildren.length;m++){var _=this._groupChildren[m].getChildLayer(i);if(_)return _}return null},m._removeChildTileCache=function(i){if(!i)return this;var g,m=this.getRenderer();if(!m)return this;var _=i.getId(),b=function(){return g&&g.info&&g.info.layer===_};m.tileCache&&m.tileCache.keys().forEach((function(i){g=m.tileCache.get(i),b()&&m.tileCache.remove(i)}));var T=m.tilesInView||{};for(var P in T)g=T[P],b()&&delete T[P];var I=m.tilesLoading||{};for(var H in I)g=I[H],b()&&m.abortTileLoading(g.image,g.info);return this},m._onLayerShowHide=function(i){var{type:g,target:m}=i||{};"remove"===g&&m?(this.layers.splice(this.layers.indexOf(m),1),m._doRemove(),m.off(Wp,this._onLayerShowHide,this),this._refresh()):"setzindex"===g?this._sortLayers():"forcereloadstart"===g&&this._removeChildTileCache(m),this._renderLayers()},m._renderLayers=function(){var i=this.getRenderer();return i&&i.setToRedraw(),this},m._refresh=function(){var i=this,g=this.getMap();return this._groupChildren=[],this.layerMap={},this.layers.forEach((function(m){i.layerMap[m.getId()]=m,m.getChildLayer&&i._groupChildren.push(m),m.getMap()||m._bindMap(g),m.off(Wp,i._onLayerShowHide,i),m.on(Wp,i._onLayerShowHide,i)})),this},m.isVisible=function(){if(!i.prototype.isVisible.call(this))return!1;for(var g=this.layers,m=0,_=g.length;m<_;m++)if(g[m].isVisible())return!0;return!1},m._checkChildren=function(){var i=this,g={};this.layers.forEach((function(m){var _=m.getId();if(g[_])throw new Error("Duplicate child layer id ("+_+") in the GroupTileLayer ("+i.getId()+")");g[_]=1}))},m._sortLayers=function(){this.layers.sort((function(i,g){return i.options.zIndex-g.options.zIndex}))},g}(Up);Xp.registerJSONType("GroupTileLayer"),Xp.mergeOptions({urlTemplate:"",maxCacheSize:1024});var Zp,$p={urlTemplate:"",crs:null,uppercase:!1,detectRetina:!1},Yp={service:"WMS",request:"GetMap",layers:"",styles:"",format:"image/jpeg",transparent:!1,version:"1.1.1"},Qp=function(i){function g(g,m){var _;return _=i.call(this,g)||this,Zp||(Zp=I({},_.options)),_.wmsParams=I({},Yp),_._setOptions(m),_.setZIndex(m.zIndex),$t.proxy||_._optionsHook(m),_}tn(g,i);var m=g.prototype;return m._optionsHook=function(i={}){for(var g in i)"tileSize"===g&&(this._tileSize=null),g in Zp||(this.wmsParams[g]=i[g]);var m=this.getTileSize();return this.wmsParams.width=m.width,this.wmsParams.height=m.height,this._wmsVersion=parseFloat(this.wmsParams.version),this},m.onAdd=function(){var g=this.getMap().getDevicePixelRatio(),m=$p.detectRetina?g:1;this.wmsParams.width*=m,this.wmsParams.height*=m;var _=this.options.crs||this.getMap().getProjection().code;this.wmsParams[this._wmsVersion>=1.3?"crs":"srs"]=_,i.prototype.onAdd.call(this)},m.getTileUrl=function(g,m,_){var b=this.getSpatialReference().getResolution(_),T=this._getTileConfig().getTilePrjExtent(g,m,b),P=T.getMax(),I=T.getMin(),H=(this._wmsVersion>=1.3&&("EPSG:4326"===this.wmsParams.crs||"EPSG:4490"===this.wmsParams.crs)?[I.y,I.x,P.y,P.x]:[I.x,I.y,P.x,P.y]).join(","),W=i.prototype.getTileUrl.call(this,g,m,_);return W+function(i,g,m){var _=[];for(var b in i)_.push(encodeURIComponent(m?b.toUpperCase():b)+"="+encodeURIComponent(i[b]));return(g&&-1!==g.indexOf("?")?"&":"?")+_.join("&")}(this.wmsParams,W,this.options.uppercase)+(this.options.uppercase?"&BBOX=":"&bbox=")+H},m.toJSON=function(){return{type:"WMSTileLayer",id:this.getId(),options:this.config()}},g.fromJSON=function(i){return i&&"WMSTileLayer"===i.type?new g(i.id,i.options):null},g}(Up);Qp.registerJSONType("WMSTileLayer"),Qp.mergeOptions($p);var Jp=function(i){function g(g,m){var _;return(_=i.call(this,g,m)||this).options.hasOwnProperty("forceRenderOnMoving")||(_.options.forceRenderOnMoving=!1),_}tn(g,i);var m=g.prototype;return m.drawTile=function(){},m.toJSON=function(){return{type:"CanvasTileLayer",id:this.getId(),options:this.config()}},g.fromJSON=function(i){return i&&"CanvasTileLayer"===i.type?new g(i.id,i.options):null},g}(Up);function Kp(i,g,m){var _=i.createShader(g);if(i.shaderSource(_,m),i.compileShader(_),!i.getShaderParameter(_,i.COMPILE_STATUS)){var b=i.getShaderInfoLog(_);throw i.deleteShader(_),new Error("Failed to compile shader: "+b)}return _}function eg(i,g,m){var _=Kp(i,i.VERTEX_SHADER,g),b=Kp(i,i.FRAGMENT_SHADER,m);if(!_||!b)return null;var T=i.createProgram();return T?(i.attachShader(T,_),i.attachShader(T,b),i.linkProgram(T),{program:T,vertexShader:_,fragmentShader:b}):null}function tg(i,g,m){if(Array.isArray(m[0])){for(var _=Float32Array.BYTES_PER_ELEMENT,b=0,T=0;T<m.length;T++)b+=m[T][1]||0;for(var P=0,I=0;I<m.length;I++){var H=i.getAttribLocation(g,m[I][0]);if(H<0)throw new Error("Failed to get the storage location of "+m[I][0]);i.vertexAttribPointer(H,m[I][1],i[m[I][2]||"FLOAT"],!1,_*b,_*P),P+=m[I][1]||0,i.enableVertexAttribArray(H)}}else{var W=i.getAttribLocation(g,m[0]);i.vertexAttribPointer(W,m[1],i[m[2]||"FLOAT"],!1,0,0),i.enableVertexAttribArray(W)}}Jp.registerJSONType("CanvasTileLayer");var ng={never:512,"<":513,"=":514,"<=":515,">":516,"!=":517,">=":518,always:519};var rg=[1,1,1,1],ig=new Float32Array(8),og=new Int16Array(8),sg="\n        attribute vec2 a_position;\n\n        attribute vec2 a_texCoord;\n\n        uniform mat4 u_matrix;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            gl_Position = u_matrix * vec4(a_position, 0., 1.);\n\n            v_texCoord = a_texCoord;\n        }\n    ",ag="\n        precision mediump float;\n\n        uniform sampler2D u_image;\n\n        uniform float u_opacity;\n        uniform float u_debug_line;\n        uniform vec4 u_base_color;\n        uniform float u_alpha_test;\n        varying vec2 v_texCoord;\n\n        void main() {\n            if (u_debug_line == 1.) {\n                gl_FragColor = vec4(0., 1., 0., 1.);\n            } else {\n                gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n            }\n            gl_FragColor *= u_base_color;\n            if (gl_FragColor.a < u_alpha_test) {\n                discard;\n            }\n        }\n    ",lg=["",0],hg=[0,0,0],cg=new Array(16),ug=new un(20,20),fg=function(i){var g=function(i){function g(){var g;return(g=i.apply(this,arguments)||this)._layerAlt=0,g._layerAltitude=0,g}tn(g,i);var _=g.prototype;return _.drawGLImage=function(i,g,m,_,b,T,P,I,q,$){this.gl.program!==this.program&&this.useProgram(this.program);var ye=this.gl;if(this.loadTexture(i,I),this.canvas.gl&&this.canvas.gl.wrap){var Re=this.layer&&this.layer.options.opacity;H(Re)&&(Re=1),P*=Re}hg[0]=g||0,hg[1]=m||0,hg[2]=0;var Be=this.layer,Ge=this.getMap();if(Be){var{altitude:je}=Be.options,Xe=W(je);if(Xe||(this._layerAlt=0),this._layerAltitude!==je&&Xe){var Ze=Ge.altitudeToPoint(je,Ge.getGLRes());this._layerAltitude=je,this._layerAlt=Ze}}hg[2]=this._layerAlt||0;var Ye=Mo(cg);vo(Ye,Ye,hg),xo(Ye,Ye,[T,T,1]),To(Ye,Ge.projViewMatrix,Ye),ye.uniformMatrix4fv(this.program.u_matrix,!1,Ye),ye.uniform1f(this.program.u_opacity,P),ye.uniform1f(this.program.u_debug_line,0),ye.uniform4fv(this.program.u_base_color,$||rg),ye.uniform1f(this.program.u_alpha_test,this.layer.options.alphaTest||0);var{glBuffer:Qe}=i;!Qe||Qe.width===_&&Qe.height===b||(this.saveImageBuffer(Qe),delete i.glBuffer),i.glBuffer?ye.bindBuffer(ye.ARRAY_BUFFER,Qe):i.glBuffer=this.bufferTileData(0,0,_,b),lg[0]="a_position",lg[1]=2,lg[2]=i.glBuffer.type,this.enableVertexAttrib(lg),ye.bindBuffer(ye.ARRAY_BUFFER,this.texBuffer),lg[0]="a_texCoord",lg[1]=2,lg[2]="UNSIGNED_BYTE",this.enableVertexAttrib(lg),ye.drawArrays(ye.TRIANGLE_STRIP,0,4),q&&this.drawDebug(Ye,0,0,_,b,q)},_.drawDebug=function(i,g,m,_,b,T){var P=this.gl;P.disable(P.DEPTH_TEST),P.bindBuffer(P.ARRAY_BUFFER,this._debugBuffer),this.enableVertexAttrib(["a_position",2,"FLOAT"]),P.bufferData(P.ARRAY_BUFFER,new Float32Array([g,m,g+_,m,g+_,m-b,g,m-b,g,m]),P.DYNAMIC_DRAW),P.uniformMatrix4fv(this.program.u_matrix,!1,i),P.uniform1f(this.program.u_opacity,1),P.uniform1f(this.program.u_debug_line,1),P.uniform4fv(this.program.u_base_color,rg),P.uniform1f(this.program.u_alpha_test,this.layer.options.alphaTest||0),P.drawArrays(P.LINE_STRIP,0,5);var I=this._debugInfoCanvas;if(!I){var H=this.mapDPR||this.getMap().getDevicePixelRatio()>1?2:1;(I=this._debugInfoCanvas=document.createElement("canvas")).width=256*H,I.height=32*H;var W=I.getContext("2d");W.font="20px monospace",W.scale(H,H)}var q=I.getContext("2d");q.clearRect(0,0,I.width,I.height),Va.fillText(q,T,ug,this.layer.options.debugOutline),this.loadTexture(I),P.texImage2D(P.TEXTURE_2D,0,P.RGBA,P.RGBA,P.UNSIGNED_BYTE,I);var $=g+(_=256),ye=m-b+32,Re=m-b;P.bufferData(P.ARRAY_BUFFER,this.set8(g,ye,g,Re,$,ye,$,Re),P.DYNAMIC_DRAW),P.uniform1f(this.program.u_debug_line,0),P.bindBuffer(P.ARRAY_BUFFER,this.texBuffer),this.enableVertexAttrib(["a_texCoord",2,"UNSIGNED_BYTE"]),P.drawArrays(P.TRIANGLE_STRIP,0,4),P.enable(P.DEPTH_TEST)},_.bufferTileData=function(i,g,m,_,b){var T,P=i,I=i+m,H=g,W=g-_;T=q(P)&&q(I)&&q(H)&&q(W)?this.set8Int(P,H,P,W,I,H,I,W):this.set8(P,H,P,W,I,H,I,W);var $=this.loadImageBuffer(T,b);return $.width=m,$.height=_,$.type=T instanceof Int16Array?"SHORT":"FLOAT",$},_.createCanvas2=function(){this.canvas2=Va.createCanvas(this.canvas.width,this.canvas.height)},_.createGLContext=function(){this.gl=this.canvas.gl&&this.canvas.gl.wrap?this.canvas.gl.wrap():function(i,g){for(var m={alpha:!0,stencil:!0,preserveDrawingBuffer:!0,antialias:!1},_=["webgl","experimental-webgl"],b=null,T=0;T<_.length;++T){try{b=i.getContext(_[T],g||m)}catch(i){}if(b)break}return b}(this.canvas2||this.canvas,this.layer.options.glOptions);var i=this.gl;i.clearColor(0,0,0,0),i.enable(i.DEPTH_TEST),i.enable(i.STENCIL_TEST),i.enable(i.BLEND),i.blendFunc(i.ONE,i.ONE_MINUS_SRC_ALPHA),this.program=this.createProgram(sg,this.layer.options.fragmentShader||ag),this._debugBuffer=this.createBuffer(),this.useProgram(this.program),this.texBuffer=this.createBuffer(),i.bindBuffer(i.ARRAY_BUFFER,this.texBuffer),this.enableVertexAttrib(["a_texCoord",2,"UNSIGNED_BYTE"]),i.bufferData(i.ARRAY_BUFFER,new Uint8Array([0,0,0,1,1,0,1,1]),i.STATIC_DRAW),this.enableSampler("u_image"),i.activeTexture(i.TEXTURE0),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!0)},_.resizeGLCanvas=function(){this.gl&&this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.canvas2&&(this.canvas2.width===this.canvas.width&&this.canvas2.height===this.canvas.height||(this.canvas2.width=this.canvas.width,this.canvas2.height=this.canvas.height))},_.clearGLCanvas=function(){this.gl&&(this.gl.clearStencil(255),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.STENCIL_BUFFER_BIT)),this.gl.wrap||this.gl.clear(this.gl.DEPTH_BUFFER_BIT)},_.disposeImage=function(i){i&&(i.texture&&this.saveTexture(i.texture),i.glBuffer&&this.saveImageBuffer(i.glBuffer),delete i.texture,delete i.glBuffer)},_._createTexture=function(i){var g=this.gl,m=this.getTexture()||g.createTexture();g.bindTexture(g.TEXTURE_2D,m),g.texParameteri(g.TEXTURE_2D,g.TEXTURE_MIN_FILTER,g.NEAREST),g.texParameteri(g.TEXTURE_2D,g.TEXTURE_MAG_FILTER,g.NEAREST),g.texParameteri(g.TEXTURE_2D,g.TEXTURE_WRAP_S,g.CLAMP_TO_EDGE),g.texParameteri(g.TEXTURE_2D,g.TEXTURE_WRAP_T,g.CLAMP_TO_EDGE);var _=this.layer.options.mipmapTexture;return!_||dg(i.width)&&dg(i.height)||(i=function(i){if(dg(i.width)&&dg(i.height))return i;var g=i.width,m=i.height;dg(g)||(g=pg(g));dg(m)||(m=pg(m));var _=document.createElement("canvas");_.width=g,_.height=m;var b=_.getContext("2d");return b.imageSmoothingEnabled=!1,b.drawImage(i,0,0,g,m),_}(i)),g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,i),_&&g.generateMipmap(g.TEXTURE_2D),m},_.getTexture=function(){this._textures||(this._textures=[]);var i=this._textures;return i&&i.length>0?i.pop():null},_.saveTexture=function(i){this._textures.push(i)},_.loadTexture=function(i,g=!1){var m=this.gl,_=i.texture;if(_||(_=this._createTexture(i),i.texture=_),m.bindTexture(m.TEXTURE_2D,_),this.layer.options.mipmapTexture){var b=this.getMap(),T=this.mapDPR||b.getDevicePixelRatio();b.isMoving()&&b.getRenderer().isViewChanged()?m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.LINEAR_MIPMAP_LINEAR):m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.LINEAR),m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,1!==T||g?m.LINEAR:m.NEAREST)}return _},_.getImageBuffer=function(){this._imageBuffers||(this._imageBuffers=[]);var i=this._imageBuffers;return i&&i.length>0?i.pop():null},_.saveImageBuffer=function(i){this._imageBuffers||(this._imageBuffers=[]),this._imageBuffers.push(i)},_.loadImageBuffer=function(i,g){var m=this.gl,_=g||this.createImageBuffer();return m.bindBuffer(m.ARRAY_BUFFER,_),m.bufferData(m.ARRAY_BUFFER,i,m.STATIC_DRAW),_},_.createImageBuffer=function(){return this.getImageBuffer()||this.createBuffer()},_.removeGLCanvas=function(){var i=this.gl;if(i){if(this._debugBuffer&&(i.deleteBuffer(this._debugBuffer),delete this._debugBuffer),this._buffers&&(this._buffers.forEach((function(g){i.deleteBuffer(g)})),delete this._buffers),this._textures&&(this._textures.forEach((function(g){return i.deleteTexture(g)})),delete this._textures),this._debugInfoCanvas){var g=this._debugInfoCanvas.texture;g&&i.deleteTexture(g),delete this._debugInfoCanvas.texture,delete this._debugInfoCanvas}var m=i.program;i.deleteShader(m.fragmentShader),i.deleteShader(m.vertexShader),i.deleteProgram(m),delete this.gl,delete this.canvas2}},_.createBuffer=function(){var i=this.gl.createBuffer();if(!i)throw new Error("Failed to create the buffer object");return this._buffers||(this._buffers=[]),this._buffers.push(i),i},_.enableVertexAttrib=function(i){tg(this.gl,this.gl.program,i)},_.createProgram=function(i,g){for(var m=this.gl,{program:_,vertexShader:b,fragmentShader:T}=eg(m,i,g),P=m.getProgramParameter(_,35718),I=[],H=0;H<P;++H){var W=m.getActiveUniform(_,H);I.push(W.name)}return _.vertexShader=b,_.fragmentShader=T,this._initUniforms(_,I),_},_.useProgram=function(i){var g=this.gl;return g.useProgram(i),g.program=i,this},_.enableSampler=function(i,g){var m=this.gl,_=this._getUniform(m.program,i);return g||(g=0),m.uniform1i(_,g),_},_._initUniforms=function(i,g){for(var _=0;_<g.length;_++){var b=g[_],T=g[_],P=b.indexOf("[");P>=0&&(b=b.substring(0,P),m||(T=T.substring(0,P))),i[b]=this._getUniform(i,T)}},_._getUniform=function(i,g){var m=this.gl.getUniformLocation(i,g);if(!m)throw new Error("Failed to get the storage location of "+g);return m},_.set8=function(i,g,m,_,b,T,P,I){var H=ig;return H[0]=i,H[1]=g,H[2]=m,H[3]=_,H[4]=b,H[5]=T,H[6]=P,H[7]=I,H},_.set8Int=function(i,g,m,_,b,T,P,I){var H=og;return H[0]=i,H[1]=g,H[2]=m,H[3]=_,H[4]=b,H[5]=T,H[6]=P,H[7]=I,H},g}(i);return g};function dg(i){return!(i&i-1)&&0!==i}function pg(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}var gg=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.needToRedraw=function(){var i=this.getMap();return!(!i.isInteracting()&&!i.getRenderer().isViewChanged())&&!(!i.getPitch()&&i.isMoving()&&!i.isZooming()&&!i.isRotating()&&!this.layer.options.forceRenderOnMoving)},m.createContext=function(){if(!(this.gl&&this.gl.canvas===this.canvas||this.context)&&(this.context=Va.getCanvas2DPerformanceContext(this.canvas),this.context)){this.context.dpr=1,this.layer.options.globalCompositeOperation&&(this.context.globalCompositeOperation=this.layer.options.globalCompositeOperation);var i=this.getMap().getDevicePixelRatio();1!==i&&this._canvasContextScale(this.context,i)}},m.resetCanvasTransform=function(){if(this.context){var i=this.getMap().getDevicePixelRatio();this.context.setTransform(i,0,0,i,0,0)}},m.clearCanvas=function(){if(this.context){var i=this.getMap();if(i){var g=1/(this.mapDPR||i.getDevicePixelRatio()),m=this.canvas.height*g;Va.clearRect(this.context,0,0,Math.max(this.canvas.width*g,this.canvas.width),Math.max(m,this.canvas.height))}}},m.clear=function(){this.clearCanvas(),this.setToRedraw()},m.prepareCanvas=function(){this.canvas?(this.resetCanvasTransform(),this.clearCanvas(),this.resizeCanvas()):(this.createCanvas(),this.createContext(),this.layer.onCanvasCreate(),this.layer.fire("canvascreate",{context:this.context,gl:this.gl})),delete this._maskExtent;var i=this.layer.getMask();if(!i)return this.layer.fire("renderstart",{context:this.context,gl:this.gl}),null;var g=this._maskExtent=i._getMaskPainter().get2DExtent();return g&&this._extent2D&&g.intersects(this._extent2D),this.layer.fire("renderstart",{context:this.context,gl:this.gl}),g},m.onResize=function(i){delete this._extent2D,this.resizeCanvas(),this.setToRedraw()},g}(Lu),mg={renderer:$t.webgl?"gl":"canvas",crossOrigin:null,alphaTest:!1,depthMask:!0,depthFunc:"<="},Ag=new un(0,0),yg=function(i){function g(g,m,_){var b;return!m||Array.isArray(m)||m.url||(_=m,m=null),(b=i.call(this,g,_)||this)._images=m,b}tn(g,i);var m=g.prototype;return m.onAdd=function(){this._prepareImages(this._images)},m.setImages=function(i){return this._images=i,this._prepareImages(i),this},m.getImages=function(){return this._images},m._prepareImages=function(i){i=i||[],Array.isArray(i)||(i=[i]);var g=this.getMap(),m=g.getGLRes();this._imageData=i.map((function(i){var _=new Pl(i.extent);return I({},i,{extent:_,extent2d:_.convertTo((function(i){return g.coordToPointAtRes(i,m)}))})})),this._images=i;var _=this.getRenderer();_&&_.refreshImages()},m.getRenderer=function(){return i.prototype.getRenderer.call(this)},g}(Fu);yg.mergeOptions(mg);var _g,vg=[],xg=function(i){var g=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.isDrawable=function(){return!0},m.checkResources=function(){var i=this;if(this._imageLoaded)return vg;var g=this.layer._imageData.map((function(i){return[i.url,null,null]}));if(this.resources){var m=[],_=Ko();g.forEach((function(g){if(i.resources.isResourceLoaded(g)){var b=i.resources.getImage(g);_.addResource(g,b)}else m.push(g)})),this.resources.forEach((function(g,m){_.isResourceLoaded(g)||i.retireImage(m.image)})),this.resources=_,g=m}return this._imageLoaded=!0,g},m.retireImage=function(i){i.close&&i.close()},m.refreshImages=function(){this._imageLoaded=!1,this.setToRedraw()},m.draw=function(i,g){this.isDrawable()&&(this.prepareCanvas(),this._painted=!1,this.drawImages(i,g),this.completeRender())},m.drawImage=function(i,g,m){},m.drawImages=function(i,g){var m=this.layer._imageData,_=this.getMap(),b=_.get2DExtentAtRes(_.getGLRes());if(m&&m.length)for(var T=0;T<m.length;T++){var P=m[T].extent2d,I=this.resources&&this.resources.getImage(m[T].url);if(I&&b.intersects(P)){this._painted=!0;var H=m[T].opacity;W(H)||(H=1),this.drawImage(I,P,H)}}},m.drawOnInteracting=function(i,g,m){this.draw()},g}(i);return g},bg=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.isDrawable=function(){return!this.getMap().getPitch()||(console&&console.warn("ImageLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."),!1)},m.drawImage=function(i,g,m){var _=0,b=this.context;m<1&&(_=b.globalAlpha,b.globalAlpha=m);var T=this.getMap(),P=Ag.set(g.xmin,g.ymax),I=T._pointAtResToContainerPoint(P,T.getGLRes()),H=I.x,W=I.y,q=T.getBearing();q&&(b.save(),b.translate(H,W),q&&b.rotate(-q*Math.PI/180),H=W=0);var $=T.getGLScale();b.drawImage(i,H,W,g.getWidth()/$,g.getHeight()/$),q&&b.restore(),_&&(b.globalAlpha=_)},g}(xg(gg)),wg=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.drawOnInteracting=function(i,g,m){this.draw(g,m)},m._prepareGLContext=function(){var i=this.gl;i&&(i.disable(i.STENCIL_TEST),i.disable(i.POLYGON_OFFSET_FILL),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFunc(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA),i.depthFunc(function(i){return ng[i]}(this.layer.options.depthFunc)),i.depthMask(!!this.layer.options.depthMask))},m.drawImages=function(g,m){var _=this.gl;if(m&&m.renderTarget){var b=m.renderTarget.fbo;if(b){var T=m.renderTarget.getFramebuffer(b);_.bindFramebuffer(_.FRAMEBUFFER,T)}}(this._prepareGLContext(),i.prototype.drawImages.call(this),m&&m.renderTarget)&&(m.renderTarget.fbo&&_.bindFramebuffer(_.FRAMEBUFFER,null))},m.isDrawable=function(){return!0},m.drawImage=function(i,g,m){var _=g.getWidth();this.drawGLImage(i,g.xmin,g.ymax,_,g.getHeight(),1,m,i.width!==_)},m.createContext=function(){this.createGLContext()},m.resizeCanvas=function(g){this.canvas&&(i.prototype.resizeCanvas.call(this,g),this.resizeGLCanvas())},m.clearCanvas=function(){this.canvas&&(i.prototype.clearCanvas.call(this),this.clearGLCanvas())},m.retireImage=function(i){i.close&&i.close(),this.disposeImage(i)},m.onRemove=function(){this.removeGLCanvas(),i.prototype.onRemove.call(this)},g}(fg(bg));yg.registerRenderer("canvas",bg),yg.registerRenderer("gl",wg),function(i){i[i.never=0]="never",i[i["<"]=1]="<",i[i["="]=2]="=",i[i["<="]=3]="<=",i[i[" >"]=4]=" >",i[i["!="]=5]="!=",i[i[">="]=6]=">=",i[i.always=7]="always"}(_g||(_g={}));var Tg=new kl,Sg={debug:!1,enableSimplify:!0,defaultIconSize:[20,20],cacheVectorOnCanvas:!0,cacheSvgOnCanvas:$t.gecko,enableAltitude:!0,altitudeProperty:"altitude",drawAltitude:!1,sortByDistanceToCamera:!1,roundPoint:!1,altitude:0,clipBBoxBufferSize:3,collision:!1,collisionBufferSize:2,collisionDelay:250,collisionScope:"layer",progressiveRender:!1,progressiveRenderCount:1e3,progressiveRenderDebug:!1},Mg=function(i){function g(g,m,_){var b;return(b=i.call(this,g,m,_)||this).isVectorLayer=!0,b}tn(g,i);var m=g.prototype;return m.onConfig=function(g){if(i.prototype.onConfig.call(this,g),!H(g.enableAltitude))for(var m=this.getGeometries()||[],_=0,b=m.length;_<b;_++){var T=m[_];T&&(T._clearAltitudeCache(),T.fire("positionchange"))}if(g.enableAltitude||g.drawAltitude||g.altitudeProperty){var P=this.getRenderer();P&&P.setToRedraw&&P.setToRedraw()}},m.identify=function(i,g){g=g||{};var m=this.getRenderer();i instanceof pl||(i=new pl(i));var _=this.getMap().coordToContainerPoint(i);return g.onlyVisible&&m&&m.identifyAtPoint?m.identifyAtPoint(_,g):this._hitGeos(this._geoList,_,g)},m.identifyAtPoint=function(i,g){g=g||{};var m=this.getRenderer();return i instanceof un||(i=new un(i)),g.onlyVisible&&m&&m.identifyAtPoint?m.identifyAtPoint(i,g):this._hitGeos(this._geoList,i,g)},m._hitGeos=function(i,g,m={}){if(!i||!i.length)return[];for(var _=[],b=0,T=0,P=i.length;T<P;T++){var I=i[T];I.isPoint&&!0===I._collided||(_[b]=I,b++)}i=_;var H=m.filter,q=[],$=m.tolerance,ye=this.getMap(),Re=this.getRenderer(),Be=Re&&Re.getImageData&&Re.getImageData();if(Be){var Ge=0,je=Re.maxTolerance;if(W(je))Ge=je;else for(var Xe=i.length-1;Xe>=0;Xe--){var Ze=i[Xe]._hitTestTolerance()+($||0);Ze>Ge&&(Ge=Ze)}var Ye=ye.getDevicePixelRatio();Be.r=Ye;for(var Qe=!1,Je=g.x-Ge,Ke=g.y-Ge,et=-Ge;et<=Ge;et++){for(var tt=-Ge;tt<=Ge;tt++){var at=Math.round((Je+et)*Ye),ht=Math.round((Ke+tt)*Ye);if(Be.data[ht*Be.width*4+4*at+3]>0){Qe=!0;break}}if(Qe)break}if(!Qe)return q}for(var gt=m.onlyVisible,yt=i.length-1;yt>=0;yt--){var vt=i[yt];if(vt&&vt.options.interactive&&(gt||vt.isVisible())){var xt=vt._getPainter();if(xt){var bt=xt.getRenderBBOX&&xt.getRenderBBOX();if(bt){var{x:Tt,y:Mt}=g;if(Tt<bt[0]||Mt<bt[1]||Tt>bt[2]||Mt>bt[3])continue}if(!(vt instanceof vf&&(vt._getArrowStyle()||vt instanceof zf))){var Pt=vt.getContainerExtent(Tg);if($&&(Pt=Pt._expand($)),!Pt||!Pt.contains(g))continue}if(vt._containsPoint(g,$)&&(!H||H(vt))&&(q.push(vt),m.count&&q.length>=m.count))break}}}return q},m.getAltitude=function(){return this.options.altitude||0},m.toJSON=function(i){i||(i={clipExtent:null,geometries:null});var g={type:this.getJSONType(),id:this.getId(),options:this.config()};if(H(i.geometries)||i.geometries){var m;if(i.clipExtent){var _=this.getMap(),b=_?_.getProjection():null;m=new Pl(i.clipExtent,b)}for(var T=[],P=this.getGeometries(),I=0,W=P.length;I<W;I++){var q=P[I],$=q.getExtent();if($&&(!m||m.intersects($))){var ye=q.toJSON(i.geometries);T.push(ye)}}g.geometries=T}return g},m.getRenderer=function(){return i.prototype.getRenderer.call(this)},g.fromJSON=function(i){if(!i||"VectorLayer"!==i.type)return null;for(var m=new g(i.id,i.options),_=i.geometries,b=[],T=0;T<_.length;T++){var P=gu.fromJSON(_[T]);P&&b.push(P)}return m.addGeometry(b),m},g.getPainterClass=function(){return Jc},g.getCollectionPainterClass=function(){return tu},g}(td);Mg.mergeOptions(Sg),Mg.registerJSONType("VectorLayer"),nd.setLayerClass(Mg,Mg,Mg);var Cg=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.getPrepareParams=function(){return[]},m.getDrawParams=function(){return[]},m.onCanvasCreate=function(){this.canvas&&this.layer.options.doubleBuffer&&(this.buffer=Va.createCanvas(this.canvas.width,this.canvas.height,this.getMap().CanvasClass))},m.needToRedraw=function(){return!!this.layer.options.animation||!(this.getMap().isInteracting()&&!this.layer.drawOnInteracting)&&i.prototype.needToRedraw.call(this)},m.draw=function(...i){this.prepareCanvas(),this.prepareDrawContext(),this._drawLayer(...i)},m.drawOnInteracting=function(...i){this._drawLayerOnInteracting(...i)},m.getCanvasImage=function(){var g=i.prototype.getCanvasImage.call(this);if(g&&g.image&&this.layer.options.doubleBuffer){var m=g.image;this.buffer.width===m.width&&this.buffer.height===m.height||(this.buffer.width=m.width,this.buffer.height=m.height);var _=this.buffer.getContext("2d"),b=this.layer.doubleBuffer(_,this.context);(void 0===b||b)&&(Va.image(_,m,0,0),g.image=this.buffer)}return g},m.remove=function(){return delete this._drawContext,i.prototype.remove.call(this)},m.onZoomStart=function(g){this.layer.onZoomStart(g),i.prototype.onZoomStart.call(this,g)},m.onZooming=function(g){this.layer.onZooming(g),i.prototype.onZooming.call(this,g)},m.onZoomEnd=function(g){this.layer.onZoomEnd(g),i.prototype.onZoomEnd.call(this,g)},m.onMoveStart=function(g){this.layer.onMoveStart(g),i.prototype.onMoveStart.call(this,g)},m.onMoving=function(g){this.layer.onMoving(g),i.prototype.onMoving.call(this,g)},m.onMoveEnd=function(g){this.layer.onMoveEnd(g),i.prototype.onMoveEnd.call(this,g)},m.onResize=function(g){this.layer.onResize(g),i.prototype.onResize.call(this,g)},m.prepareDrawContext=function(){if(!this._predrawed){var i=Pg(this.getPrepareParams());this._drawContext=this.layer.prepareToDraw(this.context,...i),this._drawContext||(this._drawContext=[]),Array.isArray(this._drawContext)||(this._drawContext=[this._drawContext]),this._predrawed=!0}},m._prepareDrawParams=function(){if(!this.getMap())return null;var i=this.getViewExtent();return i.maskExtent&&!i.extent.intersects(i.maskExtent)?(this.completeRender(),null):[...[this.context,i],...Pg(this.getDrawParams()),...this._drawContext]},m._drawLayer=function(...i){var g=this._prepareDrawParams();g&&(this.layer.draw.apply(this.layer,g.concat(i)),this.completeRender())},m._drawLayerOnInteracting=function(...i){if(this.layer.drawOnInteracting){var g=this._prepareDrawParams();g&&(this.layer.drawOnInteracting(...g,...i),this.completeRender())}},g}(gg);function Pg(i){return i||(i=[]),Array.isArray(i)||(i=[i]),i}var Ig=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.isCanvasRender=function(){return!0},m.prepareToDraw=function(){},m.draw=function(...i){},m.redraw=function(){return this._getRenderer()&&this._getRenderer().setToRedraw(),this},m.play=function(){return this.config("animation",!0),this},m.pause=function(){return this.config("animation",!1),this},m.isPlaying=function(){return this.options.animation},m.clearCanvas=function(){return this._getRenderer()&&this._getRenderer().clearCanvas(),this},m.requestMapToRender=function(){var i=this._getRenderer();return i&&i.requestMapToRender&&i.requestMapToRender(),this},m.completeRender=function(){return this._getRenderer()&&this._getRenderer().completeRender(),this},m.onCanvasCreate=function(){return this},m.onZoomStart=function(){},m.onZooming=function(){},m.onZoomEnd=function(){},m.onMoveStart=function(){},m.onMoving=function(){},m.onMoveEnd=function(){},m.onResize=function(){},m.doubleBuffer=function(i){return i.clearRect(0,0,i.canvas.width,i.canvas.height),this},m._getRenderer=function(){return i.prototype._getRenderer.call(this)},g}(Fu);Ig.mergeOptions({doubleBuffer:!1,animation:!1}),Ig.registerRenderer("canvas",Cg);var kg=new un(0,0),Og=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.getParticles=function(i){},m.draw=function(i,g){var m=this.getParticles(P());if(m&&0!==m.length){var _=this.getMap(),b=g.extent;g.maskExtent&&(b=g.extent.intersection(g.maskExtent)),b=b.convertTo((function(i){return _._pointToContainerPoint(i,void 0,0,kg)}));for(var T=2*Math.PI,I=0,H=m.length;I<H;I++){var W=m[I].point;if(b.contains(W)){var q=m[I].color||this.options.lineColor||"#fff",$=m[I].r;i.fillStyle!==q&&(i.fillStyle=q),$<=2?i.fillRect(W.x-$/2,W.y-$/2,$,$):(i.beginPath(),i.arc(W.x,W.y,$/2,0,T),i.fill())}}this._fillCanvas(i)}else{this._getRenderer()&&(this._getRenderer()._shouldClear=!0)}},m._fillCanvas=function(i){var g=i.globalCompositeOperation;i.globalCompositeOperation="destination-out",i.fillStyle="rgba(0, 0, 0, "+1/(this.options.trail||30)+")",i.fillRect(0,0,i.canvas.width,i.canvas.height),i.globalCompositeOperation=g},g}(Ig);Og.mergeOptions({animation:!0}),Og.registerRenderer("canvas",function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.draw=function(){this.canvas&&this.layer.options.animation&&!this._shouldClear||(this.prepareCanvas(),this._shouldClear=!1),this.prepareDrawContext(),this._drawLayer()},m.drawOnInteracting=function(){this.draw(),this._shouldClear=!1},m.onSkipDrawOnInteracting=function(){this._shouldClear=!0},g}(Cg));var Eg,Rg,Lg=Ko(),Dg=function(i){function g(g,m,_){var b;(b=i.call(this,_||{})||this).target=g,g.once("remove",b.delete,b);var T=b.options.symbol,P=T.markerLineWidth||1;return b.w=T.markerWidth+P,b.h=T.markerHeight+P,b.opacity=H(T.opacity)?1:T.opacity,b.map=m,b.events=_.events,b._fetchImage(),b.addTo(m),b}tn(g,i);var m=g.prototype;return m.getCursor=function(){return this.options.cursor||"default"},m._fetchImage=function(){var i=this.map,g=this.options.symbol,{markerFile:m}=g;this.url=m||lo(g);var _=Lg.getImage(this.url);if(!_){var b=this.w,T=this.h;if(m)(_=new Image).onload=function(){var g=i.getRenderer();g&&g.setToRedraw()},_.src=this.url;else{var P=document.createElement("canvas");P.width=b,P.height=T,_=uc(P.getContext("2d"),{x:b/2,y:T/2},g,Lg)}Lg.addResource([this.url,b,T],_)}Lg.login(this.url),this._img=_},m.setContainerPoint=function(i){this._point=i,this._point._sub(this.w/2,this.h/2)},m.getContainerPoint=function(){return this._point.add(this.w/2,this.h/2)},m.offset=function(i){this._point._add(i)},m.render=function(i){if(!this._img)return!1;var g=this.options.symbol,m=g.markerDx||0,_=g.markerDy||0,b=this.map,{x:T,y:P}=this._point,I=this.w,H=this.h;if(T+I>0&&T<b.width&&P+H>0&&P<b.height){var W=b.getDevicePixelRatio();return i.globalAlpha=this.opacity,i.drawImage(this._img,Math.round((T+m)*W),Math.round((P+_)*W),Math.round(I*W),Math.round(H*W)),!0}return!1},m.delete=function(){if(this.map){var i=this.map.getRenderer();i&&i.removeTopElement(this)}Lg.logout(this.url),this._dragger&&(this._dragger.disable(),delete this._dragger),delete this.map},m.hitTest=function(i){var g=this.options.symbol,m=this._point.x+(g.markerDx||0),_=this._point.y+(g.markerDy||0);return i.x>=m&&i.x<=m+this.w&&i.y>=_&&i.y<=_+this.h},m.addTo=function(i){this.map=i,i.getRenderer().addTopElement(this)},m.onEvent=function(i){this.fire(i.type,i)},m.mousedown=function(i){var g=this.options.cursor;g&&i.target.setCursor(g),this.onDragstart(i)},m.onDragstart=function(i){var{containerPoint:g,target:m}=i,_=m.getPanels().mapWrapper||m.getContainer(),b=this._dragger=new dl(_);b.on("dragging",this.onDragging,this).on("mouseup",this.onDragend,this).enable(),b.onMouseDown(i.domEvent),Eg=g.x,Rg=g.y,this.fire("dragstart",{containerPoint:g})},m.onDragging=function(i){if(this._dragger){var g=this.map,m=Ur(i.domEvent,g.getContainer()),_={x:m.x-Eg,y:m.y-Rg},b=g.containerPointToCoord(new un(Eg,Rg)),T=g.containerPointToCoord(m);Eg=m.x,Rg=m.y,this.offset(_),this.fire("dragging",{containerPoint:m,coordOffset:T._sub(b)})}},m.onDragend=function(i){if(this._dragger){var g=this.map;g.resetCursor();var m=Ur(i.domEvent,g.getContainer());this.offset({x:m.x-Eg,y:m.y-Rg}),this._dragger.disable(),delete this._dragger,this.fire("dragend",{containerPoint:m})}},m.needCollision=function(){var{target:i}=this;return!this.options.ignoreCollision&&(i&&i.options&&i.options.collision)},m.getRenderBBOX=function(i){var{target:g,map:m}=this;if(!g||!g.options||!m)return null;var _=this.options.symbol,b=_.markerDx||0,T=_.markerDy||0,{x:P,y:I}=this._point,H=this.w,W=this.h;i=i||m.getDevicePixelRatio(),this.bbox=this.bbox||Bo();var q=Math.round((P+b)*i),$=Math.round((I+T)*i),ye=Math.round(H*i),Re=Math.round(W*i);this.bbox[0]=q,this.bbox[1]=$,this.bbox[2]=q+ye,this.bbox[3]=$+Re;var{options:Be}=g;return qo(this.bbox,Be.collisionBufferSize||0),this.bbox},m.setZIndex=function(i){this.options.zIndex=i},g}(Za(Ya)),Fg=function(){function i(i,g,m){this.target=i,i.once("remove",this.delete,this),this.map=g,this.options=m||{},this.addTo(g)}var g=i.prototype;return g.setPoints=function(i){this.points=i;var g=i.map((function(i){return i.x})),m=i.map((function(i){return i.y}));this.xmin=Math.min(...g),this.xmax=Math.max(...g),this.ymin=Math.min(...m),this.ymax=Math.max(...m)},g.hitTest=function(){return!1},g.render=function(i){var g=this.map;if(!(this.xmax<=0||this.xmin>=g.width||this.ymax<=0||this.ymin>=g.height)){var m=g.getDevicePixelRatio();i.lineWidth=1,i.strokeStyle="#000",i.globalAlpha=1,i.beginPath();var _=this.points;i.moveTo(T(_[0].x),T(_[0].y));for(var b=1;b<this.points.length;b++)i.lineTo(T(_[b].x),T(_[b].y));i.closePath(),i.stroke()}function T(i){return Math.round(i)*m+.5}},g.addTo=function(i){this.map=i,i.getRenderer().addTopElement(this)},g.delete=function(){if(this.map){var i=this.map.getRenderer();i&&i.removeTopElement(this)}},i}(),Ng=Qn+"_edit_stage_",Hg="dragend dragstart";function Bg(i,g){return{markerType:i,markerFill:"#fff",markerLineColor:"#000",markerLineWidth:2,markerWidth:10,markerHeight:10,opacity:g}}function zg(i,g){var m=i.getGLRes(),_=i.coordToPointAtRes(g,m);return i._pointAtResToContainerPoint(_,m,g.z||0)}function Vg(i,g,m){var _=i.getMap();if(!g||0===g.z)return _.containerPointToCoord(m);var b=g.z,T=_.getGLRes(),P=_.coordToPointAtRes(g,T),I=_._pointAtResToContainerPoint(P,T,0),H=_._pointAtResToContainerPoint(P,T,b).sub(I),W=m.sub(H),q=_.containerPointToCoord(W);return q.z=0,!i.getGeometries&&i.isPoint&&(q.z=b),q}function Ug(i){var g=this.target,m=this.paramOptions;return g._updating=!0,m.onDown&&(m.onDown.call(g,i.containerPoint,i),g._geometry.fire("handledragstart")),!1}function Gg(i){var g=this.target,m=this.paramOptions;return g._hideContext(),m.onMove&&(m.onMove.call(g,i),g._geometry.fire("handledragging")),!1}function jg(i){var g=this.target,m=this.paramOptions;return m.onUp&&(m.onUp.call(g,i),g._geometry.fire("handledragend")),g._updating=!1,!1}var Wg={fixAspectRatio:!1,symbol:null,removeVertexOn:"contextmenu",centerHandleSymbol:Bg("ellipse",1),vertexHandleSymbol:Bg("square",1),newVertexHandleSymbol:Bg("square",.4),collision:!1,collisionBufferSize:0,vertexZIndex:0,newVertexZIndex:0,shadowDraggable:!1},qg=function(i){function g(g,m){var _;return(_=i.call(this,m)||this)._geometry=g,_._geometry?_:Qt(_)}tn(g,i);var m=g.prototype;return m.getMap=function(){return this._geometry.getMap()},m.prepare=function(){var i=this.getMap();i&&(i.on("drawtopstart",this._refresh,this),this.options.symbol&&(this._originalSymbol=this._geometry.getSymbol(),this._geometry.setSymbol(this.options.symbol)),this._prepareEditStageLayer())},m._prepareEditStageLayer=function(){var i=this._geometry.getLayer();if("canvas"===i.options.renderer){var g=this.getMap(),m=gn(),_=Ng+m+"_shadow";if(this._shadowLayer=g.getLayer(_),!this._shadowLayer)this._shadowLayer=new(0,i.constructor)(_),g.addLayer(this._shadowLayer)}},m.start=function(){if(this._geometry&&this._geometry.getMap()&&!this._geometry.editing){this.editing=!0,this.prepare();var i,g=this._geometry,m="canvas"===this._geometry.getLayer().options.renderer;this._geometryDraggble=g.options.draggable,m?(g.config("draggable",!1),(i=g.copy()).setSymbol(g._getInternalSymbol()),i.copyEventListeners(g),g._getParent()&&i.copyEventListeners(g._getParent()),i._setEventTarget(g),i.setId(null).config({draggable:this.options.shadowDraggable}),this._shadow=i,g.hide()):g instanceof yf&&g.config("draggable",!0),this._switchGeometryEvents("on"),(g instanceof yf||g instanceof Df||g instanceof Hf||g instanceof Nf)&&this._createOrRefreshOutline(),this._shadowLayer&&this._shadowLayer.bringToFront().addGeometry(i),g instanceof yf?i&&(i.config("draggable",!0),i.on("dragend",this._onMarkerDragEnd,this)):this._createCenterHandle(),g instanceof yf&&!1!==this.options.resize?this.createMarkerEditor():g instanceof Df?this.createCircleEditor():g instanceof Hf||g instanceof Nf?this.createEllipseOrRectEditor():g instanceof Bf||(g instanceof gf||g instanceof vf)&&this.createPolygonEditor()}},m.stop=function(){delete this._history,delete this._historyPointer,delete this._editOutline,this._switchGeometryEvents("off"),this.getMap()?(this._geometry.config("draggable",this._geometryDraggble),this._shadow&&(this._shadow.off(Hg,this._shadowDragEvent,this),delete this._shadow,delete this._geometryDraggble,this._geometry.show()),this._shadowLayer&&(this._shadowLayer.remove(),delete this._shadowLayer),this._refreshHooks=[],this.options.symbol&&(this._geometry.setSymbol(this._originalSymbol),delete this._originalSymbol),this.editing=!1,this.fire("remove")):this.fire("remove")},m.isEditing=function(){return!H(this.editing)&&this.editing},m._getGeometryEvents=function(){return{symbolchange:this._onGeoSymbolChange,dragstart:this._onDragStart,dragend:this._onDragEnd,"positionchange shapechange":this._exeAndReset}},m._switchGeometryEvents=function(i){if(this._geometry){var g=this._getGeometryEvents();for(var m in g)this._geometry[i](m,g[m],this)}},m._onGeoSymbolChange=function(i){this._shadow&&this._shadow.setSymbol(i.target._getInternalSymbol())},m._onMarkerDragEnd=function(){this._update("setCoordinates",this._shadow.getCoordinates().toArray())},m._createOrRefreshOutline=function(){var i=this._geometry,g=this._editOutline;g||(this._editOutline=new Fg(this,this.getMap()),this._addRefreshHook(this._createOrRefreshOutline));var m=this._editOutline.points;if(i instanceof yf)this._editOutline.setPoints(i.getContainerExtent().toArray(m));else{var _=i.getShell(),b=i._getEditCenter(),T=Bo();Go(_,T);var P=new Pl(T[0],T[1],T[2],T[3]),I=this.getMap(),H=P.toArray().map((function(i){return i.z=b.z,zg(I,i)}));this._editOutline.setPoints(H)}return g},m._shadowDragEvent=function(i){"dragend"===i.type&&this._updateCoordFromShadow()},m._createCenterHandle=function(){var i,g=this,m=this.getMap(),_=this.options.centerHandleSymbol;this._shadow&&this._shadow.off(Hg,this._shadowDragEvent,this),this.options.shadowDraggable&&this._shadow&&this._shadow.on(Hg,this._shadowDragEvent,this);var b=zg(m,this._geometry._getEditCenter()),T=this.createHandle(b,{ignoreCollision:!0,symbol:_,cursor:"move",onDown:function(){if(g._shadow){var m=ho((i=g._shadow.copy())._getInternalSymbol(),.5);i.setSymbol(m).addTo(g._geometry.getLayer())}},onMove:function(m){var _=m.coordOffset;i?i.translate(_):g._geometry.translate(_)},onUp:function(){if(i){var m=i.getFirstCoordinate(),_=g._geometry.getFirstCoordinate(),b=m.sub(_);g._update("translate",b),i.remove()}}});this._addRefreshHook((function(){var i=g._geometry._getEditCenter();T.setContainerPoint(zg(m,i))}))},m._createHandleInstance=function(i,g){g=g||{};var m=this.getMap(),_=Ei(g.symbol,(function(){return[m.getZoom(),{"{bearing}":m.getBearing(),"{pitch}":m.getPitch(),"{zoom}":m.getZoom()}]})),b=new Dg(this,m,{symbol:_,cursor:g.cursor,events:this.options.removeVertexOn,ignoreCollision:g.ignoreCollision});return b.setContainerPoint(i),b},m.createHandle=function(i,g){g||(g={});var m=this._createHandleInstance(i,g);return m.paramOptions=g,m.on("dragstart",Ug),m.on("dragging",Gg),m.on("dragend",jg),g.onRefresh&&(m.refresh=g.onRefresh),m},m._createResizeHandles=function(i,g,m){var _=this,b=["nw-resize","n-resize","ne-resize","w-resize","e-resize","sw-resize","s-resize","se-resize"],T=[null,"y",null,"x","x",null,"y",null],P=this._geometry,I=P instanceof yf,H=[];i||(i=[]);var W=this,q=[],$={},ye=this.getMap(),Re=this.options.vertexHandleSymbol,Be=function(){for(var Be=function(){if(I){var i=P.getContainerExtent();return[new un(i.xmin,i.ymin),new un((i.xmax+i.xmin)/2,i.ymin),new un(i.xmax,i.ymin),new un(i.xmin,(i.ymin+i.ymax)/2),new un(i.xmax,(i.ymin+i.ymax)/2),new un(i.xmin,i.ymax),new un((i.xmax+i.xmin)/2,i.ymax),new un(i.xmax,i.ymax)]}var g=P.getShell(),m=P._getEditCenter(),_=Bo();Go(g,_);var b=new Pl(_[0],_[1],_[2],_[3]);return(H=[new pl(b.xmin,b.ymax),new pl((b.xmax+b.xmin)/2,b.ymax),new pl(b.xmax,b.ymax),new pl(b.xmin,(b.ymax+b.ymin)/2),new pl(b.xmax,(b.ymax+b.ymin)/2),new pl(b.xmin,b.ymin),new pl((b.xmax+b.xmin)/2,b.ymin),new pl(b.xmax,b.ymin)]).map((function(i){return i.z=m.z,zg(ye,i)}))}(),Ge=function(I){if(Array.isArray(i)&&i.some((function(i){return i===I})))return 1;var ye,Ge=Be[I],je=H[I];if(q.length<Be.length-i.length){var Xe=_.createHandle(Ge,{symbol:Re,cursor:b[I],axis:T[I],onMove:(ye=I,function(i){W._updating=!0,g(i.containerPoint,ye),P.fire("resizing")}),onUp:function(){W._updating=!1,m()}});$[I]=q.length,q.push(Xe),Xe.coord=je}else q[$[I]].coord=je,q[$[I]].setContainerPoint(Ge)},je=0;je<Be.length;je++)Ge(je)};return Be(),this._addRefreshHook(Be),q},m.createMarkerEditor=function(){var i=this,g=this._shadow||this._geometry,m=this.getMap();if(g._canEdit()){this._history||this._recordHistory(Be());var _=g._getInternalSymbol(),b=new un(0,0);W(_.markerDx)&&(b.x=_.markerDx),W(_.markerDy)&&(b.y=_.markerDy);var T=null,P="middle",I="middle";if(Nc.test(_)){var H=_.markerType;"pin"===H||"pie"===H||"bar"===H?(T=[5,6,7],P="bottom"):"rectangle"===H&&(T=[0,1,2,3,5],P="top",I="left")}else(bc.test(_)||Hc.test(_))&&(P="bottom",T=[5,6,7]);var q,$=[2,1,2,0,0,2,1,2];if(this.options.fixAspectRatio){var ye=g.getSize();q=ye.width/ye.height}var Re=this._createResizeHandles(T,(function(_,H){if(T&&T.indexOf(H)>=0){var W=m.containerPointToCoordinate(_.sub(b)),ye=g.getCoordinates();W.x=ye.x,g.setCoordinates(W),i._updateCoordFromShadow(!0),_=Re[Re.length-1-H].getContainerPoint()}var Be=zg(m,g._getEditCenter()).add(b),Ge=g._getInternalSymbol(),je=_.sub(Be);"bottom"===P&&_.y>Be.y&&(je.y=0);var Xe="middle"===P?2:1,Ze="left"===I?1:2,Ye=Math.abs(je.x)*Ze,Qe=Math.abs(je.y)*Xe;q&&(Qe=(Ye=Math.max(Ye,Qe*q))/q);var Je=$[H];g instanceof Xf?((q||0===Je||2===Je)&&(g.setWidth(Ye),g!==i._geometry&&i._geometry.setWidth(Ye)),(q||1===Je||2===Je)&&(g.setHeight(Qe),g!==i._geometry&&i._geometry.setHeight(Qe))):((q||0===Je||2===Je)&&(Ge.markerWidth=Math.min(Ye,i._geometry.options.maxMarkerWidth||1/0)),(q||1===Je||2===Je)&&(Ge.markerHeight=Math.min(Qe,i._geometry.options.maxMarkerHeight||1/0)),g.setSymbol(Ge),g!==i._geometry&&i._geometry.setSymbol(Ge))}),(function(){i._update(Be())}))}else console&&console.warn("A marker can't be resized with symbol:",g.getSymbol());function Be(){var i=[["setCoordinates",g.getCoordinates().toArray()]];return g instanceof Xf?(i.push(["setWidth",g.getWidth()]),i.push(["setHeight",g.getHeight()])):i.push(["setSymbol",g.getSymbol()]),i}},m.createCircleEditor=function(){var i=this,g=this._shadow||this._geometry,m=this.getMap();this._history||this._recordHistory([["setCoordinates",g.getCoordinates().toArray()],["setRadius",g.getRadius()]]),this._createResizeHandles(null,(function(_){var b=g.getCenter(),T=Vg(g,b,_),P=new vf([[b.x,b.y],[T.x,b.y]]),I=new vf([[b.x,b.y],[b.x,T.y]]),H=Math.max(m.computeGeometryLength(P),m.computeGeometryLength(I));g.setRadius(H),g!==i._geometry&&i._geometry.setRadius(H)}),(function(){i._update("setRadius",g.getRadius())}))},m.createEllipseOrRectEditor=function(){var i=this,g=[2,1,2,0,0,2,1,2],m=this._shadow||this._geometry;this._history||this._recordHistory(I());var _,b=this.getMap(),T=this._geometry instanceof Hf;this.options.fixAspectRatio&&(_=m.getWidth()/m.getHeight());var P=this._createResizeHandles(null,(function(I,H){var W,q,$,ye=T?1:2,Re=P[H].getContainerPoint(),Be=g[H];if(T){var Ge=P[7-H],je=Ge.getContainerPoint(),Xe=(W=Re.sub(je)).abs();q=b.pixelToDistance(Xe.x,0),$=b.pixelToDistance(0,Xe.y);var Ze=m.getSize(),Ye=m.getCoordinates(),Qe=m.getWidth(),Je=m.getHeight(),Ke=Ge.coord,et=Vg(m,Ye,I),tt=new vf([[Ke.x,Ke.y],[et.x,Ke.y]]),at=new vf([[Ke.x,Ke.y],[Ke.x,et.y]]);if(q=b.computeGeometryLength(tt),$=b.computeGeometryLength(at),0===Be)if(_&&(Xe.y=Xe.x/_,Ze.height=Math.abs(Xe.y),$=q/_),Re.y=je.y-Ze.height/2,et.y=Ye.y,4===H)et.x=Math.min(et.x,Ye.x);else{var ht=b.locate(Ye,Qe,0);et.x=b.locate(new pl(ht.x,et.y),-q,0).x}else if(1===Be)_&&(Xe.x=Xe.y*_,Ze.width=Math.abs(Xe.x),q=$*_),Re.x=je.x-Ze.width/2,et.x=Ye.x,et.y=Math.max(et.y,Ke.y);else{if(_&&(q>$*_?($=q/_,Re.y=je.y+Xe.x*Sn(W.y)/_):(q=$*_,Re.x=je.x+Xe.y*Sn(W.x)*_)),0===H||5===H){var gt=b.locate(Ye,Qe,0===H?0:-Je);et.x=b.locate(new pl(gt.x,et.y),-q,0).x}else et.x=Math.min(et.x,Ke.x);et.y=Math.max(et.y,Ke.y)}et.z=Ye.z,m.setCoordinates(et),i._updateCoordFromShadow(!0)}else{var yt=m.getCenter(),vt=Vg(m,yt,I),xt=new vf([[yt.x,yt.y],[vt.x,yt.y]]),bt=new vf([[yt.x,yt.y],[yt.x,vt.y]]);q=b.computeGeometryLength(xt),$=b.computeGeometryLength(bt),_&&($=(q=Math.max(q,$*_))/_)}(_||0===Be||2===Be)&&(m.setWidth(q*ye),m!==i._geometry&&i._geometry.setWidth(q*ye)),(_||1===Be||2===Be)&&(m.setHeight($*ye),m!==i._geometry&&i._geometry.setHeight($*ye))}),(function(){i._update(I())}));function I(){return[["setCoordinates",m.getCoordinates().toArray()],["setWidth",m.getWidth()],["setHeight",m.getHeight()]]}},m.createPolygonEditor=function(){var i=this.getMap(),g=this._shadow||this._geometry,m=this;this._history||this._recordHistory("setCoordinates",pl.toNumberArrays(g.getCoordinates()));var _=g instanceof gf?3:2,b="maptalks--editor-vertex-index",{vertexZIndex:T,newVertexZIndex:P}=this.options,I={0:[]},H={0:[]};function q(i,m){if(g instanceof gf){var _=g.getCoordinates();_[m]=i,g.setCoordinates(_)}else g.setCoordinates(i)}function $(i=0){if(g instanceof gf){var m=g.getCoordinates()[i]||[];return m.slice(0,m.length-1)}return g.getCoordinates()}function ye(){for(var i in I){for(var g=I[i].length-1;g>=0;g--)I[i][g][b]=g;for(var _=H[i].length-1;_>=0;_--)H[i][_][b]=_}m._updateCoordFromShadow()}function Be(T){m._updating=!0;var P=T.target,Re=P[b],Be=W(P._ringIndex)?P._ringIndex:0,Ge=$(Be);if(Ge.length<=_)console.warn(" Geometry."+g.type+" Require at least "+_+" vertices,Geometry: ",g);else{if(Ge.splice(Re,1),q(Ge,Be),0===Re)H[Be][0].delete(),H[Be].splice(0,1);else if(Re===I[Be].length-1){var je=H[Be].length;H[Be][je-1].delete(),H[Be].splice(je-1,1)}else H[Be][Re-1].delete(),H[Be].splice(Re-1,1),H[Be][Re-1].delete(),H[Be].splice(Re-1,1),H[Be].splice(Re-1,0,Je.call(m,Re-1,Be));if(I[Be].splice(Re,1)[0].delete(),Be>0){var Xe=g.getCoordinates(),Ze=Xe[Be];Ze&&Array.isArray(Ze)&&Ze.length>1&&g!==this._geometry&&g.setCoordinates(Xe)}ye(),m._updating=!1,m._geometry.fire("handleremove",Object.assign({},T,{coordinate:i.containerPointToCoordinate(T.containerPoint),vertex:T.target}))}}function Ge(i,_,b=0){var T=m._geometry.snapTo;T&&Re(T)&&(i=m._geometry.snapTo(i)||i);var P,I=$(b),W=i.sub(Xe()),q=Vg(m._geometry,I[_],W),ye=I[_];ye.x=q.x,ye.y=q.y,g.setCoordinates(g.getCoordinates()),m._updateCoordFromShadow(!0),P=0===_?H[b].length-1:_-1,H[b][_]&&H[b][_].refresh(),H[b][P]&&H[b][P].refresh()}var je=new un(0,0);function Xe(){var i=g._getCompiledSymbol();return je.x=i.lineDx||0,je.y=i.lineDy||0,je}function Ze(g,_=0,P){var I=(P||$(_))[g],H=zg(i,I)._add(Xe()),W=m.createHandle(H,{symbol:m.options.vertexHandleSymbol,cursor:"pointer",axis:null,onMove:function(){Ge(W.getContainerPoint(),W[b],_)},onRefresh:function(g,m){if(I=(m||$(_))[W[b]]){var T=zg(i,I);W.setContainerPoint(T._add(Xe()))}},onUp:function(){m._updateCoordFromShadow()},onDown:function(i,g){}});return W[b]=g,W._ringIndex=_,W.on(m.options.removeVertexOn,Be),W.setZIndex(T),W}var Ye=!1,Qe=!1;function Je(g,_=0,T){var W=T||$(_),Re=W[g].add(g+1>=W.length?W[0]:W[g+1]).multi(.5);Qe&&(Re=zg(i,Re));var Be=m.createHandle(Re,{symbol:m.options.newVertexHandleSymbol,cursor:"pointer",axis:null,onDown:function(i,g){if(!g||!g.domEvent||2!==g.domEvent.button){var T=$(_),P=Be[b],I=T[P].add(T[P+1]||T[0]).multi(.5);T.splice(P+1,0,I),q(T,_),Be.opacity=1,Qe=!0,H[_].splice(P,0,Je.call(m,P,_),Je.call(m,P+1,_)),Qe=!1,Ye=!0}},onMove:function(){Ge(Be.getContainerPoint(),Be[b]+1,_)},onUp:function(i){if(i&&i.domEvent&&2===i.domEvent.button)Ye=!1;else{var g=Be[b];xn(Be,H[_]),Be.delete(),I[_].splice(g,0,Ze.call(m,g,_)),ye(),m._updateCoordFromShadow(),Ye=!1}},onRefresh:function(g,m){W=m||$(g);var _,T=Be[b];if(_=T===W.length-1?0:T+1,W[T]&&W[_]){var P=W[T].add(W[_]).multi(.5),I=zg(i,P);Be.setContainerPoint(I._add(Xe()))}}});return Be[b]=g,Be.setZIndex(P),Be}if(g instanceof gf)for(var Ke=g.getHoles().length+1,et=0;et<Ke;et++){I[et]=[],H[et]=[];for(var tt=$(et),at=0,ht=tt.length;at<ht;at++)I[et].push(Ze.call(this,at,et,tt)),at<ht-1&&H[et].push(Je.call(this,at,et,tt));H[et].push(Je.call(this,tt.length-1,et,tt))}else{for(var gt=$(0),yt=0,vt=gt.length;yt<vt;yt++)I[0].push(Ze.call(this,yt,0,gt)),yt<vt-1&&H[0].push(Je.call(this,yt,0,gt));H[0].length&&2===g.getCoordinates().length&&(H[0][0].options.symbol.markerDx=12)}var xt=i.getRenderer();xt&&xt.sortTopElements(),this._addRefreshHook((function(){if(!Ye){for(var i in H)for(var m=$(i),_=H[i].length-1;_>=0;_--)H[i][_].refresh(i,m);for(var b in H[0].length&&g instanceof vf&&(2===g.getCoordinates().length?H[0][0].options.symbol.markerDx=12:g.getCoordinates().length>2&&(H[0][0].options.symbol.markerDx=0)),I)for(var T=$(b),P=I[b].length-1;P>=0;P--)I[b][P].refresh(b,T)}}))},m._refresh=function(){if(this._refreshHooks)for(var i=this._refreshHooks.length-1;i>=0;i--)this._refreshHooks[i].call(this)},m._hideContext=function(){this._geometry&&(this._geometry.closeMenu(),this._geometry.closeInfoWindow())},m._addRefreshHook=function(i){i&&(this._refreshHooks||(this._refreshHooks=[]),this._refreshHooks.push(i))},m._update=function(i,...g){this._exeHistory([i,g]),this._recordHistory(i,...g)},m._updateCoordFromShadow=function(i){var g=(this._shadow||this._geometry).getCoordinates(),m=this._geometry,_=this._updating;this._updating=!0,m.setCoordinates(g),i||this._recordHistory("setCoordinates",pl.toNumberArrays(m.getCoordinates())),this._updating=_},m._recordHistory=function(i,...g){if(this._history||(this._history=[],this._historyPointer=0),this._history.length){var m=this._history[this._history.length-1];if(m[0]===i&&JSON.stringify(m[1])===JSON.stringify(g))return}this._historyPointer<this._history.length-1&&this._history.splice(this._historyPointer+1),this._history.push([i,g]),this._historyPointer=this._history.length-1,this._geometry.fire("editrecord")},m.cancel=function(){return this._history&&0!==this._historyPointer?(this._historyPointer=0,this._exeAndReset(this._history[0]),this):this},m.undo=function(){if(this._isundoEdit())return this;var i=this._history[--this._historyPointer];return this._exeAndReset(i),this},m.redo=function(){if(this._isRedoEdit())return this;var i=this._history[++this._historyPointer];return this._exeAndReset(i),this},m._exeAndReset=function(i){if(!this._updating){this._exeHistory(i);var g=this._history,m=this._historyPointer;this.stop(),this._history=g,this._historyPointer=m,this.start()}},m._onDragStart=function(){this._updating=!0},m._onDragEnd=function(){this._updating=!1},m._exeHistory=function(i){if(Array.isArray(i)){var g=this._updating;this._updating=!0;var m=this._shadow||this._geometry,_=this._geometry;Array.isArray(i[0])?i[0].forEach((function(i){var g=i[0],b=i.slice(1);m[g].call(m,...b),m!==_&&_[g].call(_,...b)})):(m[i[0]].call(m,...i[1]),m!==_&&_[i[0]].call(_,...i[1])),this._updating=g}},m._isRedoEdit=function(){return!this._history||this._historyPointer===this._history.length-1},m._isundoEdit=function(){return!this._history||0===this._historyPointer},g}(Za(Ya));qg.mergeOptions(Wg),qf.include({startEditText:function(){return this.getMap()?(this._recordVisible(),this.hide(),this.endEditText(),this._prepareEditor(),this._fireEvent("edittextstart"),this):this},endEditText:function(){if(this._textEditor){var i=this._textEditor.innerHTML;i=i.replace(/<p>/gi,"").replace(/<\/p>/gi,"<br/>"),this._textEditor.innerHTML=i;var g=this._textEditor.innerText.replace(/[\r\n]+$/gi,"");this.setContent(g),Kr(this._textEditor,"mousedown dblclick",Hr),this.getMap().off("mousedown",this.endEditText,this),this._editUIMarker.remove(),delete this._editUIMarker,this._textEditor.onkeyup=null,delete this._textEditor,this._recoveryVisible(),this.show(),this._fireEvent("edittextend")}return this},isEditingText:function(){return!!this._textEditor},getTextEditor:function(){return this._editUIMarker},_prepareEditor:function(){var i=this.getMap(),g=this._createEditor();this._textEditor=g,i.on("mousedown",this.endEditText,this);var m=this._getEditorOffset();this._editUIMarker=new Wd(this.getCoordinates(),{animation:null,content:g,dx:m.dx,dy:m.dy}).addTo(i),this._setCursorToLast(this._textEditor)},_getEditorOffset:function(){var i=this._getInternalSymbol()||{},g=0,m=0,_=i.textHorizontalAlignment;return"middle"===_||H(_)?(g=(i.textDx||0)-2,m=(i.textDy||0)-2):(g=(i.markerDx||0)-2,m=(i.markerDy||0)-2),{dx:g,dy:m}},_createEditor:function(){var i=this.getContent(),g=this.getSize(),m=this._getInternalSymbol()||{},_=g.width,b=m.textFill||"#000000",T=m.textSize||12,P=g.height,I=m.markerLineColor||"#000",H=m.markerFill||"#3398CC",W=m.textLineSpacing||0,q=Or("div");return q.contentEditable=!0,q.style.cssText="background:"+H+"; border:1px solid "+I+";\n            color:"+b+";font-size:"+T+"px;width:"+(_-2)+"px;height:"+(P-2)+"px;margin: auto;\n            line-height:"+(T+W)+"px;outline: 0; padding:0; margin:0;word-wrap: break-word;\n            overflow: hidden;-webkit-user-modify: read-write-plaintext-only;",q.innerText=i,Jr(q,"mousedown dblclick",Hr),q.onkeyup=function(i){13===i.keyCode&&(q.style.height=parseInt(q.style.height||0)+T/2+"px")},q},_setCursorToLast:function(i){var g;window.getSelection?(i.focus(),(g=window.getSelection()).selectAllChildren(i),g.collapseToEnd()):document.selection&&((g=document.selection.createRange()).moveToElementText(i),g.collapse(!1),g.select())}}),gu.include({animate:function(i,g,m){var _=this;this._animPlayer&&this._animPlayer.finish(),Re(g)&&(m=g),g||(g={});var b,T=this.getMap(),P=this._getProjection(),I=this._prepareAnimationStyles(i),H=g.focus;if(delete this._animationStarted,T){var W=T._getRenderer();g.framer=function(i){W.callInNextFrame(i)}}if(P||!H){var q=af.animate(I,g,(function(i){if(T&&T.isRemoved())q.finish();else{T&&!_._animationStarted&&H&&T.onMoveStart();var g=i.styles;for(var I in g)if("symbol"!==I&&"translate"!==I&&g.hasOwnProperty(I)){var W="set"+I[0].toUpperCase()+I.slice(1);_[W](g[I])}var $=g.translate;if($){var ye=$;b&&(ye=$.sub(b)),b=$,_.translate(ye)}var Re=g.symbol;if(Re){var Be=_.getSymbol()||{};_.setSymbol(co(Be,Re))}if(T&&H){var Ge=P.project(_.getCenter());T._setPrjCenter(Ge);var je=T._parseEventFromCoord(P.unproject(Ge));"running"!==q.playState?T.onMoveEnd(je):T.onMoving(je)}_._fireAnimateEvent(q.playState),m&&m(i)}}),this);return this._animPlayer=q,this._animPlayer.play()}console.error(ff)},_prepareAnimationStyles:function(i){var g=this._getInternalSymbol(),m={};for(var _ in i)if(i.hasOwnProperty(_)){var b=i[_];if("translate"!==_&&"symbol"!==_){var T=this["get"+_[0].toUpperCase()+_.substring(1)]();m[_]=[T,b]}else if("symbol"===_){var P=void 0;if(Array.isArray(i.symbol)){if(!Array.isArray(g))throw new Error("geometry'symbol isn't a composite symbol, while the symbol in styles is.");P=[];for(var I=i.symbol,H=0;H<I.length;H++)if(I[H]){var W={};for(var q in I[H])I[H].hasOwnProperty(q)&&(W[q]=[g[H][q],I[H][q]]);P.push(W)}else P.push(null)}else{if(Array.isArray(g))throw new Error("geometry'symbol is a composite symbol, while the symbol in styles isn't.");for(var $ in P={},b)b.hasOwnProperty($)&&(P[$]=[g[$],b[$]])}m.symbol=P}else"translate"===_&&(m.translate=new pl(b))}return m},_fireAnimateEvent:function(i){"finished"===i?(delete this._animationStarted,this._fireEvent("animateend")):"running"===i&&(this._animationStarted?this._fireEvent("animating"):(this._fireEvent("animatestart"),this._animationStarted=!0))}});var Xg=Qn+"_drag_stage",Zg=$t.touch?"touchstart mousedown":"mousedown";function $g(i,g,m){var _=i._getEditCenter(),b=i.getMap();if(!_||0===_.z)return m||b.containerPointToCoord(g);var T=_.z,P=b.getGLRes(),I=b.coordToPointAtRes(_,P),H=b._pointAtResToContainerPoint(I,P,0),W=b._pointAtResToContainerPoint(I,P,T).sub(H),q=g.sub(W),$=b.containerPointToCoord(q);return $.z=0,!i.getGeometries&&i.isPoint&&($.z=T),$}var Yg=function(i){function g(g){return i.call(this,g)||this}tn(g,i);var m=g.prototype;return m.addHooks=function(){this.target.on(Zg,this._startDrag,this)},m.removeHooks=function(){this._endDrag(),this.target.off(Zg,this._startDrag,this),delete this.container},m._prepareDragHandler=function(){this._dragHandler=new dl(this.container),this._dragHandler.on("dragging",this._dragging,this).on("mouseup",this._endDrag,this).enable()},m._prepareShadow=function(){var i=this,g=this.target;if("canvas"===g.getLayer().options.renderer&&g.options.dragShadow){this._prepareDragStageLayer(),this._shadow&&this._shadow.remove();var m=this._shadow=g.copy();if(m.getGeometries){var _=m.getGeometries(),b=g.getGeometries();_.forEach((function(g,m){i._updateShadowSymbol(g,b[m])}))}else this._updateShadowSymbol(m,g);m.setId(null),this._prepareShadowConnectors()}},m._updateShadowSymbol=function(i,g){if(i.setSymbol(g._getInternalSymbol()),g.options.dragShadow){var m=ho(i._getInternalSymbol(),.5);i.setSymbol(m)}},m._prepareShadowConnectors=function(){var i=this.target,g=this._shadow,m=this._dragStageLayer._getRenderer().resources,_=[];if(Qf._hasConnectors(i))for(var b=Qf._getConnectors(i),T=0,P=b.length;T<P;T++){var I=b[T],H=I.config(),W=I._getInternalSymbol();H.symbol=ho(W,.5);var q=void 0;q=I.getConnectSource()===i?new I.constructor(g,I.getConnectTarget(),H):new I.constructor(I.getConnectSource(),g,H),_.push(q),I.getLayer()&&I.getLayer()._getRenderer()&&m.merge(I.getLayer()._getRenderer().resources)}this._shadowConnectors=_,_.push(g),this._dragStageLayer.bringToFront().addGeometry(_)},m._onTargetUpdated=function(){this._shadow&&this._shadow.setSymbol(this.target._getSymbol())},m._prepareDragStageLayer=function(){var i=this.target.getMap(),g=this.target.getLayer(),m=i.getLayer(Xg);m&&m.remove(),this._dragStageLayer=new(0,g.constructor)(Xg,{enableAltitude:g.options.enableAltitude,altitudeProperty:g.options.altitudeProperty}),i.addLayer(this._dragStageLayer);var _=Ko();_.merge(g._getRenderer().resources),this._dragStageLayer._getRenderer().resources=_},m._startDrag=function(i){var g=this.target.getMap();if(g&&(!this.target._getParent()&&!this.isDragging())){var m=i.domEvent;if(!(m.touches&&m.touches.length>1||2===m.button)){this.container=g.getPanels().mapWrapper||g.getContainer(),this.target.on("click",this._endDrag,this);var _=this._correctCoord(i.coordinate);this._lastCoord=$g(this.target,i.containerPoint,_),this._lastPoint=i.containerPoint,this._prepareDragHandler(),this._dragHandler.onMouseDown(i.domEvent),Jr(this.container,"mouseleave",this._endDrag,this),this._startParam=i,this._moved=!1}}},m._dragging=function(i){var g=this.target,m=g.getMap();if(!m._isEventOutMap(i.domEvent)){var _=m._parseEvent(i.domEvent),b=_.domEvent;if(!(b.touches&&b.touches.length>1||m._isContainerPointOutOfMap(_.containerPoint))){if(!this._moved)return this._moved=!0,g.on("symbolchange",this._onTargetUpdated,this),this._isDragging=!0,this._prepareShadow(),this._shadow&&(g.options.dragShadow||g.hide(),this._shadow._fireEvent("dragstart",_)),this.target._fireEvent("dragstart",this._startParam||_),void delete this._startParam;var T=this._shadow||g,P=T.options.dragOnAxis,I=T.options.dragOnScreenAxis,H=_.containerPoint,W=_.coordinate;this._lastPoint=this._lastPoint||H,this._lastCoord=this._lastCoord||W,I?("x"===P?H.y=this._lastPoint.y:"y"===P&&(H.x=this._lastPoint.x),W=m.containerPointToCoord(H)):W=this._correctCoord(W),W=$g(g,_.containerPoint,W);var q=H.sub(this._lastPoint),$=W.sub(this._lastCoord);I||("x"===P?q.y=$.y=0:"y"===P&&(q.x=$.x=0)),this._lastPoint=H,this._lastCoord=W;var ye=!T.getGeometries&&T.isPoint;ye?T.setCoordinates(W):T.translate($),T===g||g.options.dragShadow||(ye?g.setCoordinates(W):g.translate($)),_.coordOffset=$,_.pointOffset=q,T._fireEvent("dragging",_),T!==g&&g._fireEvent("dragging",_)}}},m._endDrag=function(i){if(this._dragHandler&&(this._dragHandler.disable(),delete this._dragHandler),this.container&&Kr(this.container,"mouseleave",this._endDrag),this.target){var g=this.target;g.off("click",this._endDrag,this),g.off("symbolchange",this._onTargetUpdated,this),delete this._lastCoord,delete this._lastPoint,this._isDragging=!1;var m=g.getMap();if(this.enabled()&&m){var _=m._parseEvent(i?i.domEvent:null);this._updateTargetAndRemoveShadow(_),this._moved&&g._fireEvent("dragend",_)}}},m.isDragging=function(){return!!this._isDragging},m._updateTargetAndRemoveShadow=function(i){if(this._shadow){var g=this.target,m=g.getMap();g.options.dragShadow||g.show();var _=this._shadow;if(_){if(g.options.dragShadow){var b=_.getFirstCoordinate(),T=g.getFirstCoordinate(),P=b.sub(T);g.translate(P)}_._fireEvent("dragend",i),_.remove(),delete this._shadow}this._shadowConnectors&&(m.getLayer(Xg).removeGeometry(this._shadowConnectors),delete this._shadowConnectors),this._dragStageLayer&&(this._dragStageLayer._getRenderer().resources=Ko(),this._dragStageLayer.remove())}},m._correctCoord=function(i){var g=this.target.getMap();if(!g.getPitch())return i;var m=this.target;if(!m.getMinAltitude())return i;var _=(m.getMinAltitude()+m.getMaxAltitude())/2;return g.locateByPoint(i,0,-_)},g}($a);gu.mergeOptions({draggable:!1,dragShadow:!0,dragOnAxis:null,dragOnScreenAxis:!1}),gu.addInitHook("addHandler","draggable",Yg),gu.include({isDragging:function(){return this._getParent()?this._getParent().isDragging():!!this.draggable&&this.draggable.isDragging()}}),gu.include({startEdit:function(i){var g=this.getMap();return g&&this.options.editable?(this._editor&&this.endEdit(),this._recordVisible(),this._editor=new qg(this,i),this._editor.start(),this._getParent()||this.fire("editstart"),g.getRenderer().setToRedraw(),this):this},endEdit:function(){if(this._editor){this._editor.stop(),delete this._editor,this._recoveryVisible(),this._getParent()||this.fire("editend");var i=this.getMap();i&&i.getRenderer().setToRedraw()}return this},redoEdit:function(){return this.isEditing()?(this._editor.redo(),this._getParent()||this.fire("redoedit"),this):this},undoEdit:function(){return this.isEditing()?(this._editor.undo(),this._getParent()||this.fire("undoedit"),this):this},cancelEdit:function(){return this.isEditing()?(this._recoveryVisible(),this._editor.cancel(),this._getParent()||this.fire("canceledit"),this):this},isEditing:function(){return!!this._editor&&this._editor.isEditing()},undoEditcheck:function(){if(this.isEditing())return this._editor._isundoEdit()},redoEditcheck:function(){if(this.isEditing())return this._editor._isRedoEdit()}}),gu.include({_onEvent:function(i,g){var m=this.getMap();if(m){var _=g||this._getEventTypeToFire(i);"contextmenu"===_&&this.listens("contextmenu")&&(Hr(i),Nr(i));var b=m._getEventParams(i);W(this._pickGeometryIndex)&&(b.pickGeometryIndex=this._pickGeometryIndex),this._fireEvent(_,b)}},_getEventTypeToFire:function(i){return i.type}}),gu.include({setInfoWindow:function(i){return this.removeInfoWindow(),i instanceof Qd?(this._infoWindow=i,this._infoWinOptions=I({},this._infoWindow.options),this._infoWindow.addTo(this),this):(this._infoWinOptions=I({},i),this._infoWindow?this._infoWindow._setOptions(i):this.getMap()&&this._bindInfoWindow(),this)},getInfoWindow:function(){return this._infoWindow?this._infoWindow:null},openInfoWindow:function(i){return this.getMap()?(i||(i=this.getCenter()),this._infoWindow?this._infoWindow.show(i):this._infoWinOptions&&this.getMap()&&(this._bindInfoWindow(),this._infoWindow.show(i)),this):this},closeInfoWindow:function(){return this._infoWindow&&this._infoWindow.hide(),this},removeInfoWindow:function(){return this._unbindInfoWindow(),delete this._infoWinOptions,delete this._infoWindow,this},_bindInfoWindow:function(){var i=this._infoWinOptions;return i?(this._infoWindow=new Qd(i),this._infoWindow.addTo(this),this):this},_unbindInfoWindow:function(){return this._infoWindow&&(this.closeInfoWindow(),this._infoWindow.remove(),delete this._infoWindow),this}}),gu.fromJSON=function(i){if(Array.isArray(i)){for(var g=[],m=0,_=i.length;m<_;m++){var b=gu.fromJSON(i[m]);Array.isArray(i)?g=g.concat(b):g.push(b)}return g}return i&&!i.feature?Lf.toGeometry(i):(i.subType?(T=gu.getJSONClass(i.subType).fromJSON(i),H(i.feature.id)||T.setId(i.feature.id)):(T=Lf.toGeometry(i.feature),i.options&&T.config(i.options)),i.symbol&&T.setSymbol(i.symbol),i.infoWindow&&T.setInfoWindow(i.infoWindow),T);var T};var Qg=new un(0,0),Jg=new un(0,0),Kg=[],em=function(i){function g(){return i.call(this,Ss)||this}tn(g,i);var m=g.prototype;return m.checkUrl=function(i){return i&&ye(i)?Zn(i):i},m.fetchImage=function(i,g,m,_){i=this.checkUrl(i),this.send({url:i,fetchOptions:_},Kg,m,g)},g}(Mu),tm=function(i){var g=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.init=function(){var i=this;this.tilesInView={},this.tilesLoading={},this._parentTiles=[],this._childTiles=[],this._tileQueue=[],this._tileQueueIds=new Set;var g=this.layer.getTileSize().width;this.tileCache=new Js(this.layer.options.maxCacheSize*g/512*g/512,(function(g){i.deleteTile(g)})),$t.decodeImageInWorker&&this.layer.options.decodeImageInWorker&&("gl"===this.layer.options.renderer||!$t.safari&&!$t.iosWeixin)&&(this._tileImageWorkerConn=new em),this._compareTiles=rm.bind(this)},m.getCurrentTileZoom=function(){return this._tileZoom},m.draw=function(i,g){var m=this.getMap();if(!this.isDrawable||this.isDrawable()){var _,b=this.prepareCanvas();if(b)if(((this.layer||{}).parent||{}).isMap&&!b.intersects(this.canvasExtent2D))return void this.completeRender();this._renderTimestamp!==i&&(this._consumeTileQueue(),this._computeAvgTileAltitude(),this._renderTimestamp=i);var T=!1,P=this._frameTiles;if(P&&i===P.timestamp){if(P.empty)return;_=P}else{if(!(_=this._getTilesInCurrentFrame()))return this._frameTiles={empty:!0,timestamp:i},void this.completeRender();T=!0,this._frameTiles=_,this._frameTiles.timestamp=i,_.loadingCount&&this.loadTileQueue(_.tileQueue)}var{tiles:I,childTiles:H,parentTiles:W,placeholders:q,loading:$,loadingCount:ye,missedTiles:Re,incompleteTiles:Be}=_;this._drawTiles(I,W,H,q,g,Re,Be),ye||$||(m.isAnimating()||!this._parentTiles.length&&!this._childTiles.length||(this._parentTiles=[],this._childTiles=[],this.setToRedraw()),this.completeRender()),T&&this.retireTiles()}},m.getTileGridsInCurrentFrame=function(){return this._frameTileGrids},m.getCurrentTimestamp=function(){return this._renderTimestamp||0},m._getTilesInCurrentFrame=function(){var i=this.getMap();this.map=i;var g=this.layer;g._spatialRef=g.getSpatialReference();var m=g._isPyramidMode()&&g.options.terrainTileMode,_=g.getTiles();if(this._frameTileGrids=_,!(_=_.tileGrids)||!_.length)return g._spatialRef=null,this.map=null,null;var b=_.reduce((function(i,g){return i+(g&&g.tiles&&g.tiles.length||0)}),0);b>=this.tileCache.max/2&&this.tileCache.setMaxSize(2*b+1);var T=0,P=!1,I={},H=[],W=[],q={},$=[],ye={},Re=[],Be={},Ge={},je=this.markTiles(),Xe=this._getLoadLimit(),Ze=_.length,Ye=void 0===this._tileZoom&&g.options.currentTilesFirst&&!this._terrainHelper;this._tileZoom=_[0].zoom;var Qe=null,Je=null;m&&(Qe=[],Je=new Map);for(var Ke=0;Ke<Ze;Ke++){var et=_[Ke],tt=et.tiles,at=et.parents||Kg,ht=at.length,gt=Ye?tt:_n(at,tt),yt=void 0;gt.length&&(yt=this._generatePlaceHolder(gt[0].res));for(var vt=0,xt=gt.length;vt<xt;vt++){var bt=gt[vt];g._debugTile(bt,"_getTilesInCurrentFrame");var Tt=bt.id,Mt=!Ye&&vt<ht,Pt=!1,It=H.length;if(this._isLoadingTile(Tt))Pt=P=!0,this.markCurrent(this.tilesLoading[Tt],!0);else{var Et=this.getCachedTile(bt,Mt);if(Et)Mt||(Et.image&&this.isTileFadingIn(Et.image)&&(Pt=P=!0,this.setToRedraw()),this.isTileComplete(Et)?H.push(Et):(Pt=!0,m&&Je.set(Tt,Et)));else{Pt=P=!0;var Lt=Xe&&T+je[0]>Xe;if(!this._tileQueueIds.has(bt.id)&&!Lt&&(!i.isInteracting()||i.isMoving()||i.isRotating()))T++,Ge[Tt]=bt}}if(m&&!Mt&&(H.length===It?Qe.push(bt):I[bt.id]=1),!m&&!Mt&&Pt&&!I[Tt]){I[Tt]=1,yt&&!Be[Tt]&&(bt.cache=!1,Re.push({image:yt,info:bt}),Be[Tt]=1);var Dt=this._findChildTiles(bt);if(Dt.length&&Dt.forEach((function(i){ye[i.info.id]||($.push(i),ye[i.info.id]=1)})),!Dt.length||4!==Dt.length){var Ft=this._findParentTile(bt);if(Ft){var Ht=Ft.info.id;void 0===q[Ht]&&(q[Ht]=W.length,W.push(Ft))}}}}}var Bt=[];if(m)for(var zt=0;zt<Qe.length;zt++){var Vt=Qe[zt].info?Qe[zt].info:Qe[zt];if(Vt.parent&&!I[Vt.id]){var{tiles:Ut,missedTiles:Gt}=this._findChildTiles(Vt);Ut.length?(yn(H,Ut),yn(Bt,Gt)):Je.has(Vt.id)?(H.push(Je.get(Vt.id)),Je.delete(Vt.id)):(I[Vt.id]=1,Bt.push(Vt))}}return this.tileCache.shrink(),g._spatialRef=null,this.map=null,{childTiles:$,missedTiles:Bt,parentTiles:W,tiles:H,incompleteTiles:Je&&Array.from(Je.values()),placeholders:Re,loading:P,loadingCount:T,tileQueue:Ge}},m.removeTileCache=function(i){delete this.tilesInView[i],this.tileCache.remove(i)},m.isTileCachedOrLoading=function(i){return this.tileCache.get(i)||this.tilesInView[i]||this.tilesLoading[i]},m.isTileCached=function(i){return!(!this.tileCache.get(i)&&!this.tilesInView[i])},m.isTileFadingIn=function(i){return this.getTileFadingOpacity(i)<1},m._drawTiles=function(i,g,m,_,b,T,P){g.length&&(g.sort(this._compareTiles),this._parentTiles=g),m.length&&(this._childTiles=m,this._childTiles.sort(this._compareTiles));var I=this.getMap(),H=I.getRenderer().canvas,W=!0,q=H._frameTileState;q||(q=H._frameTileState={timestamp:0,count:0}),this.layer.constructor!==Up&&this.layer.constructor!==Qp||(this._renderTimestamp===q.timestamp&&q.count>I.options.tileBackgroundLimitPerFrame?W=!1:this._renderTimestamp!==q.timestamp?(q.timestamp=this._renderTimestamp,q.count=1):q.count++);var $={tiles:i,parentTiles:this._parentTiles,childTiles:this._childTiles,parentContext:b};if(this.onDrawTileStart($,b),W&&1===this.layer.options.opacity){this.layer._silentConfig=!0;var ye=this.layer.options.fadeAnimation;this.layer.options.fadeAnimation=!1,this._drawChildTiles(m,b),this._drawParentTiles(this._parentTiles,b),this.layer.options.fadeAnimation=ye,this.layer._silentConfig=!1}this.drawingCurrentTiles=!0,i.sort(this._compareTiles);for(var Re=0,Be=i.length;Re<Be;Re++)this._drawTileAndCache(i[Re],b);if(delete this.drawingCurrentTiles,W&&this.layer.options.opacity<1){this.layer._silentConfig=!0;var Ge=this.layer.options.fadeAnimation;this.layer.options.fadeAnimation=!1,this._drawChildTiles(m,b),this._drawParentTiles(this._parentTiles,b),this.layer.options.fadeAnimation=Ge,this.layer._silentConfig=!1}this.onDrawTileEnd($,b)},m._drawChildTiles=function(i,g){var m=this;this.drawingChildTiles=!0,i.forEach((function(i){return m._drawTile(i.info,i.image,g)})),delete this.drawingChildTiles},m._drawParentTiles=function(i,g){var m=this;this.drawingParentTiles=!0,i.forEach((function(i){return m._drawTile(i.info,i.image,g)})),delete this.drawingParentTiles},m.onDrawTileStart=function(i,g){},m.onDrawTileEnd=function(i,g){},m._drawTile=function(i,g,m){g&&this.drawTile(i,g,m)},m.drawTile=function(i,g,m){},m._drawTileAndCache=function(i,g){this.isValidCachedTile(i)&&(this.tilesInView[i.info.id]=i),this._drawTile(i.info,i.image,g)},m.drawOnInteracting=function(i,g,m){this.draw(g,m)},m.checkIfNeedRedraw=function(){return!!this._tileQueue.length},m.hitDetect=function(){return!1},m._getLoadLimit=function(){return(this.map||this.getMap()).isInteracting()?this.layer.options.loadingLimitOnInteracting:this.layer.options.loadingLimit||0},m._isLoadingTile=function(i){return!!this.tilesLoading[i]},m.loadTileQueue=function(i){for(var g in i)if(i.hasOwnProperty(g)){var m=i[g],_=this.loadTile(m);void 0===_.loadTime&&(this.tilesLoading[m.id]={image:_,current:!0,info:m})}},m.loadTile=function(i){var g=this,m={};if(this.loadTileBitmap&&Re(this.loadTileBitmap)){this.loadTileBitmap(i.url,i,(function(m){g.onTileLoad(m,i)}),(function(m,_){g.onTileError(_,i,m)}))}else if(this._tileImageWorkerConn&&this.loadTileImage===this.constructor.prototype.loadTileImage)this._fetchImage(m,i);else{var _=this.layer.getTileSize(i.layer);(m=new Image).width=_.width,m.height=_.height,m.onload=this.onTileLoad.bind(this,m,i),m.onerror=this.onTileError.bind(this,m,i),this.loadTileImage(m,i.url,i)}return m},m._fetchImage=function(i,g){var m=this;if(i instanceof Image)i.src=g.url;else{var{x:_,y:b}=g,T=Math.abs(_+b)%this._tileImageWorkerConn.workers.length;this._tileImageWorkerConn.fetchImage(g.url,T,(function(_,b){_?m.onTileError(i,g,_):qn(b,(function(i){m.onTileLoad(i,g)}))}),this.layer.options.fetchOptions||{referrer:document.location.href,headers:{accept:"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8"}})}},m.loadTileImage=function(i,g,m){var _=this.layer.options.crossOrigin;return H(_)||(i.crossOrigin=_),dn(i,[g])},m.abortTileLoading=function(i,g){(g&&void 0!==g.id&&this.removeTileLoading(g),i)&&(i instanceof Image&&(i.onload=nm,i.onerror=nm,i.src=Vn),this.loadTileBitmap&&Re(this.loadTileBitmap)&&this.loadTileBitmap(g.url,g,(function(){}),{command:"abortTile"}))},m.onTileLoad=function(i,g){this.removeTileLoading(g),this._tileQueue.push({tileInfo:g,tileData:i}),this._tileQueueIds.add(g.id),this.setToRedraw()},m.removeTileLoading=function(i){delete this.tilesLoading[i.id],this.setToRedraw()},m._consumeTileQueue=function(){for(var i=0,g=this.layer.options.tileLimitPerFrame,m=this._tileQueue;m.length&&(g<=0||i<g);){var{tileData:_,tileInfo:b}=m.shift();this._tileQueueIds.has(b.id)&&(this._tileQueueIds.delete(b.id),this.checkTileInQueue(_,b)&&(this.consumeTile(_,b),i++))}},m._computeAvgTileAltitude=function(){var i=0,g=0,m=0;for(var _ in this.tilesInView){var b=this.tilesInView[_]&&this.tilesInView[_].info;b&&(i+=b.minAltitude||0,g+=b.maxAltitude||0,m++)}this.avgMinAltitude=i/m,this.avgMaxAltitude=g/m},m.checkTileInQueue=function(i,g){return!0},m.consumeTile=function(i,g){if(this.layer&&this.tilesInView){var m={tile:g,tileImage:i};this.resetTileLoadTime(i=m.tileImage),this.removeTileLoading(g),this._addTileToCache(g,i),this.layer.fire("tileload",m),this.setToRedraw()}},m.resetTileLoadTime=function(i){0!==i.loadTime&&(i.loadTime=P())},m.onTileError=function(i,g,m){if(this.layer){var _=this.layer.options.reloadErrorTileFunction;if(_)_.call(this,this.layer,this,g,i);else{var b=this.layer.options.errorUrl,T=!(i instanceof Image);if(b){if(i instanceof Image&&i.src!==b)return i.src=b,void this.removeTileLoading(g);(i=new Image).src=b}this.abortTileLoading(i,g),i.loadTime=0,T&&(i.fetchErrorTime=P()),this.removeTileLoading(g),this._addTileToCache(g,i),this.setToRedraw(),this.layer.fire("tileerror",{tile:g})}}},m.getDebugInfo=function(i){var g=i.split("_"),m=g.length;return g[m-3]+"/"+g[m-2]+"/"+g[m-1]},m.findChildTiles=function(i){return this._findChildTiles(i)},m._findChildTiles=function(i){var g=this._getLayerOfTile(i.layer),m=g._isPyramidMode(),_=g&&g.options.terrainTileMode&&m;if(!g||!g.options.background&&!_||i.z>this.layer.getMaxZoom())return Kg;var b=this.map||this.getMap(),T=[];if(m){if(!_){for(var P=2*i.x,I=2*i.y,H=i.z+1,W=[],q=0;q<2;q++)for(var $=0;$<2;$++)W.push(P+q,I+$,H);for(;W.length;){var ye=W.pop(),Re=W.pop(),Be=W.pop(),Ge=g._getTileId(Be,Re,ye,i.layer),je=ye+1<=i.z+2,Xe=this.tileCache.getAndRemove(Ge);if(Xe){if(this.isValidCachedTile(Xe))T.push(Xe),this.tileCache.add(Ge,Xe);else if(je)for(var Ze=0;Ze<2;Ze++)for(var Ye=0;Ye<2;Ye++)W.push(2*Be+Ze,2*Re+Ye,ye+1)}else if(je)for(var Qe=0;Qe<2;Qe++)for(var Je=0;Je<2;Je++)W.push(2*Be+Qe,2*Re+Je,ye+1)}return T}var Ke;_&&(Ke=[]);for(var et=2*i.x,tt=2*i.y,at=i.z+1,ht=[],gt=0;gt<2;gt++)for(var yt=0;yt<2;yt++){var vt=g._getTileId(et+gt,tt+yt,at,i.layer),xt=this.tileCache.getAndRemove(vt);xt&&this.isValidCachedTile(xt)?(T.push(xt),this.tileCache.add(vt,xt),ht.push(null)):ht.push(vt)}if(T.length<4)for(var bt=0,Tt=0;Tt<2;Tt++)for(var Mt=0;Mt<2;Mt++){var Pt=ht[bt++];if(Pt){for(var It=et+Tt,Et=tt+Mt,Lt=at,Dt=T.length,Ft=[],Ht=0;Ht<2;Ht++)for(var Bt=0;Bt<2;Bt++){var zt=g._getTileId(2*It+Ht,2*Et+Bt,Lt+1,i.layer),Vt=this.tileCache.getAndRemove(zt);Vt&&this.isValidCachedTile(Vt)?(T.push(Vt),this.tileCache.add(zt,Vt),Ft.push(null)):Ft.push(zt)}if(_&&T.length-Dt<4){var Ut=g.tileInfoCache.get(Pt)||g._createChildNode(i,Tt,Mt,[0,0],Pt);if(T.length-Dt===0)Ke.push(Ut);else for(var Gt=0,jt=0;jt<2;jt++)for(var Wt=0;Wt<2;Wt++){var qt=Ft[Gt++];if(qt){var Xt=this.layer.tileInfoCache.get(qt)||g._createChildNode(Ut,jt,Wt,[0,0],qt);Ke.push(Xt)}}}}}return _?{tiles:T,missedTiles:Ke}:T}for(var Zt=i.res,$t=i.extent2d.getMin(),Yt=i.extent2d.getMax(),Qt=g._project(b._pointToPrjAtRes($t,Zt,Qg),Qg),Jt=g._project(b._pointToPrjAtRes(Yt,Zt,Jg),Jg),Kt=1;Kt<1;Kt++)this._findChildTilesAt(T,Qt,Jt,g,i.z+Kt);return T},m._findChildTilesAt=function(i,g,m,_,b){var T=_._spatialRef||_.getSpatialReference(),P=_.getId(),I=T.getResolution(b);if(I)for(var H,W,q=_._getTileConfig(),$=q.getTileIndex(g,I),ye=q.getTileIndex(m,I),Re=Math.min($.idx,ye.idx),Be=Math.max($.idx,ye.idx),Ge=Math.min($.idy,ye.idy),je=Math.max($.idy,ye.idy),Xe=Re;Xe<Be;Xe++)for(var Ze=Ge;Ze<je;Ze++)H=_._getTileId(Xe,Ze,b,P),(W=this.tileCache.getAndRemove(H))&&this.isValidCachedTile(W)&&(i.push(W),this.tileCache.add(H,W))},m.findParentTile=function(i,g){return this._findParentTile(i,g)},m._findParentTile=function(i,g){var m=this.map||this.getMap(),_=this._getLayerOfTile(i.layer);if(!_||!_.options.background&&!_.options.terrainTileMode)return null;var b=_.getMinZoom(),T=g||i.z-b;if(_._isPyramidMode()){for(var P=i.z-T,I=i.z-1;I>=P;I--){var H=Math.pow(2,i.z-I),W=Math.floor(i.x/H),q=Math.floor(i.y/H),$=void 0;$=I===i.z-1?i.parent:_._getTileId(W,q,I,i.layer);var ye=this.tileCache.getAndRemove($);if(ye&&this.isValidCachedTile(ye))return this.tileCache.add($,ye),ye}return null}for(var Re=_.getSpatialReference(),Be=Re.getZoomDirection(),Ge=i.res,je=i.extent2d.getCenter(),Xe=_._project(m._pointToPrjAtRes(je,Ge)),Ze=1;Ze<=T;Ze++){var Ye=i.z-Be*Ze,Qe=Re.getResolution(Ye);if(Qe){var Je=_._getTileConfig().getTileIndex(Xe,Qe),Ke=_._getTileId(Je.x,Je.y,Ye,i.layer),et=this.tileCache.getAndRemove(Ke);if(et)return this.tileCache.add(Ke,et),et}}return null},m.isValidCachedTile=function(i){return!!i.image},m.isTileComplete=function(i){return!0},m._getLayerOfTile=function(i){return this.layer.getChildLayer?this.layer.getChildLayer(i):this.layer},m.getCachedTile=function(i,g){var m=i.id,_=this.tilesInView,b=this.tileCache.getAndRemove(m);if(b){g||(_[m]=b);var T=this.tilesLoading;if(T&&T[m]){this.markCurrent(T[m],!1);var{image:P,info:I}=T[m];this.abortTileLoading(P,I),delete T[m]}}else b=_[m];return b&&(b.current=!0,this.isValidCachedTile(b)&&this.tileCache.add(m,b)),b},m._addTileToCache=function(i,g){this.isValidCachedTile({info:i,image:g})&&this.tileCache.add(i.id,{image:g,info:i})},m.getTileOpacity=function(i,g){var m=this.getTileFadingOpacity(i);if(this.layer.getChildLayer){var _=this.layer.getLayer(g.layer);_&&(m*=_.options.opacity)}return m},m.getTileFadingOpacity=function(i){return this.layer.options.fadeAnimation&&i.loadTime?Math.min(1,(P()-i.loadTime)/this.layer.options.fadeDuration):1},m.clearTileCaches=function(){this.retireTiles(!0),this.tileCache.reset(),this.tilesInView={},this.tilesLoading={},this._tileQueue=[],this._tileQueueIds.clear(),this._parentTiles=[],this._childTiles=[]},m.removeTileCaches=function(){delete this.tileCache,delete this._tilePlaceHolder,delete this._tileZoom},m.markCurrent=function(i,g){i.current=g},m.markTiles=function(){var i=0,g=0;if(this.tilesLoading)for(var m in this.tilesLoading)this.markCurrent(this.tilesLoading[m],!1),i++;if(this.tilesInView)for(var _ in this.tilesInView)this.markCurrent(this.tilesInView[_],!1),g++;return[i,g]},m.retireTiles=function(i){for(var g in this.tilesLoading){var m=this.tilesLoading[g];!i&&m.current||(m.image&&this.abortTileLoading(m.image,m.info),this.deleteTile(m),this.removeTileLoading(m.info))}for(var _ in this.tilesInView){var b=this.tilesInView[_];b.current||(delete this.tilesInView[_],this.tileCache.has(_)||this.deleteTile(b))}},m.deleteTile=function(i){if(i&&i.image){var g=i.info.id;this._tileQueueIds.has(g)&&this._tileQueueIds.delete(g),i.image.close&&i.image.close(),i.image instanceof Image&&(i.image.onload=null,i.image.onerror=null);var m=this.layer;m&&m.fire("tiledelete",{tile:i.info,tileImage:i.image})}},m._generatePlaceHolder=function(i){var g=this.map||this.getMap(),m=this.layer.options.placeholder;if(!m||g.getPitch())return null;var _=this.layer.getTileSize(),b=i/g._getResolution(),T=this._tilePlaceHolder=this._tilePlaceHolder||Va.createCanvas(1,1,g.CanvasClass);return T.width=_.width*b,T.height=_.height*b,Re(m)?m(T):function(i){var g=i.getContext("2d"),m=i.width,_=i.height,b=m/16,T=_/16;g.beginPath();for(var P=0;P<16;P++)g.moveTo(0,P*T),g.lineTo(m,P*T),g.moveTo(P*b,0),g.lineTo(P*b,_);g.strokeStyle="rgba(180, 180, 180, 0.1)",g.lineWidth=1,g.stroke(),g.beginPath();for(var I=[[0,0],[m,0],[0,_],[m,_],[0,0],[0,_],[m,0],[m,_],[0,_/2],[m,_/2],[m/2,0],[m/2,_]],H=1;H<I.length;H+=2)g.moveTo(I[H-1][0],I[H-1][1]),g.lineTo(I[H][0],I[H][1]);g.lineWidth=4,g.stroke()}(T),T},m.setTerrainHelper=function(i){this._terrainHelper=i},m._validateTileImage=function(i){if(i)return!i.fetchErrorTime},g}(i);return g};function nm(){return!1}function rm(i,g){return Math.abs(this._tileZoom-i.info.z)-Math.abs(this._tileZoom-g.info.z)}var im=new un(0,0),om=new un(0,0),sm=function(i){function g(g){var m;return(m=i.call(this,g)||this).init(),m}tn(g,i);var m=g.prototype;return m._drawTiles=function(i,g,m,_,b,T,P){var I=this;g.length&&(g.sort(this._compareTiles),this._parentTiles=g),m.length&&(this._childTiles=m,this._childTiles.sort(this._compareTiles));var H=!0;this.layer.constructor!==Up&&this.layer.constructor!==Qp||(this._renderTimestamp===this.canvas._parentTileTimestamp?H=!1:this.canvas._parentTileTimestamp=this._renderTimestamp);var W="gl"===this.layer.options.renderer&&(!this.isGL||this.isGL()),q={tiles:i,parentTiles:this._parentTiles,childTiles:this._childTiles,parentContext:b};if(this.onDrawTileStart(q,b),H&&1===this.layer.options.opacity){this.layer._silentConfig=!0;var $=this.layer.options.fadeAnimation;this.layer.options.fadeAnimation=!1,W?(this._drawChildTiles(m,b),this._drawParentTiles(this._parentTiles,b)):(this._drawParentTiles(this._parentTiles,b),this._drawChildTiles(m,b)),this.layer.options.fadeAnimation=$,this.layer._silentConfig=!1}this.drawingCurrentTiles=!0,i.sort(this._compareTiles);for(var ye=0,Re=i.length;ye<Re;ye++)this._drawTileAndCache(i[ye],b);if(delete this.drawingCurrentTiles,H&&this.layer.options.opacity<1){this.layer._silentConfig=!0;var Be=this.layer.options.fadeAnimation;this.layer.options.fadeAnimation=!1,W?(this._drawChildTiles(m,b),this._drawParentTiles(this._parentTiles,b)):(this._drawParentTiles(this._parentTiles,b),this._drawChildTiles(m,b)),this.layer.options.fadeAnimation=Be,this.layer._silentConfig=!1}_.forEach((function(i){return I._drawTile(i.info,i.image,b)})),this.onDrawTileEnd(q,b)},m.needToRedraw=function(){var g=this.getMap();return!!this.checkIfNeedRedraw()||(g.getPitch()?i.prototype.needToRedraw.call(this):!(!g.isRotating()&&!g.isZooming())||(g.isMoving()?!!this.layer.options.forceRenderOnMoving:i.prototype.needToRedraw.call(this)))},m.isDrawable=function(){return!this.getMap().getPitch()||(console&&console.warn("TileLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."),this.clear(),!1)},m.clipCanvas=function(g){return i.prototype.clipCanvas.call(this,g)},m.clear=function(){this.clearTileCaches(),i.prototype.clear.call(this)},m.onRemove=function(){this.clear(),this.removeTileCaches(),i.prototype.onRemove.call(this)},m.drawTile=function(i,g,m){if(this._validateTileImage(g)){var _=this.getMap();if(_){var{extent2d:b,offset:T}=i,P=im.set(b.xmin-T[0],b.ymax-T[1]),I=i.z,H=i.id,W=_.getZoom(),q=this.context,$=_._pointAtResToContainerPoint(P,i.res,0,om),ye=_.getBearing(),Re=ye||W!==I,Be=this.getTileOpacity(g,i),Ge=q.globalAlpha;Be<1&&(q.globalAlpha=Be),Re||$._round();var je=$.x,Xe=$.y,Ze=i.extent2d.xmax-i.extent2d.xmin,Ye=i.extent2d.ymax-i.extent2d.ymin,Qe=this.layer,Je=Qe?Qe.options.bufferPixel:0;if(Re){q.save(),q.translate(je,Xe),ye&&q.rotate(-ye*Math.PI/180),Ze+=Je,Ye+=Je;var Ke=_._getResolution();if(Ke!==i.res){var et=i.res/Ke;q.scale(et,et)}je=Xe=0}if(Va.image(q,g,je,Xe,Ze,Ye),this.layer.options.debug){var tt=this.layer.options.debugOutline;q.save(),q.strokeStyle=tt,q.fillStyle=tt,q.font="20px monospace";var at=new un(je,Xe);Va.rectangle(q,at,{width:Ze,height:Ye},1,0),Va.fillText(q,this.getDebugInfo(H),at._add(32,Ye-14),tt),Va.drawCross(q,je+Ze/2,Xe+Ye/2,2,tt),q.restore()}Re&&q.restore(),q.globalAlpha!==Ge&&(q.globalAlpha=Ge),this.setCanvasUpdated()}}},g}(tm(gg));Up.registerRenderer("canvas",sm);var am=new un(0,0),lm={properties:{}},hm=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.isDrawable=function(){return!0},m.needToRedraw=function(){var g=this.getMap();return!(!this.isGL()||g.getPitch()||!g.isZooming()||g.isMoving()||g.isRotating())||i.prototype.needToRedraw.call(this)},m.onDrawTileStart=function(i,g){var m=this.gl;if(m.enable(m.DEPTH_TEST),m.depthFunc(m.LEQUAL),m.enable(m.POLYGON_OFFSET_FILL),m.enable(m.STENCIL_TEST),m.stencilOp(m.KEEP,m.KEEP,m.REPLACE),m.depthMask(!!this.layer.options.depthMask),g&&g.renderTarget){var _=g.renderTarget.fbo;if(_){var b=g.renderTarget.getFramebuffer(_);m.bindFramebuffer(m.FRAMEBUFFER,b)}}},m.onDrawTileEnd=function(i,g){var m=this.gl;g&&g.renderTarget&&(g.renderTarget.fbo&&m.bindFramebuffer(m.FRAMEBUFFER,null))},m.drawTile=function(g,m,_){if(this._validateTileImage(m)&&(!_||!_.sceneFilter||_.sceneFilter(lm))){var b=this.getMap();if(g&&b&&m){var T=g._glScale=g._glScale||g.res/b.getGLRes(),P=g.extent2d.xmax-g.extent2d.xmin,I=g.extent2d.ymax-g.extent2d.ymin;if(!1!==g.cache&&this._bindGLBuffer(m,P,I),this.isGL()){var{extent2d:W,offset:q}=g,$=am.set(W.xmin-q[0],g.extent2d.ymax-q[1]),ye=$.x*T,Re=$.y*T,Be=this.layer.options.opacity;Be=H(Be)?1:Be;var Ge=this.getTileOpacity(m,g)*Be,je=null;this.layer.options.debug&&(je=this.getDebugInfo(g.id));var Xe=this.gl;Xe.stencilFunc(Xe.LEQUAL,Math.abs(this.getCurrentTileZoom()-g.z),255);var Ze=this.layer.getPolygonOffset(),Ye=this.drawingCurrentTiles?Ze:Ze+1;Xe.polygonOffset(Ye,Ye),this.drawGLImage(m,ye,Re,P,I,T,Ge,b._getResolution()!==g.res,je),this.getTileFadingOpacity(m)<1?this.setToRedraw():this.setCanvasUpdated()}else i.prototype.drawTile.call(this,g,m)}}},m._bindGLBuffer=function(i,g,m){i.glBuffer||(i.glBuffer=this.bufferTileData(0,0,g,m))},m.loadTileImage=function(i,g){var m=this.layer.options.crossOrigin;i.crossOrigin=null!==m?m:"",i.src=g},m.onCanvasCreate=function(){this.canvas.gl&&this.canvas.gl.wrap||this.createCanvas2()},m.createContext=function(){i.prototype.createContext.call(this),this.createGLContext()},m.resizeCanvas=function(g){this.canvas&&(i.prototype.resizeCanvas.call(this,g),this.resizeGLCanvas())},m.clearCanvas=function(){this.canvas&&(i.prototype.clearCanvas.call(this),this.clearGLCanvas())},m.getCanvasImage=function(){if(!this.isGL()||!this.canvas2)return i.prototype.getCanvasImage.call(this);var g=i.prototype.getCanvasImage.call(this);return g&&(g.image=this.canvas2),g},m.isGL=function(){return!0},m.deleteTile=function(g){i.prototype.deleteTile.call(this,g),g&&g.image&&this.disposeImage(g.image),delete g.image},m.onRemove=function(){i.prototype.onRemove.call(this),this.removeGLCanvas()},g}(fg(sm));function cm(i){var g=this,m=this.layer.getTileSize(),_=this.canvas.constructor,b=this.getMap(),T=b.getDevicePixelRatio(),P=Va.createCanvas(m.width*T,m.height*T,_);P.layer=this.layer;var I=new un(i.extent2d.xmin,i.extent2d.ymax),H=new Pl(b.pointToCoordinate(I),b.pointToCoordinate(I.add(m.width,m.height)),b.getProjection());return this.layer.drawTile(P,{url:i.url,point:I,center:b.pointToCoordinate(I.add(m.width/2,m.height/2)),extent:H,z:i.z,x:i.x,y:i.y},(function(m){m?g.onTileError(P,i):g.onTileLoad(P,i)})),P}Up.registerRenderer("gl",hm);var um=function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g.prototype.loadTile=function(...i){return cm.apply(this,i)},g}(sm),fm=function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g.prototype.loadTile=function(...i){return cm.apply(this,i)},g}(hm);Jp.registerRenderer("canvas",um),Jp.registerRenderer("gl",fm);var dm="undefined"!=typeof Int8Array?new Int8Array([-1,1,0,-1,-1,0,1,1,0,1,-1,0]):[],pm=function(){function i(i,g,m){this.gl=i,this.quadVertices=g||dm,this.attributes=["a_position",3,gm(g)],this.debug=m}var g=i.prototype;return g.start=function(){var i=this.gl;i.enable(i.STENCIL_TEST),i.stencilMask(255),i.stencilOp(i.KEEP,i.REPLACE,i.REPLACE),i.depthMask(!1),this._save(),this.buffer||(this._createBuffer(),this._createProgram()),i.useProgram(this.program),i.bindBuffer(i.ARRAY_BUFFER,this.buffer),tg(i,this.program,this.attributes),this.transformLoc||(this.transformLoc=i.getUniformLocation(this.program,"transform")),this.colorLoc||(this.colorLoc=i.getUniformLocation(this.program,"color")),this.debug||i.colorMask(!1,!1,!1,!1)},g.end=function(){var i=this.gl;i.depthMask(!0),this._restore(),this.debug||i.colorMask(!0,!0,!0,!0)},g.draw=function(i){var g=this.gl;g.uniformMatrix4fv(this.transformLoc,!1,i),g.uniform3fv(this.colorLoc,[Math.random(),Math.random(),Math.random()]),g.drawArrays(g.TRIANGLE_STRIP,0,4)},g.remove=function(){var i=this.gl;return this.buffer&&i.deleteBuffer(this.buffer),this.program&&(i.deleteShader(this.program.fragmentShader),i.deleteShader(this.program.vertexShader),i.deleteProgram(this.program)),delete this.transformLoc,delete this.gl,this},g.stencilMask=function(i){return this.gl.stencilMask(i),this},g.stencilFunc=function(i,g,m){return this.ref=g,this.gl.stencilFunc(i,g,m),this},g.stencilOp=function(i,g,m){return this.gl.stencilOp(i,g,m),this},g.resetFunc=function(){return this.ref=1,this.gl.stencilFunc(this.gl.ALWAYS,1,255),this},g._save=function(){this._savedProgram=this.gl.program},g._restore=function(){var i=this.gl;i.program=this._savedProgram,i.program&&i.useProgram(i.program)},g._createBuffer=function(){var i=this.gl;if(this.buffer=i.createBuffer(),!this.buffer)throw new Error("Failed to create the buffer object");i.bindBuffer(i.ARRAY_BUFFER,this.buffer),i.bufferData(i.ARRAY_BUFFER,this.quadVertices,i.STATIC_DRAW)},g._createProgram=function(){var{program:i,vertexShader:g,fragmentShader:m}=eg(this.gl,"\n    attribute vec3 a_position;\n    uniform mat4 transform;\n\n    void main()\n    {\n        gl_Position = transform * vec4(a_position, 1.0);\n    }\n","\n    precision mediump float;\n    uniform vec3 color;\n    void main()\n    {\n        gl_FragColor = vec4(color, 1.0);\n    }\n");i.vertexShader=g,i.fragmentShader=m,this.program=i},i}();function gm(i){return i instanceof Float32Array?"FLOAT":i instanceof Int16Array?"SHORT":i instanceof Uint16Array?"UNSIGNED_SHORT":i instanceof Int8Array?"BYTE":i instanceof Uint8Array||i instanceof Uint8ClampedArray?"UNSIGNED_BYTE":"FLOAT"}var mm=function(i){var g=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.checkResources=function(){var i=this._geosToCheck||[];if(!this._resourceChecked&&this.layer._geoList&&yn(i,this.layer._geoList),!kn(i))return[];for(var g=[],m={},_=i.length-1;_>=0;_--){var b=i[_]._getExternalResources();if(b.length)if(this.resources)for(var T=0;T<b.length;T++){var P=b[T][0];this.resources.isResourceLoaded(b[T])||m[P]||(g.push(b[T]),m[P]=1)}else g.push(...b)}return this._resourceChecked=!0,delete this._geosToCheck,g},m._addGeoToCheckRes=function(i){i&&(Array.isArray(i)||(i=[i]),this._geosToCheck||(this._geosToCheck=[]),yn(this._geosToCheck,i))},m.onGeometryAdd=function(i){this._addGeoToCheckRes(i),_m(this)},m.onGeometryRemove=function(i){this.layer.fire("removegeo",{type:"removegeo",target:this,geometries:i}),_m(this)},m.onGeometrySymbolChange=function(i){this._addGeoToCheckRes(i.target),_m(this)},m.onGeometryShapeChange=function(i){_m(this)},m.onGeometryPositionChange=function(i){_m(this)},m.onGeometryZIndexChange=function(i){_m(this)},m.onGeometryShow=function(i){_m(this)},m.onGeometryHide=function(i){_m(this)},m.onGeometryPropertiesChange=function(i){_m(this)},g}(i);return g},Am=function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g.prototype.render=function(...g){return this.layer._sortGeometries(),i.prototype.render.apply(this,g)},g}(mm(gg)),ym=function(i){function g(){return i.apply(this,arguments)||this}return tn(g,i),g.prototype.render=function(...g){return this.layer._sortGeometries(),i.prototype.render.apply(this,g)},g}(mm(Lu));function _m(i){i instanceof Am&&i.layer.options.drawImmediate&&i.render(),i.setToRedraw()}var vm=new kl,xm=[],bm=new kl;function wm(i){if(!i)return null;var g=i.getContext("2d");return g.clearRect(0,0,i.width,i.height),g}function Tm(i){return i&&i.options.progressiveRender&&i.options.progressiveRenderDebug}var Sm=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.setToRedraw=function(){return i.prototype.setToRedraw.call(this),this._resetProgressiveRender(),this},m._geoIsCollision=function(i,g){if(!i)return!1;if(!i.options.collision)return!1;if(i.isPoint&&i.getContainerExtent){i.bbox||(i.bbox=[0,0,0,0]);var m=this.layer.options.collisionBufferSize,_=i.getContainerExtent();if(!_)return!1;if(i.bbox[0]=_.xmin-m,i.bbox[1]=_.ymin-m,i.bbox[2]=_.xmax+m,i.bbox[3]=_.ymax+m,g.collides(i.bbox))return i._collided=!0,!0;g.insertBox(i.bbox)}return!1},m.getImageData=function(){if(!this._lastRenderTime||P()-this._lastRenderTime<32)return null;if(!this.context||!this.context.canvas)return null;if(!this._imageData){var{width:i,height:g}=this.context.canvas;try{var m=this.screenshotRenderResult(0,0,i,g);m&&(this._imageData=m.getImageData(0,0,i,g))}catch(i){console.warn("hit detect failed with tainted canvas, some geometries have external resources in another domain:\n",i)}}return this._imageData},m.clearImageData=function(){this._imageData=null,delete this._imageData,this._lastRenderTime=P()},m.checkResources=function(...g){var m=this,_=i.prototype.checkResources.apply(this,g),b=this.layer.getStyle();return b&&(Array.isArray(b)||(b=[b]),b.forEach((function(i){for(var g=no(i.symbol,!0),b=0,T=g.length;b<T;b++)m.resources.isResourceLoaded(g[b])||_.push(g[b])}))),_},m.needToRedraw=function(){if(this.isProgressiveRender()&&!this.renderEnd)return!0;var g=this.getMap();return!(!g.isInteracting()||!this.layer.options.enableAltitude)||!(g.isZooming()&&!g.isRotating()&&!g.getPitch()&&!this._hasPoint&&this.layer.constructor===Mg)&&i.prototype.needToRedraw.call(this)},m.draw=function(){if(this.getMap()){if(!this.layer.isVisible()||this.layer.isEmpty())return this.clearCanvas(),void this.completeRender();this.prepareCanvas(),this.drawGeos(),this.completeRender()}},m.isBlank=function(){return!!this.context&&(!this.isProgressiveRender()&&!this.context.canvas._drawn)},m.drawOnInteracting=function(){if(this._geosToDraw){this._updateMapStateCache(),this._updateDisplayExtent();var i=this.getMap(),g=this.layer.getCount(),m=this.mapStateCache.resolution;(i.isZooming()&&i.options.seamlessZoom&&void 0!==this._drawnRes&&m>1.5*this._drawnRes&&this._geosToDraw.length<g||i.isMoving()||i.isInteracting())&&(this.prepareToDraw(),this._batchConversionMarkers(this.mapStateCache.glRes),this._onlyHasPoint||this._checkGeos(),this._drawnRes=m),this._sortByDistanceToCamera(i.cameraPosition);var{collision:_,collisionDelay:b}=this.layer.options;if(_){var T=P();this._lastCollisionTime||(this._lastCollisionTime=T),T-this._lastCollisionTime<=b?this._geosToDraw=this._lastGeosToDraw||this._geosToDraw:(this._collidesGeos(),this._lastCollisionTime=T)}for(var I=0,H=this._geosToDraw.length;I<H;I++){var W=this._geosToDraw[I];W._isCheck||W.isVisible()?(W._paint(this._displayExtent),this._geosToDraw[I]._cPoint=void 0,this._geosToDraw[I]._inCurrentView=void 0):(delete W._cPoint,delete W._inCurrentView)}this.clearImageData(),this._lastGeosToDraw=this._geosToDraw,Tm(this.layer)&&console.log("progressiveRender on drawOnInteracting page:",this.page)}},m.show=function(...g){this.layer.forEach((function(i){i._repaint()})),i.prototype.show.apply(this,g)},m.forEachGeo=function(i,g){this.layer.forEach(i,g)},m._checkGeos=function(){for(var i=this.getCurrentNeedRenderGeos(),g=0,m=i.length;g<m;g++)this.checkGeo(i[g]);return this},m.drawGeos=function(){this._drawSnapshot(),this._updateMapStateCache(),this._drawnRes=this.mapStateCache.resolution,this._updateDisplayExtent(),this.prepareToDraw(),this._batchConversionMarkers(this.mapStateCache.glRes),this._onlyHasPoint||this._checkGeos(),this._sortByDistanceToCamera(this.getMap().cameraPosition),this._collidesGeos();for(var i=0,g=this._geosToDraw.length;i<g;i++)this._geosToDraw[i]._paint(),this._geosToDraw[i]._cPoint=void 0,this._geosToDraw[i]._inCurrentView=void 0;this.clearImageData(),this._lastGeosToDraw=this._geosToDraw,Tm(this.layer)&&console.log("progressiveRender drawGeos page:",this.page),this._snapshot(),this._setDrawGeosDrawTime()},m.prepareToDraw=function(){return this.layer._drawTime=P(),this._hasPoint=!1,this._geosToDraw=[],this},m._setDrawGeosDrawTime=function(){for(var i=P(),g=this.layer._drawTime,m=this.getGeoPainterList(),_=0,b=m.length;_<b;_++){var T=m[_];T&&T._setDrawTime&&T._setDrawTime(g)}return Tm(this.layer)&&console.log("_setDrawGeosDrawTime time:",P()-i+"ms"),this},m.checkGeo=function(i){if(i.isPoint&&void 0!==this._onlyHasPoint)(i._inCurrentView||i.hasAltitude())&&(this._hasPoint=!0,i._isCheck=!0,this._geosToDraw.push(i));else if(i._isCheck=!1,i&&i.isVisible()&&i.getMap()&&i.getLayer()&&i.getLayer().isCanvasRender()){var g=i._getPainter();if(g){var m=!0;if(i._inCurrentView||!H(i.options.arcDegree)||i.hasAltitude())m=!0;else if(!1===i._inCurrentView)m=!1;else{var _=g.get2DExtent(this.resources,vm);_&&_.intersects(this._displayExtent)||(m=!1)}m&&(g.hasPoint()&&(this._hasPoint=!0),i._isCheck=!0,this._geosToDraw.push(i))}}},m._collidesGeos=function(){var i=this._geosToDraw;if(!this.layer.options.collision){for(var g=0,m=i.length;g<m;g++){var _=i[g];_.isPoint&&(_._collided=!1)}return this}var b=this.layer.options.collisionScope,T=this.layer.getCollisionIndex();"layer"===b&&T.clear(),this._geosToDraw=[];for(var P=0,I=i.length;P<I;P++){var H=i[P];H.isPoint&&(H._collided=!1,this._geoIsCollision(H,T))?H._collided=!0:this._geosToDraw.push(i[P])}return this},m.onZoomEnd=function(...g){delete this.canvasExtent2D,i.prototype.onZoomEnd.apply(this,g)},m.onRemove=function(){this.forEachGeo((function(i){i.onHide()})),delete this._geosToDraw,delete this.snapshotCanvas,delete this.pageGeos,delete this.geoPainterList},m.onGeometryPropertiesChange=function(g){g&&this.layer._styleGeometry(g.target),i.prototype.onGeometryPropertiesChange.call(this,g)},m._updateDisplayExtent=function(){var i=this.canvasExtent2D;if(this._maskExtent){if(!this._maskExtent.intersects(i))return void this.completeRender();i=i.intersection(this._maskExtent)}this._displayExtent=i},m.identifyAtPoint=function(i,g={}){var m=this.getGeosForIdentify();return m?this.layer._hitGeos(m,i,g):[]},m._updateMapStateCache=function(){var i=this.getMap(),g=i._pointToContainerPoint(this.middleWest)._add(0,-i.height/2),m=i.getResolution(),_=i.getPitch(),b=i.getBearing(),T=i.getGLScale(),P=i.getGLRes(),I=i.getContainerExtent(),H=i.get2DExtent(),W=i.get2DExtentAtRes(P);return this.mapStateCache={resolution:m,pitch:_,bearing:b,glScale:T,glRes:P,_2DExtent:H,glExtent:W,containerExtent:I,offset:g},this},m._batchConversionMarkers=function(i){if(this._onlyHasPoint=void 0,!this._constructorIsThis())return[];var g=[],m=[],_=[],b={},T=this.layer,P=T.options,I=T.getAltitude?T.getAltitude():0,H=T.isCanvasRender();this._onlyHasPoint=!0;for(var W=0,q=this.getCurrentNeedRenderGeos(),$=0,ye=q.length;$<ye;$++){var Re=q[$];if(Re.isPoint){var Be=Re._painter;Be||(Be=Re._getPainter());var Ge=Be.getRenderPoints("center")[0][0],je=P.enableAltitude?Re._getAltitude():I;void 0===b[je]&&(b[je]=Be.getAltitude()),g[W]=Ge,_[W]=b[je],m[W]=Re,W++}else this._onlyHasPoint=!1}if(0===W)return[];var Xe=this.getMap(),Ze=Wn(g,"_pt");Ze=Xe._pointsAtResToContainerPoints(g,i,_,Ze);for(var Ye=Xe.getContainerExtent(),{xmax:Qe,ymax:Je,xmin:Ke,ymin:et}=Ye,tt={},at=0,ht=m.length;at<ht;at++){var gt=m[at];if(gt._cPoint=Ze[at],gt._cPoint){var{x:yt,y:vt}=Ze[at];if(gt._inCurrentView=yt>=Ke&&vt>=et&&yt<=Qe&&vt<=Je||gt.hasAltitude(),!gt._inCurrentView){var xt=gt.getSymbolHash(),bt=void 0;bt=xt?tt[xt]=tt[xt]||gt._painter.getFixedExtent():gt._painter.getFixedExtent(),bm.set(bt.xmin,bt.ymin,bt.xmax,bt.ymax),bm._add(Ze[at]),gt._inCurrentView=bm.intersects(Ye)}gt._inCurrentView&&(gt.isVisible()&&H||(gt._inCurrentView=!1),this._onlyHasPoint&&gt._inCurrentView&&(this._hasPoint=!0,gt._isCheck=!0,this._geosToDraw.push(gt)))}else gt._inCurrentView=!1}return Ze},m._sortByDistanceToCamera=function(i){if(this.layer.options.sortByDistanceToCamera&&this._geosToDraw.length){var g=this.getMap(),m=g.distanceToPoint(1e3,0,g.getGLScale()).x/1e3,_="center";this._geosToDraw.sort((function(g,b){if(!g.isPoint||!b.isPoint)return 0;var T=g._painter,P=b._painter;if(!T||!P)return 0;var I=T.getRenderPoints(_)[0][0],H=P.getRenderPoints(_)[0][0],W=T.getAltitude()*m,q=P.getAltitude()*m;es(xm,I.x,I.y,W);var $=fs(xm,i);return es(xm,H.x,H.y,q),fs(xm,i)-$}))}},m._constructorIsThis=function(){return this.constructor===g},m.isProgressiveRender=function(){var i=this.layer;if(!i)return!1;var{progressiveRender:g,collision:m}=i.options||{};return!m&&g},m.getGeosForIdentify=function(){return this.isProgressiveRender()?this.pageGeos||[]:this._geosToDraw||[]},m.getGeoPainterList=function(){if(!this.isProgressiveRender()){for(var i=[],g=this._geosToDraw||[],m=0,_=g.length;m<_;m++)i.push(g[m]._painter);return i}return this.geoPainterList||[]},m._checkSnapshotCanvas=function(){if(!this.isProgressiveRender())return delete this.snapshotCanvas,null;var i=this.canvas;if(!i)return delete this.snapshotCanvas,null;this.snapshotCanvas||(this.snapshotCanvas=Va.createCanvas(1,1));var g=this.snapshotCanvas,{width:m,height:_,style:b}=i;return g.width===m&&g.height===_||(g.width=m,g.height=_),g.style.width===b.width&&g.style.height===b.height||(g.style.width=b.width,g.style.height=b.height),g},m._getCurrentNeedRenderGeos=function(){var i=this.layer._geoList||[];if(!this.isProgressiveRender())return i;var g=this.layer,{progressiveRenderCount:m}=g.options,_=this.page;return i.slice((_-1)*m,_*m)},m.getCurrentNeedRenderGeos=function(){return this._getCurrentNeedRenderGeos()},m._resetProgressiveRender=function(){Tm(this.layer)&&console.log("progressiveRender resetProgressiveRender"),this.renderEnd=!1,this.page=1,this.pageGeos=[],this.geoPainterList=[],this.maxTolerance=0,this._clearSnapshotCanvas()},m._clearSnapshotCanvas=function(){var i=this._checkSnapshotCanvas();i&&wm(i)},m._snapshot=function(){for(var i=this.isProgressiveRender(),g=this._geosToDraw||[],m=0,_=g.length;m<_;m++){var b=g[m],T=b._hitTestTolerance()||0;if(this.maxTolerance=Math.max(this.maxTolerance,T),i)this.pageGeos.push(b),this.geoPainterList.push(b._painter)}if(!i)return this;var I=P(),H=this._checkSnapshotCanvas();H&&this.canvas&&wm(H).drawImage(this.canvas,0,0);var W=this.layer,{progressiveRenderCount:q}=W.options,$=Math.ceil((W._geoList||[]).length/q);return this.renderEnd=this.page>=$,this.renderEnd&&this._setDrawGeosDrawTime(),Tm(this.layer)&&console.log("snapshot time:",P()-I+"ms"),this.renderEnd||this.page++,this},m._drawSnapshot=function(){if(!this.isProgressiveRender())return this;var{snapshotCanvas:i,context:g}=this;if(!i||!g)return this;var m=this.getMap();if(!m)return this;var _=this.mapDPR||m.getDevicePixelRatio()||1;return this._canvasContextScale(g,1/_),g.drawImage(i,0,0),this._canvasContextScale(g,_),this},g}(Am);Mg.registerRenderer("canvas",Sm);var Mm=function(i){function g(g){var m;return(m=i.call(this)||this).map=g,m._handlerQueue=[],m._thisDocVisibilitychange=m._onDocVisibilitychange.bind(m),m._thisDocDragStart=m._onDocDragStart.bind(m),m._thisDocDragEnd=m._onDocDragEnd.bind(m),m._thisDocDPRChange=m._onDocDPRChange.bind(m),m}tn(g,i);var m=g.prototype;return m._getAllLayerToRender=function(){return this.map._getLayers()},m.setToRedraw=function(){for(var i=this._getAllLayerToRender(),g=0,m=i.length;g<m;g++){var _=i[g].getRenderer();_&&_.canvas&&_.setToRedraw&&_.setToRedraw()}},m.callInNextFrame=function(i){this._handlerQueue.push(i)},m.executeFrameCallbacks=function(){var i=this._handlerQueue;this._handlerQueue=[];for(var g=0,m=i.length;g<m;g++)i[g]()},m.offsetPlatform=function(i,g){if(!this.map.getPanels().front)return this;if(!g&&0===i.x&&0===i.y)return this;var m=this.map.getPanels(),_=this._frontCount=m.back.layerDOM.childElementCount,b=this._backCount=m.front.layerDOM.childElementCount,T=this._uiCount=m.front.uiDOM.childElementCount;if(_||b||T){var P=this.map.offsetPlatform();P=i?P.add(i)._round():P.round(),b&&zr(m.back,P),(_||T)&&zr(m.front,P)}return this},m.domChanged=function(){var i=this.map.getPanels();return!!i.front&&(void 0===this._frontCount||this._frontCount!==i.back.layerDOM.childElementCount||(void 0===this._backCount||this._backCount!==i.front.layerDOM.childElementCount||(void 0===this._uiCount||this._uiCount!==i.front.uiDOM.childElementCount)))},m.resetContainer=function(){if(this.map&&(this.map._resetMapViewPoint(),this.map.getPanels().front)){var i=new un(0,0);zr(this.map.getPanels().back,i),zr(this.map.getPanels().front,i)}},m.onZoomEnd=function(){this.resetContainer()},m._onDocVisibilitychange=function(){"visible"===document.visibilityState&&this.setToRedraw()},m._getWrapPanel=function(){if(!this.map)return null;var i=this.map.getPanels();return i&&i.mapWrapper},m._onDocDragStart=function(){var i=this._getWrapPanel();i&&(i.style.overflow="visible")},m._onDocDragEnd=function(){var i=this._getWrapPanel();i&&(i.style.overflow="hidden")},m._onDocDPRChange=function(){var i=this.map;i&&i.options&&!i.options.devicePixelRatio&&i.checkSize&&i.getRenderer&&(i.getRenderer()&&i.checkSize(!0))},m._containerIsOffscreen=function(){var i=this,g=this.map.getContainer();if(!g)return!0;if(!g._resizeObserver){var m=new ResizeObserver((function(g){var{clientWidth:m,clientHeight:_}=g[0].target;i._containerClientWidth=m,i._containerClientHeight=_}));m.observe(g),g._resizeObserver=m}return!g.style||"none"===g.style.display||Math.min(this._containerClientWidth,this._containerClientHeight)<=0},g}(Ya);function Cm(i,g,m,_){return new(m||(m=Promise))((function(g,b){function T(i){try{I(_.next(i))}catch(i){b(i)}}function P(i){try{I(_.throw(i))}catch(i){b(i)}}function I(i){var _;i.done?g(i.value):(_=i.value,_ instanceof m?_:new m((function(i){i(_)}))).then(T,P)}I((_=_.apply(i,[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;var Pm=new va,Im=function(i){function g(g){var m;return(m=i.call(this,g)||this).ready=!1,m._containerIsCanvas=!!g.getContainer().getContext,m._registerEvents(),m._loopTime=0,m._resizeEventList=[],m._resizeTime=-1/0,m._frameCycleRenderCount=0,m}tn(g,i);var _=g.prototype;return _.load=function(){this.initContainer()},_._updateMapCurrentViewGLInfo=function(){var i=this.map;if(!i)return this;i._currentViewGLInfo=null;var g=i.getContainerExtent();if(!g)return this;var m=100,{xmin:_,ymin:b,xmax:T,ymax:P}=g,I=new un(_,b),H=new un(T,b),W=new un(T+m,P+m),q=new un(_-m,P+m),$=i._getResolution()/i.getGLRes(),ye=[I,H,W,q].map((function(g){return i._containerPointToPoint(g)._multi($)})),Re=ye[2],Be=ye[3];ye=ye.sort((function(i,g){return g.y-i.y}));var Ge,je,Xe,Ze,[Ye,Qe,Je,Ke]=ye;Ye.x<Qe.x?(Ge=Ye,Xe=Qe):(Ge=Qe,Xe=Ye),Je.x<Ke.x?(je=Je,Ze=Ke):(je=Ke,Ze=Je);var et=Bo();Go(ye,et);var[tt,at,ht,gt]=et,yt=new un((tt+ht)/2,(at+gt)/2);i._currentViewGLInfo={lt:Ge,rt:Xe,rb:Ze,lb:je,center:yt,RB:Re,LB:Be}},_.renderFrame=function(i){this._updateMapCurrentViewGLInfo();var g=this.map;if(!g||!g.options.renderable)return!1;if(this._handleResizeEventList(i),g.options.stopRenderOnOffscreen&&this._containerIsOffscreen())return!1;this._updateDomPosition(i),delete this._isViewChanged,g._fireEvent("framestart"),this.updateMapDOM(),g.clearCollisionIndex();var m=this._getAllLayerToRender();return this.drawLayers(m,i)&&this.drawTops(),g._fireEvent("frameend"),this._recordView(),this._mapview=this._getMapView(),delete this._spatialRefChanged,this._fireLayerLoadEvents(m),this.executeFrameCallbacks(),g.uiCollides(),!0},_.getFrameTimestamp=function(){return this._frameTimestamp||0},_.updateMapDOM=function(){var i=this.map;if(!i.isZooming()){var g=i.getViewPointFrameOffset();g?i.offsetPlatform(g):this.domChanged()&&this.offsetPlatform(null,!0)}},_.checkIfNeedToRedrawLayers=function(i){if(this.isSpatialReferenceChanged())return!0;for(var g=0,m=i.length;g<m;g++)if(this._checkLayerRedraw(i[g]))return!0;return!1},_.drawLayers=function(i,g){if(!this.checkIfNeedToRedrawLayers(i)&&!this.map.options.forceRedrawPerFrame)return!1;this.clearCanvas();for(var m=this.map,_=m.isInteracting(),b=i.length,T=0;T<b;T++){var P=i[T];if(P.isVisible()){var I=P.isCanvasRender(),H=P._getRenderer();H&&(I&&this.clearLayerCanvasContext(P),_&&I?this._drawCanvasLayerOnInteracting(P,0,0,g):_&&H.drawOnInteracting?(H.prepareRender&&H.prepareRender(),H.checkAndDraw?H.checkAndDraw(H.drawOnInteracting,this._eventParam,g):H.drawOnInteracting(this._eventParam,g)):H.render(g))}}return m._fireEvent("renderend",{context:this.context}),!0},_._checkLayerRedraw=function(i){if(this.isSpatialReferenceChanged())return!0;var g=this.map,m=i._getRenderer();return!!m&&(i.isCanvasRender()?m.testIfNeedRedraw():!(!m.needToRedraw||!m.needToRedraw())||(g.isInteracting()||this.isViewChanged()))},_._drawCanvasLayerOnInteracting=function(i,g,m,_){var b=i._getRenderer();if(b.mustRenderOnInteracting&&b.mustRenderOnInteracting())b.render(_);else if(b.drawOnInteracting){b.prepareRender();var T=b.prepareCanvas();return b.checkAndDraw?b.checkAndDraw(b.drawOnInteracting,this._eventParam,_):b.drawOnInteracting(this._eventParam,_),T}return null},_._fireLayerLoadEvents=function(i){for(var g=i.length-1;g>=0;g--){var m=i[g],_=m._getRenderer();_&&_.isRenderComplete()&&m.fire("layerload")}},_.updateMapSize=function(i){if(i&&!this._containerIsCanvas){var g=i.width+"px",m=i.height+"px",_=this.map.getPanels();_.mapWrapper.style.width=g,_.mapWrapper.style.height=m,this._updateCanvasSize()}},_.getMainPanel=function(){return this.map?this._containerIsCanvas?this.map.getContainer():this.map.getPanels()?this.map.getPanels().mapWrapper:null:null},_.toDataURL=function(i,g){return this.canvas?this.canvas.toDataURL(i,g):null},_.remove=function(){$t.webgl&&"undefined"!=typeof document&&(Ja.off(Ka,this._thisDocDPRChange,this),Ja.off(el,this._thisDocVisibilitychange,this),Ja.off(tl,this._thisDocDragStart,this),Ja.off(nl,this._thisDocDragEnd,this)),this._resizeInterval&&clearInterval(this._resizeInterval),this._resizeObserver&&this._resizeObserver.disconnect(),delete this.canvas,delete this.map,delete this._spatialRefChanged,this._cancelFrameLoop()},_.hitDetect=function(i){var g=this.map;if(g&&g.options.hitDetect&&!g.isInteracting()){var m=g._getLayers(),_="default",b=g.options.hitDetectLimit||0,T=0;i&&i._round&&i._round();for(var P=m.length-1;P>=0;P--){var I=m[P];if(!(!I.options.hitDetect||I.isEmpty&&I.isEmpty())&&I.options.geometryEvents){var H=I._getRenderer();if(H&&H.hitDetect&&(!H.isBlank||!H.isBlank())){if("default"!==I.options.cursor&&H.hitDetect(i)){_=I.options.cursor||"pointer";break}if(T++,b>0&&T>b)break}}}g._trySetCursor(_)}},_.initContainer=function(){var i=this.map.getPanels();function g(g,m,_,b){var T=Or("div",m);return _&&(T.style.cssText=_),i[g]=T,b||Br(T),T}var m=this.map.getContainer();if(this._containerIsCanvas)this.createCanvas();else{m.innerHTML="";var _="position:absolute;top:0px;left:0px;",b=g("mapWrapper","maptalks-wrapper","position:absolute;overflow:hidden;",!0),T=g("allLayers","maptalks-all-layers",_+"padding:0px;margin:0px;z-index:0;overflow:visible;",!0),P=g("backStatic","maptalks-back-static",_+"z-index:0;",!0),I=g("back","maptalks-back",_+"z-index:1;"),H=g("backLayer","maptalks-back-layer",_),W=g("canvasContainer","maptalks-canvas-layer",_+"border:none;z-index:2;"),q=g("frontStatic","maptalks-front-static",_+"z-index:3;",!0),$=g("front","maptalks-front",_+"z-index:4;",!0),ye=g("frontLayer","maptalks-front-layer",_+"z-index:0;"),Re=g("ui","maptalks-ui",_+"border:none;z-index:1;",!0),Be=g("control","maptalks-control","z-index:1",!0);m.appendChild(b),T.appendChild(P),I.appendChild(H),I.layerDOM=H,T.appendChild(I),T.appendChild(W),$.appendChild(ye),$.layerDOM=ye,$.uiDOM=Re,T.appendChild(q),T.appendChild($),$.appendChild(Re),b.appendChild(T),b.appendChild(Be),this.createCanvas(),this.resetContainer();var Ge=this.map._getContainerDomSize();this.updateMapSize(Ge)}},_.isViewChanged=function(){if(void 0!==this._isViewChanged)return this._isViewChanged;var i=this._mapview,g=this._getMapView();return this._isViewChanged=!i||!Un(i,g),this._isViewChanged},_._recordView=function(){var i=this.map;!i._onViewChange||i.isInteracting()||i.isAnimating()||Un(i.getView(),i._getCurrentView())||i._onViewChange(i.getView())},_.isSpatialReferenceChanged=function(){return this._spatialRefChanged},_._getMapView=function(){var i=this.map,g=i._getPrjCenter();return{x:g.x,y:g.y,zoom:i.getZoom(),pitch:i.getPitch(),bearing:i.getBearing(),width:i.width,height:i.height}},_._lockFrameRenderEnable=function(){var{maxFPS:i}=this.map.options||{};if(i<=0||T.maxFPS<=i)return!0;var g=Math.ceil(T.maxFPS/i);return this._frameCycleRenderCount>=g},_.onLoad=function(){this._frameLoop(0)},_._frameLoop=function(i){this.map?(this._bindFrameLoop||(this._bindFrameLoop=this._frameLoop.bind(this)),this.ready?(this._frameCycleRenderCount++,this._lockFrameRenderEnable()?(this._frameTimestamp=i=i||0,this._resizeCount=0,this.renderFrame(i),this._frameCycleRenderCount=0):this.map.options.debug&&console.log("skip framing, frameCycleRenderCount:",this._frameCycleRenderCount),this._animationFrame=ln(this._bindFrameLoop)):this._animationFrame=ln(this._bindFrameLoop)):this._cancelFrameLoop()},_._cancelFrameLoop=function(){delete this._bindFrameLoop,this._animationFrame&&hn(this._animationFrame)},_._updateCanvasSize=function(){if(this.canvas&&!this._containerIsCanvas){var i=this.map,g=i.getSize(),m=this.canvas,_=i.getDevicePixelRatio(),{width:b,height:T,cssWidth:P,cssHeight:I}=Yn(g,_);!m.style||m.style.width===P&&m.style.height===I||(m.style.width=P,m.style.height=I),b===m.width&&T===m.height||(m.width=b,m.height=T);var H=this.topLayer;!H||b===H.width&&T===H.height||(H.width=b,H.height=T,H.style.width=P,H.style.height=I)}},_.createCanvas=function(){var i=this;this._containerIsCanvas?this.canvas=this.map.getContainer():(this.canvas=Or("canvas"),this.map.getPanels().canvasContainer.appendChild(this.canvas),this._updateCanvasSize());this.createContext().then((function(){i.ready=!0}))},_.createContext=function(){return Cm(this,0,void 0,rn().mark((function i(){return rn().wrap((function(i){for(;;)switch(i.prev=i.next){case 0:case"end":return i.stop()}}),i)})))},_.clearLayerCanvasContext=function(i){},_.clearCanvas=function(){},_.createTopCanvas=function(){this.topLayer=Or("canvas"),this.map.getPanels().canvasContainer.insertBefore(this.topLayer,this.canvas),this.topCtx=this.topLayer.getContext("2d")},_.removeTopCanvas=function(){Rr(this.topLayer),delete this.topLayer,delete this.topCtx},_._updateDomPosition=function(i){return void 0===this._checkPositionTime&&(this._checkPositionTime=0),Math.abs(i-this._checkPositionTime)>=500&&(Vr(this.map.getContainer()),this._checkPositionTime=i),this},_._handleResizeEventList=function(i){if(!this._resizeEventList)return this;var g=this._resizeEventList.length;return 0===g||this._resizeTime&&i-this._resizeTime<60||(this.map.setContainerDomRect(this._resizeEventList[g-1].contentRect),this._resizeEventList=[],this._checkSize(),this._resizeCount=this._resizeCount||0,this.renderFrame((this._frameTimestamp||0)+ ++this._resizeCount/100),this._resizeTime=i),this},_._checkSize=function(){this.map&&this.map.checkSize()},_._setCheckSizeInterval=function(i){var g=this;$t.resizeObserver?(this._resizeObserver&&this._resizeObserver.disconnect(),this.map&&(this._resizeObserver=new ResizeObserver((function(i){!g.map||g.map.isRemoved()?g._resizeObserver.disconnect():i.length&&(g._resizeEventList=g._resizeEventList||[],g._resizeEventList.push(i[0]))})),this._resizeObserver.observe(this.map.getContainer()))):(clearInterval(this._resizeInterval),this._checkSizeInterval=i,this._resizeInterval=setInterval((function(){!g.map||g.map.isRemoved()?clearInterval(g._resizeInterval):g._checkSize()}),this._checkSizeInterval))},_._registerEvents=function(){var i=this,g=this.map;g.options.checkSize&&!m&&"undefined"!=typeof window&&this._setCheckSizeInterval(g.options.checkSizeInterval),$t.mobile||g.on("_mousemove",this._onMapMouseMove,this),g.on("_dragrotatestart _dragrotating _dragrotateend _movestart _moving _moveend _zoomstart",(function(g){i._eventParam=g})),g.on("_zooming",(function(m){g.getPitch()||(i._zoomMatrix=m.matrix.container),i._eventParam=m})),g.on("_zoomend",(function(g){i._eventParam=g,delete i._zoomMatrix})),g.on("_spatialreferencechange",(function(){i._spatialRefChanged=!0})),$t.webgl&&"undefined"!=typeof document&&(Ja.on(Ka,this._thisDocDPRChange,this),Ja.on(el,this._thisDocVisibilitychange,this),Ja.on(tl,this._thisDocDragStart,this),Ja.on(nl,this._thisDocDragEnd,this))},_._onMapMouseMove=function(i){var g=this,m=this.map;!m.isInteracting()&&m.options.hitDetect&&(this._hitDetectFrame&&hn(this._hitDetectFrame),this._hitDetectFrame=ln((function(){g.hitDetect(i.containerPoint)})))},_._getCanvasLayers=function(){return this.map._getLayers((function(i){return i.isCanvasRender()}))},_.addTopElement=function(i){this._tops||(this._tops=[]),this._tops.push(i)},_.removeTopElement=function(i){if(this._tops){var g=this._tops.indexOf(i);g>=0&&this._tops.splice(g,1)}},_.getTopElements=function(){return this._tops||[]},_.sortTopElements=function(){this._tops=this._tops.sort((function(i,g){return((g.options||{}).zIndex||0)-((i.options||{}).zIndex||0)}))},_.drawTops=function(){this.getTopElements().length?(this.topCtx||this.createTopCanvas(),this.drawTopElements()):this.topCtx&&this.removeTopCanvas()},_.drawTopElements=function(){var i=this.getTopElements();this.topCtx.clearRect(0,0,this.topLayer.width,this.topLayer.height);var g=Pm;g.clear(),this.map.fire("drawtopstart"),this.map.fire("drawtops");for(var m=!1,_=this.map.getDevicePixelRatio(),b=[],T=0;T<i.length;T++){var P=i[T];if(P.needCollision&&P.needCollision()){var I=P.getRenderBBOX(_);if(I){if(g.collides(I)){var H=P.target&&P.target._geometry;H&&-1===b.indexOf(H)&&(b.push(H),H.fire("handlecollision"));continue}g.insertBox(I)}}P.render(this.topCtx)&&(m=!0)}m&&this.context&&this.context.drawImage&&this.context.drawImage(this.topLayer,0,0),this.map.fire("drawtopsend")},_.isWebGL=function(){return!1},_.isWebGPU=function(){return!1},g}(Mm),km=function(i){function g(){return i.apply(this,arguments)||this}tn(g,i);var m=g.prototype;return m.renderFrame=function(i){this._updateMapCurrentViewGLInfo();var g=this.map;if(!g||!g.options.renderable)return!1;if(this._handleResizeEventList(i),g.options.stopRenderOnOffscreen&&this._containerIsOffscreen())return!0;this._updateDomPosition(i),delete this._isViewChanged,g._fireEvent("framestart"),this.updateMapDOM(),g.clearCollisionIndex();var m=this._getAllLayerToRender();return this.drawLayers(m,i),this.drawLayerCanvas(m)&&(this.drawTops(),this._drawCenterCross(),g.options.debugSky&&this._debugSky()),this._needClear=!1,g._fireEvent("frameend"),this._recordView(),this._mapview=this._getMapView(),delete this._spatialRefChanged,this._fireLayerLoadEvents(),this.executeFrameCallbacks(),this._canvasUpdated=!1,g.uiCollides(),!0},m._needRedrawAllLayers=function(i){var g=this;if(this.isSpatialReferenceChanged())return!0;var m=[];i.forEach((function(i){if(i&&(i._toRedraw=g._checkLayerRedraw(i))){m.push(i);var _=i.getLayers&&i.getLayers();_&&Array.isArray(_)&&yn(m,_)}}));for(var _=0,b=m.length;_<b;_++){var T=m[_],P=T&&T.options;if(P&&P.collision&&"map"===P.collisionScope)return!0}return!1},m.drawLayers=function(i,g){for(var m=this._needRedrawAllLayers(i),_=this.map,b=_.isInteracting(),T=[],P=[],I=_.options.fpsOnInteracting||0,H=0===I?0:1e3/I,W=this.map.options.layerCanvasLimitOnInteracting,q=i.length,$=_.getBaseLayer(),ye=0,Re=0;Re<q;Re++){var Be=i[Re];if(Be.isVisible()){var Ge=Be.isCanvasRender();Ge&&T.push(Be.getId());var je=Be._getRenderer();if(je){var Xe=m||Be._toRedraw;Ge&&je.isCanvasUpdated()&&(Xe||P.push(Be.getId()),this.setLayerCanvasUpdated());var Ze=je.__zoomTransformMatrix;if(delete je.__zoomTransformMatrix,Xe){if(b&&Ge){if(W>0&&q-1-Re>W&&Be!==$){Be._getRenderer().clearCanvas();continue}ye+=this._drawCanvasLayerOnInteracting(Be,ye,H,g)}else b&&je.drawOnInteracting?(je.prepareRender&&je.prepareRender(),je.checkAndDraw?je.checkAndDraw(je.drawOnInteracting,this._eventParam,g):je.drawOnInteracting(this._eventParam,g)):(je.render(g),Ge&&Ze&&je.isLoadingResource()&&(je.__zoomTransformMatrix=Ze));Ge&&(P.push(Be.getId()),this.setLayerCanvasUpdated())}else Ge&&b&&(_.isZooming()&&!_.getPitch()?(je.prepareRender(),je.__zoomTransformMatrix=this._zoomMatrix):(_.getPitch()||_.isRotating())&&je.clearCanvas())}}}var Ye=this._canvasIds||[],Qe=this._updatedIds||[];if(this._canvasIds=T,this._updatedIds=P,!this.isLayerCanvasUpdated()){var Je="---";Ye.join(Je)===T.join(Je)&&Qe.join(Je)===P.join(Je)||this.setLayerCanvasUpdated()}return!0},m._drawCanvasLayerOnInteracting=function(i,g,m,_){var b=this.map,T=i._getRenderer(),P=T.getDrawTime(),I=0===m||m>0&&g+P<=m;if(T.mustRenderOnInteracting&&T.mustRenderOnInteracting())T.render(_);else{if(T.drawOnInteracting&&(i===b.getBaseLayer()||I||b.isZooming()&&i.options.forceRenderOnZooming||b.isMoving()&&i.options.forceRenderOnMoving||b.isRotating()&&i.options.forceRenderOnRotating))return T.prepareRender(),T.prepareCanvas(),T.checkAndDraw?T.checkAndDraw(T.drawOnInteracting,this._eventParam,_):T.drawOnInteracting(this._eventParam,_),P;!b.isZooming()||b.getPitch()||b.isRotating()?(b.getPitch()||b.isRotating())&&T.clearCanvas():(T.prepareRender(),T.__zoomTransformMatrix=this._zoomMatrix)}return T.drawOnInteracting&&!I&&T.onSkipDrawOnInteracting(this._eventParam,_),0},m._fireLayerLoadEvents=function(){if(this._updatedIds&&this._updatedIds.length>0){var i=this.map;this._updatedIds.reverse().forEach((function(g){var m=i.getLayer(g);if(m){var _=m._getRenderer();_&&_.isRenderComplete()&&m.fire("layerload")}}))}},m.isLayerCanvasUpdated=function(){return this._canvasUpdated},m.setLayerCanvasUpdated=function(){this._canvasUpdated=!0},m.drawLayerCanvas=function(i){var g=this.map;if(!g)return!1;if(!this.isLayerCanvasUpdated()&&!this.isViewChanged()&&!1===this._needClear)return!1;this.canvas||this.createCanvas(),g._fireEvent("renderstart",{context:this.context}),this._updateCanvasSize()||this.clearCanvas();for(var m,_=g.isInteracting(),b=g.options.layerCanvasLimitOnInteracting,T=i.length,P=[],I=0;I<T;I++){if(i[I].isVisible()&&i[I].isCanvasRender())if(i[I]._getRenderer()){var H=this._getLayerImage(i[I]);H&&H.image&&(i[I]===g.getBaseLayer()?m=[i[I],H]:P.push([i[I],H]))}}var W=this.canvas.width,q=this.canvas.height;m&&(this._drawLayerCanvasImage(m[0],m[1],W,q),this._drawFog()),T=P.length;for(var $=_&&b>=0&&T>b?T-b:0;$<T;$++)this._drawLayerCanvasImage(P[$][0],P[$][1],W,q);return g._fireEvent("renderend",{context:this.context}),!0},m.setToRedraw=function(){var i=this._getAllLayerToRender();this._needClear=!0;for(var g=0,m=i.length;g<m;g++){var _=i[g].getRenderer();_&&_.canvas&&_.setToRedraw&&_.setToRedraw()}},m.remove=function(){delete this.context,i.prototype.remove.call(this)},m.hitDetect=function(i){var g=this.map;if(g&&g.options.hitDetect&&!g.isInteracting()){var m=g._getLayers(),_="default",b=g.options.hitDetectLimit||0,T=0;i&&i._round&&i._round();for(var P=m.length-1;P>=0;P--){var I=m[P];if(!(!I.options.hitDetect||I.isEmpty&&I.isEmpty())&&I.options.geometryEvents){var H=I._getRenderer();if(H&&H.hitDetect&&(!H.isBlank||!H.isBlank())){if("default"!==I.options.cursor&&H.hitDetect(i)){_=I.options.cursor||"pointer";break}if(T++,b>0&&T>b)break}}}g._trySetCursor(_)}},m._getLayerImage=function(i){var g=i._getRenderer();return g.getCanvasImage?g.getCanvasImage():null},m._drawLayerCanvasImage=function(i,g,m,_){var b=this.context,T=g.point.round(),P=this.map.getDevicePixelRatio();1!==P&&T._multi(P);var I=g.image,H=I.width,q=I.height;if(!(T.x+H<=0||T.y+q<=0)){var $=i.options.opacity;if(W($)||($=1),!($<=0)){var ye=g.opacity;if(W(ye)||(ye=1),!(ye<=0)){var Re=b.globalAlpha;"canvas"===i.options.renderer&&($<1&&(b.globalAlpha*=$),ye<1&&(b.globalAlpha*=ye)),i.options.cssFilter&&(b.filter=i.options.cssFilter);var Be=i.getRenderer(),Ge=Be.__zoomTransformMatrix,je=Be.clipCanvas(this.context);Ge&&(b.save(),b.setTransform(...Ge)),b.drawImage(I,0,0,H,q,T.x,T.y,m,_),Ge&&b.restore(),je&&b.restore(),"none"!==b.filter&&(b.filter="none"),b.globalAlpha=Re}}}},m._drawCenterCross=function(){var i=this.map.options.centerCross;if(i){var g=this.context,m=new un(this.canvas.width/2,this.canvas.height/2);Re(i)?i(g,m):Va.drawCross(this.context,m.x,m.y,2,"#f00")}},m._drawContainerExtent=function(){var{cascadePitches:i}=this.map.options,g=this.map.height-this.map._getVisualHeight(i[0]),m=this.map.height-this.map._getVisualHeight(i[1]),_=this.map.getContainerExtent(),b=this.context;b.beginPath(),b.moveTo(0,_.ymin),b.lineTo(_.xmax,_.ymin),b.stroke(),b.beginPath(),b.moveTo(0,g),b.lineTo(_.xmax,g),b.stroke(),b.beginPath(),b.moveTo(0,m),b.lineTo(_.xmax,m),b.stroke()},m._drawFog=function(){var i=this.map;if(!(i.getPitch()<=i.options.maxVisualPitch)&&i.options.fog){var g=i.getDevicePixelRatio(),m=this.context,_=i.getContainerExtent(),b=(i.height-i._getVisualHeight(75))*g;b<0&&(b=0);var T=_.ymin*g,P=Math.ceil(T-b),I=i.options.fogColor.join(),H=m.createLinearGradient(0,b,0,T+30),W=1-30/(P+30);H.addColorStop(0,"rgba("+I+", 0)"),H.addColorStop(.3,"rgba("+I+", 0.3)"),H.addColorStop(W,"rgba("+I+", 1)"),H.addColorStop(1,"rgba("+I+", 0)"),m.beginPath(),m.fillStyle=H,m.fillRect(0,b,Math.ceil(_.getWidth())*g,Math.ceil(P+30))}},m._debugSky=function(){var i=this.map;if(!i)return this;var g=i.getContainerExtent().ymin;if(g<=0)return this;var m=this.context;return m.strokeStyle="red",m.strokeRect(0,0,i.width,g),this},m.clearCanvas=function(){this.canvas&&Va.clearRect(this.context,0,0,this.canvas.width,this.canvas.height)},m._updateCanvasSize=function(){if(!this.canvas||this._containerIsCanvas)return!1;var i=this.map,g=i.getSize(),m=this.canvas,_=i.getDevicePixelRatio(),{width:b,height:T,cssWidth:P,cssHeight:I}=Yn(g,_);return!m.style||m.style.width===P&&m.style.height===I||(m.style.width=P,m.style.height=I),(b!==m.width||T!==m.height)&&(m.height=T,m.width=b,this.topLayer.width=m.width,this.topLayer.height=m.height,!0)},m.createCanvas=function(){this.topLayer=Or("canvas"),this.topCtx=this.topLayer.getContext("2d"),this._containerIsCanvas?this.canvas=this.map.getContainer():(this.canvas=Or("canvas"),this._updateCanvasSize(),this.map.getPanels().canvasContainer.appendChild(this.canvas)),this.context=this.canvas.getContext("2d"),this.ready=!0},m.drawTops=function(){i.prototype.drawTopElements.call(this)},g}(Im);Uu.registerRenderer("canvas",km),Uu.mergeOptions({fog:!1,fogColor:[233,233,233]});var Om=Object.freeze({__proto__:null,CanvasLayerRenderer:Cg,CanvasRenderer:gg,CanvasTileLayerCanvasRenderer:um,CanvasTileLayerGLRenderer:fm,ImageGLRenderable:fg,ImageLayerCanvasRenderer:bg,ImageLayerGLRenderer:wg,ImageLayerRenderable:xg,LayerAbstractRenderer:Lu,MapAbstractRenderer:Im,MapCanvasRenderer:km,MapRenderer:Mm,OverlayLayerCanvasRenderer:Am,OverlayLayerGLRenderer:ym,QuadStencil:pm,Renderable:bh,ResourceCache:Jo,TileLayerCanvasRenderer:sm,TileLayerGLRenderer:hm,TileLayerRendererable:tm,VectorLayerCanvasRenderer:Sm}),Em={_getRenderPoints:function(){return[[this._getCenter2DPoint(this.getMap().getGLRes())],null]}};yf.include(Em),Nf.include(Em),Df.include(Em),Bf.include(Em),Hf.include({_getRenderPoints:function(i){var g=this.getMap(),m=g.getGLRes();if("vertex"===i){for(var _=this._trimRing(this.getShell()),b=[],T=0,P=_.length;T<P;T++)b.push(g.coordToPointAtRes(_[T],m));return[b,null]}return[[g.coordToPointAtRes(this.getCenter(),m)],null]}});var Rm={_getRenderPoints:function(i){var g,m=this.getMap(),_=m.getGLRes(),b=null;if("point"===i)(g=this._getPath2DPoints(this._getPrjCoordinates(),!1,_))&&g.length>0&&Array.isArray(g[0])&&(g=g[0].concat(g[1]));else if("vertex"===i)if(b=[],(g=this._getPath2DPoints(this._getPrjCoordinates(),!1,_))&&g.length>0&&Array.isArray(g[0])){for(var T=0,P=g.length;T<P;T++)for(var I=0,H=g[T].length;I<H;I++)b.push(0===I?[g[T][I],g[T][I+1]]:[g[T][I-1],g[T][I]]);g=g[0].concat(g[1])}else for(var W=0,q=g.length;W<q;W++)b.push(0===W?[g[W],g[W+1]]:[g[W-1],g[W]]);else if("line"===i){g=[],b=[];var $=this._getPath2DPoints(this._getPrjCoordinates(),!1,_);if($.length>0&&Array.isArray($[0]))for(var ye,Re=1,Be=$.length;Re<Be;Re++){ye=$[Re],this instanceof gf&&ye.length>0&&!ye[0].equals(ye[ye.length-1])&&ye.push(ye[0]);for(var Ge=1,je=ye.length;Ge<je;Ge++)g.push(ye[Ge].add(ye[Ge-1])._multi(.5)),b.push([ye[Ge-1],ye[Ge]])}else{this instanceof gf&&$.length>0&&!$[0].equals($[$.length-1])&&$.push($[0]);for(var Xe=1,Ze=$.length;Xe<Ze;Xe++)g.push($[Xe].add($[Xe-1])._multi(.5)),b.push([$[Xe-1],$[Xe]])}}else if("vertex-first"===i){var Ye=this._getPrjCoordinates(),Qe=Ye.length,Je=Qe?m._prjToPointAtRes(Ye[0],_):null;g=Qe?[Je]:[],b=Qe?[[Je,Ye[1]?m._prjToPointAtRes(Ye[1],_):Je]]:[]}else if("vertex-last"===i){var Ke=this._getPrjCoordinates(),et=Ke.length,tt=et?m._prjToPointAtRes(Ke[et-1],_):null;g=et?[tt]:[];var at=et>1?et-2:et-1;b=et?[[Ke[at]?m._prjToPointAtRes(Ke[at],_):tt,tt]]:[]}else if("vertex-firstlast"===i){g=[],b=[];var ht=this._getPrjCoordinates(),gt=ht.length;if(gt){var yt=m._prjToPointAtRes(ht[0],_);if(g=[yt],gt>1){b=[[yt,m._prjToPointAtRes(ht[1],_)]];var vt=m._prjToPointAtRes(ht[gt-1],_);g.push(vt),b.push([m._prjToPointAtRes(ht[gt>1?gt-2:gt-1],_),vt])}}}else{var xt=this.getCenter();if(xt){var bt=this._getProjection().project(xt);g=[m._prjToPointAtRes(bt,_)]}else g=[]}return[g,b]}};vf.include(Rm),gf.include(Rm);var Lm={within:!1,center:[0,0]};function Dm(i){if(i&&i._containerBbox){Lm.within=!1;var{minx:g,miny:m,maxx:_,maxy:b}=i._containerBbox,T=Math.abs(_-g),P=Math.abs(b-m);T<=1&&P<=1&&(Lm.within=!0,Lm.center[0]=(g+_)/2,Lm.center[1]=(m+b)/2),delete i._containerBbox}else Lm.within=!1;return Lm}function Fm(){var i=this._getPrjShell(),g=Bo();Go(i,g);var[m,_,b,T]=g;return new Pl(m,_,b,T)}function Nm(){var i=this._getPrjShell();if(!i||!Array.isArray(i))return[];var g=this._getProjection(),m=this.getCoordinates()||{};return i.map((function(i){var _=g.unproject(i);return _.z=m.z||0,_}))}gu.include({_redrawWhenPitch:function(){return!1},_redrawWhenRotate:function(){return!1},_getRenderBBOX:function(i,g){return i.isHitTesting?null:(Uo(zo),Go(g,zo),zo)}});var Hm={_redrawWhenPitch:function(){return!0},_redrawWhenRotate:function(){return this instanceof Nf||this instanceof Bf},_computeRotatedPrjExtent:Fm,getRotatedShell:Nm,_paintAsPath:function(){if(this.isRotated())return!0;var i=this.getMap();return this._getAltitude()>0||i.getPitch()||this instanceof Nf&&i.getBearing()},_getPaintParams:function(){var i=this.getMap();if(this._paintAsPath())return gf.prototype._getPaintParams.call(this,!0);var g=this._getPrjCoordinates(),m=i._prjToPointAtRes(g,i.getGLRes());return[m,...this._getRenderSize(m)]},_paintOn:function(...i){return this._paintAsPath()?Va.polygon(...i):Va.ellipse(...i)},_getRenderSize:function(i){var g=this.getMap(),m=g.getGLRes(),_=this._getPrjExtent(),b=g._prjToPointAtRes(_.getMin(),m),T=g._prjToPointAtRes(_.getMax(),m);return[Math.abs(T.x-b.x)/2,Math.abs(T.y-i.y),Math.abs(i.y-b.y)]}};Nf.include(Hm),Df.include(Hm),Hf.include({_getPaintParams:function(){var i=this.getMap(),g=this._getPrjShell();return[this._getPath2DPoints(g,!1,i.getGLRes())]},_paintOn:Va.polygon,_computeRotatedPrjExtent:Fm,getRotatedShell:Nm});var Bm={_redrawWhenPitch:function(){return!0},_getPaintParams:function(){if(this._paintAsPath())return gf.prototype._getPaintParams.call(this,!0);var i=this.getMap(),g=i._prjToPointAtRes(this._getPrjCoordinates(),i.getGLRes()),m=this._getRenderSize(g),[_,b]=this._correctAngles();return[g,m[0],[_,b]]},_paintOn:function(...i){if(this._paintAsPath())return Va.polygon(...i);var g=this.getMap().getBearing();return g&&(i[3]=i[3].slice(0),i[3][0]+=g,i[3][1]+=g),Va.sector(...i)}};Bf.include(Hm,Bm),df.include({_paintAsPath:function(){return!0}});var zm={arrowStyles:{classic:[3,4]},_getArrowShape:function(i,g,m,_,b){if(!i||!g||i.equals(g))return null;b||(b=0);var T,P=m*_[1]+b,I=m*_[0]/2+b;(T=g.sub(g.nextCtrlPoint||g.prevCtrlPoint?new un(g.prevCtrlPoint?g.prevCtrlPoint:g.nextCtrlPoint):i))._unit();var H=g.sub(T.multi(P));T._perp();var W=H.add(T.multi(I));return T._multi(-1),[W,g,H.add(T.multi(I)),W]},_getPaintParams:function(){var i=this._getPrjCoordinates();return[this._getPath2DPoints(i,!1,this.getMap().getGLRes())]},_paintOn:function(i,g,m,_,b,T){var P=Dm(this._painter);return P.within?Va.pixelRect(i,P.center,m,_):this.options.smoothness?Va.paintSmoothLine(i,g,m,this.options.smoothness,!1,this._animIdx,this._animTailRatio):(i.lineColorIn=T,Va.path(i,g,m,null,b)),this._paintArrow(i,g,m),this._getRenderBBOX(i,g)},_getArrowPlacement:function(){return this.options.arrowPlacement},_getArrowStyle:function(){var i=this.options.arrowStyle;return i?Array.isArray(i)?i:this.arrowStyles[i]:null},_getArrows:function(i,g,m){var _=this,b=this._getArrowStyle();if(!b||i.length<2)return[];for(var T,P,I=i.length>0&&Array.isArray(i[0])?i:[i],H=this._getArrowPlacement(),W=[],q=function(){if(T&&P){var i=_._getArrowShape(T,P,g,b,m);i&&W.push(i)}},$=I.length-1;$>=0;$--){var ye=I[$],Re=ye.length,Be=ye[0],Ge=ye[Re-1];"vertex-first"===H?(T=Be.arrowNextPoint||ye[1],P=Be):"vertex-last"===H&&(T=Ge.arrowPrePoint||ye[Re-2],P=Ge),q(),"vertex-firstlast"===H&&(T=Be.arrowNextPoint||ye[1],P=Be,q(),T=Ge.arrowPrePoint||ye[Re-2],P=Ge,q()),"point"===H&&this._getArrowPoints(W,ye,g,b,m)}return W},_getArrowPoints:function(i,g,m,_,b){for(var T=0,P=g.length-1;T<P;T++){var I=g[T+1],H=this._getArrowShape(I.arrowPrePoint||g[T],I,m,_,b);H&&i.push(H)}},_paintArrow:function(i,g,m){var _=this._getInternalSymbol().lineWidth;(!W(_)||_<3)&&(_=3);var b=this._getArrows(g,_);if(b.length){i.setLineDash&&i.setLineDash([]);for(var T=b.length-1;T>=0;T--)i.fillStyle=i.strokeStyle,Va.polygon(i,b[T],m,m)}}};vf.include(zm);var Vm={_getPaintParams:function(i){var g=this.getMap().getGLRes(),m=this._getPrjShell(),_=this._getPath2DPoints(m,i,g),b=_.length>0&&Array.isArray(_[0]);b&&(_=[[_[0]],[_[1]]]);var T=this._getPrjHoles(),P=[];if(T&&T.length>0){for(var I=this._simplified,H=0;H<T.length;H++){var W=this._getPath2DPoints(T[H],i,g);Array.isArray(W)&&b?Array.isArray(W[0])?(_[0].push(W[0]),_[1].push(W[1])):_[0].push(W):P.push(W)}I&&(this._simplified=I)}return b||yn(_=[_],P),[_]},_paintOn:function(i,g,m,_,b,T){var P=Dm(this._painter);return P.within?Va.pixelRect(i,P.center,m,_):(i.lineColorIn=T,Va.polygon(i,g,m,_,b,this.options.smoothness)),this._getRenderBBOX(i,g)}};gf.include(Vm),Uu.VERSION=g;var Um={Actor:Mu};b(g);"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function Gm(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var jm={exports:{}};!function(i){i.exports=function(){function i(i,g){this.id=Xt++,this.type=i,this.data=g}function g(i){if(0===i.length)return[];var m=i.charAt(0),_=i.charAt(i.length-1);if(1<i.length&&m===_&&('"'===m||"'"===m))return['"'+i.substr(1,i.length-2).replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'];if(m=/\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(i))return g(i.substr(0,m.index)).concat(g(m[1])).concat(g(i.substr(m.index+m[0].length)));if(1===(m=i.split(".")).length)return['"'+i.replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'];for(i=[],_=0;_<m.length;++_)i=i.concat(g(m[_]));return i}function m(i){return"["+g(i).join("][")+"]"}function _(g,m){return"function"==typeof g?new i(0,g):"number"==typeof g||"boolean"==typeof g?new i(5,g):Array.isArray(g)?new i(6,g.map((function(i,g){return _(i)}))):g instanceof i?g:void 0}function b(){var i={"":0},g=[""];return{id:function(m){var _=i[m];return _||(_=i[m]=g.length,g.push(m),_)},str:function(i){return g[i]}}}function T(i,g,m){function _(){var g=window.innerWidth,_=window.innerHeight;i!==document.body&&(g=(_=i.getBoundingClientRect()).right-_.left,_=_.bottom-_.top),T.width=m*g,T.height=m*_,qt(T.style,{width:g+"px",height:_+"px"})}var b,T=document.createElement("canvas");return qt(T.style,{border:0,margin:0,padding:0,top:0,left:0}),i.appendChild(T),i===document.body&&(T.style.position="absolute",qt(i.style,{margin:0,padding:0})),i!==document.body&&"function"==typeof ResizeObserver?(b=new ResizeObserver((function(){setTimeout(_)}))).observe(i):window.addEventListener("resize",_,!1),_(),{canvas:T,onDestroy:function(){b?b.disconnect():window.removeEventListener("resize",_),i.removeChild(T)}}}function P(i,g){function m(m){try{return i.getContext(m,g)}catch(i){return null}}return m("webgl")||m("experimental-webgl")||m("webgl-experimental")}function I(i){return"string"==typeof i?i.split():i}function H(i){return"string"==typeof i?document.querySelector(i):i}function W(i){var g,m,_,b,W=i||{};i={};var q=[],$=[],ye="undefined"==typeof window?1:window.devicePixelRatio,Re=!1,Be=function(i){},Ge=function(){};if("string"==typeof W?g=document.querySelector(W):"object"==typeof W&&("string"==typeof W.nodeName&&"function"==typeof W.appendChild&&"function"==typeof W.getBoundingClientRect?g=W:"function"==typeof W.drawArrays||"function"==typeof W.drawElements?_=(b=W).canvas:("gl"in W?b=W.gl:"canvas"in W?_=H(W.canvas):"container"in W&&(m=H(W.container)),"attributes"in W&&(i=W.attributes),"extensions"in W&&(q=I(W.extensions)),"optionalExtensions"in W&&($=I(W.optionalExtensions)),"onDone"in W&&(Be=W.onDone),"profile"in W&&(Re=!!W.profile),"pixelRatio"in W&&(ye=+W.pixelRatio))),g&&("canvas"===g.nodeName.toLowerCase()?_=g:m=g),!b){if(!_){if(!(g=T(m||document.body,Be,ye)))return null;_=g.canvas,Ge=g.onDestroy}void 0===i.premultipliedAlpha&&(i.premultipliedAlpha=!0),b=P(_,i)}return b?{gl:b,canvas:_,container:m,extensions:q,optionalExtensions:$,pixelRatio:ye,profile:Re,onDone:Be,onDestroy:Ge}:(Ge(),Be("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"),null)}function q(i,g){function m(g){var m;g=g.toLowerCase();try{m=_[g]=i.getExtension(g)}catch(i){}return!!m}for(var _={},b=0;b<g.extensions.length;++b){var T=g.extensions[b];if(!m(T))return g.onDestroy(),g.onDone('"'+T+'" extension is not supported by the current WebGL context, try upgrading your system or a different browser'),null}return g.optionalExtensions.forEach(m),{extensions:_,restore:function(){Object.keys(_).forEach((function(i){if(_[i]&&!m(i))throw Error("(regl): error restoring extension "+i)}))}}}function $(i,g){for(var m=Array(i),_=0;_<i;++_)m[_]=g(_);return m}function ye(i){var g,m;return g=(65535<i)<<4,g|=m=(255<(i>>>=g))<<3,(g|=m=(15<(i>>>=m))<<2)|(m=(3<(i>>>=m))<<1)|i>>>m>>1}function Re(){function i(i){e:{for(var g=16;268435456>=g;g*=16)if(i<=g){i=g;break e}i=0}return 0<(g=m[ye(i)>>2]).length?g.pop():new ArrayBuffer(i)}function g(i){m[ye(i.byteLength)>>2].push(i)}var m=$(8,(function(){return[]}));return{alloc:i,free:g,allocType:function(g,m){var _=null;switch(g){case 5120:_=new Int8Array(i(m),0,m);break;case 5121:_=new Uint8Array(i(m),0,m);break;case 5122:_=new Int16Array(i(2*m),0,m);break;case 5123:_=new Uint16Array(i(2*m),0,m);break;case 5124:_=new Int32Array(i(4*m),0,m);break;case 5125:_=new Uint32Array(i(4*m),0,m);break;case 5126:_=new Float32Array(i(4*m),0,m);break;default:return null}return _.length!==m?_.subarray(0,m):_},freeType:function(i){g(i.buffer)}}}function Be(i){return!!i&&"object"==typeof i&&Array.isArray(i.shape)&&Array.isArray(i.stride)&&"number"==typeof i.offset&&i.shape.length===i.stride.length&&(Array.isArray(i.data)||Kt(i.data))}function Ge(i,g,m,_,b,T){for(var P=0;P<g;++P)for(var I=i[P],H=0;H<m;++H)for(var W=I[H],q=0;q<_;++q)b[T++]=W[q]}function je(i,g,m,_,b){for(var T=1,P=m+1;P<g.length;++P)T*=g[P];var I=g[m];if(4===g.length-m){var H=g[m+1],W=g[m+2];for(g=g[m+3],P=0;P<I;++P)Ge(i[P],H,W,g,_,b),b+=T}else for(P=0;P<I;++P)je(i[P],g,m+1,_,b),b+=T}function Xe(i){return 0|nn[Object.prototype.toString.call(i)]}function Ze(i,g){for(var m=0;m<g.length;++m)i[m]=g[m]}function Ye(i,g,m,_,b,T,P){for(var I=0,H=0;H<m;++H)for(var W=0;W<_;++W)i[I++]=g[b*H+T*W+P]}function Qe(i,g,m,_){function b(g){this.id=H++,this.buffer=i.createBuffer(),this.type=g,this.usage=35044,this.byteLength=0,this.dimension=1,this.dtype=5121,this.persistentData=null,m.profile&&(this.stats={size:0})}function T(g,m,_){g.byteLength=m.byteLength,i.bufferData(g.type,m,_)}function P(i,g,m,_,b,P){if(i.usage=m,Array.isArray(g)){if(i.dtype=_||5126,0<g.length)if(Array.isArray(g[0])){b=an(g);for(var I=_=1;I<b.length;++I)_*=b[I];i.dimension=_,T(i,g=sn(g,b,i.dtype),m),P?i.persistentData=g:Qt.freeType(g)}else"number"==typeof g[0]?(i.dimension=b,Ze(b=Qt.allocType(i.dtype,g.length),g),T(i,b,m),P?i.persistentData=b:Qt.freeType(b)):Kt(g[0])&&(i.dimension=g[0].length,i.dtype=_||Xe(g[0])||5126,T(i,g=sn(g,[g.length,g[0].length],i.dtype),m),P?i.persistentData=g:Qt.freeType(g))}else if(Kt(g))i.dtype=_||Xe(g),i.dimension=b,T(i,g,m),P&&(i.persistentData=new Uint8Array(new Uint8Array(g.buffer)));else if(Be(g)){var H=g.stride,W=(I=g.offset,0),q=0,$=0,ye=0;1===(b=g.shape).length?(W=b[0],q=1,$=H[0],ye=0):2===b.length&&(W=b[0],q=b[1],$=H[0],ye=H[1]),i.dtype=_||Xe(g.data)||5126,i.dimension=q,Ye(b=Qt.allocType(i.dtype,W*q),g.data,W,q,$,ye,I),T(i,b,m),P?i.persistentData=b:Qt.freeType(b)}else g instanceof ArrayBuffer&&(i.dtype=5121,i.dimension=b,T(i,g,m),P&&(i.persistentData=new Uint8Array(new Uint8Array(g))))}function I(m){g.bufferCount--,_(m),i.deleteBuffer(m.buffer),m.buffer=null,delete W[m.id]}var H=0,W={};b.prototype.bind=function(){i.bindBuffer(this.type,this.buffer)},b.prototype.destroy=function(){I(this)};var q=[];return m.profile&&(g.getTotalBufferSize=function(){var i=0;return Object.keys(W).forEach((function(g){i+=W[g].stats.size})),i}),{create:function(_,T,H,q){function $(g){var _=35044,b=null,T=0,I=0,H=ye&&ye.dimension||1;return Array.isArray(g)||Kt(g)||Be(g)||g instanceof ArrayBuffer?b=g:"number"==typeof g?T=0|g:g&&("data"in g&&(b=g.data),"usage"in g&&(_=on[g.usage]),"type"in g&&(I=rn[g.type]),"dimension"in g&&(H=0|g.dimension),"length"in g&&(T=0|g.length)),ye.bind(),b?P(ye,b,_,I,H,q):(T&&i.bufferData(ye.type,T,_),ye.dtype=I||5121,ye.usage=_,ye.dimension=H,ye.byteLength=T),m.profile&&(ye.stats.size=ye.byteLength*ln[ye.dtype]),$}g.bufferCount++;var ye=new b(T);return W[ye.id]=ye,H||$(_),$._reglType="buffer",$._buffer=ye,$.subdata=function(g,m){var _,b=0|(m||0);if(ye.bind(),Kt(g)||g instanceof ArrayBuffer)i.bufferSubData(ye.type,b,g);else if(Array.isArray(g)){if(0<g.length)if("number"==typeof g[0]){var T=Qt.allocType(ye.dtype,g.length);Ze(T,g),i.bufferSubData(ye.type,b,T),Qt.freeType(T)}else(Array.isArray(g[0])||Kt(g[0]))&&(_=an(g),T=sn(g,_,ye.dtype),i.bufferSubData(ye.type,b,T),Qt.freeType(T))}else if(Be(g)){var P=g.stride,I=T=0,H=0,W=0;1===(_=g.shape).length?(T=_[0],I=1,H=P[0],W=0):2===_.length&&(T=_[0],I=_[1],H=P[0],W=P[1]),_=Array.isArray(g.data)?ye.dtype:Xe(g.data),Ye(_=Qt.allocType(_,T*I),g.data,T,I,H,W,g.offset),i.bufferSubData(ye.type,b,_),Qt.freeType(_)}return $},m.profile&&($.stats=ye.stats),$.destroy=function(){I(ye)},$},createStream:function(i,g){var m=q.pop();return m||(m=new b(i)),m.bind(),P(m,g,35040,0,1,!1),m},destroyStream:function(i){q.push(i)},clear:function(){en(W).forEach(I),q.forEach(I)},getBuffer:function(i){return i&&i._buffer instanceof b?i._buffer:null},restore:function(){en(W).forEach((function(g){g.buffer=i.createBuffer(),i.bindBuffer(g.type,g.buffer),i.bufferData(g.type,g.persistentData||g.byteLength,g.usage)}))},_initBuffer:P}}function Je(i,g,m,_){function b(i){this.id=H++,I[this.id]=this,this.buffer=i,this.primType=4,this.type=this.vertCount=0}function T(_,b,T,P,I,H,W){var q;if(_.buffer.bind(),b?((q=W)||Kt(b)&&(!Be(b)||Kt(b.data))||(q=g.oes_element_index_uint?5125:5123),m._initBuffer(_.buffer,b,T,q,3)):(i.bufferData(34963,H,T),_.buffer.dtype=q||5121,_.buffer.usage=T,_.buffer.dimension=3,_.buffer.byteLength=H),q=W,!W){switch(_.buffer.dtype){case 5121:case 5120:q=5121;break;case 5123:case 5122:q=5123;break;case 5125:case 5124:q=5125}_.buffer.dtype=q}_.type=q,0>(b=I)&&(b=_.buffer.byteLength,5123===q?b>>=1:5125===q&&(b>>=2)),_.vertCount=b,b=P,0>P&&(b=4,1===(P=_.buffer.dimension)&&(b=0),2===P&&(b=1),3===P&&(b=4)),_.primType=b}function P(i){_.elementsCount--,delete I[i.id],i.buffer.destroy(),i.buffer=null}var I={},H=0,W={uint8:5121,uint16:5123};g.oes_element_index_uint&&(W.uint32=5125),b.prototype.bind=function(){this.buffer.bind()};var q=[];return{create:function(i,g){function I(i){if(i)if("number"==typeof i)H(i),q.primType=4,q.vertCount=0|i,q.type=5121;else{var g=null,m=35044,_=-1,b=-1,P=0,$=0;Array.isArray(i)||Kt(i)||Be(i)?g=i:("data"in i&&(g=i.data),"usage"in i&&(m=on[i.usage]),"primitive"in i&&(_=hn[i.primitive]),"count"in i&&(b=0|i.count),"type"in i&&($=W[i.type]),"length"in i?P=0|i.length:(P=b,5123===$||5122===$?P*=2:5125!==$&&5124!==$||(P*=4))),T(q,g,m,_,b,P,$)}else H(),q.primType=4,q.vertCount=0,q.type=5121;return I}var H=m.create(null,34963,!0),q=new b(H._buffer);return _.elementsCount++,I(i),I._reglType="elements",I._elements=q,I.subdata=function(i,g){return H.subdata(i,g),I},I.destroy=function(){P(q)},I},createStream:function(i){var g=q.pop();return g||(g=new b(m.create(null,34963,!0,!1)._buffer)),T(g,i,35040,-1,-1,0,0),g},destroyStream:function(i){q.push(i)},getElements:function(i){return"function"==typeof i&&i._elements instanceof b?i._elements:null},clear:function(){en(I).forEach(P)}}}function Ke(i){for(var g=Qt.allocType(5123,i.length),m=0;m<i.length;++m)if(isNaN(i[m]))g[m]=65535;else if(1/0===i[m])g[m]=31744;else if(-1/0===i[m])g[m]=64512;else{cn[0]=i[m];var _=(T=un[0])>>>31<<15,b=(T<<1>>>24)-127,T=T>>13&1023;g[m]=-24>b?_:-14>b?_+(T+1024>>-14-b):15<b?_+31744:_+(b+15<<10)+T}return g}function et(i){return Array.isArray(i)||Kt(i)}function tt(i){return"[object "+i+"]"}function at(i){return Array.isArray(i)&&(0===i.length||"number"==typeof i[0])}function ht(i){return!(!Array.isArray(i)||0===i.length||!et(i[0]))}function gt(i){return Object.prototype.toString.call(i)}function yt(i){if(!i)return!1;var g=gt(i);return 0<=bn.indexOf(g)||at(i)||ht(i)||Be(i)}function vt(i,g){36193===i.type?(i.data=Ke(g),Qt.freeType(g)):i.data=g}function xt(i,g,m,_,b,T){if(i=void 0!==Sn[i]?Sn[i]:pn[i]*wn[g],T&&(i*=6),b){for(_=0;1<=m;)_+=i*m*m,m/=2;return _}return i*m*_}function bt(i,g,m,_,b,T,P){function I(){this.format=this.internalformat=6408,this.type=5121,this.flipY=this.premultiplyAlpha=this.compressed=!1,this.unpackAlignment=1,this.colorSpace=37444,this.channels=this.height=this.width=0}function H(i,g){i.internalformat=g.internalformat,i.format=g.format,i.type=g.type,i.compressed=g.compressed,i.premultiplyAlpha=g.premultiplyAlpha,i.flipY=g.flipY,i.unpackAlignment=g.unpackAlignment,i.colorSpace=g.colorSpace,i.width=g.width,i.height=g.height,i.channels=g.channels}function W(i,g){if("object"==typeof g&&g){"premultiplyAlpha"in g&&(i.premultiplyAlpha=g.premultiplyAlpha),"flipY"in g&&(i.flipY=g.flipY),"alignment"in g&&(i.unpackAlignment=g.alignment),"colorSpace"in g&&(i.colorSpace=zt[g.colorSpace]),"type"in g&&(i.type=Vt[g.type]);var m=i.width,_=i.height,b=i.channels,T=!1;"shape"in g?(m=g.shape[0],_=g.shape[1],3===g.shape.length&&(b=g.shape[2],T=!0)):("radius"in g&&(m=_=g.radius),"width"in g&&(m=g.width),"height"in g&&(_=g.height),"channels"in g&&(b=g.channels,T=!0)),i.width=0|m,i.height=0|_,i.channels=0|b,m=!1,"format"in g&&(_=i.internalformat=Ut[m=g.format],i.format=rn[_],m in Vt&&!("type"in g)&&(i.type=Vt[m]),m in Gt&&(i.compressed=!0),m=!0),!T&&m?i.channels=pn[i.format]:T&&!m&&i.channels!==dn[i.format]&&(i.format=i.internalformat=dn[i.channels])}}function q(g){i.pixelStorei(37440,g.flipY),i.pixelStorei(37441,g.premultiplyAlpha),i.pixelStorei(37443,g.colorSpace),i.pixelStorei(3317,g.unpackAlignment)}function $(){I.call(this),this.yOffset=this.xOffset=0,this.data=null,this.needsFree=!1,this.element=null,this.needsCopy=!1}function ye(i,g){var m=null;if(yt(g)?m=g:g&&(W(i,g),"x"in g&&(i.xOffset=0|g.x),"y"in g&&(i.yOffset=0|g.y),yt(g.data)&&(m=g.data)),g.copy){var _=b.viewportWidth,T=b.viewportHeight;i.width=i.width||_-i.xOffset,i.height=i.height||T-i.yOffset,i.needsCopy=!0}else if(m){if(Kt(m))i.channels=i.channels||4,i.data=m,"type"in g||5121!==i.type||(i.type=0|nn[Object.prototype.toString.call(m)]);else if(at(m)){switch(i.channels=i.channels||4,T=(_=m).length,i.type){case 5121:case 5123:case 5125:case 5126:(T=Qt.allocType(i.type,T)).set(_),i.data=T;break;case 36193:i.data=Ke(_)}i.alignment=1,i.needsFree=!0}else if(Be(m)){_=m.data,Array.isArray(_)||5121!==i.type||(i.type=0|nn[Object.prototype.toString.call(_)]);var P,I,H,q,$=m.stride;3===(T=m.shape).length?(H=T[2],q=$[2]):q=H=1,P=T[0],I=T[1],T=$[0],$=$[1],i.alignment=1,i.width=P,i.height=I,i.channels=H,i.format=i.internalformat=dn[H],i.needsFree=!0,P=q,m=m.offset;for(var ye=Qt.allocType(36193===i.type?5126:i.type,(H=i.width)*(q=i.height)*(I=i.channels)),Re=0,Ge=0;Ge<q;++Ge)for(var je=0;je<H;++je)for(var Xe=0;Xe<I;++Xe)ye[Re++]=_[T*je+$*Ge+P*Xe+m];vt(i,ye)}else if(gt(m)===gn||gt(m)===mn||gt(m)===An)i.element=gt(m)===gn||gt(m)===mn?m:m.canvas,i.width=i.element.width,i.height=i.element.height,i.channels=4;else if(gt(m)===yn)i.element=m,i.width=m.width,i.height=m.height,i.channels=4;else if(gt(m)===_n)i.element=m,i.width=m.naturalWidth,i.height=m.naturalHeight,i.channels=4;else if(gt(m)===xn)i.element=m,i.width=m.videoWidth,i.height=m.videoHeight,i.channels=4;else if(ht(m)){for(_=i.width||m[0].length,T=i.height||m.length,$=i.channels,$=et(m[0][0])?$||m[0][0].length:$||1,P=tn.shape(m),H=1,q=0;q<P.length;++q)H*=P[q];H=Qt.allocType(36193===i.type?5126:i.type,H),tn.flatten(m,P,"",H),vt(i,H),i.alignment=1,i.width=_,i.height=T,i.channels=$,i.format=i.internalformat=dn[$],i.needsFree=!0}}else i.width=i.width||1,i.height=i.height||1,i.channels=i.channels||4}function Re(g,m,b,T,P){var I=g.element,H=g.data,W=g.internalformat,$=g.format,ye=g.type,Re=g.width,Be=g.height;q(g),I?i.texSubImage2D(m,P,b,T,$,ye,I):g.compressed?i.compressedTexSubImage2D(m,P,b,T,W,Re,Be,H):g.needsCopy?(_(),i.copyTexSubImage2D(m,P,b,T,g.xOffset,g.yOffset,Re,Be)):i.texSubImage2D(m,P,b,T,Re,Be,$,ye,H)}function Ge(){return on.pop()||new $}function je(i){i.needsFree&&Qt.freeType(i.data),$.call(i),on.push(i)}function Xe(){I.call(this),this.genMipmaps=!1,this.mipmapHint=4352,this.mipmask=0,this.images=Array(16)}function Ze(i,g,m){var _=i.images[0]=Ge();i.mipmask=1,_.width=i.width=g,_.height=i.height=m,_.channels=i.channels=4}function Ye(i,g){var m=null;if(yt(g))H(m=i.images[0]=Ge(),i),ye(m,g),i.mipmask=1;else if(W(i,g),Array.isArray(g.mipmap))for(var _=g.mipmap,b=0;b<_.length;++b)H(m=i.images[b]=Ge(),i),m.width>>=b,m.height>>=b,ye(m,_[b]),i.mipmask|=1<<b;else H(m=i.images[0]=Ge(),i),ye(m,g),i.mipmask=1;H(i,i.images[0])}function Qe(g,m){for(var b=g.images,T=0;T<b.length&&b[T];++T){var P=b[T],I=m,H=T,W=P.element,$=P.data,ye=P.internalformat,Re=P.format,Be=P.type,Ge=P.width,je=P.height;q(P),W?i.texImage2D(I,H,Re,Re,Be,W):P.compressed?i.compressedTexImage2D(I,H,ye,Math.max(1,Ge),Math.max(1,je),0,$):P.needsCopy?(_(),i.copyTexImage2D(I,H,Re,P.xOffset,P.yOffset,Ge,je,0)):i.texImage2D(I,H,Re,Ge,je,0,Re,Be,$||null)}}function Je(){var i=sn.pop()||new Xe;I.call(i);for(var g=i.mipmask=0;16>g;++g)i.images[g]=null;return i}function tt(i){for(var g=i.images,m=0;m<g.length;++m)g[m]&&je(g[m]),g[m]=null;sn.push(i)}function bt(){this.magFilter=this.minFilter=9728,this.wrapT=this.wrapS=33071,this.anisotropic=1,this.genMipmaps=!1,this.mipmapHint=4352}function Tt(i,g){"min"in g&&(i.minFilter=Bt[g.min],0<=fn.indexOf(i.minFilter)&&!("faces"in g)&&(i.genMipmaps=!0)),"mag"in g&&(i.magFilter=Ht[g.mag]);var m=i.wrapS,_=i.wrapT;if("wrap"in g){var b=g.wrap;"string"==typeof b?m=_=Ft[b]:Array.isArray(b)&&(m=Ft[b[0]],_=Ft[b[1]])}else"wrapS"in g&&(m=Ft[g.wrapS]),"wrapT"in g&&(_=Ft[g.wrapT]);if(i.wrapS=m,i.wrapT=_,"anisotropic"in g&&(i.anisotropic=g.anisotropic),"mipmap"in g){switch(m=!1,typeof g.mipmap){case"string":i.mipmapHint=Dt[g.mipmap],m=i.genMipmaps=!0;break;case"boolean":m=i.genMipmaps=g.mipmap;break;case"object":i.genMipmaps=!1,m=!0}!m||"min"in g||(i.minFilter=9984)}}function Mt(m,_){i.texParameteri(_,10241,m.minFilter),i.texParameteri(_,10240,m.magFilter),i.texParameteri(_,10242,m.wrapS),i.texParameteri(_,10243,m.wrapT),g.ext_texture_filter_anisotropic&&i.texParameteri(_,34046,m.anisotropic),m.genMipmaps&&(i.hint(33170,m.mipmapHint),i.generateMipmap(_))}function Pt(g){I.call(this),this.mipmask=0,this.internalformat=6408,this.id=an++,this.refCount=1,this.target=g,this.texture=i.createTexture(),this.unit=-1,this.bindCount=0,this.texInfo=new bt,P.profile&&(this.stats={size:0})}function It(g){i.activeTexture(33984),i.bindTexture(g.target,g.texture)}function Et(){var g=cn[0];g?i.bindTexture(g.target,g.texture):i.bindTexture(3553,null)}function Lt(g){var m=g.texture,_=g.unit,b=g.target;0<=_&&(i.activeTexture(33984+_),i.bindTexture(b,null),cn[_]=null),i.deleteTexture(m),g.texture=null,g.params=null,g.pixels=null,g.refCount=0,delete ln[g.id],T.textureCount--}var Dt={"don't care":4352,"dont care":4352,nice:4354,fast:4353},Ft={repeat:10497,clamp:33071,mirror:33648},Ht={nearest:9728,linear:9729},Bt=qt({mipmap:9987,"nearest mipmap nearest":9984,"linear mipmap nearest":9985,"nearest mipmap linear":9986,"linear mipmap linear":9987},Ht),zt={none:0,browser:37444},Vt={uint8:5121,rgba4:32819,rgb565:33635,"rgb5 a1":32820},Ut={alpha:6406,luminance:6409,"luminance alpha":6410,rgb:6407,rgba:6408,rgba4:32854,"rgb5 a1":32855,rgb565:36194},Gt={};g.ext_srgb&&(Ut.srgb=35904,Ut.srgba=35906),g.oes_texture_float&&(Vt.float32=Vt.float=5126),g.oes_texture_half_float&&(Vt.float16=Vt["half float"]=36193),g.webgl_depth_texture&&(qt(Ut,{depth:6402,"depth stencil":34041}),qt(Vt,{uint16:5123,uint32:5125,"depth stencil":34042})),g.webgl_compressed_texture_s3tc&&qt(Gt,{"rgb s3tc dxt1":33776,"rgba s3tc dxt1":33777,"rgba s3tc dxt3":33778,"rgba s3tc dxt5":33779}),g.webgl_compressed_texture_atc&&qt(Gt,{"rgb atc":35986,"rgba atc explicit alpha":35987,"rgba atc interpolated alpha":34798}),g.webgl_compressed_texture_pvrtc&&qt(Gt,{"rgb pvrtc 4bppv1":35840,"rgb pvrtc 2bppv1":35841,"rgba pvrtc 4bppv1":35842,"rgba pvrtc 2bppv1":35843}),g.webgl_compressed_texture_etc1&&(Gt["rgb etc1"]=36196,Gt["rgb etc2"]=37492);var jt=Array.prototype.slice.call(i.getParameter(34467));Object.keys(Gt).forEach((function(i){var g=Gt[i];0<=jt.indexOf(g)&&(Ut[i]=g)}));var Wt=Object.keys(Ut);m.textureFormats=Wt;var Xt=[];Object.keys(Ut).forEach((function(i){Xt[Ut[i]]=i}));var Zt=[];Object.keys(Vt).forEach((function(i){Zt[Vt[i]]=i}));var $t=[];Object.keys(Ht).forEach((function(i){$t[Ht[i]]=i}));var Yt=[];Object.keys(Bt).forEach((function(i){Yt[Bt[i]]=i}));var Jt=[];Object.keys(Ft).forEach((function(i){Jt[Ft[i]]=i}));var rn=Wt.reduce((function(i,m){var _=Ut[m];return i[_]=6409===_||6406===_||6409===_||6410===_||6402===_||34041===_||g.ext_srgb&&(35904===_||35906===_)?_:32855===_||0<=m.indexOf("rgba")?6408:6407,i}),{}),on=[],sn=[],an=0,ln={},hn=m.maxTextureUnits,cn=Array(hn).map((function(){return null}));return qt(Pt.prototype,{bind:function(){this.bindCount+=1;var g=this.unit;if(0>g){for(var m=0;m<hn;++m){var _=cn[m];if(_){if(0<_.bindCount)continue;_.unit=-1}cn[m]=this,g=m;break}P.profile&&T.maxTextureUnits<g+1&&(T.maxTextureUnits=g+1),this.unit=g,i.activeTexture(33984+g),i.bindTexture(this.target,this.texture)}return g},unbind:function(){--this.bindCount},decRef:function(){0>=--this.refCount&&Lt(this)}}),P.profile&&(T.getTotalTextureSize=function(){var i=0;return Object.keys(ln).forEach((function(g){i+=ln[g].stats.size})),i}),{create2D:function(g,m){function _(g,m){var T=b.texInfo;bt.call(T),T.version=i instanceof WebGL2RenderingContext?2:1;var I=Je();return"number"==typeof g?Ze(I,0|g,"number"==typeof m?0|m:0|g):g?(Tt(T,g),Ye(I,g)):Ze(I,1,1),T.genMipmaps&&(I.mipmask=(Math.max(I.width,I.height)<<1)-1),b.mipmask=I.mipmask,H(b,I),b.internalformat=I.internalformat,_.width=I.width,_.height=I.height,It(b),Qe(I,3553),Mt(T,3553),Et(),tt(I),P.profile&&(b.stats.size=xt(b.internalformat,b.type,I.width,I.height,T.genMipmaps,!1)),_.format=Xt[b.internalformat],_.type=Zt[b.type],_.mag=$t[T.magFilter],_.min=Yt[T.minFilter],_.wrapS=Jt[T.wrapS],_.wrapT=Jt[T.wrapT],_}var b=new Pt(3553);return ln[b.id]=b,T.textureCount++,_(g,m),_.subimage=function(i,g,m,T){g|=0,m|=0,T|=0;var P=Ge();return H(P,b),P.width=0,P.height=0,ye(P,i),P.width=P.width||(b.width>>T)-g,P.height=P.height||(b.height>>T)-m,It(b),Re(P,3553,g,m,T),Et(),je(P),_},_.resize=function(g,m){var T=0|g,I=0|m||T;if(T===b.width&&I===b.height)return _;_.width=b.width=T,_.height=b.height=I,It(b);for(var H=0;b.mipmask>>H;++H){var W=T>>H,q=I>>H;if(!W||!q)break;i.texImage2D(3553,H,b.format,W,q,0,b.format,b.type,null)}return Et(),P.profile&&(b.stats.size=xt(b.internalformat,b.type,T,I,!1,!1)),_},_.texParameteri=function(g,m){It(b);var _=i.texParameteri(3553,g,m);return Et(),_},_._reglType="texture2d",_._texture=b,P.profile&&(_.stats=b.stats),_.destroy=function(){b.decRef()},_},createCube:function(g,m,_,b,I,q){function $(i,g,m,_,b,T){var I,q=Be.texInfo;for(bt.call(q),I=0;6>I;++I)Xe[I]=Je();if("number"!=typeof i&&i){if("object"==typeof i)if(g)Ye(Xe[0],i),Ye(Xe[1],g),Ye(Xe[2],m),Ye(Xe[3],_),Ye(Xe[4],b),Ye(Xe[5],T);else if(Tt(q,i),W(Be,i),"faces"in i)for(i=i.faces,I=0;6>I;++I)H(Xe[I],Be),Ye(Xe[I],i[I]);else for(I=0;6>I;++I)Ye(Xe[I],i)}else for(i=0|i||1,I=0;6>I;++I)Ze(Xe[I],i,i);for(H(Be,Xe[0]),Be.mipmask=q.genMipmaps?(Math.max(Xe[0].width,Xe[0].height)<<1)-1:Xe[0].mipmask,Be.internalformat=Xe[0].internalformat,$.width=Xe[0].width,$.height=Xe[0].height,It(Be),I=0;6>I;++I)Qe(Xe[I],34069+I);for(Mt(q,34067),Et(),P.profile&&(Be.stats.size=xt(Be.internalformat,Be.type,$.width,$.height,q.genMipmaps,!0)),$.format=Xt[Be.internalformat],$.type=Zt[Be.type],$.mag=$t[q.magFilter],$.min=Yt[q.minFilter],$.wrapS=Jt[q.wrapS],$.wrapT=Jt[q.wrapT],I=0;6>I;++I)tt(Xe[I]);return $}var Be=new Pt(34067);ln[Be.id]=Be,T.cubeCount++;var Xe=Array(6);return $(g,m,_,b,I,q),$.subimage=function(i,g,m,_,b){m|=0,_|=0,b|=0;var T=Ge();return H(T,Be),T.width=0,T.height=0,ye(T,g),T.width=T.width||(Be.width>>b)-m,T.height=T.height||(Be.height>>b)-_,It(Be),Re(T,34069+i,m,_,b),Et(),je(T),$},$.resize=function(g){if((g|=0)!==Be.width){$.width=Be.width=g,$.height=Be.height=g,It(Be);for(var m=0;6>m;++m)for(var _=0;Be.mipmask>>_;++_)i.texImage2D(34069+m,_,Be.format,g>>_,g>>_,0,Be.format,Be.type,null);return Et(),P.profile&&(Be.stats.size=xt(Be.internalformat,Be.type,$.width,$.height,!1,!0)),$}},$._reglType="textureCube",$._texture=Be,P.profile&&($.stats=Be.stats),$.destroy=function(){Be.decRef()},$},clear:function(){for(var g=0;g<hn;++g)i.activeTexture(33984+g),i.bindTexture(3553,null),cn[g]=null;en(ln).forEach(Lt),T.cubeCount=0,T.textureCount=0},getTexture:function(i){return null},restore:function(){for(var g=0;g<hn;++g){var m=cn[g];m&&(m.bindCount=0,m.unit=-1,cn[g]=null)}en(ln).forEach((function(g){g.texture=i.createTexture(),i.bindTexture(g.target,g.texture);for(var m=0;32>m;++m)if(g.mipmask&1<<m)if(3553===g.target)i.texImage2D(3553,m,g.internalformat,g.width>>m,g.height>>m,0,g.internalformat,g.type,null);else for(var _=0;6>_;++_)i.texImage2D(34069+_,m,g.internalformat,g.width>>m,g.height>>m,0,g.internalformat,g.type,null);Mt(g.texInfo,g.target)}))},refresh:function(){for(var g=0;g<hn;++g){var m=cn[g];m&&(m.bindCount=0,m.unit=-1,cn[g]=null),i.activeTexture(33984+g),i.bindTexture(3553,null),i.bindTexture(34067,null)}}}}function Tt(i,g,m,_,b,T){function P(i,g,m){this.target=i,this.texture=g,this.renderbuffer=m;var _=i=0;g?(i=g.width,_=g.height):m&&(i=m.width,_=m.height),this.width=i,this.height=_}function I(i){i&&(i.texture&&i.texture._texture.decRef(),i.renderbuffer&&i.renderbuffer._renderbuffer.decRef())}function H(i,g,m){i&&(i.texture?i.texture._texture.refCount+=1:i.renderbuffer._renderbuffer.refCount+=1)}function W(g,m){m&&(m.texture?i.framebufferTexture2D(36160,g,m.target,m.texture._texture.texture,0):i.framebufferRenderbuffer(36160,g,36161,m.renderbuffer._renderbuffer.renderbuffer))}function q(i){var g=3553,m=null,_=null,b=i;return"object"==typeof i&&(b=i.data,"target"in i&&(g=0|i.target)),"texture2d"===(i=b._reglType)||"textureCube"===i?m=b:"renderbuffer"===i&&(_=b,g=36161),new P(g,m,_)}function $(i,g,m,T,I){return m?((i=_.create2D({width:i,height:g,format:T,type:I}))._texture.refCount=0,new P(3553,i,null)):((i=b.create({width:i,height:g,format:T}))._renderbuffer.refCount=0,new P(36161,null,i))}function ye(i){return i&&(i.texture||i.renderbuffer)}function Re(i,g,m){i&&(i.texture?i.texture.resize(g,m):i.renderbuffer&&i.renderbuffer.resize(g,m),i.width=g,i.height=m)}function Be(){this.id=et++,tt[this.id]=this,this.framebuffer=i.createFramebuffer(),this.height=this.width=0,this.colorAttachments=[],this.depthStencilAttachment=this.stencilAttachment=this.depthAttachment=null}function Ge(i){i.colorAttachments.forEach(I),I(i.depthAttachment),I(i.stencilAttachment),I(i.depthStencilAttachment)}function je(g){i.deleteFramebuffer(g.framebuffer),g.framebuffer=null,T.framebufferCount--,delete tt[g.id]}function Xe(g,_){var b;i.bindFramebuffer(36160,g.framebuffer);var T=g.colorAttachments;for(b=0;b<T.length;++b)W(36064+b,T[b]);for(b=T.length;b<m.maxColorAttachments;++b)i.framebufferTexture2D(36160,36064+b,3553,null,0);i.framebufferTexture2D(36160,33306,3553,null,0),i.framebufferTexture2D(36160,36096,3553,null,0),i.framebufferTexture2D(36160,36128,3553,null,0),W(36096,g.depthAttachment),W(36128,g.stencilAttachment),W(33306,g.depthStencilAttachment),_||(i.checkFramebufferStatus(36160),i.isContextLost()),i.bindFramebuffer(36160,Ye.next?Ye.next.framebuffer:null),Ye.cur=Ye.next,_||i.getError()}function Ze(g,m){function _(i,g){var m,T=0,P=0,I=!0,W=!0;m=null;var Re=!0,Be="rgba",je="uint8",Ze=1,Ye=null,Ke=null,et=null,tt=!1;if("number"==typeof i)T=0|i,P=0|g||T;else if(i){var at=i;"shape"in at?(T=(P=at.shape)[0],P=P[1]):("radius"in at&&(T=P=at.radius),"width"in at&&(T=at.width),"height"in at&&(P=at.height)),("color"in at||"colors"in at)&&(m=at.color||at.colors),m||("colorCount"in at&&(Ze=0|at.colorCount),"colorTexture"in at&&(Re=!!at.colorTexture,Be="rgba4"),"colorType"in at&&(je=at.colorType,!Re)&&("half float"===je||"float16"===je?Be="rgba16f":"float"!==je&&"float32"!==je||(Be="rgba32f")),"colorFormat"in at&&(0<=Qe.indexOf(Be=at.colorFormat)?Re=!0:0<=Je.indexOf(Be)&&(Re=!1))),("depthTexture"in at||"depthStencilTexture"in at)&&(tt=!(!at.depthTexture&&!at.depthStencilTexture)),"depth"in at&&("boolean"==typeof at.depth?I=at.depth:(Ye=at.depth,W=!1)),"stencil"in at&&("boolean"==typeof at.stencil?W=at.stencil:(Ke=at.stencil,I=!1)),"depthStencil"in at&&("boolean"==typeof at.depthStencil?I=W=at.depthStencil:(et=at.depthStencil,W=I=!1))}else T=P=1;var ht=null,gt=null,yt=null,vt=null;if(Array.isArray(m))ht=m.map(q);else if(m)ht=[q(m)];else for(ht=Array(Ze),m=0;m<Ze;++m)ht[m]=$(T,P,Re,Be,je);for(T=T||ht[0].width,P=P||ht[0].height,Ye?gt=q(Ye):I&&!W&&(gt=$(T,P,tt,"depth","uint32")),Ke?yt=q(Ke):W&&!I&&(yt=$(T,P,!1,"stencil","uint8")),et?vt=q(et):!Ye&&!Ke&&W&&I&&(vt=$(T,P,tt,"depth stencil","depth stencil")),I=null,m=0;m<ht.length;++m)H(ht[m]),ht[m]&&ht[m].texture&&(W=Pn[ht[m].texture._texture.format]*kn[ht[m].texture._texture.type],null===I&&(I=W));return H(gt),H(yt),H(vt),Ge(b),b.width=T,b.height=P,b.colorAttachments=ht,b.depthAttachment=gt,b.stencilAttachment=yt,b.depthStencilAttachment=vt,_.color=ht.map(ye),_.depth=ye(gt),_.stencil=ye(yt),_.depthStencil=ye(vt),_.width=b.width,_.height=b.height,Xe(b,at&&at.ignoreStatusCheck),_}var b=new Be;return T.framebufferCount++,_(g,m),qt(_,{resize:function(i,g){var m=Math.max(0|i,1),T=Math.max(0|g||m,1);if(m===b.width&&T===b.height)return _;for(var P=b.colorAttachments,I=0;I<P.length;++I)Re(P[I],m,T);return Re(b.depthAttachment,m,T),Re(b.stencilAttachment,m,T),Re(b.depthStencilAttachment,m,T),b.width=_.width=m,b.height=_.height=T,Xe(b),_},blit:function(g,m,_){i.bindFramebuffer(36008,g._framebuffer.framebuffer),i.bindFramebuffer(36009,b.framebuffer),m||(m=16384),i.blitFramebuffer(0,0,g.width,g.height,0,0,b.width,b.height,m,"linear"===_?9729:9728),i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null)},_reglType:"framebuffer",_framebuffer:b,destroy:function(){je(b),Ge(b)},use:function(i){Ye.setFBO({framebuffer:_},i)}})}var Ye={cur:null,next:null,dirty:!1,setFBO:null},Qe=["rgba"],Je=["rgba4","rgb565","rgb5 a1"];g.ext_srgb&&Je.push("srgba"),g.ext_color_buffer_half_float&&Je.push("rgba16f","rgb16f"),g.webgl_color_buffer_float&&Je.push("rgba32f");var Ke=["uint8"];g.oes_texture_half_float&&Ke.push("half float","float16"),g.oes_texture_float&&Ke.push("float","float32");var et=0,tt={};return qt(Ye,{getFramebuffer:function(i){return"function"==typeof i&&"framebuffer"===i._reglType&&(i=i._framebuffer)instanceof Be?i:null},create:Ze,createCube:function(i){function g(i){var b,T={color:null},P=0,I=null;b="rgba";var H="uint8",W=1;if("number"==typeof i?P=0|i:i?("shape"in i?P=i.shape[0]:("radius"in i&&(P=0|i.radius),"width"in i?P=0|i.width:"height"in i&&(P=0|i.height)),("color"in i||"colors"in i)&&(I=i.color||i.colors),I||("colorCount"in i&&(W=0|i.colorCount),"colorType"in i&&(H=i.colorType),"colorFormat"in i&&(b=i.colorFormat)),"depth"in i&&(T.depth=i.depth),"stencil"in i&&(T.stencil=i.stencil),"depthStencil"in i&&(T.depthStencil=i.depthStencil)):P=1,I)if(Array.isArray(I))for(i=[],b=0;b<I.length;++b)i[b]=I[b];else i=[I];else for(i=Array(W),I={radius:P,format:b,type:H},b=0;b<W;++b)i[b]=_.createCube(I);for(T.color=Array(i.length),b=0;b<i.length;++b)W=i[b],P=P||W.width,T.color[b]={target:34069,data:i[b]};for(b=0;6>b;++b){for(W=0;W<i.length;++W)T.color[W].target=34069+b;0<b&&(T.depth=m[0].depth,T.stencil=m[0].stencil,T.depthStencil=m[0].depthStencil),m[b]?m[b](T):m[b]=Ze(T)}return qt(g,{width:P,height:P,color:i})}var m=Array(6);return g(i),qt(g,{faces:m,resize:function(i){var _=0|i;if(_===g.width)return g;var b=g.color;for(i=0;i<b.length;++i)b[i].resize(_);for(i=0;6>i;++i)m[i].resize(_);return g.width=g.height=_,g},_reglType:"framebufferCube",destroy:function(){m.forEach((function(i){i.destroy()}))}})},clear:function(){en(tt).forEach(je)},restore:function(){Ye.cur=null,Ye.next=null,Ye.dirty=!0,en(tt).forEach((function(g){g.framebuffer=i.createFramebuffer(),Xe(g)}))}})}function Mt(){this.w=this.z=this.y=this.x=this.state=0,this.buffer=null,this.size=0,this.normalized=!1,this.type=5126,this.divisor=this.stride=this.offset=0}function Pt(i,g,m,_,b,T,P){function I(i){if(i!==Xe.currentVAO){var m=g.oes_vertex_array_object;m.bindVertexArrayOES(i?i.vao:null),Xe.currentVAO=i}}function H(m){if(m!==Xe.currentVAO){if(m)m.bindAttrs();else{for(var _=g.angle_instanced_arrays,b=0;b<Re.length;++b){var T=Re[b];T.buffer?(i.enableVertexAttribArray(b),T.buffer.bind(),i.vertexAttribPointer(b,T.size,T.type,T.normalized,T.stride,T.offfset),_&&T.divisor&&_.vertexAttribDivisorANGLE(b,T.divisor)):(i.disableVertexAttribArray(b),i.vertexAttrib4f(b,T.x,T.y,T.z,T.w))}i.bindBuffer(34963,P.elements?P.elements.buffer.buffer:null)}Xe.currentVAO=m}}function W(){en(je).forEach((function(i){i.destroy()}))}function q(){this.id=++Ge,this.attributes=[],this.elements=null,this.ownsElements=!1,this.offset=this.count=0,this.instances=-1,this.primitive=4;var i=g.oes_vertex_array_object;this.vao=i?i.createVertexArrayOES():null,je[this.id]=this,this.buffers=[]}function $(){g.oes_vertex_array_object&&en(je).forEach((function(i){i.refresh()}))}var ye=m.maxAttributes,Re=Array(ye);for(m=0;m<ye;++m)Re[m]=new Mt;var Ge=0,je={},Xe={Record:Mt,scope:{},state:Re,currentVAO:null,targetVAO:null,restore:g.oes_vertex_array_object?$:function(){},createVAO:function(i){function g(i){var _;Array.isArray(i)?(_=i,m.elements&&m.ownsElements&&m.elements.destroy(),m.elements=null,m.ownsElements=!1,m.offset=0,m.count=0,m.instances=-1,m.primitive=4):(i.elements?(_=i.elements,m.ownsElements?("function"==typeof _&&"elements"===_._reglType?m.elements.destroy():m.elements(_),m.ownsElements=!1):T.getElements(i.elements)?(m.elements=i.elements,m.ownsElements=!1):(m.elements=T.create(i.elements),m.ownsElements=!0)):(m.elements=null,m.ownsElements=!1),_=i.attributes,m.offset=0,m.count=-1,m.instances=-1,m.primitive=4,m.elements&&(m.count=m.elements._elements.vertCount,m.primitive=m.elements._elements.primType),"offset"in i&&(m.offset=0|i.offset),"count"in i&&(m.count=0|i.count),"instances"in i&&(m.instances=0|i.instances),"primitive"in i&&(m.primitive=hn[i.primitive])),i={};var P=m.attributes;P.length=_.length;for(var I=0;I<_.length;++I){var H,W=_[I],q=P[I]=new Mt,$=W.data||W;Array.isArray($)||Kt($)||Be($)?(m.buffers[I]&&(H=m.buffers[I],Kt($)&&H._buffer.byteLength>=$.byteLength?H.subdata($):(H.destroy(),m.buffers[I]=null)),m.buffers[I]||(H=m.buffers[I]=b.create(W,34962,!1,!0)),q.buffer=b.getBuffer(H),q.size=0|q.buffer.dimension,q.normalized=!1,q.type=q.buffer.dtype,q.offset=0,q.stride=0,q.divisor=0,q.state=1,i[I]=1):b.getBuffer(W)?(q.buffer=b.getBuffer(W),q.size=0|q.buffer.dimension,q.normalized=!1,q.type=q.buffer.dtype,q.offset=0,q.stride=0,q.divisor=0,q.state=1):b.getBuffer(W.buffer)?(q.buffer=b.getBuffer(W.buffer),q.size=0|(+W.size||q.buffer.dimension),q.normalized=!!W.normalized||!1,q.type="type"in W?rn[W.type]:q.buffer.dtype,q.offset=0|(W.offset||0),q.stride=0|(W.stride||0),q.divisor=0|(W.divisor||0),q.state=1):"x"in W&&(q.x=+W.x||0,q.y=+W.y||0,q.z=+W.z||0,q.w=+W.w||0,q.state=2)}for(H=0;H<m.buffers.length;++H)!i[H]&&m.buffers[H]&&(m.buffers[H].destroy(),m.buffers[H]=null);return m.refresh(),g}var m=new q;return _.vaoCount+=1,g.destroy=function(){for(var i=0;i<m.buffers.length;++i)m.buffers[i]&&m.buffers[i].destroy();m.buffers.length=0,m.ownsElements&&(m.elements.destroy(),m.elements=null,m.ownsElements=!1),m.destroy()},g._vao=m,g._reglType="vao",g(i)},getVAO:function(i){return"function"==typeof i&&i._vao?i._vao:null},destroyBuffer:function(g){for(var m=0;m<Re.length;++m){var _=Re[m];_.buffer===g&&(i.disableVertexAttribArray(m),_.buffer=null)}},setVAO:g.oes_vertex_array_object?I:H,clear:g.oes_vertex_array_object?W:function(){}};return q.prototype.bindAttrs=function(){for(var m=g.angle_instanced_arrays,_=this.attributes,b=0;b<_.length;++b){var P=_[b];P.buffer?(i.enableVertexAttribArray(b),i.bindBuffer(34962,P.buffer.buffer),i.vertexAttribPointer(b,P.size,P.type,P.normalized,P.stride,P.offset),m&&P.divisor&&m.vertexAttribDivisorANGLE(b,P.divisor)):(i.disableVertexAttribArray(b),i.vertexAttrib4f(b,P.x,P.y,P.z,P.w))}for(m=_.length;m<ye;++m)i.disableVertexAttribArray(m);(m=T.getElements(this.elements))?i.bindBuffer(34963,m.buffer.buffer):i.bindBuffer(34963,null)},q.prototype.refresh=function(){var i=g.oes_vertex_array_object;i&&(i.bindVertexArrayOES(this.vao),this.bindAttrs(),Xe.currentVAO=null,i.bindVertexArrayOES(null))},q.prototype.destroy=function(){if(this.vao){var i=g.oes_vertex_array_object;this===Xe.currentVAO&&(Xe.currentVAO=null,i.bindVertexArrayOES(null)),i.deleteVertexArrayOES(this.vao),this.vao=null}this.ownsElements&&(this.elements.destroy(),this.elements=null,this.ownsElements=!1),je[this.id]&&(delete je[this.id],--_.vaoCount)},Xe}function It(i,g,m,_){function b(i,g,m,_){this.name=i,this.id=g,this.location=m,this.info=_}function T(i,g){for(var m=0;m<i.length;++m)if(i[m].id===g.id)return void(i[m].location=g.location);i.push(g)}function P(m,_,b){if(!(P=(b=35632===m?W:q)[_])){var T=g.str(_),P=i.createShader(m);i.shaderSource(P,T),i.compileShader(P),b[_]=P}return P}function I(i,g){this.id=Re++,this.fragId=i,this.vertId=g,this.program=null,this.uniforms=[],this.attributes=[],this.refCount=1,_.profile&&(this.stats={uniformsCount:0,attributesCount:0})}function H(m,I,H){var W;W=P(35632,m.fragId);var q=P(35633,m.vertId);if(I=m.program=i.createProgram(),i.attachShader(I,W),i.attachShader(I,q),H)for(W=0;W<H.length;++W)i.bindAttribLocation(I,(q=H[W])[0],q[1]);i.linkProgram(I),q=i.getProgramParameter(I,35718),_.profile&&(m.stats.uniformsCount=q);var $=m.uniforms;for(W=0;W<q;++W)if(H=i.getActiveUniform(I,W)){if(1<H.size)for(var ye=0;ye<H.size;++ye){var Re=H.name.replace("[0]","["+ye+"]");T($,new b(Re,g.id(Re),i.getUniformLocation(I,Re),H))}ye=H.name,1<H.size&&(ye=ye.replace("[0]","")),T($,new b(ye,g.id(ye),i.getUniformLocation(I,ye),H))}for(q=i.getProgramParameter(I,35721),_.profile&&(m.stats.attributesCount=q),m=m.attributes,W=0;W<q;++W)(H=i.getActiveAttrib(I,W))&&T(m,new b(H.name,g.id(H.name),i.getAttribLocation(I,H.name),H))}var W={},q={},$={},ye=[],Re=0;return _.profile&&(m.getMaxUniformsCount=function(){var i=0;return ye.forEach((function(g){g.stats.uniformsCount>i&&(i=g.stats.uniformsCount)})),i},m.getMaxAttributesCount=function(){var i=0;return ye.forEach((function(g){g.stats.attributesCount>i&&(i=g.stats.attributesCount)})),i}),{clear:function(){var g=i.deleteShader.bind(i);en(W).forEach(g),W={},en(q).forEach(g),q={},ye.forEach((function(g){i.deleteProgram(g.program)})),ye.length=0,$={},m.shaderCount=0},program:function(g,_,b,T){var P=$[_];P||(P=$[_]={});var Re=P[g];if(Re&&(Re.refCount++,!T))return Re;var Be=new I(_,g);return m.shaderCount++,H(Be,b,T),Re||(P[g]=Be),ye.push(Be),qt(Be,{destroy:function(){if(Be.refCount--,0>=Be.refCount){i.deleteProgram(Be.program);var g=ye.indexOf(Be);ye.splice(g,1),m.shaderCount--}0>=P[Be.vertId].refCount&&(i.deleteShader(q[Be.vertId]),delete q[Be.vertId],delete $[Be.fragId][Be.vertId]),Object.keys($[Be.fragId]).length||(i.deleteShader(W[Be.fragId]),delete W[Be.fragId],delete $[Be.fragId])}})},restore:function(){W={},q={};for(var i=0;i<ye.length;++i)H(ye[i],null,ye[i].attributes.map((function(i){return[i.location,i.name]})))},shader:P,frag:-1,vert:-1}}function Et(i,g,m,_,b,T,P){function I(b){var T;T=null===g.next?5121:g.next.colorAttachments[0].texture._texture.type;var P=0,I=0,H=_.framebufferWidth,W=_.framebufferHeight,q=null;return Kt(b)?q=b:b&&(P=0|b.x,I=0|b.y,H=0|(b.width||_.framebufferWidth-P),W=0|(b.height||_.framebufferHeight-I),q=b.data||null),m(),b=H*W*4,q||(5121===T?q=new Uint8Array(b):5126===T&&(q=q||new Float32Array(b))),i.pixelStorei(3333,4),i.readPixels(P,I,H,W,6408,T,q),q}function H(i){var m;return g.setFBO({framebuffer:i.framebuffer},(function(){m=I(i)})),m}return function(i){return i&&"framebuffer"in i?H(i):I(i)}}function Lt(i){return Array.prototype.slice.call(i)}function Dt(i){return Lt(i).join("")}function Ft(){function i(){var i=[],g=[];return qt((function(){i.push.apply(i,Lt(arguments))}),{def:function(){var _="v"+m++;return g.push(_),0<arguments.length&&(i.push(_,"="),i.push.apply(i,Lt(arguments)),i.push(";")),_},toString:function(){return Dt([0<g.length?"var "+g.join(",")+";":"",Dt(i)])}})}function g(){function g(i,g){_(i,g,"=",m.def(i,g),";")}var m=i(),_=i(),b=m.toString,T=_.toString;return qt((function(){m.apply(m,Lt(arguments))}),{def:m.def,entry:m,exit:_,save:g,set:function(i,_,b){g(i,_),m(i,_,"=",b,";")},toString:function(){return b()+T()}})}var m=0,_=[],b=[],T=i(),P={};return{global:T,link:function(i){for(var g=0;g<b.length;++g)if(b[g]===i)return _[g];return g="g"+m++,_.push(g),b.push(i),g},block:i,proc:function(i,m){function _(){var i="a"+b.length;return b.push(i),i}var b=[];m=m||0;for(var T=0;T<m;++T)_();var I=(T=g()).toString;return P[i]=qt(T,{arg:_,toString:function(){return Dt(["function(",b.join(),"){",I(),"}"])}})},scope:g,cond:function(){var i=Dt(arguments),m=g(),_=g(),b=m.toString,T=_.toString;return qt(m,{then:function(){return m.apply(m,Lt(arguments)),this},else:function(){return _.apply(_,Lt(arguments)),this},toString:function(){var g=T();return g&&(g="else{"+g+"}"),Dt(["if(",i,"){",b(),"}",g])}})},compile:function(){var i=['"use strict";',T,"return {"];Object.keys(P).forEach((function(g){i.push('"',g,'":',P[g].toString(),",")})),i.push("}");var g=Dt(i).replace(/;/g,";\n").replace(/}/g,"}\n").replace(/{/g,"{\n");return Function.apply(null,_.concat(g)).apply(null,b)}}}function Ht(i){return Array.isArray(i)||Kt(i)||Be(i)}function Bt(i){return i.sort((function(i,g){return"viewport"===i?-1:"viewport"===g?1:i<g?-1:1}))}function zt(i,g,m,_){this.thisDep=i,this.contextDep=g,this.propDep=m,this.append=_}function Vt(i){return i&&!(i.thisDep||i.contextDep||i.propDep)}function Ut(i){return new zt(!1,!1,!1,i)}function Gt(i,g){var m=i.type;if(0===m)return new zt(!0,1<=(m=i.data.length),2<=m,g);if(4===m)return new zt((m=i.data).thisDep,m.contextDep,m.propDep,g);if(5===m)return new zt(!1,!1,!1,g);if(6===m){for(var _=m=!1,b=!1,T=0;T<i.data.length;++T){var P=i.data[T];1===P.type?b=!0:2===P.type?_=!0:3===P.type?m=!0:0===P.type?(m=!0,1<=(P=P.data)&&(_=!0),2<=P&&(b=!0)):4===P.type&&(m=m||P.data.thisDep,_=_||P.data.contextDep,b=b||P.data.propDep)}return new zt(m,_,b,g)}return new zt(3===m,2===m,1===m,g)}function jt(i,g,m,_,b,T,P,I,H,W,q,ye,Re,Be,Ge){function je(i){return i.replace(".","_")}function Xe(i,g,m){var _=je(i);dn.push(i),fn[_]=un[_]=!!m,pn[_]=g}function Ze(i,g,m){var _=je(i);dn.push(i),Array.isArray(m)?(un[_]=m.slice(),fn[_]=m.slice()):un[_]=fn[_]=m,gn[_]=g}function Ye(){var i=Ft(),m=i.link,_=i.global;i.id=yn++,i.batchId="0";var b=m(mn),T=i.shared={props:"a0"};Object.keys(mn).forEach((function(i){T[i]=_.def(b,".",i)}));var P=i.next={},I=i.current={};Object.keys(gn).forEach((function(i){Array.isArray(un[i])&&(P[i]=_.def(T.next,".",i),I[i]=_.def(T.current,".",i))}));var H=i.constants={};Object.keys(An).forEach((function(i){H[i]=_.def(JSON.stringify(An[i]))})),i.invoke=function(g,_){switch(_.type){case 0:var b=["this",T.context,T.props,i.batchId];return g.def(m(_.data),".call(",b.slice(0,Math.max(_.data.length+1,4)),")");case 1:return g.def(T.props,_.data);case 2:return g.def(T.context,_.data);case 3:return g.def("this",_.data);case 4:return _.data.append(i,g),_.data.ref;case 5:return _.data.toString();case 6:return _.data.map((function(m){return i.invoke(g,m)}))}},i.attribCache={};var q={};return i.scopeAttrib=function(i){if((i=g.id(i))in q)return q[i];var _=W.scope[i];return _||(_=W.scope[i]=new on),q[i]=m(_)},i}function Qe(i){var g,m=i.static;if(i=i.dynamic,"profile"in m){var _=!!m.profile;(g=Ut((function(i,g){return _}))).enable=_}else if("profile"in i){var b=i.profile;g=Gt(b,(function(i,g){return i.invoke(g,b)}))}return g}function Je(i,g){var m=i.static,_=i.dynamic;if("framebuffer"in m){var b=m.framebuffer;return b?(b=I.getFramebuffer(b),Ut((function(i,g){var m=i.link(b),_=i.shared;return g.set(_.framebuffer,".next",m),g.set(_=_.context,".framebufferWidth",m+".width"),g.set(_,".framebufferHeight",m+".height"),m}))):Ut((function(i,g){var m=i.shared;return g.set(m.framebuffer,".next","null"),g.set(m=m.context,".framebufferWidth",m+".drawingBufferWidth"),g.set(m,".framebufferHeight",m+".drawingBufferHeight"),"null"}))}if("framebuffer"in _){var T=_.framebuffer;return Gt(T,(function(i,g){var m=i.invoke(g,T),_=i.shared,b=_.framebuffer;return m=g.def(b,".getFramebuffer(",m,")"),g.set(b,".next",m),g.set(_=_.context,".framebufferWidth",m+"?"+m+".width:"+_+".drawingBufferWidth"),g.set(_,".framebufferHeight",m+"?"+m+".height:"+_+".drawingBufferHeight"),m}))}return null}function Ke(i,g,m){function _(i){if(i in b){var m=b[i];i=!0;var _,P,I=0|m.x,H=0|m.y;return"width"in m?_=0|m.width:i=!1,"height"in m?P=0|m.height:i=!1,new zt(!i&&g&&g.thisDep,!i&&g&&g.contextDep,!i&&g&&g.propDep,(function(i,g){var b=i.shared.context,T=_;"width"in m||(T=g.def(b,".","framebufferWidth","-",I));var W=P;return"height"in m||(W=g.def(b,".","framebufferHeight","-",H)),[I,H,T,W]}))}if(i in T){var W=T[i];return i=Gt(W,(function(i,g){var m=i.invoke(g,W),_=i.shared.context,b=g.def(m,".x|0"),T=g.def(m,".y|0");return[b,T,g.def('"width" in ',m,"?",m,".width|0:","(",_,".","framebufferWidth","-",b,")"),m=g.def('"height" in ',m,"?",m,".height|0:","(",_,".","framebufferHeight","-",T,")")]})),g&&(i.thisDep=i.thisDep||g.thisDep,i.contextDep=i.contextDep||g.contextDep,i.propDep=i.propDep||g.propDep),i}return g?new zt(g.thisDep,g.contextDep,g.propDep,(function(i,g){var m=i.shared.context;return[0,0,g.def(m,".","framebufferWidth"),g.def(m,".","framebufferHeight")]})):null}var b=i.static,T=i.dynamic;if(i=_("viewport")){var P=i;i=new zt(i.thisDep,i.contextDep,i.propDep,(function(i,g){var m=P.append(i,g),_=i.shared.context;return g.set(_,".viewportWidth",m[2]),g.set(_,".viewportHeight",m[3]),m}))}return{viewport:i,scissor_box:_("scissor.box")}}function tt(i,g){if("string"==typeof(m=i.static).frag&&"string"==typeof m.vert){if(0<Object.keys(g.dynamic).length)return null;var m=g.static,_=Object.keys(m);if(0<_.length&&"number"==typeof m[_[0]]){for(var b=[],T=0;T<_.length;++T)b.push([0|m[_[T]],_[T]]);return b}}return null}function at(i,m,_){function b(i){if(i in T){var m=g.id(T[i]);return(i=Ut((function(){return m}))).id=m,i}if(i in P){var _=P[i];return Gt(_,(function(i,g){var m=i.invoke(g,_);return g.def(i.shared.strings,".id(",m,")")}))}return null}var T=i.static,P=i.dynamic,I=b("frag"),H=b("vert"),W=null;return Vt(I)&&Vt(H)?(W=q.program(H.id,I.id,null,_),i=Ut((function(i,g){return i.link(W)}))):i=new zt(I&&I.thisDep||H&&H.thisDep,I&&I.contextDep||H&&H.contextDep,I&&I.propDep||H&&H.propDep,(function(i,g){var m,_,b=i.shared.shader;return m=I?I.append(i,g):g.def(b,".","frag"),_=H?H.append(i,g):g.def(b,".","vert"),g.def(b+".program("+_+","+m+")")})),{frag:I,vert:H,progVar:i,program:W}}function ht(i,g){function m(i,g){if(i in _){var m=0|_[i];return g?P.offset=m:P.instances=m,Ut((function(i,_){return g&&(i.OFFSET=m),m}))}if(i in b){var T=b[i];return Gt(T,(function(i,m){var _=i.invoke(m,T);return g&&(i.OFFSET=_),_}))}if(g){if(q)return Ut((function(i,g){return i.OFFSET=0}));if(I)return new zt(H.thisDep,H.contextDep,H.propDep,(function(i,g){return g.def(i.shared.vao+".currentVAO?"+i.shared.vao+".currentVAO.offset:0")}))}else if(I)return new zt(H.thisDep,H.contextDep,H.propDep,(function(i,g){return g.def(i.shared.vao+".currentVAO?"+i.shared.vao+".currentVAO.instances:-1")}));return null}var _=i.static,b=i.dynamic,P={},I=!1,H=function(){if("vao"in _){var i=_.vao;return null!==i&&null===W.getVAO(i)&&(i=W.createVAO(i)),I=!0,P.vao=i,Ut((function(g){var m=W.getVAO(i);return m?g.link(m):"null"}))}if("vao"in b){I=!0;var g=b.vao;return Gt(g,(function(i,m){var _=i.invoke(m,g);return m.def(i.shared.vao+".getVAO("+_+")")}))}return null}(),q=!1,$=function(){if("elements"in _){if(P.elements=g=_.elements,Ht(g)){var i=P.elements=T.create(g,!0),g=T.getElements(i);q=!0}else g&&(g=T.getElements(g),q=!0);return i=Ut((function(i,m){if(g){var _=i.link(g);return i.ELEMENTS=_}return i.ELEMENTS=null})),i.value=g,i}if("elements"in b){q=!0;var m=b.elements;return Gt(m,(function(i,g){var _=(b=i.shared).isBufferArgs,b=b.elements,T=i.invoke(g,m),P=g.def("null");return _=g.def(_,"(",T,")"),T=i.cond(_).then(P,"=",b,".createStream(",T,");").else(P,"=",b,".getElements(",T,");"),g.entry(T),g.exit(i.cond(_).then(b,".destroyStream(",P,");")),i.ELEMENTS=P}))}return I?new zt(H.thisDep,H.contextDep,H.propDep,(function(i,g){return g.def(i.shared.vao+".currentVAO?"+i.shared.elements+".getElements("+i.shared.vao+".currentVAO.elements):null")})):null}(),ye=m("offset",!0),Re=function(){if("primitive"in _){var i=_.primitive;return P.primitive=i,Ut((function(g,m){return hn[i]}))}if("primitive"in b){var g=b.primitive;return Gt(g,(function(i,m){var _=i.constants.primTypes,b=i.invoke(m,g);return m.def(_,"[",b,"]")}))}return q?Vt($)?Ut($.value?function(i,g){return g.def(i.ELEMENTS,".primType")}:function(){return 4}):new zt($.thisDep,$.contextDep,$.propDep,(function(i,g){var m=i.ELEMENTS;return g.def(m,"?",m,".primType:",4)})):I?new zt(H.thisDep,H.contextDep,H.propDep,(function(i,g){return g.def(i.shared.vao+".currentVAO?"+i.shared.vao+".currentVAO.primitive:4")})):null}(),Be=function(){if("count"in _){var i=0|_.count;return P.count=i,Ut((function(){return i}))}if("count"in b){var g=b.count;return Gt(g,(function(i,m){return i.invoke(m,g)}))}return q?Vt($)?$?ye?new zt(ye.thisDep,ye.contextDep,ye.propDep,(function(i,g){return g.def(i.ELEMENTS,".vertCount-",i.OFFSET)})):Ut((function(i,g){return g.def(i.ELEMENTS,".vertCount")})):Ut((function(){return-1})):new zt($.thisDep||ye.thisDep,$.contextDep||ye.contextDep,$.propDep||ye.propDep,(function(i,g){var m=i.ELEMENTS;return i.OFFSET?g.def(m,"?",m,".vertCount-",i.OFFSET,":-1"):g.def(m,"?",m,".vertCount:-1")})):I?new zt(H.thisDep,H.contextDep,H.propDep,(function(i,g){return g.def(i.shared.vao,".currentVAO?",i.shared.vao,".currentVAO.count:-1")})):null}(),Ge=m("instances",!1);return{elements:$,primitive:Re,count:Be,instances:Ge,offset:ye,vao:H,vaoActive:I,elementsActive:q,static:P}}function gt(i,g){var m=i.static,_=i.dynamic,b={};return dn.forEach((function(i){function g(g,P){if(i in m){var I=g(m[i]);b[T]=Ut((function(){return I}))}else if(i in _){var H=_[i];b[T]=Gt(H,(function(i,g){return P(i,g,i.invoke(g,H))}))}}var T=je(i);switch(i){case"cull.enable":case"blend.enable":case"dither":case"stencil.enable":case"depth.enable":case"scissor.enable":case"polygonOffset.enable":case"sample.alpha":case"sample.enable":case"depth.mask":case"lineWidth":return g((function(i){return i}),(function(i,g,m){return m}));case"depth.func":return g((function(i){return Ln[i]}),(function(i,g,m){return g.def(i.constants.compareFuncs,"[",m,"]")}));case"depth.range":return g((function(i){return i}),(function(i,g,m){return[g.def("+",m,"[0]"),g=g.def("+",m,"[1]")]}));case"blend.func":return g((function(i){return[Rn["srcRGB"in i?i.srcRGB:i.src],Rn["dstRGB"in i?i.dstRGB:i.dst],Rn["srcAlpha"in i?i.srcAlpha:i.src],Rn["dstAlpha"in i?i.dstAlpha:i.dst]]}),(function(i,g,m){function _(i,_){return g.def('"',i,_,'" in ',m,"?",m,".",i,_,":",m,".",i)}i=i.constants.blendFuncs;var b=_("src","RGB"),T=_("dst","RGB"),P=(b=g.def(i,"[",b,"]"),g.def(i,"[",_("src","Alpha"),"]"));return[b,T=g.def(i,"[",T,"]"),P,i=g.def(i,"[",_("dst","Alpha"),"]")]}));case"blend.equation":return g((function(i){return"string"==typeof i?[sn[i],sn[i]]:"object"==typeof i?[sn[i.rgb],sn[i.alpha]]:void 0}),(function(i,g,m){var _=i.constants.blendEquations,b=g.def(),T=g.def();return(i=i.cond("typeof ",m,'==="string"')).then(b,"=",T,"=",_,"[",m,"];"),i.else(b,"=",_,"[",m,".rgb];",T,"=",_,"[",m,".alpha];"),g(i),[b,T]}));case"blend.color":return g((function(i){return $(4,(function(g){return+i[g]}))}),(function(i,g,m){return $(4,(function(i){return g.def("+",m,"[",i,"]")}))}));case"stencil.mask":return g((function(i){return 0|i}),(function(i,g,m){return g.def(m,"|0")}));case"stencil.func":return g((function(i){return[Ln[i.cmp||"keep"],i.ref||0,"mask"in i?i.mask:-1]}),(function(i,g,m){return[i=g.def('"cmp" in ',m,"?",i.constants.compareFuncs,"[",m,".cmp]",":",7680),g.def(m,".ref|0"),g=g.def('"mask" in ',m,"?",m,".mask|0:-1")]}));case"stencil.opFront":case"stencil.opBack":return g((function(g){return["stencil.opBack"===i?1029:1028,Dn[g.fail||"keep"],Dn[g.zfail||"keep"],Dn[g.zpass||"keep"]]}),(function(g,m,_){function b(i){return m.def('"',i,'" in ',_,"?",T,"[",_,".",i,"]:",7680)}var T=g.constants.stencilOps;return["stencil.opBack"===i?1029:1028,b("fail"),b("zfail"),b("zpass")]}));case"polygonOffset.offset":return g((function(i){return[0|i.factor,0|i.units]}),(function(i,g,m){return[g.def(m,".factor|0"),g=g.def(m,".units|0")]}));case"cull.face":return g((function(i){var g=0;return"front"===i?g=1028:"back"===i&&(g=1029),g}),(function(i,g,m){return g.def(m,'==="front"?',1028,":",1029)}));case"frontFace":return g((function(i){return Fn[i]}),(function(i,g,m){return g.def(m+'==="cw"?2304:2305')}));case"colorMask":return g((function(i){return i.map((function(i){return!!i}))}),(function(i,g,m){return $(4,(function(i){return"!!"+m+"["+i+"]"}))}));case"sample.coverage":return g((function(i){return["value"in i?i.value:1,!!i.invert]}),(function(i,g,m){return[g.def('"value" in ',m,"?+",m,".value:1"),g=g.def("!!",m,".invert")]}))}})),b}function yt(i,g){var m=i.static,_=i.dynamic,b={};return Object.keys(m).forEach((function(i){var g,_=m[i];if("number"==typeof _||"boolean"==typeof _)g=Ut((function(){return _}));else if("function"==typeof _){var T=_._reglType;"texture2d"===T||"textureCube"===T?g=Ut((function(i){return i.link(_)})):"framebuffer"!==T&&"framebufferCube"!==T||(g=Ut((function(i){return i.link(_.color[0])})))}else et(_)&&(g=Ut((function(i){return i.global.def("[",$(_.length,(function(i){return _[i]})),"]")})));g.value=_,b[i]=g})),Object.keys(_).forEach((function(i){var g=_[i];b[i]=Gt(g,(function(i,m){return i.invoke(m,g)}))})),b}function vt(i,m){var _=i.static,T=i.dynamic,P={};return Object.keys(_).forEach((function(i){var m=_[i],T=g.id(i),I=new on;if(Ht(m))I.state=1,I.buffer=b.getBuffer(b.create(m,34962,!1,!0)),I.type=0;else if(W=b.getBuffer(m))I.state=1,I.buffer=W,I.type=0;else if("constant"in m){var H=m.constant;I.buffer="null",I.state=2,"number"==typeof H?I.x=H:On.forEach((function(i,g){g<H.length&&(I[i]=H[g])}))}else{var W=Ht(m.buffer)?b.getBuffer(b.create(m.buffer,34962,!1,!0)):b.getBuffer(m.buffer),q=0|m.offset,$=0|m.stride,ye=0|m.size,Re=!!m.normalized,Be=0;"type"in m&&(Be=rn[m.type]),m=0|m.divisor,I.buffer=W,I.state=1,I.size=ye,I.normalized=Re,I.type=Be||W.dtype,I.offset=q,I.stride=$,I.divisor=m}P[i]=Ut((function(i,g){var m=i.attribCache;if(T in m)return m[T];var _={isStream:!1};return Object.keys(I).forEach((function(i){_[i]=I[i]})),I.buffer&&(_.buffer=i.link(I.buffer),_.type=_.type||_.buffer+".dtype"),m[T]=_}))})),Object.keys(T).forEach((function(i){var g=T[i];P[i]=Gt(g,(function(i,m){function _(i){m(H[i],"=",b,".",i,"|0;")}var b=i.invoke(m,g),T=i.constants,P=(I=i.shared).isBufferArgs,I=I.buffer,H={isStream:m.def(!1)},W=new on;W.state=1,Object.keys(W).forEach((function(i){H[i]=m.def(""+W[i])}));var q=H.buffer,$=H.type;return m("if(",P,"(",b,")){",H.isStream,"=true;",q,"=",I,".createStream(",34962,",",b,");",$,"=",q,".dtype;","}else{",q,"=",I,".getBuffer(",b,");","if(",q,"){",$,"=",q,".dtype;",'}else if("constant" in ',b,"){",H.state,"=",2,";","if(typeof "+b+'.constant === "number"){',H[On[0]],"=",b,".constant;",On.slice(1).map((function(i){return H[i]})).join("="),"=0;","}else{",On.map((function(i,g){return H[i]+"="+b+".constant.length>"+g+"?"+b+".constant["+g+"]:0;"})).join(""),"}}else{","if(",P,"(",b,".buffer)){",q,"=",I,".createStream(",34962,",",b,".buffer);","}else{",q,"=",I,".getBuffer(",b,".buffer);","}",$,'="type" in ',b,"?",T.glTypes,"[",b,".type]:",q,".dtype;",H.normalized,"=!!",b,".normalized;"),_("size"),_("offset"),_("stride"),_("divisor"),m("}}"),m.exit("if(",H.isStream,"){",I,".destroyStream(",q,");","}"),H}))})),P}function xt(i){var g=i.static,m=i.dynamic,_={};return Object.keys(g).forEach((function(i){var m=g[i];_[i]=Ut((function(i,g){return"number"==typeof m||"boolean"==typeof m?""+m:i.link(m)}))})),Object.keys(m).forEach((function(i){var g=m[i];_[i]=Gt(g,(function(i,m){return i.invoke(m,g)}))})),_}function bt(i,g,_,b,T){function P(i){var g=H[i];g&&($[i]=g)}var I=tt(i,g),H=Ke(i,Re=Je(i)),q=ht(i),$=gt(i),ye=at(i,T,I);P("viewport"),P(je("scissor.box"));var Re,Be=0<Object.keys($).length;if((Re={framebuffer:Re,draw:q,shader:ye,state:$,dirty:Be,scopeVAO:null,drawVAO:null,useVAO:!1,attributes:{}}).profile=Qe(i),Re.uniforms=yt(_),Re.drawVAO=Re.scopeVAO=q.vao,!Re.drawVAO&&ye.program&&!I&&m.angle_instanced_arrays&&q.static.elements){var Ge=!0;if(i=ye.program.attributes.map((function(i){return i=g.static[i],Ge=Ge&&!!i,i})),Ge&&0<i.length){var Xe=W.getVAO(W.createVAO({attributes:i,elements:q.static.elements}));Re.drawVAO=new zt(null,null,null,(function(i,g){return i.link(Xe)})),Re.useVAO=!0}}return I?Re.useVAO=!0:Re.attributes=vt(g),Re.context=xt(b),Re}function Tt(i,g,m){var _=i.shared.context,b=i.scope();Object.keys(m).forEach((function(T){g.save(_,"."+T);var P=m[T].append(i,g);Array.isArray(P)?b(_,".",T,"=[",P.join(),"];"):b(_,".",T,"=",P,";")})),g(b)}function Mt(i,g,m,_){var b,T=(I=i.shared).gl,P=I.framebuffer;ln&&(b=g.def(I.extensions,".webgl_draw_buffers"));var I=(H=i.constants).drawBuffer,H=H.backBuffer;i=m?m.append(i,g):g.def(P,".next"),_||g("if(",i,"!==",P,".cur){"),g("if(",i,"){",T,".bindFramebuffer(",36160,",",i,".framebuffer);"),ln&&g(b,".drawBuffersWEBGL(",I,"[",i,".colorAttachments.length]);"),g("}else{",T,".bindFramebuffer(",36160,",null);"),ln&&g(b,".drawBuffersWEBGL(",H,");"),g("}",P,".cur=",i,";"),_||g("}")}function Pt(i,g,m){var _=i.shared,b=_.gl,T=i.current,P=i.next,I=_.current,H=_.next,W=i.cond(I,".dirty");dn.forEach((function(g){var _,q;if(!((g=je(g))in m.state))if(g in P){_=P[g],q=T[g];var ye=$(un[g].length,(function(i){return W.def(_,"[",i,"]")}));W(i.cond(ye.map((function(i,g){return i+"!=="+q+"["+g+"]"})).join("||")).then(b,".",gn[g],"(",ye,");",ye.map((function(i,g){return q+"["+g+"]="+i})).join(";"),";"))}else _=W.def(H,".",g),ye=i.cond(_,"!==",I,".",g),W(ye),g in pn?ye(i.cond(_).then(b,".enable(",pn[g],");").else(b,".disable(",pn[g],");"),I,".",g,"=",_,";"):ye(b,".",gn[g],"(",_,");",I,".",g,"=",_,";")})),0===Object.keys(m.state).length&&W(I,".dirty=false;"),g(W)}function It(i,g,m,_){var b=i.shared,T=i.current,P=b.current,I=b.gl;Bt(Object.keys(m)).forEach((function(b){var H=m[b];if(!_||_(H)){var W=H.append(i,g);if(pn[b]){var q=pn[b];Vt(H)?g(I,W?".enable(":".disable(",q,");"):g(i.cond(W).then(I,".enable(",q,");").else(I,".disable(",q,");")),g(P,".",b,"=",W,";")}else if(et(W)){var $=T[b];g(I,".",gn[b],"(",W,");",W.map((function(i,g){return $+"["+g+"]="+i})).join(";"),";")}else g(I,".",gn[b],"(",W,");",P,".",b,"=",W,";")}}))}function Et(i,g){an&&(i.instancing=g.def(i.shared.extensions,".angle_instanced_arrays"))}function Lt(i,g,m,_,b){function T(){return"undefined"==typeof performance?"Date.now()":"performance.now()"}function P(i){i(W=g.def(),"=",T(),";"),"string"==typeof b?i(ye,".count+=",b,";"):i(ye,".count++;"),Be&&(_?i(q=g.def(),"=",Ge,".getNumPendingQueries();"):i(Ge,".beginQuery(",ye,");"))}function I(i){i(ye,".cpuTime+=",T(),"-",W,";"),Be&&(_?i(Ge,".pushScopeStats(",q,",",Ge,".getNumPendingQueries(),",ye,");"):i(Ge,".endQuery();"))}function H(i){var m=g.def(Re,".profile");g(Re,".profile=",i,";"),g.exit(Re,".profile=",m,";")}var W,q,$=i.shared,ye=i.stats,Re=$.current,Ge=$.timer;if(m=m.profile){if(Vt(m))return void(m.enable?(P(g),I(g.exit),H("true")):H("false"));H(m=m.append(i,g))}else m=g.def(Re,".profile");P($=i.block()),g("if(",m,"){",$,"}"),I(i=i.block()),g.exit("if(",m,"){",i,"}")}function Dt(i,g,m,_,b){function T(i){switch(i){case 35664:case 35667:case 35671:return 2;case 35665:case 35668:case 35672:return 3;case 35666:case 35669:case 35673:return 4;default:return 1}}function P(m,_,b){function T(){g(H,".enableVertexAttribArray(",W,");");var m,T=b.type;m=b.size?g.def(b.size,"||",_):_,g(H,".bindBuffer(",34962,",",$,".buffer);",H,".vertexAttribPointer(",[W,m,T,b.normalized,b.stride,b.offset],");",q,".type=",T,";",q,".size=",m,";",Re.map((function(i){return q+"."+i+"="+b[i]+";"})).join("")),an&&g("if(",q,".divisor!==",T=b.divisor,"){",i.instancing,".vertexAttribDivisorANGLE(",[W,T],");",q,".divisor=",T,";}")}function P(){g("if(",q,".buffer){",H,".disableVertexAttribArray(",W,");",q,".buffer=null;","}if(",On.map((function(i,g){return q+"."+i+"!=="+ye[g]})).join("||"),"){",H,".vertexAttrib4f(",W,",",ye,");",On.map((function(i,g){return q+"."+i+"="+ye[g]+";"})).join(""),"}")}var H=I.gl,W=g.def(m,".location"),q=g.def(I.attributes,"[",W,"]"),$=b.buffer,ye=[b.x,b.y,b.z,b.w],Re=["buffer","normalized","offset","stride"];1===(m=b.state)?T():2===m?P():(g("if(",m,"===",1,"){"),T(),g("}else{"),P(),g("}"))}var I=i.shared;_.forEach((function(_){var I,H=_.name,W=m.attributes[H];if(W){if(!b(W))return;I=W.append(i,g)}else{if(!b(Nn))return;var q=i.scopeAttrib(H);I={},Object.keys(new on).forEach((function(i){I[i]=g.def(q,".",i)}))}P(i.link(_),T(_.info.type),I)}))}function jt(i,m,_,b,T,P){for(var I,H=i.shared,W=H.gl,q={},ye=0;ye<b.length;++ye){var Re=(Ze=b[ye]).name,Be=Ze.info.type,Ge=_.uniforms[Re];if(1<(Je=Ze.info.size)){if(!Ge)continue;var je=Re.replace("[0]","");if(q[je])continue;q[je]=1}var Xe,Ze=i.link(Ze)+".location";if(Ge){if(!T(Ge))continue;if(Vt(Ge)){if(Re=Ge.value,35678===Be||35680===Be)m(W,".uniform1i(",Ze,",",(Be=i.link(Re._texture||Re.color[0]._texture))+".bind());"),m.exit(Be,".unbind();");else if(35674===Be||35675===Be||35676===Be)Je=i.global.def("new Float32Array(["+Array.prototype.slice.call(Re)+"])"),Re=2,35675===Be?Re=3:35676===Be&&(Re=4),m(W,".uniformMatrix",Re,"fv(",Ze,",false,",Je,");");else{switch(Be){case 5126:I="1f";break;case 35664:I="2f";break;case 35665:I="3f";break;case 35666:I="4f";break;case 35670:case 5124:I="1i";break;case 35671:case 35667:I="2i";break;case 35672:case 35668:I="3i";break;case 35673:case 35669:I="4i"}1<Je?(I+="v",Re=i.global.def("["+Array.prototype.slice.call(Re)+"]")):Re=et(Re)?Array.prototype.slice.call(Re):Re,m(W,".uniform",I,"(",Ze,",",Re,");")}continue}Xe=Ge.append(i,m)}else{if(!T(Nn))continue;Xe=m.def(H.uniforms,"[",g.id(Re),"]")}switch(35678===Be?m("if(",Xe,"&&",Xe,'._reglType==="framebuffer"){',Xe,"=",Xe,".color[0];","}"):35680===Be&&m("if(",Xe,"&&",Xe,'._reglType==="framebufferCube"){',Xe,"=",Xe,".color[0];","}"),Re=1,Be){case 35678:case 35680:Be=m.def(Xe,"._texture"),m(W,".uniform1i(",Ze,",",Be,".bind());"),m.exit(Be,".unbind();");continue;case 5124:case 35670:I="1i";break;case 35667:case 35671:I="2i",Re=2;break;case 35668:case 35672:I="3i",Re=3;break;case 35669:case 35673:I="4i",Re=4;break;case 5126:I="1f";break;case 35664:I="2f",Re=2;break;case 35665:I="3f",Re=3;break;case 35666:I="4f",Re=4;break;case 35674:I="Matrix2fv";break;case 35675:I="Matrix3fv";break;case 35676:I="Matrix4fv"}if(-1===I.indexOf("Matrix")&&1<Je&&(I+="v",Re=1),"M"===I.charAt(0)){m(W,".uniform",I,"(",Ze,","),Ze=Math.pow(Be-35674+2,2);var Ye=i.global.def("new Float32Array(",Ze,")");Array.isArray(Xe)?m("false,(",$(Ze,(function(i){return Ye+"["+i+"]="+Xe[i]})),",",Ye,")"):m("false,(Array.isArray(",Xe,")||",Xe," instanceof Float32Array)?",Xe,":(",$(Ze,(function(i){return Ye+"["+i+"]="+Xe+"["+i+"]"})),",",Ye,")"),m(");")}else{if(1<Re){Be=[];for(var Qe=[],Je=0;Je<Re;++Je)Array.isArray(Xe)?Qe.push(Xe[Je]):Qe.push(m.def(Xe+"["+Je+"]")),P&&Be.push(m.def());P&&m("if(!",i.batchId,"||",Be.map((function(i,g){return i+"!=="+Qe[g]})).join("||"),"){",Be.map((function(i,g){return i+"="+Qe[g]+";"})).join("")),m(W,".uniform",I,"(",Ze,",",Qe.join(","),");")}else P&&(Be=m.def(),m("if(!",i.batchId,"||",Be,"!==",Xe,"){",Be,"=",Xe,";")),m(W,".uniform",I,"(",Ze,",",Xe,");");P&&m("}")}}}function Wt(i,g,m,_){function b(b){var T=ye[b];return T?T.append(i,T.contextDep&&_.contextDynamic||T.propDep?m:g):g.def($,".",b)}function T(){function i(){m(H,".drawElementsInstancedANGLE(",[Be,je,Xe,Ge+"<<(("+Xe+"-5121)>>1)",I],");")}function g(){m(H,".drawArraysInstancedANGLE(",[Be,Ge,je,I],");")}Re&&"null"!==Re?Ze?i():(m("if(",Re,"){"),i(),m("}else{"),g(),m("}")):g()}function P(){function i(){m(q+".drawElements("+[Be,je,Xe,Ge+"<<(("+Xe+"-5121)>>1)"]+");")}function g(){m(q+".drawArrays("+[Be,Ge,je]+");")}Re&&"null"!==Re?Ze?i():(m("if(",Re,"){"),i(),m("}else{"),g(),m("}")):g()}var I,H,W=i.shared,q=W.gl,$=W.draw,ye=_.draw,Re=function(){var b=ye.elements,T=g;return b?((b.contextDep&&_.contextDynamic||b.propDep)&&(T=m),b=b.append(i,T),ye.elementsActive&&T("if("+b+")"+q+".bindBuffer(34963,"+b+".buffer.buffer);")):(b=T.def(),T(b,"=",$,".","elements",";","if(",b,"){",q,".bindBuffer(",34963,",",b,".buffer.buffer);}","else if(",W.vao,".currentVAO){",b,"=",i.shared.elements+".getElements("+W.vao,".currentVAO.elements);",cn?"":"if("+b+")"+q+".bindBuffer(34963,"+b+".buffer.buffer);","}")),b}(),Be=b("primitive"),Ge=b("offset"),je=function(){var b=ye.count,T=g;return b?((b.contextDep&&_.contextDynamic||b.propDep)&&(T=m),b=b.append(i,T)):b=T.def($,".","count"),b}();if("number"==typeof je){if(0===je)return}else m("if(",je,"){"),m.exit("}");an&&(I=b("instances"),H=i.instancing);var Xe=Re+".type",Ze=ye.elements&&Vt(ye.elements)&&!ye.vaoActive;an&&("number"!=typeof I||0<=I)?"string"==typeof I?(m("if(",I,">0){"),T(),m("}else if(",I,"<0){"),P(),m("}")):T():P()}function Xt(i,g,m,_,b){return b=(g=Ye()).proc("body",b),an&&(g.instancing=b.def(g.shared.extensions,".angle_instanced_arrays")),i(g,b,m,_),g.compile().body}function $t(i,g,m,_){Et(i,g),m.useVAO?m.drawVAO?g(i.shared.vao,".setVAO(",m.drawVAO.append(i,g),");"):g(i.shared.vao,".setVAO(",i.shared.vao,".targetVAO);"):(g(i.shared.vao,".setVAO(null);"),Dt(i,g,m,_.attributes,(function(){return!0}))),jt(i,g,m,_.uniforms,(function(){return!0}),!1),Wt(i,g,g,m)}function Yt(i,g){var m=i.proc("draw",1);Et(i,m),Tt(i,m,g.context),Mt(i,m,g.framebuffer),Pt(i,m,g),It(i,m,g.state),Lt(i,m,g,!1,!0);var _=g.shader.progVar.append(i,m);if(m(i.shared.gl,".useProgram(",_,".program);"),g.shader.program)$t(i,m,g,g.shader.program);else{m(i.shared.vao,".setVAO(null);");var b=i.global.def("{}"),T=m.def(_,".id"),P=m.def(b,"[",T,"]");m(i.cond(P).then(P,".call(this,a0);").else(P,"=",b,"[",T,"]=",i.link((function(m){return Xt($t,i,g,m,1)})),"(",_,");",P,".call(this,a0);"))}0<Object.keys(g.state).length&&m(i.shared.current,".dirty=true;"),i.shared.vao&&m(i.shared.vao,".setVAO(null);")}function Qt(i,g,m,_){function b(){return!0}i.batchId="a1",Et(i,g),Dt(i,g,m,_.attributes,b),jt(i,g,m,_.uniforms,b,!1),Wt(i,g,g,m)}function Jt(i,g,m,_){function b(i){return i.contextDep&&P||i.propDep}function T(i){return!b(i)}Et(i,g);var P=m.contextDep,I=g.def(),H=g.def();i.shared.props=H,i.batchId=I;var W=i.scope(),q=i.scope();g(W.entry,"for(",I,"=0;",I,"<","a1",";++",I,"){",H,"=","a0","[",I,"];",q,"}",W.exit),m.needsContext&&Tt(i,q,m.context),m.needsFramebuffer&&Mt(i,q,m.framebuffer),It(i,q,m.state,b),m.profile&&b(m.profile)&&Lt(i,q,m,!1,!0),_?(m.useVAO?m.drawVAO?b(m.drawVAO)?q(i.shared.vao,".setVAO(",m.drawVAO.append(i,q),");"):W(i.shared.vao,".setVAO(",m.drawVAO.append(i,W),");"):W(i.shared.vao,".setVAO(",i.shared.vao,".targetVAO);"):(W(i.shared.vao,".setVAO(null);"),Dt(i,W,m,_.attributes,T),Dt(i,q,m,_.attributes,b)),jt(i,W,m,_.uniforms,T,!1),jt(i,q,m,_.uniforms,b,!0),Wt(i,W,q,m)):(g=i.global.def("{}"),_=m.shader.progVar.append(i,q),H=q.def(_,".id"),W=q.def(g,"[",H,"]"),q(i.shared.gl,".useProgram(",_,".program);","if(!",W,"){",W,"=",g,"[",H,"]=",i.link((function(g){return Xt(Qt,i,m,g,2)})),"(",_,");}",W,".call(this,a0[",I,"],",I,");"))}function Kt(i,g){function m(i){return i.contextDep&&b||i.propDep}var _=i.proc("batch",2);i.batchId="0",Et(i,_);var b=!1,T=!0;Object.keys(g.context).forEach((function(i){b=b||g.context[i].propDep})),b||(Tt(i,_,g.context),T=!1);var P=!1;if((I=g.framebuffer)?(I.propDep?b=P=!0:I.contextDep&&b&&(P=!0),P||Mt(i,_,I)):Mt(i,_,null),g.state.viewport&&g.state.viewport.propDep&&(b=!0),Pt(i,_,g),It(i,_,g.state,(function(i){return!m(i)})),g.profile&&m(g.profile)||Lt(i,_,g,!1,"a1"),g.contextDep=b,g.needsContext=T,g.needsFramebuffer=P,(T=g.shader.progVar).contextDep&&b||T.propDep)Jt(i,_,g,null);else if(T=T.append(i,_),_(i.shared.gl,".useProgram(",T,".program);"),g.shader.program)Jt(i,_,g,g.shader.program);else{_(i.shared.vao,".setVAO(null);");var I=i.global.def("{}"),H=(P=_.def(T,".id"),_.def(I,"[",P,"]"));_(i.cond(H).then(H,".call(this,a0,a1);").else(H,"=",I,"[",P,"]=",i.link((function(m){return Xt(Jt,i,g,m,2)})),"(",T,");",H,".call(this,a0,a1);"))}0<Object.keys(g.state).length&&_(i.shared.current,".dirty=true;"),i.shared.vao&&_(i.shared.vao,".setVAO(null);")}function en(i,m){function _(g){var _=m.shader[g];_&&b.set(T.shader,"."+g,_.append(i,b))}var b=i.proc("scope",3);i.batchId="a2";var T=i.shared,P=T.current;Tt(i,b,m.context),m.framebuffer&&m.framebuffer.append(i,b),Bt(Object.keys(m.state)).forEach((function(g){var _=m.state[g].append(i,b);et(_)?_.forEach((function(m,_){b.set(i.next[g],"["+_+"]",m)})):b.set(T.next,"."+g,_)})),Lt(i,b,m,!0,!0),["elements","offset","count","instances","primitive"].forEach((function(g){var _=m.draw[g];_&&b.set(T.draw,"."+g,""+_.append(i,b))})),Object.keys(m.uniforms).forEach((function(_){var P=m.uniforms[_].append(i,b);Array.isArray(P)&&(P="["+P.join()+"]"),b.set(T.uniforms,"["+g.id(_)+"]",P)})),Object.keys(m.attributes).forEach((function(g){var _=m.attributes[g].append(i,b),T=i.scopeAttrib(g);Object.keys(new on).forEach((function(i){b.set(T,"."+i,_[i])}))})),m.scopeVAO&&b.set(T.vao,".targetVAO",m.scopeVAO.append(i,b)),_("vert"),_("frag"),0<Object.keys(m.state).length&&(b(P,".dirty=true;"),b.exit(P,".dirty=true;")),b("a1(",i.shared.context,",a0,",i.batchId,");")}function tn(i){if("object"==typeof i&&!et(i)){for(var g=Object.keys(i),m=0;m<g.length;++m)if(Zt.isDynamic(i[g[m]]))return!0;return!1}}function nn(i,g,m){function _(i,g){P.forEach((function(m){var _=b[m];Zt.isDynamic(_)&&(_=i.invoke(g,_),g(q,".",m,"=",_,";"))}))}var b=g.static[m];if(b&&tn(b)){var T=i.global,P=Object.keys(b),I=!1,H=!1,W=!1,q=i.global.def("{}");P.forEach((function(g){var m=b[g];if(Zt.isDynamic(m))"function"==typeof m&&(m=b[g]=Zt.unbox(m)),g=Gt(m,null),I=I||g.thisDep,W=W||g.propDep,H=H||g.contextDep;else{switch(T(q,".",g,"="),typeof m){case"number":T(m);break;case"string":T('"',m,'"');break;case"object":Array.isArray(m)&&T("[",m.join(),"]");break;default:T(i.link(m))}T(";")}})),g.dynamic[m]=new Zt.DynamicVariable(4,{thisDep:I,contextDep:H,propDep:W,ref:q,append:_}),delete g.static[m]}}var on=W.Record,sn={add:32774,subtract:32778,"reverse subtract":32779};m.ext_blend_minmax&&(sn.min=32775,sn.max=32776);var an=m.angle_instanced_arrays,ln=m.webgl_draw_buffers,cn=m.oes_vertex_array_object,un={dirty:!0,profile:Ge.profile},fn={},dn=[],pn={},gn={};Xe("dither",3024),Xe("blend.enable",3042),Ze("blend.color","blendColor",[0,0,0,0]),Ze("blend.equation","blendEquationSeparate",[32774,32774]),Ze("blend.func","blendFuncSeparate",[1,0,1,0]),Xe("depth.enable",2929,!0),Ze("depth.func","depthFunc",513),Ze("depth.range","depthRange",[0,1]),Ze("depth.mask","depthMask",!0),Ze("colorMask","colorMask",[!0,!0,!0,!0]),Xe("cull.enable",2884),Ze("cull.face","cullFace",1029),Ze("frontFace","frontFace",2305),Ze("lineWidth","lineWidth",1),Xe("polygonOffset.enable",32823),Ze("polygonOffset.offset","polygonOffset",[0,0]),Xe("sample.alpha",32926),Xe("sample.enable",32928),Ze("sample.coverage","sampleCoverage",[1,!1]),Xe("stencil.enable",2960),Ze("stencil.mask","stencilMask",-1),Ze("stencil.func","stencilFunc",[519,0,-1]),Ze("stencil.opFront","stencilOpSeparate",[1028,7680,7680,7680]),Ze("stencil.opBack","stencilOpSeparate",[1029,7680,7680,7680]),Xe("scissor.enable",3089),Ze("scissor.box","scissor",[0,0,i.drawingBufferWidth,i.drawingBufferHeight]),Ze("viewport","viewport",[0,0,i.drawingBufferWidth,i.drawingBufferHeight]);var mn={gl:i,context:Re,strings:g,next:fn,current:un,draw:ye,elements:T,buffer:b,shader:q,attributes:W.state,vao:W,uniforms:H,framebuffer:I,extensions:m,timer:Be,isBufferArgs:Ht},An={primTypes:hn,compareFuncs:Ln,blendFuncs:Rn,blendEquations:sn,stencilOps:Dn,glTypes:rn,orientationType:Fn};ln&&(An.backBuffer=[1029],An.drawBuffer=$(_.maxDrawbuffers,(function(i){return 0===i?[0]:$(i,(function(i){return 36064+i}))})));var yn=0;return{next:fn,current:un,procs:function(){var i=Ye(),g=i.proc("poll"),b=i.proc("refresh"),T=i.block();g(T),b(T);var P,I=i.shared,H=I.gl,W=I.next,q=I.current;T(q,".dirty=false;"),Mt(i,g),Mt(i,b,null,!0),an&&(P=i.link(an)),m.oes_vertex_array_object&&b(i.link(m.oes_vertex_array_object),".bindVertexArrayOES(null);");for(var ye=0;ye<_.maxAttributes;++ye){var Re=b.def(I.attributes,"[",ye,"]"),Be=i.cond(Re,".buffer");Be.then(H,".enableVertexAttribArray(",ye,");",H,".bindBuffer(",34962,",",Re,".buffer.buffer);",H,".vertexAttribPointer(",ye,",",Re,".size,",Re,".type,",Re,".normalized,",Re,".stride,",Re,".offset);").else(H,".disableVertexAttribArray(",ye,");",H,".vertexAttrib4f(",ye,",",Re,".x,",Re,".y,",Re,".z,",Re,".w);",Re,".buffer=null;"),b(Be),an&&b(P,".vertexAttribDivisorANGLE(",ye,",",Re,".divisor);")}return b(i.shared.vao,".currentVAO=null;",i.shared.vao,".setVAO(",i.shared.vao,".targetVAO);"),Object.keys(pn).forEach((function(m){var _=pn[m],P=T.def(W,".",m),I=i.block();I("if(",P,"){",H,".enable(",_,")}else{",H,".disable(",_,")}",q,".",m,"=",P,";"),b(I),g("if(",P,"!==",q,".",m,"){",I,"}")})),Object.keys(gn).forEach((function(m){var _,P,I=gn[m],ye=un[m],Re=i.block();Re(H,".",I,"("),et(ye)?(I=ye.length,_=i.global.def(W,".",m),P=i.global.def(q,".",m),Re($(I,(function(i){return _+"["+i+"]"})),");",$(I,(function(i){return P+"["+i+"]="+_+"["+i+"];"})).join("")),g("if(",$(I,(function(i){return _+"["+i+"]!=="+P+"["+i+"]"})).join("||"),"){",Re,"}")):(_=T.def(W,".",m),P=T.def(q,".",m),Re(_,");",q,".",m,"=",_,";"),g("if(",_,"!==",P,"){",Re,"}")),b(Re)})),i.compile()}(),compile:function(i,g,m,_,b){var T=Ye();T.stats=T.link(b),Object.keys(g.static).forEach((function(i){nn(T,g,i)})),En.forEach((function(g){nn(T,i,g)}));var P=bt(i,g,m,_,T);return Yt(T,P),en(T,P),Kt(T,P),qt(T.compile(),{destroy:function(){P.shader.program.destroy()}})}}}function Wt(i,g){for(var m=0;m<i.length;++m)if(i[m]===g)return m;return-1}var qt=function(i,g){for(var m=Object.keys(g),_=0;_<m.length;++_)i[m[_]]=g[m[_]];return i},Xt=0,Zt={DynamicVariable:i,define:function(g,_){return new i(g,m(_+""))},isDynamic:function(g){return"function"==typeof g&&!g._reglType||g instanceof i},unbox:_,accessor:m},$t={next:"function"==typeof requestAnimationFrame?function(i){return requestAnimationFrame(i)}:function(i){return setTimeout(i,16)},cancel:"function"==typeof cancelAnimationFrame?function(i){return cancelAnimationFrame(i)}:clearTimeout},Yt="undefined"!=typeof performance&&performance.now?function(){return performance.now()}:function(){return+new Date},Qt=Re();Qt.zero=Re();var Jt=function(i,g){var m=1;g.ext_texture_filter_anisotropic&&(m=i.getParameter(34047));var _=1,b=1;g.webgl_draw_buffers&&(_=i.getParameter(34852),b=i.getParameter(36063));var T=!!g.oes_texture_float;if(T){T=i.createTexture(),i.bindTexture(3553,T),i.texImage2D(3553,0,6408,1,1,0,6408,5126,null);var P=i.createFramebuffer();if(i.bindFramebuffer(36160,P),i.framebufferTexture2D(36160,36064,3553,T,0),i.bindTexture(3553,null),36053!==i.checkFramebufferStatus(36160))T=!1;else{i.viewport(0,0,1,1),i.clearColor(1,0,0,1),i.clear(16384);var I=Qt.allocType(5126,4);i.readPixels(0,0,1,1,6408,5126,I),i.getError()?T=!1:(i.deleteFramebuffer(P),i.deleteTexture(T),T=1===I[0]),Qt.freeType(I)}}return I=!0,"undefined"!=typeof navigator&&(/MSIE/.test(navigator.userAgent)||/Trident\//.test(navigator.appVersion)||/Edge/.test(navigator.userAgent))||(I=i.createTexture(),P=Qt.allocType(5121,36),i.activeTexture(33984),i.bindTexture(34067,I),i.texImage2D(34069,0,6408,3,3,0,6408,5121,P),Qt.freeType(P),i.bindTexture(34067,null),i.deleteTexture(I),I=!i.getError()),{colorBits:[i.getParameter(3410),i.getParameter(3411),i.getParameter(3412),i.getParameter(3413)],depthBits:i.getParameter(3414),stencilBits:i.getParameter(3415),subpixelBits:i.getParameter(3408),extensions:Object.keys(g).filter((function(i){return!!g[i]})),maxAnisotropic:m,maxDrawbuffers:_,maxColorAttachments:b,pointSizeDims:i.getParameter(33901),lineWidthDims:i.getParameter(33902),maxViewportDims:i.getParameter(3386),maxCombinedTextureUnits:i.getParameter(35661),maxCubeMapSize:i.getParameter(34076),maxRenderbufferSize:i.getParameter(34024),maxTextureUnits:i.getParameter(34930),maxTextureSize:i.getParameter(3379),maxAttributes:i.getParameter(34921),maxVertexUniforms:i.getParameter(36347),maxVertexTextureUnits:i.getParameter(35660),maxVaryingVectors:i.getParameter(36348),maxFragmentUniforms:i.getParameter(36349),glsl:i.getParameter(35724),renderer:i.getParameter(7937),vendor:i.getParameter(7936),version:i.getParameter(7938),readFloat:T,npotTextureCube:I}},Kt=function(i){return i instanceof Uint8Array||i instanceof Uint16Array||i instanceof Uint32Array||i instanceof Int8Array||i instanceof Int16Array||i instanceof Int32Array||i instanceof Float32Array||i instanceof Float64Array||i instanceof Uint8ClampedArray},en=function(i){return Object.keys(i).map((function(g){return i[g]}))},tn={shape:function(i){for(var g=[];i.length;i=i[0])g.push(i.length);return g},flatten:function(i,g,m,_){var b=1;if(g.length)for(var T=0;T<g.length;++T)b*=g[T];else b=0;switch(m=_||Qt.allocType(m,b),g.length){case 0:break;case 1:for(_=g[0],g=0;g<_;++g)m[g]=i[g];break;case 2:for(_=g[0],g=g[1],T=b=0;T<_;++T)for(var P=i[T],I=0;I<g;++I)m[b++]=P[I];break;case 3:Ge(i,g[0],g[1],g[2],m,0);break;default:je(i,g,0,m,0)}return m}},nn={"[object Int8Array]":5120,"[object Int16Array]":5122,"[object Int32Array]":5124,"[object Uint8Array]":5121,"[object Uint8ClampedArray]":5121,"[object Uint16Array]":5123,"[object Uint32Array]":5125,"[object Float32Array]":5126,"[object Float64Array]":5121,"[object ArrayBuffer]":5121},rn={int8:5120,int16:5122,int32:5124,uint8:5121,uint16:5123,uint32:5125,float:5126,float32:5126},on={dynamic:35048,stream:35040,static:35044},sn=tn.flatten,an=tn.shape,ln=[];ln[5120]=1,ln[5122]=2,ln[5124]=4,ln[5121]=1,ln[5123]=2,ln[5125]=4,ln[5126]=4;var hn={points:0,point:0,lines:1,line:1,triangles:4,triangle:4,"line loop":2,"line strip":3,"triangle strip":5,"triangle fan":6},cn=new Float32Array(1),un=new Uint32Array(cn.buffer),fn=[9984,9986,9985,9987],dn=[0,6409,6410,6407,6408],pn={};pn[6409]=pn[6406]=pn[6402]=1,pn[34041]=pn[6410]=2,pn[6407]=pn[35904]=3,pn[6408]=pn[35906]=4;var gn=tt("HTMLCanvasElement"),mn=tt("OffscreenCanvas"),An=tt("CanvasRenderingContext2D"),yn=tt("ImageBitmap"),_n=tt("HTMLImageElement"),xn=tt("HTMLVideoElement"),bn=Object.keys(nn).concat([gn,mn,An,yn,_n,xn]),wn=[];wn[5121]=1,wn[5126]=4,wn[36193]=2,wn[5123]=2,wn[5125]=4;var Sn=[];Sn[32854]=2,Sn[32855]=2,Sn[36194]=2,Sn[34041]=4,Sn[33776]=.5,Sn[33777]=.5,Sn[33778]=1,Sn[33779]=1,Sn[35986]=.5,Sn[35987]=1,Sn[34798]=1,Sn[35840]=.5,Sn[35841]=.25,Sn[35842]=.5,Sn[35843]=.25,Sn[36196]=.5;var Mn=[];Mn[32854]=2,Mn[32855]=2,Mn[36194]=2,Mn[33189]=2,Mn[36168]=1,Mn[34041]=4,Mn[35056]=4,Mn[35907]=4,Mn[34836]=16,Mn[34842]=8,Mn[34843]=6;var Cn=function(i,g,m,_,b){function T(i){this.id=W++,this.refCount=1,this.renderbuffer=i,this.format=32854,this.height=this.width=0,b.profile&&(this.stats={size:0})}function P(g){var m=g.renderbuffer;i.bindRenderbuffer(36161,null),i.deleteRenderbuffer(m),g.renderbuffer=null,g.refCount=0,delete q[g.id],_.renderbufferCount--}var I={rgba4:32854,rgba8:32856,rgb565:36194,"rgb5 a1":32855,depth:33189,stencil:36168,"depth stencil":34041,"depth24 stencil8":35056};g.ext_srgb&&(I.srgba=35907),g.ext_color_buffer_half_float&&(I.rgba16f=34842,I.rgb16f=34843),g.webgl_color_buffer_float&&(I.rgba32f=34836);var H=[];Object.keys(I).forEach((function(i){H[I[i]]=i}));var W=0,q={};return T.prototype.decRef=function(){0>=--this.refCount&&P(this)},b.profile&&(_.getTotalRenderbufferSize=function(){var i=0;return Object.keys(q).forEach((function(g){i+=q[g].stats.size})),i}),{create:function(g,m){function P(g,m){var _=0,T=0,q=32854,$=0;if("object"==typeof g&&g?("shape"in g?(_=0|(T=g.shape)[0],T=0|T[1]):("radius"in g&&(_=T=0|g.radius),"width"in g&&(_=0|g.width),"height"in g&&(T=0|g.height)),"format"in g&&(q=I[g.format]),"samples"in g&&($=g.samples)):"number"==typeof g?(_=0|g,T="number"==typeof m?0|m:_):g||(_=T=1),_!==W.width||T!==W.height||q!==W.format)return P.width=W.width=_,P.height=W.height=T,P.samples=$,W.format=q,W.samples=$,i.bindRenderbuffer(36161,W.renderbuffer),$&&i.renderbufferStorageMultisample?i.renderbufferStorageMultisample(36161,$,q,_,T):i.renderbufferStorage(36161,q,_,T),b.profile&&(W.stats.size=Mn[W.format]*W.width*W.height),P.format=H[W.format],P}var W=new T(i.createRenderbuffer());return q[W.id]=W,_.renderbufferCount++,P(g,m),P.resize=function(g,m){var _=0|g,T=0|m||_;if(_===W.width&&T===W.height)return P;P.width=W.width=_,P.height=W.height=T;var I=P.samples;return i.bindRenderbuffer(36161,W.renderbuffer),I&&i.renderbufferStorageMultisample?i.renderbufferStorageMultisample(36161,I,W.format,_,T):i.renderbufferStorage(36161,W.format,_,T),b.profile&&(W.stats.size=Mn[W.format]*W.width*W.height),P},P._reglType="renderbuffer",P._renderbuffer=W,b.profile&&(P.stats=W.stats),P.destroy=function(){W.decRef()},P},clear:function(){en(q).forEach(P)},restore:function(){en(q).forEach((function(g){g.renderbuffer=i.createRenderbuffer(),i.bindRenderbuffer(36161,g.renderbuffer),g.samples&&i.renderbufferStorageMultisample?i.renderbufferStorageMultisample(36161,g.samples,g.format,g.width,g.height):i.renderbufferStorage(36161,g.format,g.width,g.height)})),i.bindRenderbuffer(36161,null)}}},Pn=[];Pn[6408]=4,Pn[6407]=3;var kn=[];kn[5121]=1,kn[5126]=4,kn[36193]=2;var On=["x","y","z","w"],En="blend.func blend.equation stencil.func stencil.opFront stencil.opBack sample.coverage viewport scissor.box polygonOffset.offset".split(" "),Rn={0:0,1:1,zero:0,one:1,"src color":768,"one minus src color":769,"src alpha":770,"one minus src alpha":771,"dst color":774,"one minus dst color":775,"dst alpha":772,"one minus dst alpha":773,"constant color":32769,"one minus constant color":32770,"constant alpha":32771,"one minus constant alpha":32772,"src alpha saturate":776},Ln={never:512,less:513,"<":513,equal:514,"=":514,"==":514,"===":514,lequal:515,"<=":515,greater:516,">":516,notequal:517,"!=":517,"!==":517,gequal:518,">=":518,always:519},Dn={0:0,zero:0,keep:7680,replace:7681,increment:7682,decrement:7683,"increment wrap":34055,"decrement wrap":34056,invert:5386},Fn={cw:2304,ccw:2305},Nn=new zt(!1,!1,!1,(function(){})),Hn=function(i,g){function m(){this.endQueryIndex=this.startQueryIndex=-1,this.sum=0,this.stats=null}function _(i,g,_){var b=P.pop()||new m;b.startQueryIndex=i,b.endQueryIndex=g,b.sum=0,b.stats=_,I.push(b)}if(!g.ext_disjoint_timer_query)return null;var b=[],T=[],P=[],I=[],H=[],W=[];return{beginQuery:function(i){var m=b.pop()||g.ext_disjoint_timer_query.createQueryEXT();g.ext_disjoint_timer_query.beginQueryEXT(35007,m),T.push(m),_(T.length-1,T.length,i)},endQuery:function(){g.ext_disjoint_timer_query.endQueryEXT(35007)},pushScopeStats:_,update:function(){var i,m;if(0!==(i=T.length)){W.length=Math.max(W.length,i+1),H.length=Math.max(H.length,i+1),H[0]=0;var _=W[0]=0;for(m=i=0;m<T.length;++m)g.ext_disjoint_timer_query.getQueryObjectEXT(q=T[m],34919)?(_+=g.ext_disjoint_timer_query.getQueryObjectEXT(q,34918),b.push(q)):T[i++]=q,H[m+1]=_,W[m+1]=i;for(T.length=i,m=i=0;m<I.length;++m){var q,$=(_=I[m]).startQueryIndex;_.sum+=H[q=_.endQueryIndex]-H[$],(q=W[q])===($=W[$])?(_.stats.gpuTime+=_.sum/1e6,P.push(_)):(_.startQueryIndex=$,_.endQueryIndex=q,I[i++]=_)}I.length=i}},getNumPendingQueries:function(){return T.length},clear:function(){b.push.apply(b,T);for(var i=0;i<b.length;i++)g.ext_disjoint_timer_query.deleteQueryEXT(b[i]);T.length=0,b.length=0},restore:function(){T.length=0,b.length=0}}};return function(i){function g(){if(0===Gt.length)tt&&tt.update(),en=null;else{en=$t.next(g),Re();for(var i=Gt.length-1;0<=i;--i){var m=Gt[i];m&&m(gt,null,0)}je.flush(),tt&&tt.update()}}function m(){!en&&0<Gt.length&&(en=$t.next(g))}function _(){en&&($t.cancel(g),en=null)}function T(i){i.preventDefault(),_(),Xt.forEach((function(i){i()}))}function P(i){je.getError(),Ze.restore(),Dt.restore(),xt.restore(),Ft.restore(),Ht.restore(),Bt.restore(),Lt.restore(),tt&&tt.restore(),zt.procs.refresh(),m(),Qt.forEach((function(i){i()}))}function I(i){function g(i,g){var m={},_={};return Object.keys(i).forEach((function(b){var T=i[b];if(Zt.isDynamic(T))_[b]=Zt.unbox(T,b);else{if(g&&Array.isArray(T))for(var P=0;P<T.length;++P)if(Zt.isDynamic(T[P]))return void(_[b]=Zt.unbox(T,b));m[b]=T}})),{dynamic:_,static:m}}function m(i){for(;$.length<i;)$.push(null);return $}var _=g(i.context||{},!0),b=g(i.uniforms||{},!0),T=g(i.attributes||{},!1);i=g(function(i){function g(i){if(i in m){var g=m[i];delete m[i],Object.keys(g).forEach((function(_){m[i+"."+_]=g[_]}))}}var m=qt({},i);return delete m.uniforms,delete m.attributes,delete m.context,delete m.vao,"stencil"in m&&m.stencil.op&&(m.stencil.opBack=m.stencil.opFront=m.stencil.op,delete m.stencil.op),g("blend"),g("depth"),g("cull"),g("stencil"),g("polygonOffset"),g("scissor"),g("sample"),"vao"in i&&(m.vao=i.vao),m}(i),!1);var P={gpuTime:0,cpuTime:0,count:0},I=zt.compile(i,T,b,_,P),H=I.draw,W=I.batch,q=I.scope,$=[];return qt((function(i,g){var _;if("function"==typeof i)return q.call(this,null,i,0);if("function"==typeof g)if("number"==typeof i)for(_=0;_<i;++_)q.call(this,null,g,_);else{if(!Array.isArray(i))return q.call(this,i,g,0);for(_=0;_<i.length;++_)q.call(this,i[_],g,_)}else if("number"==typeof i){if(0<i)return W.call(this,m(0|i),0|i)}else{if(!Array.isArray(i))return H.call(this,i);if(i.length)return W.call(this,i,i.length)}}),{stats:P,destroy:function(){I.destroy()}})}function H(i,g){var m=0;zt.procs.poll();var _=g.color;_&&(je.clearColor(+_[0]||0,+_[1]||0,+_[2]||0,+_[3]||0),m|=16384),"depth"in g&&(je.clearDepth(+g.depth),m|=256),"stencil"in g&&(je.clearStencil(0|g.stencil),m|=1024),je.clear(m)}function $(i){return Gt.push(i),m(),{cancel:function(){function g(){var i=Wt(Gt,g);Gt[i]=Gt[Gt.length-1],--Gt.length,0>=Gt.length&&_()}var m=Wt(Gt,i);Gt[m]=g}}}function ye(){var i=Vt.viewport,g=Vt.scissor_box;i[0]=i[1]=g[0]=g[1]=0,gt.viewportWidth=gt.framebufferWidth=gt.drawingBufferWidth=i[2]=g[2]=je.drawingBufferWidth,gt.viewportHeight=gt.framebufferHeight=gt.drawingBufferHeight=i[3]=g[3]=je.drawingBufferHeight}function Re(){gt.tick+=1,gt.time=Ge(),ye(),zt.procs.poll()}function Be(){Ft.refresh(),ye(),zt.procs.refresh(),tt&&tt.update()}function Ge(){return(Yt()-at)/1e3}if(!(i=W(i)))return null;var je=i.gl,Xe=je.getContextAttributes();je.isContextLost();var Ze=q(je,i);if(!Ze)return null;var Ye=b(),Ke={vaoCount:0,bufferCount:0,elementsCount:0,framebufferCount:0,shaderCount:0,textureCount:0,cubeCount:0,renderbufferCount:0,maxTextureUnits:0},et=Ze.extensions,tt=Hn(je,et),at=Yt(),ht=je.drawingBufferHeight,gt={tick:0,time:0,viewportWidth:yt=je.drawingBufferWidth,viewportHeight:ht,framebufferWidth:yt,framebufferHeight:ht,drawingBufferWidth:yt,drawingBufferHeight:ht,pixelRatio:i.pixelRatio},yt={elements:null,primitive:4,count:-1,offset:0,instances:-1},vt=Jt(je,et),xt=Qe(je,Ke,i,(function(i){return Lt.destroyBuffer(i)})),Mt=Je(je,et,xt,Ke),Lt=Pt(je,et,vt,Ke,xt,Mt,yt),Dt=It(je,Ye,Ke,i),Ft=bt(je,et,vt,(function(){zt.procs.poll()}),gt,Ke,i),Ht=Cn(je,et,vt,Ke,i),Bt=Tt(je,et,vt,Ft,Ht,Ke),zt=jt(je,Ye,et,vt,xt,Mt,Ft,Bt,{},Lt,Dt,yt,gt,tt,i),Vt=(Ye=Et(je,Bt,zt.procs.poll,gt),zt.next),Ut=je.canvas,Gt=[],Xt=[],Qt=[],Kt=[i.onDestroy],en=null;Ut&&(Ut.addEventListener("webglcontextlost",T,!1),Ut.addEventListener("webglcontextrestored",P,!1));var tn=Bt.setFBO=I({framebuffer:Zt.define.call(null,1,"framebuffer")});return Be(),Xe=qt(I,{clear:function(i){if("framebuffer"in i)if(i.framebuffer&&"framebufferCube"===i.framebuffer_reglType)for(var g=0;6>g;++g)tn(qt({framebuffer:i.framebuffer.faces[g]},i),H);else tn(i,H);else H(null,i)},prop:Zt.define.bind(null,1),context:Zt.define.bind(null,2),this:Zt.define.bind(null,3),draw:I({}),buffer:function(i){return xt.create(i,34962,!1,!1)},elements:function(i){return Mt.create(i,!1)},texture:Ft.create2D,cube:Ft.createCube,renderbuffer:Ht.create,framebuffer:Bt.create,framebufferCube:Bt.createCube,vao:Lt.createVAO,attributes:Xe,frame:$,on:function(i,g){var m;switch(i){case"frame":return $(g);case"lost":m=Xt;break;case"restore":m=Qt;break;case"destroy":m=Kt}return m.push(g),{cancel:function(){for(var i=0;i<m.length;++i)if(m[i]===g){m[i]=m[m.length-1],m.pop();break}}}},limits:vt,hasExtension:function(i){return 0<=vt.extensions.indexOf(i.toLowerCase())},read:Ye,destroy:function(){Gt.length=0,_(),Ut&&(Ut.removeEventListener("webglcontextlost",T),Ut.removeEventListener("webglcontextrestored",P)),Dt.clear(),Bt.clear(),Ht.clear(),Lt.clear(),Ft.clear(),Mt.clear(),xt.clear(),tt&&tt.clear(),Kt.forEach((function(i){i()}))},_gl:je,_refresh:Be,poll:function(){Re(),tt&&tt.update()},now:Ge,stats:Ke,blit:Bt.blit}),i.onDone(null,Xe),Xe}}()}(jm);var Wm=Gm(jm.exports),qm=1e-6,Xm="undefined"!=typeof Float32Array?Float32Array:Array,Zm=Math.random;var $m=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var i=0,g=arguments.length;g--;)i+=arguments[g]*arguments[g];return Math.sqrt(i)});var Ym=Object.freeze({__proto__:null,get ARRAY_TYPE(){return Xm},EPSILON:qm,RANDOM:Zm,equals:function(i,g){return Math.abs(i-g)<=qm*Math.max(1,Math.abs(i),Math.abs(g))},setMatrixArrayType:function(i){Xm=i},toRadian:function(i){return i*$m}});function Qm(i,g,m,_,b){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i}function Jm(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=m[0],H=m[1],W=m[2],q=m[3];return i[0]=_*I+T*H,i[1]=b*I+P*H,i[2]=_*W+T*q,i[3]=b*W+P*q,i}function Km(i,g){var m=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=m,i[2]=-m,i[3]=_,i}function eA(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i[3]=g[3]-m[3],i}var tA=Object.freeze({__proto__:null,LDU:function(i,g,m,_){return i[2]=_[2]/_[0],m[0]=_[0],m[1]=_[1],m[3]=_[3]-i[2]*m[1],[i,g,m]},add:function(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i[3]=g[3]+m[3],i},adjoint:function(i,g){var m=g[0];return i[0]=g[3],i[1]=-g[1],i[2]=-g[2],i[3]=m,i},clone:function(i){var g=new Xm(4);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g},copy:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i},create:function(){var i=new Xm(4);return Xm!=Float32Array&&(i[1]=0,i[2]=0),i[0]=1,i[3]=1,i},determinant:function(i){return i[0]*i[3]-i[2]*i[1]},equals:function(i,g){var m=i[0],_=i[1],b=i[2],T=i[3],P=g[0],I=g[1],H=g[2],W=g[3];return Math.abs(m-P)<=qm*Math.max(1,Math.abs(m),Math.abs(P))&&Math.abs(_-I)<=qm*Math.max(1,Math.abs(_),Math.abs(I))&&Math.abs(b-H)<=qm*Math.max(1,Math.abs(b),Math.abs(H))&&Math.abs(T-W)<=qm*Math.max(1,Math.abs(T),Math.abs(W))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]},frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3])},fromRotation:Km,fromScaling:function(i,g){return i[0]=g[0],i[1]=0,i[2]=0,i[3]=g[1],i},fromValues:function(i,g,m,_){var b=new Xm(4);return b[0]=i,b[1]=g,b[2]=m,b[3]=_,b},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=1,i},invert:function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=m*T-b*_;return P?(i[0]=T*(P=1/P),i[1]=-_*P,i[2]=-b*P,i[3]=m*P,i):null},mul:Jm,multiply:Jm,multiplyScalar:function(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i},multiplyScalarAndAdd:function(i,g,m,_){return i[0]=g[0]+m[0]*_,i[1]=g[1]+m[1]*_,i[2]=g[2]+m[2]*_,i[3]=g[3]+m[3]*_,i},rotate:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=Math.sin(m),H=Math.cos(m);return i[0]=_*H+T*I,i[1]=b*H+P*I,i[2]=_*-I+T*H,i[3]=b*-I+P*H,i},scale:function(i,g,m){var _=g[1],b=g[2],T=g[3],P=m[0],I=m[1];return i[0]=g[0]*P,i[1]=_*P,i[2]=b*I,i[3]=T*I,i},set:Qm,str:function(i){return"mat2("+i[0]+", "+i[1]+", "+i[2]+", "+i[3]+")"},sub:eA,subtract:eA,transpose:function(i,g){if(i===g){var m=g[1];i[1]=g[2],i[2]=m}else i[0]=g[0],i[1]=g[2],i[2]=g[1],i[3]=g[3];return i}});function nA(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=m[0],q=m[1],$=m[2],ye=m[3],Re=m[4],Be=m[5];return i[0]=_*W+T*q,i[1]=b*W+P*q,i[2]=_*$+T*ye,i[3]=b*$+P*ye,i[4]=_*Re+T*Be+I,i[5]=b*Re+P*Be+H,i}function rA(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i[3]=g[3]-m[3],i[4]=g[4]-m[4],i[5]=g[5]-m[5],i}var iA=Object.freeze({__proto__:null,add:function(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i[3]=g[3]+m[3],i[4]=g[4]+m[4],i[5]=g[5]+m[5],i},clone:function(i){var g=new Xm(6);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g},copy:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i},create:function(){var i=new Xm(6);return Xm!=Float32Array&&(i[1]=0,i[2]=0,i[4]=0,i[5]=0),i[0]=1,i[3]=1,i},determinant:function(i){return i[0]*i[3]-i[1]*i[2]},equals:function(i,g){var m=i[0],_=i[1],b=i[2],T=i[3],P=i[4],I=i[5],H=g[0],W=g[1],q=g[2],$=g[3],ye=g[4],Re=g[5];return Math.abs(m-H)<=qm*Math.max(1,Math.abs(m),Math.abs(H))&&Math.abs(_-W)<=qm*Math.max(1,Math.abs(_),Math.abs(W))&&Math.abs(b-q)<=qm*Math.max(1,Math.abs(b),Math.abs(q))&&Math.abs(T-$)<=qm*Math.max(1,Math.abs(T),Math.abs($))&&Math.abs(P-ye)<=qm*Math.max(1,Math.abs(P),Math.abs(ye))&&Math.abs(I-Re)<=qm*Math.max(1,Math.abs(I),Math.abs(Re))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]&&i[4]===g[4]&&i[5]===g[5]},frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3],i[4],i[5],1)},fromRotation:function(i,g){var m=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=m,i[2]=-m,i[3]=_,i[4]=0,i[5]=0,i},fromScaling:function(i,g){return i[0]=g[0],i[1]=0,i[2]=0,i[3]=g[1],i[4]=0,i[5]=0,i},fromTranslation:function(i,g){return i[0]=1,i[1]=0,i[2]=0,i[3]=1,i[4]=g[0],i[5]=g[1],i},fromValues:function(i,g,m,_,b,T){var P=new Xm(6);return P[0]=i,P[1]=g,P[2]=m,P[3]=_,P[4]=b,P[5]=T,P},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=1,i[4]=0,i[5]=0,i},invert:function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=m*T-_*b;return H?(i[0]=T*(H=1/H),i[1]=-_*H,i[2]=-b*H,i[3]=m*H,i[4]=(b*I-T*P)*H,i[5]=(_*P-m*I)*H,i):null},mul:nA,multiply:nA,multiplyScalar:function(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i[4]=g[4]*m,i[5]=g[5]*m,i},multiplyScalarAndAdd:function(i,g,m,_){return i[0]=g[0]+m[0]*_,i[1]=g[1]+m[1]*_,i[2]=g[2]+m[2]*_,i[3]=g[3]+m[3]*_,i[4]=g[4]+m[4]*_,i[5]=g[5]+m[5]*_,i},rotate:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=Math.sin(m),q=Math.cos(m);return i[0]=_*q+T*W,i[1]=b*q+P*W,i[2]=_*-W+T*q,i[3]=b*-W+P*q,i[4]=I,i[5]=H,i},scale:function(i,g,m){var _=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=m[0],W=m[1];return i[0]=g[0]*H,i[1]=_*H,i[2]=b*W,i[3]=T*W,i[4]=P,i[5]=I,i},set:function(i,g,m,_,b,T,P){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i[4]=T,i[5]=P,i},str:function(i){return"mat2d("+i[0]+", "+i[1]+", "+i[2]+", "+i[3]+", "+i[4]+", "+i[5]+")"},sub:rA,subtract:rA,translate:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=m[0],q=m[1];return i[0]=_,i[1]=b,i[2]=T,i[3]=P,i[4]=_*W+T*q+I,i[5]=b*W+P*q+H,i}});function oA(){var i=new Xm(9);return Xm!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[5]=0,i[6]=0,i[7]=0),i[0]=1,i[4]=1,i[8]=1,i}function sA(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[4],i[4]=g[5],i[5]=g[6],i[6]=g[8],i[7]=g[9],i[8]=g[10],i}function aA(i,g,m,_,b,T,P,I,H,W){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i[4]=T,i[5]=P,i[6]=I,i[7]=H,i[8]=W,i}function lA(i,g){if(i===g){var m=g[1],_=g[2],b=g[5];i[1]=g[3],i[2]=g[6],i[3]=m,i[5]=g[7],i[6]=_,i[7]=b}else i[0]=g[0],i[1]=g[3],i[2]=g[6],i[3]=g[1],i[4]=g[4],i[5]=g[7],i[6]=g[2],i[7]=g[5],i[8]=g[8];return i}function hA(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8],$=q*P-I*W,ye=-q*T+I*H,Re=W*T-P*H,Be=m*$+_*ye+b*Re;return Be?(i[0]=$*(Be=1/Be),i[1]=(-q*_+b*W)*Be,i[2]=(I*_-b*P)*Be,i[3]=ye*Be,i[4]=(q*m-b*H)*Be,i[5]=(-I*m+b*T)*Be,i[6]=Re*Be,i[7]=(-W*m+_*H)*Be,i[8]=(P*m-_*T)*Be,i):null}function cA(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=m[0],Re=m[1],Be=m[2],Ge=m[3],je=m[4],Xe=m[5],Ze=m[6],Ye=m[7],Qe=m[8];return i[0]=ye*_+Re*P+Be*W,i[1]=ye*b+Re*I+Be*q,i[2]=ye*T+Re*H+Be*$,i[3]=Ge*_+je*P+Xe*W,i[4]=Ge*b+je*I+Xe*q,i[5]=Ge*T+je*H+Xe*$,i[6]=Ze*_+Ye*P+Qe*W,i[7]=Ze*b+Ye*I+Qe*q,i[8]=Ze*T+Ye*H+Qe*$,i}function uA(i,g){var m=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=m,i[2]=0,i[3]=-m,i[4]=_,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i}function fA(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=m+m,I=_+_,H=b+b,W=m*P,q=_*P,$=_*I,ye=b*P,Re=b*I,Be=b*H,Ge=T*P,je=T*I,Xe=T*H;return i[0]=1-$-Be,i[3]=q-Xe,i[6]=ye+je,i[1]=q+Xe,i[4]=1-W-Be,i[7]=Re-Ge,i[2]=ye-je,i[5]=Re+Ge,i[8]=1-W-$,i}function dA(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i[3]=g[3]-m[3],i[4]=g[4]-m[4],i[5]=g[5]-m[5],i[6]=g[6]-m[6],i[7]=g[7]-m[7],i[8]=g[8]-m[8],i}var pA=Object.freeze({__proto__:null,add:function(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i[3]=g[3]+m[3],i[4]=g[4]+m[4],i[5]=g[5]+m[5],i[6]=g[6]+m[6],i[7]=g[7]+m[7],i[8]=g[8]+m[8],i},adjoint:function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8];return i[0]=P*q-I*W,i[1]=b*W-_*q,i[2]=_*I-b*P,i[3]=I*H-T*q,i[4]=m*q-b*H,i[5]=b*T-m*I,i[6]=T*W-P*H,i[7]=_*H-m*W,i[8]=m*P-_*T,i},clone:function(i){var g=new Xm(9);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g[8]=i[8],g},copy:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i},create:oA,determinant:function(i){var g=i[3],m=i[4],_=i[5],b=i[6],T=i[7],P=i[8];return i[0]*(P*m-_*T)+i[1]*(-P*g+_*b)+i[2]*(T*g-m*b)},equals:function(i,g){var m=i[0],_=i[1],b=i[2],T=i[3],P=i[4],I=i[5],H=i[6],W=i[7],q=i[8],$=g[0],ye=g[1],Re=g[2],Be=g[3],Ge=g[4],je=g[5],Xe=g[6],Ze=g[7],Ye=g[8];return Math.abs(m-$)<=qm*Math.max(1,Math.abs(m),Math.abs($))&&Math.abs(_-ye)<=qm*Math.max(1,Math.abs(_),Math.abs(ye))&&Math.abs(b-Re)<=qm*Math.max(1,Math.abs(b),Math.abs(Re))&&Math.abs(T-Be)<=qm*Math.max(1,Math.abs(T),Math.abs(Be))&&Math.abs(P-Ge)<=qm*Math.max(1,Math.abs(P),Math.abs(Ge))&&Math.abs(I-je)<=qm*Math.max(1,Math.abs(I),Math.abs(je))&&Math.abs(H-Xe)<=qm*Math.max(1,Math.abs(H),Math.abs(Xe))&&Math.abs(W-Ze)<=qm*Math.max(1,Math.abs(W),Math.abs(Ze))&&Math.abs(q-Ye)<=qm*Math.max(1,Math.abs(q),Math.abs(Ye))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]&&i[4]===g[4]&&i[5]===g[5]&&i[6]===g[6]&&i[7]===g[7]&&i[8]===g[8]},frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],i[8])},fromMat2d:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=0,i[3]=g[2],i[4]=g[3],i[5]=0,i[6]=g[4],i[7]=g[5],i[8]=1,i},fromMat4:sA,fromQuat:fA,fromRotation:uA,fromScaling:function(i,g){return i[0]=g[0],i[1]=0,i[2]=0,i[3]=0,i[4]=g[1],i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},fromTranslation:function(i,g){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=g[0],i[7]=g[1],i[8]=1,i},fromValues:function(i,g,m,_,b,T,P,I,H){var W=new Xm(9);return W[0]=i,W[1]=g,W[2]=m,W[3]=_,W[4]=b,W[5]=T,W[6]=P,W[7]=I,W[8]=H,W},identity:function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=1,i[5]=0,i[6]=0,i[7]=0,i[8]=1,i},invert:hA,mul:cA,multiply:cA,multiplyScalar:function(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i[4]=g[4]*m,i[5]=g[5]*m,i[6]=g[6]*m,i[7]=g[7]*m,i[8]=g[8]*m,i},multiplyScalarAndAdd:function(i,g,m,_){return i[0]=g[0]+m[0]*_,i[1]=g[1]+m[1]*_,i[2]=g[2]+m[2]*_,i[3]=g[3]+m[3]*_,i[4]=g[4]+m[4]*_,i[5]=g[5]+m[5]*_,i[6]=g[6]+m[6]*_,i[7]=g[7]+m[7]*_,i[8]=g[8]+m[8]*_,i},normalFromMat4:function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8],$=g[9],ye=g[10],Re=g[11],Be=g[12],Ge=g[13],je=g[14],Xe=g[15],Ze=m*I-_*P,Ye=m*H-b*P,Qe=m*W-T*P,Je=_*H-b*I,Ke=_*W-T*I,et=b*W-T*H,tt=q*Ge-$*Be,at=q*je-ye*Be,ht=q*Xe-Re*Be,gt=$*je-ye*Ge,yt=$*Xe-Re*Ge,vt=ye*Xe-Re*je,xt=Ze*vt-Ye*yt+Qe*gt+Je*ht-Ke*at+et*tt;return xt?(i[0]=(I*vt-H*yt+W*gt)*(xt=1/xt),i[1]=(H*ht-P*vt-W*at)*xt,i[2]=(P*yt-I*ht+W*tt)*xt,i[3]=(b*yt-_*vt-T*gt)*xt,i[4]=(m*vt-b*ht+T*at)*xt,i[5]=(_*ht-m*yt-T*tt)*xt,i[6]=(Ge*et-je*Ke+Xe*Je)*xt,i[7]=(je*Qe-Be*et-Xe*Ye)*xt,i[8]=(Be*Ke-Ge*Qe+Xe*Ze)*xt,i):null},projection:function(i,g,m){return i[0]=2/g,i[1]=0,i[2]=0,i[3]=0,i[4]=-2/m,i[5]=0,i[6]=-1,i[7]=1,i[8]=1,i},rotate:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=Math.sin(m),Re=Math.cos(m);return i[0]=Re*_+ye*P,i[1]=Re*b+ye*I,i[2]=Re*T+ye*H,i[3]=Re*P-ye*_,i[4]=Re*I-ye*b,i[5]=Re*H-ye*T,i[6]=W,i[7]=q,i[8]=$,i},scale:function(i,g,m){var _=m[0],b=m[1];return i[0]=_*g[0],i[1]=_*g[1],i[2]=_*g[2],i[3]=b*g[3],i[4]=b*g[4],i[5]=b*g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i},set:aA,str:function(i){return"mat3("+i[0]+", "+i[1]+", "+i[2]+", "+i[3]+", "+i[4]+", "+i[5]+", "+i[6]+", "+i[7]+", "+i[8]+")"},sub:dA,subtract:dA,translate:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=m[0],Re=m[1];return i[0]=_,i[1]=b,i[2]=T,i[3]=P,i[4]=I,i[5]=H,i[6]=ye*_+Re*P+W,i[7]=ye*b+Re*I+q,i[8]=ye*T+Re*H+$,i},transpose:lA});function gA(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15],i}function mA(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function AA(i,g){if(i===g){var m=g[1],_=g[2],b=g[3],T=g[6],P=g[7],I=g[11];i[1]=g[4],i[2]=g[8],i[3]=g[12],i[4]=m,i[6]=g[9],i[7]=g[13],i[8]=_,i[9]=T,i[11]=g[14],i[12]=b,i[13]=P,i[14]=I}else i[0]=g[0],i[1]=g[4],i[2]=g[8],i[3]=g[12],i[4]=g[1],i[5]=g[5],i[6]=g[9],i[7]=g[13],i[8]=g[2],i[9]=g[6],i[10]=g[10],i[11]=g[14],i[12]=g[3],i[13]=g[7],i[14]=g[11],i[15]=g[15];return i}function yA(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8],$=g[9],ye=g[10],Re=g[11],Be=g[12],Ge=g[13],je=g[14],Xe=g[15],Ze=m*I-_*P,Ye=m*H-b*P,Qe=m*W-T*P,Je=_*H-b*I,Ke=_*W-T*I,et=b*W-T*H,tt=q*Ge-$*Be,at=q*je-ye*Be,ht=q*Xe-Re*Be,gt=$*je-ye*Ge,yt=$*Xe-Re*Ge,vt=ye*Xe-Re*je,xt=Ze*vt-Ye*yt+Qe*gt+Je*ht-Ke*at+et*tt;return xt?(i[0]=(I*vt-H*yt+W*gt)*(xt=1/xt),i[1]=(b*yt-_*vt-T*gt)*xt,i[2]=(Ge*et-je*Ke+Xe*Je)*xt,i[3]=(ye*Ke-$*et-Re*Je)*xt,i[4]=(H*ht-P*vt-W*at)*xt,i[5]=(m*vt-b*ht+T*at)*xt,i[6]=(je*Qe-Be*et-Xe*Ye)*xt,i[7]=(q*et-ye*Qe+Re*Ye)*xt,i[8]=(P*yt-I*ht+W*tt)*xt,i[9]=(_*ht-m*yt-T*tt)*xt,i[10]=(Be*Ke-Ge*Qe+Xe*Ze)*xt,i[11]=($*Qe-q*Ke-Re*Ze)*xt,i[12]=(I*at-P*gt-H*tt)*xt,i[13]=(m*gt-_*at+b*tt)*xt,i[14]=(Ge*Ye-Be*Je-je*Ze)*xt,i[15]=(q*Je-$*Ye+ye*Ze)*xt,i):null}function _A(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=g[9],Re=g[10],Be=g[11],Ge=g[12],je=g[13],Xe=g[14],Ze=g[15],Ye=m[0],Qe=m[1],Je=m[2],Ke=m[3];return i[0]=Ye*_+Qe*I+Je*$+Ke*Ge,i[1]=Ye*b+Qe*H+Je*ye+Ke*je,i[2]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[3]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[4]=(Ye=m[4])*_+(Qe=m[5])*I+(Je=m[6])*$+(Ke=m[7])*Ge,i[5]=Ye*b+Qe*H+Je*ye+Ke*je,i[6]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[7]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[8]=(Ye=m[8])*_+(Qe=m[9])*I+(Je=m[10])*$+(Ke=m[11])*Ge,i[9]=Ye*b+Qe*H+Je*ye+Ke*je,i[10]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[11]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[12]=(Ye=m[12])*_+(Qe=m[13])*I+(Je=m[14])*$+(Ke=m[15])*Ge,i[13]=Ye*b+Qe*H+Je*ye+Ke*je,i[14]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[15]=Ye*P+Qe*q+Je*Be+Ke*Ze,i}function vA(i,g,m){var _,b,T,P,I,H,W,q,$,ye,Re,Be,Ge=m[0],je=m[1],Xe=m[2];return g===i?(i[12]=g[0]*Ge+g[4]*je+g[8]*Xe+g[12],i[13]=g[1]*Ge+g[5]*je+g[9]*Xe+g[13],i[14]=g[2]*Ge+g[6]*je+g[10]*Xe+g[14],i[15]=g[3]*Ge+g[7]*je+g[11]*Xe+g[15]):(b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=g[9],Re=g[10],Be=g[11],i[0]=_=g[0],i[1]=b,i[2]=T,i[3]=P,i[4]=I,i[5]=H,i[6]=W,i[7]=q,i[8]=$,i[9]=ye,i[10]=Re,i[11]=Be,i[12]=_*Ge+I*je+$*Xe+g[12],i[13]=b*Ge+H*je+ye*Xe+g[13],i[14]=T*Ge+W*je+Re*Xe+g[14],i[15]=P*Ge+q*je+Be*Xe+g[15]),i}function xA(i,g,m){var _=m[0],b=m[1],T=m[2];return i[0]=g[0]*_,i[1]=g[1]*_,i[2]=g[2]*_,i[3]=g[3]*_,i[4]=g[4]*b,i[5]=g[5]*b,i[6]=g[6]*b,i[7]=g[7]*b,i[8]=g[8]*T,i[9]=g[9]*T,i[10]=g[10]*T,i[11]=g[11]*T,i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15],i}function bA(i,g,m,_){var b,T,P,I,H,W,q,$,ye,Re,Be,Ge,je,Xe,Ze,Ye,Qe,Je,Ke,et,tt,at,ht,gt,yt=_[0],vt=_[1],xt=_[2],bt=Math.hypot(yt,vt,xt);return bt<qm?null:(yt*=bt=1/bt,vt*=bt,xt*=bt,b=Math.sin(m),T=Math.cos(m),H=g[1],W=g[2],q=g[3],ye=g[5],Re=g[6],Be=g[7],je=g[9],Xe=g[10],Ze=g[11],Ke=yt*vt*(P=1-T)-xt*b,et=vt*vt*P+T,tt=xt*vt*P+yt*b,at=yt*xt*P+vt*b,ht=vt*xt*P-yt*b,gt=xt*xt*P+T,i[0]=(I=g[0])*(Ye=yt*yt*P+T)+($=g[4])*(Qe=vt*yt*P+xt*b)+(Ge=g[8])*(Je=xt*yt*P-vt*b),i[1]=H*Ye+ye*Qe+je*Je,i[2]=W*Ye+Re*Qe+Xe*Je,i[3]=q*Ye+Be*Qe+Ze*Je,i[4]=I*Ke+$*et+Ge*tt,i[5]=H*Ke+ye*et+je*tt,i[6]=W*Ke+Re*et+Xe*tt,i[7]=q*Ke+Be*et+Ze*tt,i[8]=I*at+$*ht+Ge*gt,i[9]=H*at+ye*ht+je*gt,i[10]=W*at+Re*ht+Xe*gt,i[11]=q*at+Be*ht+Ze*gt,g!==i&&(i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i)}function wA(i,g){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=g[0],i[13]=g[1],i[14]=g[2],i[15]=1,i}function TA(i,g){return i[0]=g[0],i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=g[1],i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=g[2],i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function SA(i,g,m){var _,b,T,P=m[0],I=m[1],H=m[2],W=Math.hypot(P,I,H);return W<qm?null:(P*=W=1/W,I*=W,H*=W,_=Math.sin(g),b=Math.cos(g),i[0]=P*P*(T=1-b)+b,i[1]=I*P*T+H*_,i[2]=H*P*T-I*_,i[3]=0,i[4]=P*I*T-H*_,i[5]=I*I*T+b,i[6]=H*I*T+P*_,i[7]=0,i[8]=P*H*T+I*_,i[9]=I*H*T-P*_,i[10]=H*H*T+b,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i)}function MA(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=_+_,H=b+b,W=T+T,q=_*I,$=_*H,ye=_*W,Re=b*H,Be=b*W,Ge=T*W,je=P*I,Xe=P*H,Ze=P*W;return i[0]=1-(Re+Ge),i[1]=$+Ze,i[2]=ye-Xe,i[3]=0,i[4]=$-Ze,i[5]=1-(q+Ge),i[6]=Be+je,i[7]=0,i[8]=ye+Xe,i[9]=Be-je,i[10]=1-(q+Re),i[11]=0,i[12]=m[0],i[13]=m[1],i[14]=m[2],i[15]=1,i}function CA(i,g){return i[0]=g[12],i[1]=g[13],i[2]=g[14],i}function PA(i,g){var m=g[4],_=g[5],b=g[6],T=g[8],P=g[9],I=g[10];return i[0]=Math.hypot(g[0],g[1],g[2]),i[1]=Math.hypot(m,_,b),i[2]=Math.hypot(T,P,I),i}function kA(i,g){var m=new Xm(3);PA(m,g);var _=1/m[0],b=1/m[1],T=1/m[2],P=g[0]*_,I=g[1]*b,H=g[2]*T,W=g[4]*_,q=g[5]*b,$=g[6]*T,ye=g[8]*_,Re=g[9]*b,Be=g[10]*T,Ge=P+q+Be,je=0;return Ge>0?(je=2*Math.sqrt(Ge+1),i[3]=.25*je,i[0]=($-Re)/je,i[1]=(ye-H)/je,i[2]=(I-W)/je):P>q&&P>Be?(je=2*Math.sqrt(1+P-q-Be),i[3]=($-Re)/je,i[0]=.25*je,i[1]=(I+W)/je,i[2]=(ye+H)/je):q>Be?(je=2*Math.sqrt(1+q-P-Be),i[3]=(ye-H)/je,i[0]=(I+W)/je,i[1]=.25*je,i[2]=($+Re)/je):(je=2*Math.sqrt(1+Be-P-q),i[3]=(I-W)/je,i[0]=(ye+H)/je,i[1]=($+Re)/je,i[2]=.25*je),i}function OA(i,g,m,_){var b=g[0],T=g[1],P=g[2],I=g[3],H=b+b,W=T+T,q=P+P,$=b*H,ye=b*W,Re=b*q,Be=T*W,Ge=T*q,je=P*q,Xe=I*H,Ze=I*W,Ye=I*q,Qe=_[0],Je=_[1],Ke=_[2];return i[0]=(1-(Be+je))*Qe,i[1]=(ye+Ye)*Qe,i[2]=(Re-Ze)*Qe,i[3]=0,i[4]=(ye-Ye)*Je,i[5]=(1-($+je))*Je,i[6]=(Ge+Xe)*Je,i[7]=0,i[8]=(Re+Ze)*Ke,i[9]=(Ge-Xe)*Ke,i[10]=(1-($+Be))*Ke,i[11]=0,i[12]=m[0],i[13]=m[1],i[14]=m[2],i[15]=1,i}function EA(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=m+m,I=_+_,H=b+b,W=m*P,q=_*P,$=_*I,ye=b*P,Re=b*I,Be=b*H,Ge=T*P,je=T*I,Xe=T*H;return i[0]=1-$-Be,i[1]=q+Xe,i[2]=ye-je,i[3]=0,i[4]=q-Xe,i[5]=1-W-Be,i[6]=Re+Ge,i[7]=0,i[8]=ye+je,i[9]=Re-Ge,i[10]=1-W-$,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}function RA(i,g,m,_,b){var T,P=1/Math.tan(g/2);return i[0]=P/m,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=P,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=b&&b!==1/0?(i[10]=(b+_)*(T=1/(_-b)),i[14]=2*b*_*T):(i[10]=-1,i[14]=-2*_),i}var LA=RA;function DA(i,g,m,_,b,T,P){var I=1/(g-m),H=1/(_-b),W=1/(T-P);return i[0]=-2*I,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*H,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=2*W,i[11]=0,i[12]=(g+m)*I,i[13]=(b+_)*H,i[14]=(P+T)*W,i[15]=1,i}var FA=DA;function NA(i,g,m,_){var b,T,P,I,H,W,q,$,ye,Re,Be=g[0],Ge=g[1],je=g[2],Xe=_[0],Ze=_[1],Ye=_[2],Qe=m[0],Je=m[1],Ke=m[2];return Math.abs(Be-Qe)<qm&&Math.abs(Ge-Je)<qm&&Math.abs(je-Ke)<qm?mA(i):(q=Be-Qe,$=Ge-Je,ye=je-Ke,b=Ze*(ye*=Re=1/Math.hypot(q,$,ye))-Ye*($*=Re),T=Ye*(q*=Re)-Xe*ye,P=Xe*$-Ze*q,(Re=Math.hypot(b,T,P))?(b*=Re=1/Re,T*=Re,P*=Re):(b=0,T=0,P=0),I=$*P-ye*T,H=ye*b-q*P,W=q*T-$*b,(Re=Math.hypot(I,H,W))?(I*=Re=1/Re,H*=Re,W*=Re):(I=0,H=0,W=0),i[0]=b,i[1]=I,i[2]=q,i[3]=0,i[4]=T,i[5]=H,i[6]=$,i[7]=0,i[8]=P,i[9]=W,i[10]=ye,i[11]=0,i[12]=-(b*Be+T*Ge+P*je),i[13]=-(I*Be+H*Ge+W*je),i[14]=-(q*Be+$*Ge+ye*je),i[15]=1,i)}function HA(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i[3]=g[3]-m[3],i[4]=g[4]-m[4],i[5]=g[5]-m[5],i[6]=g[6]-m[6],i[7]=g[7]-m[7],i[8]=g[8]-m[8],i[9]=g[9]-m[9],i[10]=g[10]-m[10],i[11]=g[11]-m[11],i[12]=g[12]-m[12],i[13]=g[13]-m[13],i[14]=g[14]-m[14],i[15]=g[15]-m[15],i}function BA(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]&&i[4]===g[4]&&i[5]===g[5]&&i[6]===g[6]&&i[7]===g[7]&&i[8]===g[8]&&i[9]===g[9]&&i[10]===g[10]&&i[11]===g[11]&&i[12]===g[12]&&i[13]===g[13]&&i[14]===g[14]&&i[15]===g[15]}var zA=_A,VA=Object.freeze({__proto__:null,add:function(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i[3]=g[3]+m[3],i[4]=g[4]+m[4],i[5]=g[5]+m[5],i[6]=g[6]+m[6],i[7]=g[7]+m[7],i[8]=g[8]+m[8],i[9]=g[9]+m[9],i[10]=g[10]+m[10],i[11]=g[11]+m[11],i[12]=g[12]+m[12],i[13]=g[13]+m[13],i[14]=g[14]+m[14],i[15]=g[15]+m[15],i},adjoint:function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8],$=g[9],ye=g[10],Re=g[11],Be=g[12],Ge=g[13],je=g[14],Xe=g[15];return i[0]=I*(ye*Xe-Re*je)-$*(H*Xe-W*je)+Ge*(H*Re-W*ye),i[1]=-(_*(ye*Xe-Re*je)-$*(b*Xe-T*je)+Ge*(b*Re-T*ye)),i[2]=_*(H*Xe-W*je)-I*(b*Xe-T*je)+Ge*(b*W-T*H),i[3]=-(_*(H*Re-W*ye)-I*(b*Re-T*ye)+$*(b*W-T*H)),i[4]=-(P*(ye*Xe-Re*je)-q*(H*Xe-W*je)+Be*(H*Re-W*ye)),i[5]=m*(ye*Xe-Re*je)-q*(b*Xe-T*je)+Be*(b*Re-T*ye),i[6]=-(m*(H*Xe-W*je)-P*(b*Xe-T*je)+Be*(b*W-T*H)),i[7]=m*(H*Re-W*ye)-P*(b*Re-T*ye)+q*(b*W-T*H),i[8]=P*($*Xe-Re*Ge)-q*(I*Xe-W*Ge)+Be*(I*Re-W*$),i[9]=-(m*($*Xe-Re*Ge)-q*(_*Xe-T*Ge)+Be*(_*Re-T*$)),i[10]=m*(I*Xe-W*Ge)-P*(_*Xe-T*Ge)+Be*(_*W-T*I),i[11]=-(m*(I*Re-W*$)-P*(_*Re-T*$)+q*(_*W-T*I)),i[12]=-(P*($*je-ye*Ge)-q*(I*je-H*Ge)+Be*(I*ye-H*$)),i[13]=m*($*je-ye*Ge)-q*(_*je-b*Ge)+Be*(_*ye-b*$),i[14]=-(m*(I*je-H*Ge)-P*(_*je-b*Ge)+Be*(_*H-b*I)),i[15]=m*(I*ye-H*$)-P*(_*ye-b*$)+q*(_*H-b*I),i},clone:function(i){var g=new Xm(16);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g[8]=i[8],g[9]=i[9],g[10]=i[10],g[11]=i[11],g[12]=i[12],g[13]=i[13],g[14]=i[14],g[15]=i[15],g},copy:gA,create:function(){var i=new Xm(16);return Xm!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0),i[0]=1,i[5]=1,i[10]=1,i[15]=1,i},determinant:function(i){var g=i[0],m=i[1],_=i[2],b=i[3],T=i[4],P=i[5],I=i[6],H=i[7],W=i[8],q=i[9],$=i[10],ye=i[11],Re=i[12],Be=i[13],Ge=i[14],je=i[15];return(g*P-m*T)*($*je-ye*Ge)-(g*I-_*T)*(q*je-ye*Be)+(g*H-b*T)*(q*Ge-$*Be)+(m*I-_*P)*(W*je-ye*Re)-(m*H-b*P)*(W*Ge-$*Re)+(_*H-b*I)*(W*Be-q*Re)},equals:function(i,g){var m=i[0],_=i[1],b=i[2],T=i[3],P=i[4],I=i[5],H=i[6],W=i[7],q=i[8],$=i[9],ye=i[10],Re=i[11],Be=i[12],Ge=i[13],je=i[14],Xe=i[15],Ze=g[0],Ye=g[1],Qe=g[2],Je=g[3],Ke=g[4],et=g[5],tt=g[6],at=g[7],ht=g[8],gt=g[9],yt=g[10],vt=g[11],xt=g[12],bt=g[13],Tt=g[14],Mt=g[15];return Math.abs(m-Ze)<=qm*Math.max(1,Math.abs(m),Math.abs(Ze))&&Math.abs(_-Ye)<=qm*Math.max(1,Math.abs(_),Math.abs(Ye))&&Math.abs(b-Qe)<=qm*Math.max(1,Math.abs(b),Math.abs(Qe))&&Math.abs(T-Je)<=qm*Math.max(1,Math.abs(T),Math.abs(Je))&&Math.abs(P-Ke)<=qm*Math.max(1,Math.abs(P),Math.abs(Ke))&&Math.abs(I-et)<=qm*Math.max(1,Math.abs(I),Math.abs(et))&&Math.abs(H-tt)<=qm*Math.max(1,Math.abs(H),Math.abs(tt))&&Math.abs(W-at)<=qm*Math.max(1,Math.abs(W),Math.abs(at))&&Math.abs(q-ht)<=qm*Math.max(1,Math.abs(q),Math.abs(ht))&&Math.abs($-gt)<=qm*Math.max(1,Math.abs($),Math.abs(gt))&&Math.abs(ye-yt)<=qm*Math.max(1,Math.abs(ye),Math.abs(yt))&&Math.abs(Re-vt)<=qm*Math.max(1,Math.abs(Re),Math.abs(vt))&&Math.abs(Be-xt)<=qm*Math.max(1,Math.abs(Be),Math.abs(xt))&&Math.abs(Ge-bt)<=qm*Math.max(1,Math.abs(Ge),Math.abs(bt))&&Math.abs(je-Tt)<=qm*Math.max(1,Math.abs(je),Math.abs(Tt))&&Math.abs(Xe-Mt)<=qm*Math.max(1,Math.abs(Xe),Math.abs(Mt))},exactEquals:BA,frob:function(i){return Math.hypot(i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],i[8],i[9],i[10],i[11],i[12],i[13],i[14],i[15])},fromQuat:EA,fromQuat2:function(i,g){var m=new Xm(3),_=-g[0],b=-g[1],T=-g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=_*_+b*b+T*T+P*P;return $>0?(m[0]=2*(I*P+q*_+H*T-W*b)/$,m[1]=2*(H*P+q*b+W*_-I*T)/$,m[2]=2*(W*P+q*T+I*b-H*_)/$):(m[0]=2*(I*P+q*_+H*T-W*b),m[1]=2*(H*P+q*b+W*_-I*T),m[2]=2*(W*P+q*T+I*b-H*_)),MA(i,g,m),i},fromRotation:SA,fromRotationTranslation:MA,fromRotationTranslationScale:OA,fromRotationTranslationScaleOrigin:function(i,g,m,_,b){var T=g[0],P=g[1],I=g[2],H=g[3],W=T+T,q=P+P,$=I+I,ye=T*W,Re=T*q,Be=T*$,Ge=P*q,je=P*$,Xe=I*$,Ze=H*W,Ye=H*q,Qe=H*$,Je=_[0],Ke=_[1],et=_[2],tt=b[0],at=b[1],ht=b[2],gt=(1-(Ge+Xe))*Je,yt=(Re+Qe)*Je,vt=(Be-Ye)*Je,xt=(Re-Qe)*Ke,bt=(1-(ye+Xe))*Ke,Tt=(je+Ze)*Ke,Mt=(Be+Ye)*et,Pt=(je-Ze)*et,It=(1-(ye+Ge))*et;return i[0]=gt,i[1]=yt,i[2]=vt,i[3]=0,i[4]=xt,i[5]=bt,i[6]=Tt,i[7]=0,i[8]=Mt,i[9]=Pt,i[10]=It,i[11]=0,i[12]=m[0]+tt-(gt*tt+xt*at+Mt*ht),i[13]=m[1]+at-(yt*tt+bt*at+Pt*ht),i[14]=m[2]+ht-(vt*tt+Tt*at+It*ht),i[15]=1,i},fromScaling:TA,fromTranslation:wA,fromValues:function(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be,Ge){var je=new Xm(16);return je[0]=i,je[1]=g,je[2]=m,je[3]=_,je[4]=b,je[5]=T,je[6]=P,je[7]=I,je[8]=H,je[9]=W,je[10]=q,je[11]=$,je[12]=ye,je[13]=Re,je[14]=Be,je[15]=Ge,je},fromXRotation:function(i,g){var m=Math.sin(g),_=Math.cos(g);return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=_,i[6]=m,i[7]=0,i[8]=0,i[9]=-m,i[10]=_,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromYRotation:function(i,g){var m=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=0,i[2]=-m,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=m,i[9]=0,i[10]=_,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},fromZRotation:function(i,g){var m=Math.sin(g),_=Math.cos(g);return i[0]=_,i[1]=m,i[2]=0,i[3]=0,i[4]=-m,i[5]=_,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i},frustum:function(i,g,m,_,b,T,P){var I=1/(m-g),H=1/(b-_),W=1/(T-P);return i[0]=2*T*I,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=2*T*H,i[6]=0,i[7]=0,i[8]=(m+g)*I,i[9]=(b+_)*H,i[10]=(P+T)*W,i[11]=-1,i[12]=0,i[13]=0,i[14]=P*T*2*W,i[15]=0,i},getRotation:kA,getScaling:PA,getTranslation:CA,identity:mA,invert:yA,lookAt:NA,mul:zA,multiply:_A,multiplyScalar:function(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i[4]=g[4]*m,i[5]=g[5]*m,i[6]=g[6]*m,i[7]=g[7]*m,i[8]=g[8]*m,i[9]=g[9]*m,i[10]=g[10]*m,i[11]=g[11]*m,i[12]=g[12]*m,i[13]=g[13]*m,i[14]=g[14]*m,i[15]=g[15]*m,i},multiplyScalarAndAdd:function(i,g,m,_){return i[0]=g[0]+m[0]*_,i[1]=g[1]+m[1]*_,i[2]=g[2]+m[2]*_,i[3]=g[3]+m[3]*_,i[4]=g[4]+m[4]*_,i[5]=g[5]+m[5]*_,i[6]=g[6]+m[6]*_,i[7]=g[7]+m[7]*_,i[8]=g[8]+m[8]*_,i[9]=g[9]+m[9]*_,i[10]=g[10]+m[10]*_,i[11]=g[11]+m[11]*_,i[12]=g[12]+m[12]*_,i[13]=g[13]+m[13]*_,i[14]=g[14]+m[14]*_,i[15]=g[15]+m[15]*_,i},ortho:FA,orthoNO:DA,orthoZO:function(i,g,m,_,b,T,P){var I=1/(g-m),H=1/(_-b),W=1/(T-P);return i[0]=-2*I,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=-2*H,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=W,i[11]=0,i[12]=(g+m)*I,i[13]=(b+_)*H,i[14]=T*W,i[15]=1,i},perspective:LA,perspectiveFromFieldOfView:function(i,g,m,_){var b=Math.tan(g.upDegrees*Math.PI/180),T=Math.tan(g.downDegrees*Math.PI/180),P=Math.tan(g.leftDegrees*Math.PI/180),I=Math.tan(g.rightDegrees*Math.PI/180),H=2/(P+I),W=2/(b+T);return i[0]=H,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=W,i[6]=0,i[7]=0,i[8]=-(P-I)*H*.5,i[9]=(b-T)*W*.5,i[10]=_/(m-_),i[11]=-1,i[12]=0,i[13]=0,i[14]=_*m/(m-_),i[15]=0,i},perspectiveNO:RA,perspectiveZO:function(i,g,m,_,b){var T,P=1/Math.tan(g/2);return i[0]=P/m,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=P,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[11]=-1,i[12]=0,i[13]=0,i[15]=0,null!=b&&b!==1/0?(i[10]=b*(T=1/(_-b)),i[14]=b*_*T):(i[10]=-1,i[14]=-_),i},rotate:bA,rotateX:function(i,g,m){var _=Math.sin(m),b=Math.cos(m),T=g[4],P=g[5],I=g[6],H=g[7],W=g[8],q=g[9],$=g[10],ye=g[11];return g!==i&&(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[4]=T*b+W*_,i[5]=P*b+q*_,i[6]=I*b+$*_,i[7]=H*b+ye*_,i[8]=W*b-T*_,i[9]=q*b-P*_,i[10]=$*b-I*_,i[11]=ye*b-H*_,i},rotateY:function(i,g,m){var _=Math.sin(m),b=Math.cos(m),T=g[0],P=g[1],I=g[2],H=g[3],W=g[8],q=g[9],$=g[10],ye=g[11];return g!==i&&(i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[0]=T*b-W*_,i[1]=P*b-q*_,i[2]=I*b-$*_,i[3]=H*b-ye*_,i[8]=T*_+W*b,i[9]=P*_+q*b,i[10]=I*_+$*b,i[11]=H*_+ye*b,i},rotateZ:function(i,g,m){var _=Math.sin(m),b=Math.cos(m),T=g[0],P=g[1],I=g[2],H=g[3],W=g[4],q=g[5],$=g[6],ye=g[7];return g!==i&&(i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15]),i[0]=T*b+W*_,i[1]=P*b+q*_,i[2]=I*b+$*_,i[3]=H*b+ye*_,i[4]=W*b-T*_,i[5]=q*b-P*_,i[6]=$*b-I*_,i[7]=ye*b-H*_,i},scale:xA,set:function(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be,Ge,je){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i[4]=T,i[5]=P,i[6]=I,i[7]=H,i[8]=W,i[9]=q,i[10]=$,i[11]=ye,i[12]=Re,i[13]=Be,i[14]=Ge,i[15]=je,i},str:function(i){return"mat4("+i[0]+", "+i[1]+", "+i[2]+", "+i[3]+", "+i[4]+", "+i[5]+", "+i[6]+", "+i[7]+", "+i[8]+", "+i[9]+", "+i[10]+", "+i[11]+", "+i[12]+", "+i[13]+", "+i[14]+", "+i[15]+")"},sub:HA,subtract:HA,targetTo:function(i,g,m,_){var b=g[0],T=g[1],P=g[2],I=_[0],H=_[1],W=_[2],q=b-m[0],$=T-m[1],ye=P-m[2],Re=q*q+$*$+ye*ye;Re>0&&(q*=Re=1/Math.sqrt(Re),$*=Re,ye*=Re);var Be=H*ye-W*$,Ge=W*q-I*ye,je=I*$-H*q;return(Re=Be*Be+Ge*Ge+je*je)>0&&(Be*=Re=1/Math.sqrt(Re),Ge*=Re,je*=Re),i[0]=Be,i[1]=Ge,i[2]=je,i[3]=0,i[4]=$*je-ye*Ge,i[5]=ye*Be-q*je,i[6]=q*Ge-$*Be,i[7]=0,i[8]=q,i[9]=$,i[10]=ye,i[11]=0,i[12]=b,i[13]=T,i[14]=P,i[15]=1,i},translate:vA,transpose:AA});function UA(){var i=new Xm(3);return Xm!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i}function GA(i){return Math.hypot(i[0],i[1],i[2])}function jA(i,g,m){var _=new Xm(3);return _[0]=i,_[1]=g,_[2]=m,_}function WA(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i}function qA(i,g,m,_){return i[0]=g,i[1]=m,i[2]=_,i}function XA(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i}function ZA(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i}function $A(i,g,m){return i[0]=g[0]*m[0],i[1]=g[1]*m[1],i[2]=g[2]*m[2],i}function YA(i,g,m){return i[0]=g[0]/m[0],i[1]=g[1]/m[1],i[2]=g[2]/m[2],i}function QA(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i}function JA(i,g,m,_){return i[0]=g[0]+m[0]*_,i[1]=g[1]+m[1]*_,i[2]=g[2]+m[2]*_,i}function KA(i,g){return Math.hypot(g[0]-i[0],g[1]-i[1],g[2]-i[2])}function ey(i,g){var m=g[0]-i[0],_=g[1]-i[1],b=g[2]-i[2];return m*m+_*_+b*b}function ty(i){var g=i[0],m=i[1],_=i[2];return g*g+m*m+_*_}function ny(i,g){var m=g[0],_=g[1],b=g[2],T=m*m+_*_+b*b;return T>0&&(T=1/Math.sqrt(T)),i[0]=g[0]*T,i[1]=g[1]*T,i[2]=g[2]*T,i}function ry(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]}function iy(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[0],I=m[1],H=m[2];return i[0]=b*H-T*I,i[1]=T*P-_*H,i[2]=_*I-b*P,i}function oy(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[3]*_+m[7]*b+m[11]*T+m[15];return i[0]=(m[0]*_+m[4]*b+m[8]*T+m[12])/(P=P||1),i[1]=(m[1]*_+m[5]*b+m[9]*T+m[13])/P,i[2]=(m[2]*_+m[6]*b+m[10]*T+m[14])/P,i}function sy(i,g,m,_){var b=[],T=[];return b[0]=g[0]-m[0],b[1]=g[1]-m[1],b[2]=g[2]-m[2],T[0]=b[0]*Math.cos(_)-b[1]*Math.sin(_),T[1]=b[0]*Math.sin(_)+b[1]*Math.cos(_),T[2]=b[2],i[0]=T[0]+m[0],i[1]=T[1]+m[1],i[2]=T[2]+m[2],i}function ay(i,g){var m=i[0],_=i[1],b=i[2],T=g[0],P=g[1],I=g[2],H=Math.sqrt(m*m+_*_+b*b)*Math.sqrt(T*T+P*P+I*I),W=H&&ry(i,g)/H;return Math.acos(Math.min(Math.max(W,-1),1))}function ly(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]}function hy(i,g){var m=i[0],_=i[1],b=i[2],T=g[0],P=g[1],I=g[2];return Math.abs(m-T)<=qm*Math.max(1,Math.abs(m),Math.abs(T))&&Math.abs(_-P)<=qm*Math.max(1,Math.abs(_),Math.abs(P))&&Math.abs(b-I)<=qm*Math.max(1,Math.abs(b),Math.abs(I))}var cy=ZA,uy=$A,fy=YA,dy=KA,py=ey,gy=GA,my=ty,Ay=function(){var i=UA();return function(g,m,_,b,T,P){var I,H;for(m||(m=3),_||(_=0),H=b?Math.min(b*m+_,g.length):g.length,I=_;I<H;I+=m)i[0]=g[I],i[1]=g[I+1],i[2]=g[I+2],T(i,i,P),g[I]=i[0],g[I+1]=i[1],g[I+2]=i[2];return g}}(),yy=Object.freeze({__proto__:null,add:XA,angle:ay,bezier:function(i,g,m,_,b,T){var P=1-T,I=P*P,H=T*T,W=I*P,q=3*T*I,$=3*H*P,ye=H*T;return i[0]=g[0]*W+m[0]*q+_[0]*$+b[0]*ye,i[1]=g[1]*W+m[1]*q+_[1]*$+b[1]*ye,i[2]=g[2]*W+m[2]*q+_[2]*$+b[2]*ye,i},ceil:function(i,g){return i[0]=Math.ceil(g[0]),i[1]=Math.ceil(g[1]),i[2]=Math.ceil(g[2]),i},clone:function(i){var g=new Xm(3);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g},copy:WA,create:UA,cross:iy,dist:dy,distance:KA,div:fy,divide:YA,dot:ry,equals:hy,exactEquals:ly,floor:function(i,g){return i[0]=Math.floor(g[0]),i[1]=Math.floor(g[1]),i[2]=Math.floor(g[2]),i},forEach:Ay,fromValues:jA,hermite:function(i,g,m,_,b,T){var P=T*T,I=P*(2*T-3)+1,H=P*(T-2)+T,W=P*(T-1),q=P*(3-2*T);return i[0]=g[0]*I+m[0]*H+_[0]*W+b[0]*q,i[1]=g[1]*I+m[1]*H+_[1]*W+b[1]*q,i[2]=g[2]*I+m[2]*H+_[2]*W+b[2]*q,i},inverse:function(i,g){return i[0]=1/g[0],i[1]=1/g[1],i[2]=1/g[2],i},len:gy,length:GA,lerp:function(i,g,m,_){var b=g[0],T=g[1],P=g[2];return i[0]=b+_*(m[0]-b),i[1]=T+_*(m[1]-T),i[2]=P+_*(m[2]-P),i},max:function(i,g,m){return i[0]=Math.max(g[0],m[0]),i[1]=Math.max(g[1],m[1]),i[2]=Math.max(g[2],m[2]),i},min:function(i,g,m){return i[0]=Math.min(g[0],m[0]),i[1]=Math.min(g[1],m[1]),i[2]=Math.min(g[2],m[2]),i},mul:uy,multiply:$A,negate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i[2]=-g[2],i},normalize:ny,random:function(i,g){g=g||1;var m=2*Zm()*Math.PI,_=2*Zm()-1,b=Math.sqrt(1-_*_)*g;return i[0]=Math.cos(m)*b,i[1]=Math.sin(m)*b,i[2]=_*g,i},rotateX:function(i,g,m,_){var b=[],T=[];return b[0]=g[0]-m[0],b[1]=g[1]-m[1],b[2]=g[2]-m[2],T[0]=b[0],T[1]=b[1]*Math.cos(_)-b[2]*Math.sin(_),T[2]=b[1]*Math.sin(_)+b[2]*Math.cos(_),i[0]=T[0]+m[0],i[1]=T[1]+m[1],i[2]=T[2]+m[2],i},rotateY:function(i,g,m,_){var b=[],T=[];return b[0]=g[0]-m[0],b[1]=g[1]-m[1],b[2]=g[2]-m[2],T[0]=b[2]*Math.sin(_)+b[0]*Math.cos(_),T[1]=b[1],T[2]=b[2]*Math.cos(_)-b[0]*Math.sin(_),i[0]=T[0]+m[0],i[1]=T[1]+m[1],i[2]=T[2]+m[2],i},rotateZ:sy,round:function(i,g){return i[0]=Math.round(g[0]),i[1]=Math.round(g[1]),i[2]=Math.round(g[2]),i},scale:QA,scaleAndAdd:JA,set:qA,sqrDist:py,sqrLen:my,squaredDistance:ey,squaredLength:ty,str:function(i){return"vec3("+i[0]+", "+i[1]+", "+i[2]+")"},sub:cy,subtract:ZA,transformMat3:function(i,g,m){var _=g[0],b=g[1],T=g[2];return i[0]=_*m[0]+b*m[3]+T*m[6],i[1]=_*m[1]+b*m[4]+T*m[7],i[2]=_*m[2]+b*m[5]+T*m[8],i},transformMat4:oy,transformQuat:function(i,g,m){var _=m[0],b=m[1],T=m[2],P=g[0],I=g[1],H=g[2],W=b*H-T*I,q=T*P-_*H,$=_*I-b*P,ye=b*$-T*q,Re=T*W-_*$,Be=_*q-b*W,Ge=2*m[3];return q*=Ge,$*=Ge,Re*=2,Be*=2,i[0]=P+(W*=Ge)+(ye*=2),i[1]=I+q+Re,i[2]=H+$+Be,i},zero:function(i){return i[0]=0,i[1]=0,i[2]=0,i}});function _y(){var i=new Xm(4);return Xm!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0),i}function vy(i){var g=new Xm(4);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g}function xy(i,g,m,_){var b=new Xm(4);return b[0]=i,b[1]=g,b[2]=m,b[3]=_,b}function by(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i}function wy(i,g,m,_,b){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i}function Ty(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i[3]=g[3]+m[3],i}function Sy(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i[3]=g[3]-m[3],i}function My(i,g,m){return i[0]=g[0]*m[0],i[1]=g[1]*m[1],i[2]=g[2]*m[2],i[3]=g[3]*m[3],i}function Cy(i,g,m){return i[0]=g[0]/m[0],i[1]=g[1]/m[1],i[2]=g[2]/m[2],i[3]=g[3]/m[3],i}function Py(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i}function Iy(i,g){return Math.hypot(g[0]-i[0],g[1]-i[1],g[2]-i[2],g[3]-i[3])}function ky(i,g){var m=g[0]-i[0],_=g[1]-i[1],b=g[2]-i[2],T=g[3]-i[3];return m*m+_*_+b*b+T*T}function Oy(i){return Math.hypot(i[0],i[1],i[2],i[3])}function Ey(i){var g=i[0],m=i[1],_=i[2],b=i[3];return g*g+m*m+_*_+b*b}function Ry(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=m*m+_*_+b*b+T*T;return P>0&&(P=1/Math.sqrt(P)),i[0]=m*P,i[1]=_*P,i[2]=b*P,i[3]=T*P,i}function Ly(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]+i[3]*g[3]}function Dy(i,g,m,_){var b=g[0],T=g[1],P=g[2],I=g[3];return i[0]=b+_*(m[0]-b),i[1]=T+_*(m[1]-T),i[2]=P+_*(m[2]-P),i[3]=I+_*(m[3]-I),i}function Fy(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3];return i[0]=m[0]*_+m[4]*b+m[8]*T+m[12]*P,i[1]=m[1]*_+m[5]*b+m[9]*T+m[13]*P,i[2]=m[2]*_+m[6]*b+m[10]*T+m[14]*P,i[3]=m[3]*_+m[7]*b+m[11]*T+m[15]*P,i}function Ny(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]}function Hy(i,g){var m=i[0],_=i[1],b=i[2],T=i[3],P=g[0],I=g[1],H=g[2],W=g[3];return Math.abs(m-P)<=qm*Math.max(1,Math.abs(m),Math.abs(P))&&Math.abs(_-I)<=qm*Math.max(1,Math.abs(_),Math.abs(I))&&Math.abs(b-H)<=qm*Math.max(1,Math.abs(b),Math.abs(H))&&Math.abs(T-W)<=qm*Math.max(1,Math.abs(T),Math.abs(W))}var By=Sy,zy=My,Vy=Cy,Uy=Iy,Gy=ky,jy=Oy,Wy=Ey,qy=function(){var i=_y();return function(g,m,_,b,T,P){var I,H;for(m||(m=4),_||(_=0),H=b?Math.min(b*m+_,g.length):g.length,I=_;I<H;I+=m)i[0]=g[I],i[1]=g[I+1],i[2]=g[I+2],i[3]=g[I+3],T(i,i,P),g[I]=i[0],g[I+1]=i[1],g[I+2]=i[2],g[I+3]=i[3];return g}}(),Xy=Object.freeze({__proto__:null,add:Ty,ceil:function(i,g){return i[0]=Math.ceil(g[0]),i[1]=Math.ceil(g[1]),i[2]=Math.ceil(g[2]),i[3]=Math.ceil(g[3]),i},clone:vy,copy:by,create:_y,cross:function(i,g,m,_){var b=m[0]*_[1]-m[1]*_[0],T=m[0]*_[2]-m[2]*_[0],P=m[0]*_[3]-m[3]*_[0],I=m[1]*_[2]-m[2]*_[1],H=m[1]*_[3]-m[3]*_[1],W=m[2]*_[3]-m[3]*_[2],q=g[0],$=g[1],ye=g[2],Re=g[3];return i[0]=$*W-ye*H+Re*I,i[1]=-q*W+ye*P-Re*T,i[2]=q*H-$*P+Re*b,i[3]=-q*I+$*T-ye*b,i},dist:Uy,distance:Iy,div:Vy,divide:Cy,dot:Ly,equals:Hy,exactEquals:Ny,floor:function(i,g){return i[0]=Math.floor(g[0]),i[1]=Math.floor(g[1]),i[2]=Math.floor(g[2]),i[3]=Math.floor(g[3]),i},forEach:qy,fromValues:xy,inverse:function(i,g){return i[0]=1/g[0],i[1]=1/g[1],i[2]=1/g[2],i[3]=1/g[3],i},len:jy,length:Oy,lerp:Dy,max:function(i,g,m){return i[0]=Math.max(g[0],m[0]),i[1]=Math.max(g[1],m[1]),i[2]=Math.max(g[2],m[2]),i[3]=Math.max(g[3],m[3]),i},min:function(i,g,m){return i[0]=Math.min(g[0],m[0]),i[1]=Math.min(g[1],m[1]),i[2]=Math.min(g[2],m[2]),i[3]=Math.min(g[3],m[3]),i},mul:zy,multiply:My,negate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i[2]=-g[2],i[3]=-g[3],i},normalize:Ry,random:function(i,g){var m,_,b,T,P,I;g=g||1;do{P=(m=2*Zm()-1)*m+(_=2*Zm()-1)*_}while(P>=1);do{I=(b=2*Zm()-1)*b+(T=2*Zm()-1)*T}while(I>=1);var H=Math.sqrt((1-P)/I);return i[0]=g*m,i[1]=g*_,i[2]=g*b*H,i[3]=g*T*H,i},round:function(i,g){return i[0]=Math.round(g[0]),i[1]=Math.round(g[1]),i[2]=Math.round(g[2]),i[3]=Math.round(g[3]),i},scale:Py,scaleAndAdd:function(i,g,m,_){return i[0]=g[0]+m[0]*_,i[1]=g[1]+m[1]*_,i[2]=g[2]+m[2]*_,i[3]=g[3]+m[3]*_,i},set:wy,sqrDist:Gy,sqrLen:Wy,squaredDistance:ky,squaredLength:Ey,str:function(i){return"vec4("+i[0]+", "+i[1]+", "+i[2]+", "+i[3]+")"},sub:By,subtract:Sy,transformMat4:Fy,transformQuat:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[0],I=m[1],H=m[2],W=m[3],q=W*_+I*T-H*b,$=W*b+H*_-P*T,ye=W*T+P*b-I*_,Re=-P*_-I*b-H*T;return i[0]=q*W+Re*-P+$*-H-ye*-I,i[1]=$*W+Re*-I+ye*-P-q*-H,i[2]=ye*W+Re*-H+q*-I-$*-P,i[3]=g[3],i},zero:function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=0,i}});function Zy(){var i=new Xm(4);return Xm!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i[3]=1,i}function $y(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i}function Yy(i,g,m){m*=.5;var _=Math.sin(m);return i[0]=_*g[0],i[1]=_*g[1],i[2]=_*g[2],i[3]=Math.cos(m),i}function Qy(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=m[0],H=m[1],W=m[2],q=m[3];return i[0]=_*q+P*I+b*W-T*H,i[1]=b*q+P*H+T*I-_*W,i[2]=T*q+P*W+_*H-b*I,i[3]=P*q-_*I-b*H-T*W,i}function Jy(i,g,m){m*=.5;var _=g[0],b=g[1],T=g[2],P=g[3],I=Math.sin(m),H=Math.cos(m);return i[0]=_*H+P*I,i[1]=b*H+T*I,i[2]=T*H-b*I,i[3]=P*H-_*I,i}function Ky(i,g,m){m*=.5;var _=g[0],b=g[1],T=g[2],P=g[3],I=Math.sin(m),H=Math.cos(m);return i[0]=_*H-T*I,i[1]=b*H+P*I,i[2]=T*H+_*I,i[3]=P*H-b*I,i}function e_(i,g,m){m*=.5;var _=g[0],b=g[1],T=g[2],P=g[3],I=Math.sin(m),H=Math.cos(m);return i[0]=_*H+b*I,i[1]=b*H-_*I,i[2]=T*H+P*I,i[3]=P*H-T*I,i}function t_(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=Math.sqrt(m*m+_*_+b*b),I=Math.exp(T),H=P>0?I*Math.sin(P)/P:0;return i[0]=m*H,i[1]=_*H,i[2]=b*H,i[3]=I*Math.cos(P),i}function n_(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=Math.sqrt(m*m+_*_+b*b),I=P>0?Math.atan2(P,T)/P:0;return i[0]=m*I,i[1]=_*I,i[2]=b*I,i[3]=.5*Math.log(m*m+_*_+b*b+T*T),i}function r_(i,g,m,_){var b,T,P,I,H,W=g[0],q=g[1],$=g[2],ye=g[3],Re=m[0],Be=m[1],Ge=m[2],je=m[3];return(T=W*Re+q*Be+$*Ge+ye*je)<0&&(T=-T,Re=-Re,Be=-Be,Ge=-Ge,je=-je),1-T>qm?(b=Math.acos(T),P=Math.sin(b),I=Math.sin((1-_)*b)/P,H=Math.sin(_*b)/P):(I=1-_,H=_),i[0]=I*W+H*Re,i[1]=I*q+H*Be,i[2]=I*$+H*Ge,i[3]=I*ye+H*je,i}function i_(i,g){var m,_=g[0]+g[4]+g[8];if(_>0)m=Math.sqrt(_+1),i[3]=.5*m,i[0]=(g[5]-g[7])*(m=.5/m),i[1]=(g[6]-g[2])*m,i[2]=(g[1]-g[3])*m;else{var b=0;g[4]>g[0]&&(b=1),g[8]>g[3*b+b]&&(b=2);var T=(b+1)%3,P=(b+2)%3;m=Math.sqrt(g[3*b+b]-g[3*T+T]-g[3*P+P]+1),i[b]=.5*m,i[3]=(g[3*T+P]-g[3*P+T])*(m=.5/m),i[T]=(g[3*T+b]+g[3*b+T])*m,i[P]=(g[3*P+b]+g[3*b+P])*m}return i}function o_(i,g,m,_){var b=.5*Math.PI/180;g*=b,m*=b,_*=b;var T=Math.sin(g),P=Math.cos(g),I=Math.sin(m),H=Math.cos(m),W=Math.sin(_),q=Math.cos(_);return i[0]=T*H*q-P*I*W,i[1]=P*I*q+T*H*W,i[2]=P*H*W-T*I*q,i[3]=P*H*q+T*I*W,i}var s_,a_,l_,h_,c_,u_,f_=vy,d_=xy,p_=by,g_=wy,m_=Ty,A_=Qy,y_=Py,__=Ly,v_=Dy,x_=Oy,b_=x_,w_=Ey,T_=w_,S_=Ry,M_=Ny,C_=Hy,P_=(s_=UA(),a_=jA(1,0,0),l_=jA(0,1,0),function(i,g,m){var _=ry(g,m);return _<-.999999?(iy(s_,a_,g),gy(s_)<1e-6&&iy(s_,l_,g),ny(s_,s_),Yy(i,s_,Math.PI),i):_>.999999?(i[0]=0,i[1]=0,i[2]=0,i[3]=1,i):(iy(s_,g,m),i[0]=s_[0],i[1]=s_[1],i[2]=s_[2],i[3]=1+_,S_(i,i))}),I_=(h_=Zy(),c_=Zy(),function(i,g,m,_,b,T){return r_(h_,g,b,T),r_(c_,m,_,T),r_(i,h_,c_,2*T*(1-T)),i}),k_=(u_=oA(),function(i,g,m,_){return u_[0]=m[0],u_[3]=m[1],u_[6]=m[2],u_[1]=_[0],u_[4]=_[1],u_[7]=_[2],u_[2]=-g[0],u_[5]=-g[1],u_[8]=-g[2],S_(i,i_(i,u_))}),O_=Object.freeze({__proto__:null,add:m_,calculateW:function(i,g){var m=g[0],_=g[1],b=g[2];return i[0]=m,i[1]=_,i[2]=b,i[3]=Math.sqrt(Math.abs(1-m*m-_*_-b*b)),i},clone:f_,conjugate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i[2]=-g[2],i[3]=g[3],i},copy:p_,create:Zy,dot:__,equals:C_,exactEquals:M_,exp:t_,fromEuler:o_,fromMat3:i_,fromValues:d_,getAngle:function(i,g){var m=__(i,g);return Math.acos(2*m*m-1)},getAxisAngle:function(i,g){var m=2*Math.acos(g[3]),_=Math.sin(m/2);return _>qm?(i[0]=g[0]/_,i[1]=g[1]/_,i[2]=g[2]/_):(i[0]=1,i[1]=0,i[2]=0),m},identity:$y,invert:function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=m*m+_*_+b*b+T*T,I=P?1/P:0;return i[0]=-m*I,i[1]=-_*I,i[2]=-b*I,i[3]=T*I,i},len:b_,length:x_,lerp:v_,ln:n_,mul:A_,multiply:Qy,normalize:S_,pow:function(i,g,m){return n_(i,g),y_(i,i,m),t_(i,i),i},random:function(i){var g=Zm(),m=Zm(),_=Zm(),b=Math.sqrt(1-g),T=Math.sqrt(g);return i[0]=b*Math.sin(2*Math.PI*m),i[1]=b*Math.cos(2*Math.PI*m),i[2]=T*Math.sin(2*Math.PI*_),i[3]=T*Math.cos(2*Math.PI*_),i},rotateX:Jy,rotateY:Ky,rotateZ:e_,rotationTo:P_,scale:y_,set:g_,setAxes:k_,setAxisAngle:Yy,slerp:r_,sqlerp:I_,sqrLen:T_,squaredLength:w_,str:function(i){return"quat("+i[0]+", "+i[1]+", "+i[2]+", "+i[3]+")"}});function E_(i,g,m){var _=.5*m[0],b=.5*m[1],T=.5*m[2],P=g[0],I=g[1],H=g[2],W=g[3];return i[0]=P,i[1]=I,i[2]=H,i[3]=W,i[4]=_*W+b*H-T*I,i[5]=b*W+T*P-_*H,i[6]=T*W+_*I-b*P,i[7]=-_*P-b*I-T*H,i}function R_(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i}function L_(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=m[4],H=m[5],W=m[6],q=m[7],$=g[4],ye=g[5],Re=g[6],Be=g[7],Ge=m[0],je=m[1],Xe=m[2],Ze=m[3];return i[0]=_*Ze+P*Ge+b*Xe-T*je,i[1]=b*Ze+P*je+T*Ge-_*Xe,i[2]=T*Ze+P*Xe+_*je-b*Ge,i[3]=P*Ze-_*Ge-b*je-T*Xe,i[4]=_*q+P*I+b*W-T*H+$*Ze+Be*Ge+ye*Xe-Re*je,i[5]=b*q+P*H+T*I-_*W+ye*Ze+Be*je+Re*Ge-$*Xe,i[6]=T*q+P*W+_*H-b*I+Re*Ze+Be*Xe+$*je-ye*Ge,i[7]=P*q-_*I-b*H-T*W+Be*Ze-$*Ge-ye*je-Re*Xe,i}var D_=__;var F_=w_;var N_=Object.freeze({__proto__:null,add:function(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i[3]=g[3]+m[3],i[4]=g[4]+m[4],i[5]=g[5]+m[5],i[6]=g[6]+m[6],i[7]=g[7]+m[7],i},clone:function(i){var g=new Xm(8);return g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3],g[4]=i[4],g[5]=i[5],g[6]=i[6],g[7]=i[7],g},conjugate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i[2]=-g[2],i[3]=g[3],i[4]=-g[4],i[5]=-g[5],i[6]=-g[6],i[7]=g[7],i},copy:R_,create:function(){var i=new Xm(8);return Xm!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[4]=0,i[5]=0,i[6]=0,i[7]=0),i[3]=1,i},dot:D_,equals:function(i,g){var m=i[0],_=i[1],b=i[2],T=i[3],P=i[4],I=i[5],H=i[6],W=i[7],q=g[0],$=g[1],ye=g[2],Re=g[3],Be=g[4],Ge=g[5],je=g[6],Xe=g[7];return Math.abs(m-q)<=qm*Math.max(1,Math.abs(m),Math.abs(q))&&Math.abs(_-$)<=qm*Math.max(1,Math.abs(_),Math.abs($))&&Math.abs(b-ye)<=qm*Math.max(1,Math.abs(b),Math.abs(ye))&&Math.abs(T-Re)<=qm*Math.max(1,Math.abs(T),Math.abs(Re))&&Math.abs(P-Be)<=qm*Math.max(1,Math.abs(P),Math.abs(Be))&&Math.abs(I-Ge)<=qm*Math.max(1,Math.abs(I),Math.abs(Ge))&&Math.abs(H-je)<=qm*Math.max(1,Math.abs(H),Math.abs(je))&&Math.abs(W-Xe)<=qm*Math.max(1,Math.abs(W),Math.abs(Xe))},exactEquals:function(i,g){return i[0]===g[0]&&i[1]===g[1]&&i[2]===g[2]&&i[3]===g[3]&&i[4]===g[4]&&i[5]===g[5]&&i[6]===g[6]&&i[7]===g[7]},fromMat4:function(i,g){var m=Zy();kA(m,g);var _=new Xm(3);return CA(_,g),E_(i,m,_),i},fromRotation:function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=0,i[5]=0,i[6]=0,i[7]=0,i},fromRotationTranslation:E_,fromRotationTranslationValues:function(i,g,m,_,b,T,P){var I=new Xm(8);I[0]=i,I[1]=g,I[2]=m,I[3]=_;var H=.5*b,W=.5*T,q=.5*P;return I[4]=H*_+W*m-q*g,I[5]=W*_+q*i-H*m,I[6]=q*_+H*g-W*i,I[7]=-H*i-W*g-q*m,I},fromTranslation:function(i,g){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i[4]=.5*g[0],i[5]=.5*g[1],i[6]=.5*g[2],i[7]=0,i},fromValues:function(i,g,m,_,b,T,P,I){var H=new Xm(8);return H[0]=i,H[1]=g,H[2]=m,H[3]=_,H[4]=b,H[5]=T,H[6]=P,H[7]=I,H},getDual:function(i,g){return i[0]=g[4],i[1]=g[5],i[2]=g[6],i[3]=g[7],i},getReal:p_,getTranslation:function(i,g){var m=g[4],_=g[5],b=g[6],T=g[7],P=-g[0],I=-g[1],H=-g[2],W=g[3];return i[0]=2*(m*W+T*P+_*H-b*I),i[1]=2*(_*W+T*I+b*P-m*H),i[2]=2*(b*W+T*H+m*I-_*P),i},identity:function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i[4]=0,i[5]=0,i[6]=0,i[7]=0,i},invert:function(i,g){var m=F_(g);return i[0]=-g[0]/m,i[1]=-g[1]/m,i[2]=-g[2]/m,i[3]=g[3]/m,i[4]=-g[4]/m,i[5]=-g[5]/m,i[6]=-g[6]/m,i[7]=g[7]/m,i},len:x_,length:x_,lerp:function(i,g,m,_){var b=1-_;return D_(g,m)<0&&(_=-_),i[0]=g[0]*b+m[0]*_,i[1]=g[1]*b+m[1]*_,i[2]=g[2]*b+m[2]*_,i[3]=g[3]*b+m[3]*_,i[4]=g[4]*b+m[4]*_,i[5]=g[5]*b+m[5]*_,i[6]=g[6]*b+m[6]*_,i[7]=g[7]*b+m[7]*_,i},mul:L_,multiply:L_,normalize:function(i,g){var m=F_(g);if(m>0){m=Math.sqrt(m);var _=g[0]/m,b=g[1]/m,T=g[2]/m,P=g[3]/m,I=g[4],H=g[5],W=g[6],q=g[7],$=_*I+b*H+T*W+P*q;i[0]=_,i[1]=b,i[2]=T,i[3]=P,i[4]=(I-_*$)/m,i[5]=(H-b*$)/m,i[6]=(W-T*$)/m,i[7]=(q-P*$)/m}return i},rotateAroundAxis:function(i,g,m,_){if(Math.abs(_)<qm)return R_(i,g);var b=Math.hypot(m[0],m[1],m[2]);_*=.5;var T=Math.sin(_),P=T*m[0]/b,I=T*m[1]/b,H=T*m[2]/b,W=Math.cos(_),q=g[0],$=g[1],ye=g[2],Re=g[3];i[0]=q*W+Re*P+$*H-ye*I,i[1]=$*W+Re*I+ye*P-q*H,i[2]=ye*W+Re*H+q*I-$*P,i[3]=Re*W-q*P-$*I-ye*H;var Be=g[4],Ge=g[5],je=g[6],Xe=g[7];return i[4]=Be*W+Xe*P+Ge*H-je*I,i[5]=Ge*W+Xe*I+je*P-Be*H,i[6]=je*W+Xe*H+Be*I-Ge*P,i[7]=Xe*W-Be*P-Ge*I-je*H,i},rotateByQuatAppend:function(i,g,m){var _=m[0],b=m[1],T=m[2],P=m[3],I=g[0],H=g[1],W=g[2],q=g[3];return i[0]=I*P+q*_+H*T-W*b,i[1]=H*P+q*b+W*_-I*T,i[2]=W*P+q*T+I*b-H*_,i[3]=q*P-I*_-H*b-W*T,i[4]=(I=g[4])*P+(q=g[7])*_+(H=g[5])*T-(W=g[6])*b,i[5]=H*P+q*b+W*_-I*T,i[6]=W*P+q*T+I*b-H*_,i[7]=q*P-I*_-H*b-W*T,i},rotateByQuatPrepend:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=m[0],H=m[1],W=m[2],q=m[3];return i[0]=_*q+P*I+b*W-T*H,i[1]=b*q+P*H+T*I-_*W,i[2]=T*q+P*W+_*H-b*I,i[3]=P*q-_*I-b*H-T*W,i[4]=_*(q=m[7])+P*(I=m[4])+b*(W=m[6])-T*(H=m[5]),i[5]=b*q+P*H+T*I-_*W,i[6]=T*q+P*W+_*H-b*I,i[7]=P*q-_*I-b*H-T*W,i},rotateX:function(i,g,m){var _=-g[0],b=-g[1],T=-g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=I*P+q*_+H*T-W*b,ye=H*P+q*b+W*_-I*T,Re=W*P+q*T+I*b-H*_,Be=q*P-I*_-H*b-W*T;return Jy(i,g,m),i[4]=$*(P=i[3])+Be*(_=i[0])+ye*(T=i[2])-Re*(b=i[1]),i[5]=ye*P+Be*b+Re*_-$*T,i[6]=Re*P+Be*T+$*b-ye*_,i[7]=Be*P-$*_-ye*b-Re*T,i},rotateY:function(i,g,m){var _=-g[0],b=-g[1],T=-g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=I*P+q*_+H*T-W*b,ye=H*P+q*b+W*_-I*T,Re=W*P+q*T+I*b-H*_,Be=q*P-I*_-H*b-W*T;return Ky(i,g,m),i[4]=$*(P=i[3])+Be*(_=i[0])+ye*(T=i[2])-Re*(b=i[1]),i[5]=ye*P+Be*b+Re*_-$*T,i[6]=Re*P+Be*T+$*b-ye*_,i[7]=Be*P-$*_-ye*b-Re*T,i},rotateZ:function(i,g,m){var _=-g[0],b=-g[1],T=-g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=I*P+q*_+H*T-W*b,ye=H*P+q*b+W*_-I*T,Re=W*P+q*T+I*b-H*_,Be=q*P-I*_-H*b-W*T;return e_(i,g,m),i[4]=$*(P=i[3])+Be*(_=i[0])+ye*(T=i[2])-Re*(b=i[1]),i[5]=ye*P+Be*b+Re*_-$*T,i[6]=Re*P+Be*T+$*b-ye*_,i[7]=Be*P-$*_-ye*b-Re*T,i},scale:function(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i[4]=g[4]*m,i[5]=g[5]*m,i[6]=g[6]*m,i[7]=g[7]*m,i},set:function(i,g,m,_,b,T,P,I,H){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i[4]=T,i[5]=P,i[6]=I,i[7]=H,i},setDual:function(i,g){return i[4]=g[0],i[5]=g[1],i[6]=g[2],i[7]=g[3],i},setReal:p_,sqrLen:F_,squaredLength:F_,str:function(i){return"quat2("+i[0]+", "+i[1]+", "+i[2]+", "+i[3]+", "+i[4]+", "+i[5]+", "+i[6]+", "+i[7]+")"},translate:function(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=.5*m[0],H=.5*m[1],W=.5*m[2],q=g[4],$=g[5],ye=g[6],Re=g[7];return i[0]=_,i[1]=b,i[2]=T,i[3]=P,i[4]=P*I+b*W-T*H+q,i[5]=P*H+T*I-_*W+$,i[6]=P*W+_*H-b*I+ye,i[7]=-_*I-b*H-T*W+Re,i}});function H_(){var i=new Xm(2);return Xm!=Float32Array&&(i[0]=0,i[1]=0),i}function B_(i,g){return i[0]=g[0],i[1]=g[1],i}function z_(i,g,m){return i[0]=g,i[1]=m,i}function V_(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i}function U_(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i}function G_(i,g,m){return i[0]=g[0]*m[0],i[1]=g[1]*m[1],i}function j_(i,g,m){return i[0]=g[0]/m[0],i[1]=g[1]/m[1],i}function W_(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i}function q_(i,g){return Math.hypot(g[0]-i[0],g[1]-i[1])}function X_(i,g){var m=g[0]-i[0],_=g[1]-i[1];return m*m+_*_}function Z_(i){return Math.hypot(i[0],i[1])}function $_(i){var g=i[0],m=i[1];return g*g+m*m}function Y_(i,g,m){var _=g[0],b=g[1];return i[0]=m[0]*_+m[2]*b,i[1]=m[1]*_+m[3]*b,i}function Q_(i,g,m,_){var b=g[0]-m[0],T=g[1]-m[1],P=Math.sin(_),I=Math.cos(_);return i[0]=b*I-T*P+m[0],i[1]=b*P+T*I+m[1],i}function J_(i,g){return i[0]===g[0]&&i[1]===g[1]}var K_=Z_,ev=U_,tv=G_,nv=j_,rv=q_,iv=X_,ov=$_,sv=function(){var i=H_();return function(g,m,_,b,T,P){var I,H;for(m||(m=2),_||(_=0),H=b?Math.min(b*m+_,g.length):g.length,I=_;I<H;I+=m)i[0]=g[I],i[1]=g[I+1],T(i,i,P),g[I]=i[0],g[I+1]=i[1];return g}}(),av=Object.freeze({__proto__:null,add:V_,angle:function(i,g){var m=i[0],_=i[1],b=g[0],T=g[1],P=Math.sqrt(m*m+_*_)*Math.sqrt(b*b+T*T);return Math.acos(Math.min(Math.max(P&&(m*b+_*T)/P,-1),1))},ceil:function(i,g){return i[0]=Math.ceil(g[0]),i[1]=Math.ceil(g[1]),i},clone:function(i){var g=new Xm(2);return g[0]=i[0],g[1]=i[1],g},copy:B_,create:H_,cross:function(i,g,m){var _=g[0]*m[1]-g[1]*m[0];return i[0]=i[1]=0,i[2]=_,i},dist:rv,distance:q_,div:nv,divide:j_,dot:function(i,g){return i[0]*g[0]+i[1]*g[1]},equals:function(i,g){var m=i[0],_=i[1],b=g[0],T=g[1];return Math.abs(m-b)<=qm*Math.max(1,Math.abs(m),Math.abs(b))&&Math.abs(_-T)<=qm*Math.max(1,Math.abs(_),Math.abs(T))},exactEquals:J_,floor:function(i,g){return i[0]=Math.floor(g[0]),i[1]=Math.floor(g[1]),i},forEach:sv,fromValues:function(i,g){var m=new Xm(2);return m[0]=i,m[1]=g,m},inverse:function(i,g){return i[0]=1/g[0],i[1]=1/g[1],i},len:K_,length:Z_,lerp:function(i,g,m,_){var b=g[0],T=g[1];return i[0]=b+_*(m[0]-b),i[1]=T+_*(m[1]-T),i},max:function(i,g,m){return i[0]=Math.max(g[0],m[0]),i[1]=Math.max(g[1],m[1]),i},min:function(i,g,m){return i[0]=Math.min(g[0],m[0]),i[1]=Math.min(g[1],m[1]),i},mul:tv,multiply:G_,negate:function(i,g){return i[0]=-g[0],i[1]=-g[1],i},normalize:function(i,g){var m=g[0],_=g[1],b=m*m+_*_;return b>0&&(b=1/Math.sqrt(b)),i[0]=g[0]*b,i[1]=g[1]*b,i},random:function(i,g){g=g||1;var m=2*Zm()*Math.PI;return i[0]=Math.cos(m)*g,i[1]=Math.sin(m)*g,i},rotate:Q_,round:function(i,g){return i[0]=Math.round(g[0]),i[1]=Math.round(g[1]),i},scale:W_,scaleAndAdd:function(i,g,m,_){return i[0]=g[0]+m[0]*_,i[1]=g[1]+m[1]*_,i},set:z_,sqrDist:iv,sqrLen:ov,squaredDistance:X_,squaredLength:$_,str:function(i){return"vec2("+i[0]+", "+i[1]+")"},sub:ev,subtract:U_,transformMat2:Y_,transformMat2d:function(i,g,m){var _=g[0],b=g[1];return i[0]=m[0]*_+m[2]*b+m[4],i[1]=m[1]*_+m[3]*b+m[5],i},transformMat3:function(i,g,m){var _=g[0],b=g[1];return i[0]=m[0]*_+m[3]*b+m[6],i[1]=m[1]*_+m[4]*b+m[7],i},transformMat4:function(i,g,m){var _=g[0],b=g[1];return i[0]=m[0]*_+m[4]*b+m[12],i[1]=m[1]*_+m[5]*b+m[13],i},zero:function(i){return i[0]=0,i[1]=0,i}}),lv="undefined"!=typeof Float32Array?Float32Array:Array;function hv(){var i=new lv(3);return lv!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i}function cv(i,g,m){var _=new lv(3);return _[0]=i,_[1]=g,_[2]=m,_}function uv(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i}function fv(i,g,m,_){return i[0]=g,i[1]=m,i[2]=_,i}function dv(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i}function pv(i,g){var m=g[0],_=g[1],b=g[2],T=m*m+_*_+b*b;return T>0&&(T=1/Math.sqrt(T),i[0]=g[0]*T,i[1]=g[1]*T,i[2]=g[2]*T),i}function gv(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]}function mv(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[0],I=m[1],H=m[2];return i[0]=b*H-T*I,i[1]=T*P-_*H,i[2]=_*I-b*P,i}var Av=function(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i};function yv(){var i=new lv(4);return lv!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i[3]=1,i}function _v(i,g){var m=g[0]+g[4]+g[8],_=void 0;if(m>0)_=Math.sqrt(m+1),i[3]=.5*_,i[0]=(g[5]-g[7])*(_=.5/_),i[1]=(g[6]-g[2])*_,i[2]=(g[1]-g[3])*_;else{var b=0;g[4]>g[0]&&(b=1),g[8]>g[3*b+b]&&(b=2);var T=(b+1)%3,P=(b+2)%3;_=Math.sqrt(g[3*b+b]-g[3*T+T]-g[3*P+P]+1),i[b]=.5*_,i[3]=(g[3*T+P]-g[3*P+T])*(_=.5/_),i[T]=(g[3*T+b]+g[3*b+T])*_,i[P]=(g[3*P+b]+g[3*b+P])*_}return i}!function(){var i=hv()}(),function(){var i,g=(i=new lv(4),lv!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0),i)}();var vv=function(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i},xv=function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=m*m+_*_+b*b+T*T;return P>0&&(P=1/Math.sqrt(P),i[0]=m*P,i[1]=_*P,i[2]=b*P,i[3]=T*P),i};!function(){var i=hv(),g=cv(1,0,0),m=cv(0,1,0)}(),function(){var i=yv(),g=yv()}(),function(){var i,g=(i=new lv(9),lv!=Float32Array&&(i[1]=0,i[2]=0,i[3]=0,i[5]=0,i[6]=0,i[7]=0),i[0]=1,i[4]=1,i[8]=1,i)}();
/*!
   * Contains code from google filament
   * https://github.com/google/filament/
   * License Apache-2.0
   */
const bv=[],wv=[],Tv=[],Sv=[];function Mv(i,g,m){const _=mv(wv,g,m);i=_v(i,function(i,g,m,_,b,T,P,I,H,W){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i[4]=T,i[5]=P,i[6]=I,i[7]=H,i[8]=W,i}(bv,m[0],m[1],m[2],..._,...g));const b=1/32767;if((i=function(i){return i[3]<0?vv(i,i,-1):i}(i=xv(i,i)))[3]<b){i[3]=b;const g=Math.sqrt(1-b*b);i[0]*=g,i[1]*=g,i[2]*=g}const T=m[3]>0?mv(Tv,m,g):mv(Tv,g,m);return gv(mv(Sv,m,g),T)<0&&vv(i,i,-1),i}const Cv=[];function Pv(i,g,m){const _=m||[];_.setLength&&_.setLength(i.length);const b=Cv;b.length<i.length/3&&(b.length=i.length/3),b.fill(0,0,i.length/3);const T=void 0===g.length?g:g.length;for(let m=0;m<T/3;m++)void 0===g.length?Fv(i,3*m,3*m+1,3*m+2,_,b):Fv(i,g[3*m],g[3*m+1],g[3*m+2],_,b);for(let i=0;i<_.length;i+=3){const g=b[i/3];0!==g?(_[i]/=g,_[i+1]/=g,_[i+2]/=g):(_[i]=0,_[i+1]=0,_[i+2]=0)}return _}const Iv=[],kv=[],Ov=[],Ev=[],Rv=[],Lv=[],Dv=[];function Fv(i,g,m,_,b,T){fv(Ev,i[3*g],i[3*g+1],i[3*g+2]),fv(Rv,i[3*m],i[3*m+1],i[3*m+2]),fv(Lv,i[3*_],i[3*_+1],i[3*_+2]);const P=Av(Iv,Lv,Rv),I=Av(kv,Ev,Rv),H=mv(Ov,P,I);pv(Dv,H),b[3*g]=b[3*g]||0,b[3*m]=b[3*m]||0,b[3*_]=b[3*_]||0,b[3*g+1]=b[3*g+1]||0,b[3*m+1]=b[3*m+1]||0,b[3*_+1]=b[3*_+1]||0,b[3*g+2]=b[3*g+2]||0,b[3*m+2]=b[3*m+2]||0,b[3*_+2]=b[3*_+2]||0,b[3*g]+=Dv[0],b[3*m]+=Dv[0],b[3*_]+=Dv[0],b[3*g+1]+=Dv[1],b[3*m+1]+=Dv[1],b[3*_+1]+=Dv[1],b[3*g+2]+=Dv[2],b[3*m+2]+=Dv[2],b[3*_+2]+=Dv[2],T[g]+=1,T[m]+=1,T[_]+=1}
/*!
   * Contains code from THREE.JS
   * https://github.com/mrdoob/three.js/
   * License MIT
   * 
   * Generate tangents per vertex.
   */function Nv(i,g,m,_,b){const T=i.length/3,P=b||new Array(4*T),I=[],H=[];for(let i=0;i<T;i++)I[i]=[0,0,0],H[i]=[0,0,0];const W=[0,0,0],q=[0,0,0],$=[0,0,0],ye=[0,0],Re=[0,0],Be=[0,0],Ge=[0,0,0],je=[0,0,0];function Xe(g,_,b){Hv(W,i,3*g),Hv(q,i,3*_),Hv($,i,3*b),Bv(ye,m,2*g),Bv(Re,m,2*_),Bv(Be,m,2*b);const T=q[0]-W[0],P=$[0]-W[0],Xe=q[1]-W[1],Ze=$[1]-W[1],Ye=q[2]-W[2],Qe=$[2]-W[2],Je=Re[0]-ye[0],Ke=Be[0]-ye[0],et=Re[1]-ye[1],tt=Be[1]-ye[1],at=1/(Je*tt-Ke*et);fv(Ge,(tt*T-et*P)*at,(tt*Xe-et*Ze)*at,(tt*Ye-et*Qe)*at),fv(je,(Je*P-Ke*T)*at,(Je*Ze-Ke*Xe)*at,(Je*Qe-Ke*Ye)*at),dv(I[g],I[g],Ge),dv(I[_],I[_],Ge),dv(I[b],I[b],Ge),dv(H[g],H[g],je),dv(H[_],H[_],je),dv(H[b],H[b],je)}for(let i=0,g=_.length;i<g;i+=3)Xe(_[i+0],_[i+1],_[i+2]);const Ze=[],Ye=[],Qe=[],Je=[];let Ke,et,tt;function at(i){Hv(Qe,g,3*i),uv(Je,Qe),et=I[i],uv(Ze,et),Av(Ze,Ze,function(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i}(Qe,Qe,gv(Qe,et))),pv(Ze,Ze),mv(Ye,Je,et),tt=gv(Ye,H[i]),Ke=tt<0?-1:1,P[4*i]=Ze[0],P[4*i+1]=Ze[1],P[4*i+2]=Ze[2],P[4*i+3]=Ke}for(let i=0,g=_.length;i<g;i+=3)at(_[i+0]),at(_[i+1]),at(_[i+2]);return P}function Hv(i,g,m){return i[0]=g[m],i[1]=g[m+1],i[2]=g[m+2],i}function Bv(i,g,m){return i[0]=g[m],i[1]=g[m+1],i}var zv=Array.isArray,Vv=Object.keys,Uv=Object.prototype.hasOwnProperty,Gv=function i(g,m){if(g===m)return!0;if(g&&m&&"object"==typeof g&&"object"==typeof m){var _,b,T,P=zv(g),I=zv(m);if(P&&I){if((b=g.length)!=m.length)return!1;for(_=b;0!==_--;)if(!i(g[_],m[_]))return!1;return!0}if(P!=I)return!1;var H=g instanceof Date,W=m instanceof Date;if(H!=W)return!1;if(H&&W)return g.getTime()==m.getTime();var q=g instanceof RegExp,$=m instanceof RegExp;if(q!=$)return!1;if(q&&$)return g.toString()==m.toString();var ye=Vv(g);if((b=ye.length)!==Vv(m).length)return!1;for(_=b;0!==_--;)if(!Uv.call(m,ye[_]))return!1;for(_=b;0!==_--;)if(!i(g[T=ye[_]],m[T]))return!1;return!0}return g!=g&&m!=m},jv=Gm(Gv);
/*!
   * @maptalks/fusiongl v0.115.0
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.com
   */
function Wv(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}function qv(i,...g){for(let m=0;m<g.length;m++)Wv(i,g[m])}class DrawBuffersExt{constructor(i){this.context=i,this.COLOR_ATTACHMENT0_WEBGL=36064,this.COLOR_ATTACHMENT1_WEBGL=36065,this.COLOR_ATTACHMENT2_WEBGL=36066,this.COLOR_ATTACHMENT3_WEBGL=36067,this.COLOR_ATTACHMENT4_WEBGL=36068,this.COLOR_ATTACHMENT5_WEBGL=36069,this.COLOR_ATTACHMENT6_WEBGL=36070,this.COLOR_ATTACHMENT7_WEBGL=36071,this.COLOR_ATTACHMENT8_WEBGL=36072,this.COLOR_ATTACHMENT9_WEBGL=36073,this.COLOR_ATTACHMENT10_WEBGL=577040,this.COLOR_ATTACHMENT11_WEBGL=577041,this.COLOR_ATTACHMENT12_WEBGL=577042,this.COLOR_ATTACHMENT13_WEBGL=577043,this.COLOR_ATTACHMENT14_WEBGL=577044,this.COLOR_ATTACHMENT15_WEBGL=577045,this.DRAW_BUFFER0_WEBGL=34853,this.DRAW_BUFFER1_WEBGL=34854,this.DRAW_BUFFER2_WEBGL=34855,this.DRAW_BUFFER3_WEBGL=34856,this.DRAW_BUFFER4_WEBGL=34857,this.DRAW_BUFFER5_WEBGL=34858,this.DRAW_BUFFER6_WEBGL=34859,this.DRAW_BUFFER7_WEBGL=34860,this.DRAW_BUFFER8_WEBGL=34861,this.DRAW_BUFFER9_WEBGL=34862,this.DRAW_BUFFER10_WEBGL=34863,this.DRAW_BUFFER11_WEBGL=34864,this.DRAW_BUFFER12_WEBGL=34865,this.DRAW_BUFFER13_WEBGL=34866,this.DRAW_BUFFER14_WEBGL=34867,this.DRAW_BUFFER15_WEBGL=34868,this.MAX_COLOR_ATTACHMENTS_WEBGL=36063,this.MAX_DRAW_BUFFERS_WEBGL=2178}drawBuffersWEBGL(){return this.context.drawBuffers.apply(this.context,arguments)}}class VertexArrayObjectExt{constructor(i){this.context=i,this.VERTEX_ARRAY_BINDING_OES=34229}createVertexArrayOES(){return this.context.createVertexArray()}deleteVertexArrayOES(){return this.context.deleteVertexArray.apply(this.context,arguments)}isVertexArrayOES(){return this.context.isVertexArray.apply(this.context,arguments)}bindVertexArrayOES(){return this.context.bindVertexArray.apply(this.context,arguments)}}class AngleInstancedArrayExt{constructor(i){this.context=i,this.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE=35070}drawArraysInstancedANGLE(){return this.context.drawArraysInstanced.apply(this.context,arguments)}drawElementsInstancedANGLE(){return this.context.drawElementsInstanced.apply(this.context,arguments)}vertexAttribDivisorANGLE(){return this.context.vertexAttribDivisor.apply(this.context,arguments)}}const Xv=36193,Zv={webgl_depth_texture:{UNSIGNED_INT_24_8_WEBGL:34042},oes_element_index_uint:{},oes_texture_float:{},oes_texture_half_float:{HALF_FLOAT_OES:36193},ext_color_buffer_float:{},oes_standard_derivatives:{},ext_frag_depth:{},ext_blend_minmax:{MIN_EXT:32775,MAX_EXT:32776},ext_shader_texture_lod:{}},$v={has(i,g){const m=i.t;return!(!m&&!i.i.getExtension(g))&&(g=g.toLowerCase(),m&&Zv[g]||"webgl_draw_buffers"===g||"oes_vertex_array_object"===g||"angle_instanced_arrays"===g)},mock:(i,g)=>(g=g.toLowerCase(),Zv[g]?i.t?("oes_texture_float"!==g&&"oes_texture_half_float"!==g||i.i.getExtension("EXT_color_buffer_float"),Zv[g]):i.i.getExtension(g):"webgl_draw_buffers"===g?new DrawBuffersExt(i):"oes_vertex_array_object"===g?new VertexArrayObjectExt(i):"angle_instanced_arrays"===g?new AngleInstancedArrayExt(i):null),getInternalFormat:(i,g,m)=>6402===g?33190:34041===g?35056:m===Xv&&g===i.RGBA?34842:m===Xv&&g===i.RGB?34843:m===i.FLOAT&&g===i.RGBA?34836:m===i.FLOAT&&g===i.RGB?34837:g,getTextureType:(i,g)=>g===Xv?i.HALF_FLOAT:g};let Yv=1,Qv=class WebGL2RenderingContext{constructor(i){this.uid=Yv++,this.states=function(i){return{scissor:[0,0,i.canvas.width,i.canvas.height],viewport:[0,0,i.canvas.width,i.canvas.height],blendColor:[0,0,0,0],blendEquationSeparate:[i.FUNC_ADD,i.FUNC_ADD],blendFuncSeparate:[i.ONE,i.ZERO,i.ONE,i.ZERO],clearColor:[0,0,0,0],clearDepth:[1],clearStencil:[0],colorMask:[!0,!0,!0,!0],cullFace:[i.BACK],depthFunc:[i.LESS],depthMask:[!0],depthRange:[0,1],capabilities:{3042:!1,2884:!1,2929:!1,3024:!1,32823:!1,32926:!1,32928:!1,3089:!1,2960:!1},frontFace:[i.CCW],hint:{33170:[i.DONT_CARE],35723:[i.DONT_CARE]},lineWidth:[1],pixelStorei:{3333:[4],3317:[4],37440:[!1],37441:[!1],37443:[i.BROWSER_DEFAULT_WEBGL]},polygonOffset:[0,0],sampleCoverage:[1,!1],stencilFuncSeparate:{1028:[i.ALWAYS,0,4294967295],1029:[i.ALWAYS,0,4294967295]},stencilMaskSeparate:{1028:[4294967295],1029:[4294967295]},stencilOpSeparate:{1028:[i.KEEP,i.KEEP,i.KEEP],1029:[i.KEEP,i.KEEP,i.KEEP]},program:null,framebuffer:{36160:null,36008:null,36009:null},renderbuffer:{36161:null},textures:{active:-1,units:function(){const g=[],m=i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);for(let i=0;i<m;i++)g.push({3553:null,34067:null});return g[-1]={3553:null,34067:null},g}()},attributes:{},arrayBuffer:null,elementArrayBuffer:null}}(i),this.i=i,this.i._fusiongl_drawCalls=0,this.t=void 0!==window.WebGL2RenderingContext&&this.i instanceof window.WebGL2RenderingContext;const g=Object.getPrototypeOf(this);Object.setPrototypeOf(g,this.t?window.WebGL2RenderingContext.prototype:WebGLRenderingContext.prototype),this.h=i.getParameter(i.MAX_VERTEX_ATTRIBS)}get canvas(){return this.i.canvas}get drawingBufferWidth(){return this.i.drawingBufferWidth}get drawingBufferHeight(){return this.i.drawingBufferHeight}get drawingBufferColorSpace(){return this.i.drawingBufferColorSpace}set drawingBufferColorSpace(i){this.i.drawingBufferColorSpace=i}get gl(){return this.i}get buffersOES(){return this.u||(this.u=this.i.getExtension("WEBGL_draw_buffers")),this.u}get vaoOES(){return this.o||(this.o=this.i.getExtension("OES_vertex_array_object")),this.o}get angleOES(){return this.l||(this.l=this.i.getExtension("ANGLE_instanced_arrays")),this.l}get standOES(){return this.m||(this.m=this.i.getExtension("OES_standard_derivatives")),this.m}attachShader(i,g){return this.i.attachShader(i,g)}shaderSource(i,g){return this.i.shaderSource(i,g)}compileShader(i){return this.i.compileShader(i)}createShader(i){return this.i.createShader(i)}createProgram(){return this.i.createProgram()}deleteProgram(i){return this.states.program===i&&(this.states.program=null),this.i.deleteProgram(i)}deleteShader(i){return this.i.deleteShader(i)}detachShader(i,g){return this.i.detachShader(i,g)}getAttachedShaders(i){return this.i.getAttachedShaders(i)}linkProgram(i){return this.i.linkProgram(i)}makeXRCompatible(){return this.i.makeXRCompatible()}getShaderParameter(i,g){return this.i.getShaderParameter(i,g)}getShaderPrecisionFormat(i,g){return this.i.getShaderPrecisionFormat(i,g)}getShaderInfoLog(i){return this.i.getShaderInfoLog(i)}getShaderSource(i){return this.i.getShaderSource(i)}getProgramInfoLog(i){return this.i.getProgramInfoLog(i)}getProgramParameter(i,g){return this.i.getProgramParameter(i,g)}getError(){return this.i.getError()}getContextAttributes(){return this.i.getContextAttributes()}getExtension(i){return $v.has(this,i)?$v.mock(this,i):this.i.getExtension(i)}getSupportedExtensions(){return this.i.getSupportedExtensions()}getParameter(i){return this.i.getParameter(i)}isEnabled(i){return this.i.isEnabled(i)}isProgram(i){return this.i.isProgram(i)}isShader(i){return this.i.isShader(i)}validateProgram(i){return this.i.validateProgram(i)}clear(i){return this.v(),this.i.clear(i)}drawArrays(i,g,m){return this.v(),this._(),this.i.drawArrays(i,g,m)}drawElements(i,g,m,_){return this.v(),this._(),this.i.drawElements(i,g,m,_)}drawBuffers(i){return this.v(),this._(),this.t?this.i.drawBuffers(i):this.buffersOES.drawBuffersWEBGL(i)}_(){this.i._fusiongl_drawCalls++}resetDrawCalls(){this.i._fusiongl_drawCalls=0}getDrawCalls(){return this.i._fusiongl_drawCalls}S(){const i=this.i,g=i.getParameter(i.CURRENT_PROGRAM),m=i.getProgramParameter(g,i.ACTIVE_ATTRIBUTES),_=[];for(let g=0;g<m;g++)_.push(i.getVertexAttrib(g,i.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING));this.A={buffers:_,elements:i.getParameter(i.ELEMENT_ARRAY_BUFFER_BINDING),framebuffer:i.getParameter(i.FRAMEBUFFER_BINDING)},window.DEBUGGING&&(console.log(this.uid,this.A),console.log(this.uid,this.states.attributes),console.log(this.states.attributes[0].buffer===this.A.buffers[0]),console.log(this.states.attributes[1].buffer===this.A.buffers[1]),console.log(this.states.attributes[2].buffer===this.A.buffers[2]))}finish(){return this.i.finish()}flush(){return this.v(),this.i.flush()}commit(){return this.v(),this.i.commit()}isContextLost(){return this.i.isContextLost()}getFragDataLocation(i,g){return this.i.getFragDataLocation(i,g)}createSampler(){return this.i.createSampler()}deleteSampler(){return this.i.deleteSampler()}bindSampler(){return this.i.bindSampler()}isSampler(){return this.i.isSampler()}getSamplerParameter(){return this.i.getSamplerParameter()}isQuery(i){return this.i.beginQuery(i)}beginQuery(i,g){return this.i.beginQuery(i,g)}deleteQuery(i){return this.i.query(i)}isTransformFeedback(i){return this.i.isTransformFeedback(i)}beginTransformFeedback(i){return this.i.beginTransformFeedback(i)}deleteTransformFeedback(i){return this.i.deleteTransformFeedback(i)}pauseTransformFeedback(){return this.i.pauseTransformFeedback()}resumeTransformFeedback(){return this.i.resumeTransformFeedback()}transformFeedbackVaryings(i,g,m){return this.i.transformFeedbackVaryings(i,g,m)}bindBufferBase(i,g,m){return this.i.bbindBufferBase(i,g,m)}bindBufferRange(i,g,m,_,b){return this.i.bindBufferRange(i,g,m,_,b)}bindTransformFeedback(i,g){return this.i.bindTransformFeedback(i,g)}fenceSync(i,g){return this.i.fenceSync(i,g)}isSync(i){return this.i.isSync(i)}deleteSync(i){return this.i.deleteSync(i)}clientWaitSync(i,g,m){return this.i.clientWaitSync(i,g,m)}waitSync(i,g,m){return this.i.waitSync(i,g,m)}getSyncParameter(i,g){return this.i.getSyncParameter(i,g)}getIndexedParameter(i,g){return this.i.getIndexedParameter(i,g)}};qv(Qv.prototype,{bufferData(...i){return this.v(),this.i.bufferData(...i)},bufferSubData(...i){return this.v(),this.i.bufferSubData(...i)},createBuffer(){return this.i.createBuffer()},deleteBuffer(i){const g=this.states;g.arrayBuffer===i?g.arrayBuffer=null:g.elementArrayBuffer===i&&(g.elementArrayBuffer=null);const m=g.attributes;for(const g in m)m[g].buffer===i&&(m[g].buffer=null);return this.i.deleteBuffer(i)},getBufferParameter(i,g){return this.v(),this.i.getBufferParameter(i,g)},isBuffer(i){return this.i.isBuffer(i)},copyBufferSubData(i,g,m,_,b){return this.i.isBuffer(i,g,m,_,b)},readBuffer(i){return this.i.readBuffer(i)}}),qv(Qv.prototype,{checkFramebufferStatus(i){return this.i.checkFramebufferStatus(i)},createFramebuffer(){return this.i.createFramebuffer()},deleteFramebuffer(i){const g=this.states.framebuffer;for(const m in g)g[m]===i&&(g[m]=null);return this.i.deleteFramebuffer(i)},framebufferRenderbuffer(i,g,m,_){return this.v(),this.i.framebufferRenderbuffer(i,g,m,_)},framebufferTexture2D(i,g,m,_,b){return this.v(),this.i.framebufferTexture2D(i,g,m,_,b)},getFramebufferAttachmentParameter(i,g,m){return this.v(),this.i.getFramebufferAttachmentParameter(i,g,m)},isFramebuffer(i){return this.i.isFramebuffer(i)},readPixels(i,g,m,_,b,T,P){return this.v(),this.i.readPixels(i,g,m,_,b,T,P)},blitFramebuffer(i,g,m,_,b,T,P,I,H,W){return this.v(),this.i.blitFramebuffer(i,g,m,_,b,T,P,I,H,W)}}),qv(Qv.prototype,{createRenderbuffer(){return this.i.createRenderbuffer()},deleteRenderbuffer(i){const g=this.states.renderbuffer;for(const m in g)g[m]===i&&(g[m]=null);return this.i.deleteRenderbuffer(i)},getRenderbufferParameter(i,g){return this.v(),this.i.getRenderbufferParameter(i,g)},isRenderbuffer(i){return this.i.isRenderbuffer(i)},renderbufferStorage(i,g,m,_){return this.v(),this.i.renderbufferStorage(i,g,m,_)},renderbufferStorageMultisample(i,g,m,_,b){return this.v(),this.i.renderbufferStorageMultisample(i,g,m,_,b)}});const Jv="_fusion_context";qv(Qv.prototype,{scissor(i,g,m,_){this.v();const b=this.states.scissor;b[0]===i&&b[1]===g&&b[2]===m&&b[3]===_||(b[0]=i,b[1]=g,b[2]=m,b[3]=_,this.i.scissor(i,g,m,_))},viewport(i,g,m,_){this.v();const b=this.states.viewport;b[0]===i&&b[1]===g&&b[2]===m&&b[3]===_||(b[0]=i,b[1]=g,b[2]=m,b[3]=_,this.i.viewport(i,g,m,_))},blendColor(i,g,m,_){this.v();const b=this.states.blendColor;b[0]===i&&b[1]===g&&b[2]===m&&b[3]===_||(b[0]=i,b[1]=g,b[2]=m,b[3]=_,this.i.blendColor(i,g,m,_))},blendEquation(i){this.v();const g=this.states.blendEquationSeparate;g[0]===i&&g[1]===i||(g[0]=i,g[1]=i,this.i.blendEquation(i))},blendEquationSeparate(i,g){this.v();const m=this.states.blendEquationSeparate;m[0]===i&&m[1]===g||(m[0]=i,m[1]=g,this.i.blendEquationSeparate(i,g))},blendFunc(i,g){this.v();const m=this.states.blendFuncSeparate;m[0]===i&&m[2]===i&&m[1]===g&&m[3]===g||(m[0]=i,m[1]=g,m[2]=i,m[3]=g,this.i.blendFunc(i,g))},blendFuncSeparate(i,g,m,_){this.v();const b=this.states.blendFuncSeparate;b[0]===i&&b[1]===g&&b[2]===m&&b[3]===_||(b[0]=i,b[1]=g,b[2]=m,b[3]=_,this.i.blendFuncSeparate(i,g,m,_))},clearColor(i,g,m,_){this.v();const b=this.states.clearColor;b[0]===i&&b[1]===g&&b[2]===m&&b[3]===_||(b[0]=i,b[1]=g,b[2]=m,b[3]=_,this.i.clearColor(i,g,m,_))},clearDepth(i){this.v();const g=this.states.clearDepth;g[0]!==i&&(g[0]=i,this.i.clearDepth(i))},clearStencil(i){this.v();const g=this.states.clearStencil;g[0]!==i&&(g[0]=i,this.i.clearStencil(i))},colorMask(i,g,m,_){this.v();const b=this.states.colorMask;b[0]===i&&b[1]===g&&b[2]===m&&b[3]===_||(b[0]=i,b[1]=g,b[2]=m,b[3]=_,this.i.colorMask(i,g,m,_))},cullFace(i){this.v();const g=this.states.cullFace;g[0]!==i&&(g[0]=i,this.i.cullFace(i))},depthFunc(i){this.v();const g=this.states.depthFunc;g[0]!==i&&(g[0]=i,this.i.depthFunc(i))},depthMask(i){this.v();const g=this.states.depthMask;g[0]!==i&&(g[0]=i,this.i.depthMask(i))},depthRange(i,g){this.v();const m=this.states.depthRange;m[0]===i&&m[1]===g||(m[0]=i,m[1]=g,this.i.depthRange(i,g))},disable(i){this.v();const g=this.states.capabilities;g[i]&&(g[i]=!1,this.i.disable(i))},enable(i){this.v();const g=this.states.capabilities;g[i]||(g[i]=!0,this.i.enable(i))},frontFace(i){this.v();const g=this.states.frontFace;g[0]!==i&&(g[0]=i,this.i.frontFace(i))},hint(i,g){this.v();const m=this.states.hint;m[i][0]!==g&&(m[i][0]=g,this.i.hint(i,g))},lineWidth(i){this.v();const g=this.states.lineWidth;g[0]!==i&&(g[0]=i,this.i.lineWidth(i))},pixelStorei(i,g){this.v();const m=this.states.pixelStorei;m[i]!==g&&(m[i]&&(m[i][0]=g),this.i.pixelStorei(i,g))},polygonOffset(i,g){this.v();const m=this.states.polygonOffset;m[0]===i&&m[1]===g||(m[0]=i,m[1]=g,this.i.polygonOffset(i,g))},sampleCoverage(i,g){this.v();const m=this.states.sampleCoverage;m[0]===i&&m[1]===g||(m[0]=i,m[1]=g,this.i.sampleCoverage(i,g))},stencilFunc(i,g,m){this.v();const _=this.states.stencilFuncSeparate,b=this.i;_[b.FRONT][0]===i&&_[b.FRONT][1]===g&&_[b.FRONT][2]===m&&_[b.BACK][0]===i&&_[b.BACK][1]===g&&_[b.BACK][2]===m||(_[b.FRONT][0]=_[b.BACK][0]=i,_[b.FRONT][1]=_[b.BACK][1]=g,_[b.FRONT][2]=_[b.BACK][2]=m,this.i.stencilFunc(i,g,m))},stencilFuncSeparate(i,g,m,_){if(this.v(),i===this.i.FRONT_AND_BACK)return void this.stencilFunc(g,m,_);const b=this.states.stencilFuncSeparate;b[i][0]===g&&b[i][1]===m&&b[i][2]===_||(b[i][0]=g,b[i][1]=m,b[i][2]=_,this.i.stencilFuncSeparate(i,g,m,_))},stencilMask(i){this.v();const g=this.i,m=this.states.stencilMaskSeparate;m[g.FRONT][0]===i&&m[g.BACK][0]===i||(m[g.FRONT][0]=i,m[g.BACK][0]=i,this.i.stencilMask(i))},stencilMaskSeparate(i,g){if(this.v(),i===this.i.FRONT_AND_BACK)return void this.stencilMask(g);const m=this.states.stencilMaskSeparate;m[i][0]!==g&&(m[i][0]=g,this.i.stencilMaskSeparate(i,g))},stencilOp(i,g,m){this.v();const _=this.states.stencilOpSeparate,b=this.i;_[b.FRONT][0]===i&&_[b.FRONT][1]===g&&_[b.FRONT][2]===m&&_[b.BACK][0]===i&&_[b.BACK][1]===g&&_[b.BACK][2]===m||(_[b.FRONT][0]=_[b.BACK][0]=i,_[b.FRONT][1]=_[b.BACK][1]=g,_[b.FRONT][2]=_[b.BACK][2]=m,this.i.stencilOp(i,g,m))},stencilOpSeparate(i,g,m,_){if(this.v(),i===this.i.FRONT_AND_BACK)return void this.stencilOp(g,m,_);const b=this.states.stencilOpSeparate;b[i][0]===g&&b[i][1]===m&&b[i][2]===_||(b[i][0]=g,b[i][1]=m,b[i][2]=_,this.i.stencilOpSeparate(i,g,m,_))},bindFramebuffer(i,g){this.v();const m=this.states.framebuffer;m[i]!==g&&(m[i]=g,this.i.bindFramebuffer(i,g))},bindRenderbuffer(i,g){this.v();const m=this.states.renderbuffer;m[i]!==g&&(m[i]=g,this.i.bindRenderbuffer(i,g))},bindTexture(i,g){this.v();const m=this.states.textures;m.units[-1!==m.active?m.active-33984:-1][i]=g,this.i.bindTexture(i,g)},activeTexture(i){this.v();const g=this.i,m=this.states.textures,_=m.active;m.active=i,this.activeUnit!==i&&(g.activeTexture(i),this.activeUnit=i),-1===_&&(m.units[i-33984][g.TEXTURE_2D]=m.units[-1][g.TEXTURE_2D],m.units[i-33984][g.TEXTURE_CUBE_MAP]=m.units[-1][g.TEXTURE_CUBE_MAP],m.units[-1][g.TEXTURE_2D]=null,m.units[-1][g.TEXTURE_CUBE_MAP]=null)},useProgram(i){this.v();const g=this.states;g.program!==i&&(this.states.activeAttribType=0,g.program=i,void 0===i.fid&&(i.fid=0),this.p(),this.i.useProgram(i))},p(){const i=this.states.program;if(!i)return;const g=i.cachedUniforms=i.cachedUniforms||{};for(const i in g)Array.isArray(g[i])?g[i].fill(null):g[i]=null},bindBuffer(i,g){this.v();const m=this.i,_=this.states;i===m.ELEMENT_ARRAY_BUFFER?_.elementArrayBuffer=g:_.arrayBuffer=g,m.bindBuffer(i,g)},bindVertexArray(i){this.v(),this.states.activeAttribType=1;const g=this.i,m=this.states;m.vao!==i&&(m.vao=i,this.t?g.bindVertexArray(i):this.vaoOES.bindVertexArrayOES(i))},vertexAttribPointer(i,g,m,_,b,T){this.v(),this.states.attributes[i]||(this.states.attributes[i]={enable:!0});const P=this.states.attributes[i];return P.buffer=this.states.arrayBuffer,P.args?(P.args[0]=i,P.args[1]=g,P.args[2]=m,P.args[3]=_,P.args[4]=b,P.args[5]=T):P.args=[i,g,m,_,b,T],this.i.vertexAttribPointer(i,g,m,_,b,T)},vertexAttribDivisor(i,g){return this.v(),this.states.attributes[i].divisor=g,this.t?this.i.vertexAttribDivisor(i,g):this.angleOES.vertexAttribDivisorANGLE(i,g)}},{v(){const i=this.i;if(i[Jv]!==this)if(i[Jv]){this.N(i[Jv].states),i[Jv]=this}else i[Jv]=this},N(i){if(!i)return;delete this.activeUnit;const g=this.states,m=this.i;let _=0;for(const b in g)if("capabilities"!==b&&"textures"!==b&&"attributes"!==b&&"arrayBuffer"!==b&&"elementArrayBuffer"!==b&&"vao"!==b)if("program"===b)g.program!==i.program&&(m.useProgram(g.program),g.program&&(_=m.getProgramParameter(g.program,m.ACTIVE_ATTRIBUTES)));else if("framebuffer"===b)for(const _ in g[b])g[b][_]!==i[b][_]&&m.bindFramebuffer(+_,g[b][_]);else if("renderbuffer"===b)for(const _ in g[b])g[b][_]!==i[b][_]&&m.bindRenderbuffer(+_,g[b][_]);else if(!jv(g[b],i[b]))if(Array.isArray(i[b]))m[b](...g[b]);else if(i[b])for(const _ in g[b])jv(g[b][_],i[b][_])||m[b](+_,...g[b][_]);this.p();for(const _ in g.capabilities)g.capabilities[_]!==i.capabilities[_]&&m[g.capabilities[_]?"enable":"disable"](+_);const b=g.textures,T=b.units,P=i.textures.units,I=b.active-m.TEXTURE0;for(let i=0;i<T.length;i++)i===I||T[i][m.TEXTURE_2D]===P[i][m.TEXTURE_2D]&&T[i][m.TEXTURE_CUBE_MAP]===P[i][m.TEXTURE_CUBE_MAP]||(m.activeTexture(m.TEXTURE0+i),m.bindTexture(m.TEXTURE_2D,T[i][m.TEXTURE_2D]),m.bindTexture(m.TEXTURE_CUBE_MAP,T[i][m.TEXTURE_CUBE_MAP]));if(b.active>-1){const i=T[I];i[m.TEXTURE_2D]===P[I][m.TEXTURE_2D]&&i[m.TEXTURE_CUBE_MAP]===P[I][m.TEXTURE_CUBE_MAP]||(m.activeTexture(b.active),m.bindTexture(m.TEXTURE_2D,i[m.TEXTURE_2D]),m.bindTexture(m.TEXTURE_CUBE_MAP,i[m.TEXTURE_CUBE_MAP]))}this.t?m.bindVertexArray(null):this.o&&this.o.bindVertexArrayOES(null);const H=this.h;if(this.t||this.angleOES)for(let i=0;i<H;i++)this.t?m.vertexAttribDivisor(i,0):this.angleOES.vertexAttribDivisorANGLE(i,0);m.bindBuffer(m.ARRAY_BUFFER,g.arrayBuffer),m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,g.elementArrayBuffer),1===g.activeAttribType?this.F(g,m):this.L(g,m,_)},F(i,g){const m=i.vao;m&&(this.t?g.bindVertexArray(m||null):this.o&&this.o.bindVertexArrayOES(m||null))},L(i,g,m){const _=this.h,b=i.attributes;let T=0;for(let i=0;i<_;i++){const _=b[i];if(T<m&&_){if(_.buffer){if(g.bindBuffer(g.ARRAY_BUFFER,_.buffer),g.vertexAttribPointer(..._.args),_.divisor&&(this.t?g.vertexAttribDivisor(i,_.divisor):this.angleOES.vertexAttribDivisorANGLE(i,_.divisor)),_.enable){g.enableVertexAttribArray(i),T++;continue}g.disableVertexAttribArray(i)}g.disableVertexAttribArray(i)}else g.disableVertexAttribArray(i)}}}),qv(Qv.prototype,{compressedTexImage2D(i,g,m,_,b,T,P){return this.v(),this.i.compressedTexImage2D(i,g,m,_,b,T,P)},copyTexImage2D(i,g,m,_,b,T,P,I){return this.v(),this.i.copyTexImage2D(i,g,m,_,b,T,P,I)},copyTexSubImage2D(i,g,m,_,b,T,P,I){return this.v(),this.i.copyTexSubImage2D(i,g,m,_,b,T,P,I)},createTexture(){return this.i.createTexture()},deleteTexture(i){const g=this.states.textures.units;for(let m=0;m<g.length;m++)for(const _ in g[m])g[m][_]===i&&(g[m][_]=null);return this.i.deleteTexture(i)},generateMipmap(i){return this.v(),this.i.generateMipmap(i)},getTexParameter(i,g){return this.v(),this.i.getTexParameter(i,g)},isTexture(i){return this.i.isTexture(i)},texImage2D(...i){if(this.v(),this.t){const g=i[i.length-2],m=$v.getInternalFormat(this.i,i[2],g);m!==i[2]&&(i[2]=m);const _=$v.getTextureType(this.i,g);_!==g&&(i[i.length-2]=_)}return this.i.texImage2D(...i)},texSubImage2D(...i){if(this.v(),this.t){const g=i[i.length-2],m=$v.getTextureType(this.i,g);m!==g&&(i[i.length-2]=m)}return this.i.texSubImage2D(...i)},texParameterf(i,g,m){return this.v(),this.i.texParameterf(i,g,m)},texParameteri(i,g,m){return this.v(),this.i.texParameteri(i,g,m)},texStorage2D(i,g,m,_,b){return this.v(),this.i.texStorage2D(i,g,m,_,b)},texImage3D(i,g,m,_,b,T,P,I,H,W){return this.v(),this.i.texImage3D(i,g,m,_,b,T,P,I,H,W)},texStorage3D(i,g,m,_,b,T){return this.v(),this.i.texStorage3D(i,g,m,_,b,T)},texSubImage3D(i,g,m,_,b,T,P,I,H,W,q){return this.v(),this.i.texSubImage3D(i,g,m,_,b,T,P,I,H,W,q)},copyTexSubImage3D(i,g,m,_,b,T,P,I,H){return this.v(),this.i.copyTexSubImage3D(i,g,m,_,b,T,P,I,H)},compressedTexSubImage3D(i,g,m,_,b,T,P,I,H,W,q){return this.v(),this.i.compressedTexSubImage3D(i,g,m,_,b,T,P,I,H,W,q)}});const Kv=[];function ex(i,g){const m=g.length;for(let _=0;_<m;_++)i[_]=g[_];return i}qv(Qv.prototype,{bindAttribLocation(i,g,m){return this.i.bindAttribLocation(i,g,m)},enableVertexAttribArray(i){return this.v(),this.states.attributes[i]||(this.states.attributes[i]={}),this.states.attributes[i].enable=!0,this.i.enableVertexAttribArray(i)},disableVertexAttribArray(i){return this.v(),this.states.attributes[i]||(this.states.attributes[i]={}),this.states.attributes[i].enable=!1,this.i.disableVertexAttribArray(i)},getActiveAttrib(i,g){return this.i.getActiveAttrib(i,g)},getActiveUniform(i,g){return this.i.getActiveUniform(i,g)},getAttribLocation(i,g){return this.i.getAttribLocation(i,g)},getUniformLocation(i,g){return this.i.getUniformLocation(i,g)},getVertexAttrib(i,g){return this.v(),this.i.getVertexAttrib(i,g)},getVertexAttribOffset(i,g){return this.v(),this.i.getVertexAttribOffset(i,g)},uniformBlockBinding(i,g,m){return this.v(),this.i.uniformBlockBinding(i,g,m)},B(i,...g){const m=this.states.program;if(!m)return!1;let _=i.fid;void 0===_&&(_=i.fid=m.fid++);const b=m.cachedUniforms[_];return!!function(i,g){if(!i)return!1;const m=g.length;for(let _=0;_<m;_++)if(i[_]&&void 0!==i[_].length){const m=i[_].length;for(let b=0;b<m;b++)if(i[_][b]!==g[_][b])return!1}else if(i[_]!==g[_])return!1;return!0}(b,g)||(m.cachedUniforms[_]=function(i,g){i=i||new Array(g.length);const m=g.length;for(let _=0;_<m;_++)i[_]=void 0!==g[_].length?ex(i[_]||[],g[_]):g[_];return i}(b,g),!1)},uniformMatrix2fv(i,g,m){this.B(i,g,m)||(this.v(),this.i.uniformMatrix2fv(i,g,m))},uniformMatrix3fv(i,g,m){this.B(i,g,m)||(this.v(),this.i.uniformMatrix3fv(i,g,m))},uniformMatrix4fv(i,g,m){i?(m=this.C(m),this.B(i,g,m)||this.i.uniformMatrix4fv(i,g,m)):console.warn("UniformLocation invalid, null value encountered in browser:",navigator.userAgent)},C:i=>i?(Kv[0]=isNaN(i[0])?-1e30:i[0],Kv[1]=isNaN(i[1])?-1e30:i[1],Kv[2]=isNaN(i[2])?-1e30:i[2],Kv[3]=isNaN(i[3])?-1e30:i[3],Kv[4]=isNaN(i[4])?-1e30:i[4],Kv[5]=isNaN(i[5])?-1e30:i[5],Kv[6]=isNaN(i[6])?-1e30:i[6],Kv[7]=isNaN(i[7])?-1e30:i[7],Kv[8]=isNaN(i[8])?-1e30:i[8],Kv[9]=isNaN(i[9])?-1e30:i[9],Kv[10]=isNaN(i[10])?-1e30:i[10],Kv[11]=isNaN(i[11])?-1e30:i[11],Kv[12]=isNaN(i[12])?-1e30:i[12],Kv[13]=isNaN(i[13])?-1e30:i[13],Kv[14]=isNaN(i[14])?-1e30:i[14],Kv[15]=isNaN(i[15])?-1e30:i[15],Kv):i,uniform1f(i,g){return this.v(),this.i.uniform1f(i,g)},uniform1i(i,g){return this.v(),this.i.uniform1i(i,g)},uniform2f(i,g,m){return this.v(),this.i.uniform2f(i,g,m)},uniform2i(i,g,m){return this.v(),this.i.uniform2i(i,g,m)},uniform3f(i,g,m,_){return this.v(),this.i.uniform3f(i,g,m,_)},uniform3i(i,g,m,_){return this.v(),this.i.uniform3i(i,g,m,_)},uniform4f(i,g,m,_,b){return this.v(),this.i.uniform4f(i,g,m,_,b)},uniform4i(i,g,m,_,b){return this.v(),this.i.uniform4i(i,g,m,_,b)},uniform1ui(i,g){return this.v(),this.i.uniform1ui(i,g)},uniform2ui(i,g,m){return this.v(),this.i.uniform2ui(i,g,m)},uniform3ui(i,g,m,_){return this.v(),this.i.uniform3ui(i,g,m,_)},uniform4ui(i,g,m,_,b){return this.v(),this.i.uniform4ui(i,g,m,_,b)},uniform1fv(i,g,m,_){this.v(),void 0!==_?this.i.uniform1fv(i,g,m,_):void 0!==m?this.i.uniform1fv(i,g,m):this.i.uniform1fv(i,g)},uniform2fv(i,g,m,_){this.v(),void 0!==_?this.i.uniform2fv(i,g,m,_):void 0!==m?this.i.uniform2fv(i,g,m):this.i.uniform2fv(i,g)},uniform3fv(i,g,m,_){this.v(),void 0!==_?this.i.uniform3fv(i,g,m,_):void 0!==m?this.i.uniform3fv(i,g,m):this.i.uniform3fv(i,g)},uniform4fv(i,g,m,_){this.v(),void 0!==_?this.i.uniform4fv(i,g,m,_):void 0!==m?this.i.uniform4fv(i,g,m):this.i.uniform4fv(i,g)},uniform1iv(i,g,m,_){this.v(),void 0!==_?this.i.uniform1iv(i,g,m,_):void 0!==m?this.i.uniform1iv(i,g,m):this.i.uniform1iv(i,g)},uniform2iv(i,g,m,_){this.v(),void 0!==_?this.i.uniform2iv(i,g,m,_):void 0!==m?this.i.uniform2iv(i,g,m):this.i.uniform2iv(i,g)},uniform3iv(i,g,m,_){this.v(),void 0!==_?this.i.uniform3iv(i,g,m,_):void 0!==m?this.i.uniform3iv(i,g,m):this.i.uniform3iv(i,g)},uniform4iv(i,g,m,_){this.v(),void 0!==_?this.i.uniform4iv(i,g,m,_):void 0!==m?this.i.uniform4iv(i,g,m):this.i.uniform4iv(i,g)},uniform1uiv(i,g,m,_){this.v(),void 0!==_?this.i.uniform1uiv(i,g,m,_):void 0!==m?this.i.uniform1uiv(i,g,m):this.i.uniform1uiv(i,g)},uniform2uiv(i,g,m,_){this.v(),void 0!==_?this.i.uniform2uiv(i,g,m,_):void 0!==m?this.i.uniform2uiv(i,g,m):this.i.uniform2uiv(i,g)},uniform3uiv(i,g,m,_){this.v(),void 0!==_?this.i.uniform3uiv(i,g,m,_):void 0!==m?this.i.uniform3uiv(i,g,m):this.i.uniform3uiv(i,g)},uniform4uiv(i,g,m,_){this.v(),void 0!==_?this.i.uniform4uiv(i,g,m,_):void 0!==m?this.i.uniform4uiv(i,g,m):this.i.uniform4uiv(i,g)},vertexAttrib1f(i,g){return this.v(),this.i.vertexAttrib1f(i,g)},vertexAttrib2f(i,g,m){return this.v(),this.i.vertexAttrib2f(i,g,m)},vertexAttrib3f(i,g,m,_){return this.v(),this.i.vertexAttrib3f(i,g,m,_)},vertexAttrib4f(i,g,m,_,b){return this.v(),this.i.vertexAttrib4f(i,g,m,_,b)},vertexAttrib1fv(i,g){return this.v(),this.i.vertexAttrib1fv(i,g)},vertexAttrib2fv(i,g){return this.v(),this.i.vertexAttrib2fv(i,g)},vertexAttrib3fv(i,g){return this.v(),this.i.vertexAttrib3fv(i,g)},vertexAttrib4fv(i,g){return this.v(),this.i.vertexAttrib4fv(i,g)},vertexAttribI4i(i,g,m,_,b){return this.v(),this.i.vertexAttribI4i(i,g,m,_,b)},vertexAttribI4ui(i,g,m,_,b){return this.v(),this.i.vertexAttribI4ui(i,g,m,_,b)},vertexAttribI4iv(i,g){return this.v(),this.i.vertexAttribI4iv(i,g)},vertexAttribI4uiv(i,g){return this.v(),this.i.vertexAttribI4uiv(i,g)}}),qv(Qv.prototype,{createVertexArray(){return this.t?this.i.createVertexArray():this.vaoOES.createVertexArrayOES()},deleteVertexArray(i){const g=this.states;return g.vao===i&&(g.vao=null),this.t?this.i.deleteVertexArray(i):this.vaoOES.deleteVertexArrayOES(i)},isVertexArray(i){return this.t?this.i.isVertexArray(i):this.vaoOES.isVertexArrayOES(i)}}),qv(Qv.prototype,{drawArraysInstanced(i,g,m,_){return this.v(),this._(),this.t?this.i.drawArraysInstanced(i,g,m,_):this.angleOES.drawArraysInstancedANGLE(i,g,m,_)},drawElementsInstanced(i,g,m,_,b){return this.v(),this._(),this.t?this.i.drawElementsInstanced(i,g,m,_,b):this.angleOES.drawElementsInstancedANGLE(i,g,m,_,b)}});
/*!
   * @maptalks/gl v0.110.0
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.com
   */
const tx=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")},nx=tx(),rx=nx.gl_trans__coders=nx.gl_trans__coders||{};function ix(i){var g=function(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0};if(g().maptalks_gltf_loader)return;
/*!
  	 * @maptalks/gltf-loader v0.103.0
  	 * LICENSE : UNLICENSED
  	 * (c) 2016-2025 maptalks.org
  	 */var m="undefined"!=typeof Float32Array?Float32Array:Array;function _(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3],I=g[4],H=g[5],W=g[6],q=g[7],$=g[8],ye=g[9],Re=g[10],Be=g[11],Ge=g[12],je=g[13],Xe=g[14],Ze=g[15],Ye=m[0],Qe=m[1],Je=m[2],Ke=m[3];return i[0]=Ye*_+Qe*I+Je*$+Ke*Ge,i[1]=Ye*b+Qe*H+Je*ye+Ke*je,i[2]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[3]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[4]=(Ye=m[4])*_+(Qe=m[5])*I+(Je=m[6])*$+(Ke=m[7])*Ge,i[5]=Ye*b+Qe*H+Je*ye+Ke*je,i[6]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[7]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[8]=(Ye=m[8])*_+(Qe=m[9])*I+(Je=m[10])*$+(Ke=m[11])*Ge,i[9]=Ye*b+Qe*H+Je*ye+Ke*je,i[10]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[11]=Ye*P+Qe*q+Je*Be+Ke*Ze,i[12]=(Ye=m[12])*_+(Qe=m[13])*I+(Je=m[14])*$+(Ke=m[15])*Ge,i[13]=Ye*b+Qe*H+Je*ye+Ke*je,i[14]=Ye*T+Qe*W+Je*Re+Ke*Xe,i[15]=Ye*P+Qe*q+Je*Be+Ke*Ze,i}function b(){var i=new m(3);return m!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i}function T(i,g,_){var b=new m(3);return b[0]=i,b[1]=g,b[2]=_,b}function P(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i}function I(i,g,m,_){return i[0]=g,i[1]=m,i[2]=_,i}function H(i,g,m){return i[0]=g[0]+m[0],i[1]=g[1]+m[1],i[2]=g[2]+m[2],i}function W(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i}function q(i,g,m,_,b){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i}function $(i,g,m){var _=g[0],b=g[1],T=g[2],P=g[3];return i[0]=m[0]*_+m[4]*b+m[8]*T+m[12]*P,i[1]=m[1]*_+m[5]*b+m[9]*T+m[13]*P,i[2]=m[2]*_+m[6]*b+m[10]*T+m[14]*P,i[3]=m[3]*_+m[7]*b+m[11]*T+m[15]*P,i}function ye(){var i=new m(4);return m!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i[3]=1,i}Math.hypot||(Math.hypot=function(){for(var i=0,g=arguments.length;g--;)i+=arguments[g]*arguments[g];return Math.sqrt(i)}),b(),function(){var i;i=new m(4),m!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0)}();var Re,Be=function(i,g){return i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i};b(),T(1,0,0),T(0,1,0),ye(),ye(),Re=new m(9),m!=Float32Array&&(Re[1]=0,Re[2]=0,Re[3]=0,Re[5]=0,Re[6]=0,Re[7]=0),Re[0]=1,Re[4]=1,Re[8]=1;let Ge=0;function je(i){return null==i}function Xe(i){return!je(i)}function Ze(i){return!je(i)&&("string"==typeof i||null!==i.constructor&&i.constructor===String)}function Ye(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}function Qe(i){switch(i){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array}throw new Error("unsupported bufferView's component type: "+i)}function Je(i){return 0===i.indexOf("data:")&&i.indexOf("base64,")>0}function Ke(i){const g=function(i){return"undefined"!=typeof self?self.atob(i):window.atob(i)}(i.substring(i.indexOf(",")+1)),m=g.length,_=new Uint8Array(m);for(let i=0;i<m;i++)_[i]=g.charCodeAt(i);return _.buffer}const et=[],tt=[],at=[],ht=[0,0,0],gt=function(i){return i[0]=0,i[1]=0,i[2]=0,i[3]=1,i}([]),yt=[1,1,1];function vt(i,g,m,_,b,T,P){const I=Qe(P),H=I.BYTES_PER_ELEMENT;if((0===b||b===_*H)&&T%H===0){const b=new I(g,T,m*_);return i.set(b),i}0===b&&(b=_*H);const W=new Uint8Array(_*H);for(let P=0;P<m;P++){let m=null;const q=new Uint8Array(g,b*P+T,_*H);W.set(q),m=new I(W.buffer,0,_);for(let g=0;g<_;g++)i[P*_+g]=m[g]}return i}const xt="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null;function bt(i,g,m){const _=new Uint8Array(i,g,m);return xt.decode(_)}const Tt={get:function(i,g={},m){g||(g={});const _=new AbortController,b=_.signal,T=Ye({},g);T.signal=b,T.method||(T.method="GET"),T.referrerPolicy=T.referrerPolicy||"origin","undefined"==typeof window||T.referrer||(T.referrer=window.location.href),m&&(i=m(i));const P=fetch(i,T).then((i=>{const m=this.t(i,g.responseType);return m.message?m:m.then((m=>"arraybuffer"===g.responseType?{data:m,cacheControl:i.headers.get("Cache-Control"),expires:i.headers.get("Expires"),contentType:i.headers.get("Content-Type")}:m)).catch((i=>{if(!i.code||i.code!==DOMException.ABORT_ERR)throw i}))})).catch((i=>{if(!i.code||i.code!==DOMException.ABORT_ERR)throw i}));return P.xhr=_,P},t:(i,g)=>200!==i.status?{status:i.status,statusText:i.statusText,message:`incorrect http request with status code(${i.status}): ${i.statusText}`}:"arraybuffer"===g?i.arrayBuffer():"json"===g?i.json():i.text(),getArrayBuffer:(i,g={},m)=>(g||(g={}),g.responseType="arraybuffer",Tt.get(i,g,m)),getJSON:function(i,g={},m){return g&&g.jsonp?Tt.jsonp(i):((g=g||{}).responseType="json",Tt.get(i,g,m))},jsonp:function(i){const g="_maptalks_jsonp_"+Ge++;i.match(/\?/)?i+="&callback="+g:i+="?callback="+g;let m=document.createElement("script");return m.type="text/javascript",m.src=i,new Promise((i=>{window[g]=function(_){document.getElementsByTagName("head")[0].removeChild(m),m=null,delete window[g],i(_)},document.getElementsByTagName("head")[0].appendChild(m)}))}};class R{constructor(i,g,m,_,b){this.i=i,this.decoders=g,this.o=m,this.images={},this.h={},this.u=_||{},this.l=b}requestImageFromBufferURI(i,g,m){if(this.buffers[i.id]){const _=this.m(g,this.buffers[i.id]);return this.getImageByBuffer(_,m)}if(this.h[i.id])return this.h[i.id].then((()=>{const _=this.m(g,this.buffers[i.id]);return this.getImageByBuffer(_,m)}));if(Je(i.uri)){const _=this.buffers[i.id]=Ke(i.uri),b=this.m(g,_);return this.getImageByBuffer(b,m)}let _;const b=i.uri.indexOf("blob:")>=0;return _=i.uri.indexOf("://")>0||b?i.uri:this.rootPath+"/"+i.uri,this.h[i.id]=Tt.getArrayBuffer(_,this.u,this.l).then((_=>{const b=this.buffers[i.id]=_.data,T=this.m(g,b);return this.getImageByBuffer(T,m)}))}getImageByBuffer(i,g){if(this.images[g.id])return Promise.resolve(this.images[g.id]);const m=this.decoders;if(m[g.mimeType])return m[g.mimeType](i,{supportedFormats:this.o});if("image/crn"===g.mimeType||"image/ktx2"===g.mimeType||"image/cttf"===g.mimeType)throw new Error("missing transcoder for "+g.mimeType,"");return this.p(g.id,i)}requestExternalImage(i){if(this.images[i.id])return Promise.resolve(this.images[i.id]);const g=0===i.uri.indexOf("data:image/")?i.uri:this.rootPath+"/"+i.uri;return this.h[i.id]?this.h[i.id].then((()=>this.images[i.id])):this.h[i.id]=this.p(i.id,g)}p(i,g){return new Promise(((m,_)=>{let b=g;this.l&&(b=this.l(g)),this.i(b,this.u,((b,T)=>{b?_(b):(URL.revokeObjectURL(g),this.images[i]=T,m(this.images[i]))}))}))}}const Mt=["SCALAR",1,"VEC2",2,"VEC3",3,"VEC4",4,"MAT2",4,"MAT3",9,"MAT4",16],Pt=[];class k{constructor(i,g,m,_,b){this.rootPath=i,this.gltf=g,this._=!1,this.glbBuffer=m,this.buffers={},this.requests={},this.accessors={},this.A(),this.u=_,this.l=b}T(i,g){const m=this.gltf,_=m.accessors[g];if(void 0===_.bufferView)return this.accessors[_.id]=this.M(i,g,null,0),Promise.resolve(this.accessors[_.id]);if(_&&this.accessors[_.id])return Promise.resolve(this.accessors[_.id]);return this.I(m.bufferViews[_.bufferView]).then((m=>{const{buffer:b,byteOffset:T}=m;return this.accessors[_.id]=this.M(i,g,b,T)}))}I(i){const g=this.gltf.buffers[i.buffer];if(this.buffers[g.id]){return Promise.resolve({buffer:this.buffers[g.id],byteOffset:0})}if(this.requests[g.id])return this.requests[g.id].then((()=>Promise.resolve({buffer:this.buffers[g.id],byteOffset:0})));if("binary_glTF"!==i.buffer&&"KHR_binary_glTF"!==i.buffer&&g.uri){if(Je(g.uri)){const i=this.buffers[g.id]=Ke(g.uri);return Promise.resolve({buffer:i,byteOffset:0})}let i;const m=g.uri.indexOf("blob:")>=0;return i=g.uri.indexOf("://")>0||m?g.uri:this.rootPath+"/"+g.uri,this.requests[g.id]=Tt.getArrayBuffer(i,this.u,!m&&this.l).then((_=>(m&&URL.revokeObjectURL(i),{buffer:this.buffers[g.id]=_.data,byteOffset:0})))}return Promise.resolve({buffer:this.glbBuffer.buffer,byteOffset:this.glbBuffer.byteOffset})}M(i,g,m,_=0){const b=this.gltf,T=b.accessors[g],P=void 0!==T.bufferView?b.bufferViews[T.bufferView]:{},I=(P.byteOffset||0)+_,H=this.v(T.type),W=Qe(T.componentType),q=P.byteStride||0,ye={array:void 0,name:i,accessorName:g,byteLength:T.count*H*W.BYTES_PER_ELEMENT,componentType:T.componentType,count:T.count,type:T.type,itemSize:H,max:T.max,min:T.min,extensions:T.extensions};if(T.min&&(ye.min=T.min),T.max&&(ye.max=T.max),m)if(this._)ye.byteStride=q,ye.byteOffset=I+(T.byteOffset||0),!q||q===H*W.BYTES_PER_ELEMENT||"indices"===i||"input"===i||"output"===i||i.indexOf("morph")>=0?(ye.array=this.P(m,T.count,H,I+(T.byteOffset||0),W),ye.array.buffer.byteLength===ye.byteLength&&(ye.byteOffset=0)):ye.array=new Uint8Array(m,I,P.byteLength);else if(T.interleaved){ye.byteStride=0,ye.byteOffset=0;const i=new W(T.count*H);if(ye.array=vt(i,m,T.count,H,q,I+(T.byteOffset||0),T.componentType),ye.extensions&&ye.extensions.WEB3D_quantized_attributes&&H>2){const i=new Float32Array(ye.array.length),{decodeMatrix:g}=ye.extensions.WEB3D_quantized_attributes;for(let m=0;m<ye.array.length;m+=H){Pt[0]=ye.array[m],Pt[1]=ye.array[m+1],Pt[2]=ye.array[m+2],Pt[3]=1;const _=$(Pt,Pt,g);i[m]=_[0],i[m+1]=_[1],i[m+2]=_[2]}ye.componentType=5126,ye.array=i}}else ye.byteStride=0,ye.array=this.P(m,T.count,H,I+(T.byteOffset||0),W),ye.byteOffset=ye.array.byteOffset;else{ye.array=new W(T.count);const i=ye.min||ye.max;i&&(ye.array[0]=i[0],ye.array[1]=i[1],ye.array[2]=i[2])}return ye}A(){const i=this.gltf.accessors;if(Array.isArray(i))for(let g=0;g<i.length;g++)for(let m=0;m<i.length;m++)g!==m&&i[g].bufferView===i[m].bufferView&&(i[g].interleaved=i[m].interleaved=!0);else for(const g in i)for(const m in i)g!==m&&i[g].bufferView===i[m].bufferView&&(i[g].interleaved=i[m].interleaved=!0)}P(i,g,m,_,b){return _%b.BYTES_PER_ELEMENT!==0&&(i=i.slice(_,_+g*m*b.BYTES_PER_ELEMENT),_=0),new b(i,_,m*g)}v(i){const g=Mt.indexOf(i);return Mt[g+1]}requestKHRTechniquesWebgl(i){const{shaders:g}=i,m=g.map((i=>{if(void 0!==i.bufferView){const g=this.gltf.bufferViews[i.bufferView],{byteLength:m}=g;return this.I(g).then((_=>{const{buffer:b,byteOffset:T}=_,P=bt(b,T+(g.byteOffset||0),m);return i.content=P,i}))}if(i.uri){if(Je(i.uri)){const g=Ke(i.uri),m=bt(g,0,g.byteLength);return i.content=m,Promise.resolve(i)}return Tt.get(this.rootPath+"/"+i.uri,this.u,this.l).then((g=>(i.content=g,i)))}return Promise.resolve(i)}));return Promise.all(m).then((()=>i))}}class L extends R{constructor(i,g,m,_,b,T,P,I){super(_,b,T,P,I),this.rootPath=i,this.gltf=g,this.requests={},this.buffers={},this.glbBuffer=m,this.accessor=new k(i,g,m,P,I)}iterate(i,g){const m=this.gltf[g];if(!m)return;let _=0;for(const g in m)i(g,m[g],_++)}createNode(i){const g={};if(Xe(i.name)&&(g.name=i.name),Xe(i.children)&&(g.children=i.children),Xe(i.jointName)&&(g.jointName=i.jointName),Xe(i.matrix)&&(g.matrix=i.matrix),Xe(i.rotation)&&(g.rotation=i.rotation),Xe(i.scale)&&(g.scale=i.scale),Xe(i.translation)&&(g.translation=i.translation),Xe(i.extras)&&(g.extras=i.extras),Xe(i.meshes)&&(g.mesh=i.meshes[0]),g.translation||g.rotation||g.scale){const i=function(i,g){if(g.matrix)return g.matrix;if(g.translation||g.scale||g.rotation){const m=function(i,g){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=g[0],i[13]=g[1],i[14]=g[2],i[15]=1,i}(et,g.translation||ht),b=function(i,g){var m=g[0],_=g[1],b=g[2],T=g[3],P=m+m,I=_+_,H=b+b,W=m*P,q=_*P,$=_*I,ye=b*P,Re=b*I,Be=b*H,Ge=T*P,je=T*I,Xe=T*H;return i[0]=1-$-Be,i[1]=q+Xe,i[2]=ye-je,i[3]=0,i[4]=q-Xe,i[5]=1-W-Be,i[6]=Re+Ge,i[7]=0,i[8]=ye+je,i[9]=Re-Ge,i[10]=1-W-$,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}(tt,g.rotation||gt),T=function(i,g){return i[0]=g[0],i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=g[1],i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=g[2],i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}(at,g.scale||yt);return _(T,b,T),_(i,m,T)}return function(i){return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,i}(i)}([],g);delete g.translation,delete g.rotation,delete g.scale,g.matrix=i}return g}O(i){const g={};for(const m in i){const _=i[m];let b,T;_.instanceTechnique&&_.instanceTechnique.values?(b=_.instanceTechnique,T=b.values.diffuse):(b=_,T=b.values.tex||b.values.diffuseTex||b.values.diffuse);const P={baseColorTexture:{index:T}};_.name&&(P.name=_.name),_.extensions&&(P.extensions=_.extensions),_.extras&&(P.extras=_.extras),g[m]=P}return g}N(i){if(i.bufferView||i.extensions&&(i.extensions.KHR_binary_glTF||i.extensions.binary_glTF)){const g=i.bufferView?i:i.extensions.KHR_binary_glTF||i.extensions.binary_glTF;i.extensions&&(i.mimeType=g.mimeType,i.width=g.width,i.height=g.height);const m=this.gltf.bufferViews[g.bufferView],_=this.buffers[g.bufferView]=new Uint8Array(this.glbBuffer.buffer,(m.byteOffset||0)+this.glbBuffer.byteOffset,m.byteLength);return this.getImageByBuffer(_,i)}return this.requestExternalImage(i)}S(i){const g=this.gltf.textures[i];if(!g)return null;const m=this.gltf.images[g.source];return this.N(m).then((i=>({image:{array:i.data,width:i.width,height:i.height,index:g.source,mimeType:m.mimeType,name:m.name,extras:m.extras},sampler:this.gltf.samplers[g.sampler]})))}getBaseColorTexture(i){const g=this.gltf.materials[i];let m,_;if(g.instanceTechnique&&g.instanceTechnique.values?(m=g.instanceTechnique,_=m.values.diffuse):(m=g,_=m.values.tex||m.values.diffuseTex||m.values.diffuse),void 0===_||void 0===this.gltf.textures)return null;const b=this.gltf.textures[_];if(!b)return null;return{format:b.format||6408,internalFormat:b.internalFormat||6408,type:b.type||5121,sampler:this.gltf.samplers[b.sampler],source:this.gltf.images[b.source]}}getMaterial(){return null}getAnimations(){return null}}const It=9729;class F extends R{constructor(i,g,m,_,b,T,P,I){super(_,b,T,P,I),this.rootPath=i,this.gltf=g,this.glbBuffer=m,this.buffers={},this.requests={},this.accessor=new k(i,g,m,P,I)}iterate(i,g){const m=this.gltf[g];if(m)for(let g=0;g<m.length;g++)i(g,m[g],g)}createNode(i){const g={};return Ye(g,i),!Xe(i.weights)&&this.gltf.meshes&&Xe(g.mesh)?g.weights=this.gltf.meshes[g.mesh].weights:i.weights&&(g.weights=i.weights),g}S(i){const g=this.gltf.textures[i];if(!g)return null;let m=g.source;if(g.extensions&&g.extensions.EXT_texture_webp?m=g.extensions.EXT_texture_webp.source:g.extensions&&g.extensions.KHR_texture_basisu&&(m=g.extensions.KHR_texture_basisu.source),!Xe(m))return null;const _=this.gltf.images[m];return this.N(_).then((i=>{if(!i)return null;const m={image:{array:i.data,mipmap:i.mipmap,width:i.width,height:i.height,index:g.source,mimeType:_.mimeType,name:_.name,extensions:_.extensions,extras:_.extras}};Ye(m,g);const b=Xe(g.sampler)?this.gltf.samplers[g.sampler]:void 0;if(b&&(m.sampler=b,m.sampler.magFilter=b.magFilter||It,m.sampler.minFilter=b.minFilter||9987,m.sampler.wrapS=b.wrapS||10497,m.sampler.wrapT=b.wrapT||10497),"image/ktx2"===m.image.mimeType&&!m.image.mipmap&&m.sampler&&m.sampler.minFilter!==It&&9728!==m.sampler.minFilter){const i=m.sampler.minFilter;m.sampler.minFilter=9984===i||9986===i?9728:It}return i.format&&(m.format=i.format),m}))}N(i){if(!Xe(i.bufferView))return this.requestExternalImage(i);{const g=this.gltf.bufferViews[i.bufferView],m=this.gltf.buffers[g.buffer];if(m.uri)return this.requestImageFromBufferURI(m,g,i);if(this.glbBuffer)return this.B(g,i)}return null}B(i,g){const m=this.m(i,this.glbBuffer.buffer,this.glbBuffer.byteOffset);return this.getImageByBuffer(m,g)}m(i,g,m){m=m||0;return new Uint8Array(g,(i.byteOffset||0)+m,i.byteLength)}R(i,g){const m=new Array(i.byteLength);for(let g=0;g<i.byteLength;g++)m[g]=String.fromCharCode(i[g]);m.join("");const _="data:"+(g=g||"image/png")+";base64,"+function(i){return"undefined"!=typeof self?self.btoa(i):window.btoa(i)}(unescape(encodeURIComponent(m)));return _}getAnimations(i){const g=[];return i.forEach((i=>{g.push(this.getSamplers(i.samplers))})),Promise.all(g).then((g=>{for(let m=0;m<g.length;m++)i[m].samplers=g[m];return i}))}getSamplers(i){const g=[];for(let m=0;m<i.length;m++)(Xe(i[m].input)||Xe(i[m].output))&&(g.push(this.accessor.T("input",i[m].input)),g.push(this.accessor.T("output",i[m].output)));return Promise.all(g).then((g=>{for(let m=0;m<g.length/2;m++)i[m].input=g[2*m],i[m].output=g[2*m+1],i[m].interpolation||(i[m].interpolation="LINEAR");return i}))}}const Et="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null;class V{static read(i,g=0,m=0){m||(m=i.byteLength);const _=new DataView(i,g,m),b=_.getUint32(4,!0);if(1===b)return V.readV1(_,g);if(2===b)return V.readV2(i,g);throw new Error("Unsupported glb version : "+b)}static readV1(i,g){const m=i.getUint32(8,!0),_=i.getUint32(12,!0);if(m!==i.byteLength)throw new Error("Length in GLB header is inconsistent with glb's byte length.");const b=Lt(i.buffer,20+g,_);return{json:JSON.parse(b),glbBuffer:{byteOffset:20+g+_,buffer:i.buffer,byteLength:m}}}static readV2(i,g){let m,_,b;const T=new DataView(i,g+12);let P=0;for(;P+8<T.byteLength;){const I=T.getUint32(P,!0);P+=4;const H=T.getUint32(P,!0);if(P+=4,1313821514===H)m=Lt(i,g+12+P,I);else if(5130562===H){b=g+12+P,_=I;break}P+=I}return{json:JSON.parse(m),glbBuffer:{byteOffset:b,buffer:i,byteLength:_}}}}function Lt(i,g,m){if(Et){const _=new Uint8Array(i,g,m);return Et.decode(_)}return function(i){const g=i.length;let m="";for(let _=0;_<g;){let b=i[_++];if(128&b){let m=Dt[b>>3&7];if(!(64&b)||!m||_+m>g)return null;for(b&=63>>m;m>0;m-=1){const g=i[_++];if(128!=(192&g))return null;b=b<<6|63&g}}m+=String.fromCharCode(b)}return m}(new Uint8Array(i,g,m))}const Dt=[1,1,1,1,2,2,3,0],Ft=[0,0,0],Ht=[0,0,0,1],Bt=[1,1,1],zt={TRANSLATION:[0,0,0],ROTATION:[0,0,0,1],SCALE:[1,1,1]},Vt={PREVIOUS:null,NEXT:null,PREINDEX:null,NEXTINDEX:null,INTERPOLATION:null},Ut={C(i,g,m,_,b,T,I,H){const W=Xe(i)?g.animations:[g.animations[0]],q={};for(let g=0;g<W.length;g++){const $=W[g],ye=$.name||g;if(Xe(i)&&ye!==i)continue;const Re=$.channelsMap[m];if(Re)for(let i=0;i<Re.length;i++){const g=Re[i];"translation"===g.target.path?(this.U(b,$.samplers[g.sampler],_,1),q.translation=P(Ft,b)):"rotation"===g.target.path?(this.k(T,$.samplers[g.sampler],_,1),q.rotation=Be(Ht,T)):"scale"===g.target.path?(this.U(I,$.samplers[g.sampler],_,1),q.scale=P(Bt,I)):"weights"===g.target.path&&H&&(this.U(H,$.samplers[g.sampler],_,H.length),q.weights=H)}}return q},U(i,g,m,_){switch(g.interpolation){case"LINEAR":{const b=this.L(Vt,g,m,1*_);b&&(i=function(i,g,m,_){for(let b=0;b<i.length;b++)i[b]=g[b]+_*(m[b]-g[b]);return i}(i,b.PREVIOUS,b.NEXT,b.INTERPOLATION));break}case"STEP":{const b=this.L(Vt,g,m,1*_);b&&(i=function(i,g){for(let m=0;m<i.length;m++)i[m]=g[m];return i}(i,...b.PREVIOUS));break}case"CUBICSPLINE":{const b=this.L(Vt,g,m,3*_);b&&(i=this.q(i,b,g.input.array,3*_));break}}return i},k(i,g,m){switch(g.interpolation){case"LINEAR":{const _=this.L(Vt,g,m,1);_&&function(i,g,m,_){var b,T,P,I,H,W=g[0],q=g[1],$=g[2],ye=g[3],Re=m[0],Be=m[1],Ge=m[2],je=m[3];(T=W*Re+q*Be+$*Ge+ye*je)<0&&(T=-T,Re=-Re,Be=-Be,Ge=-Ge,je=-je),1-T>1e-6?(b=Math.acos(T),P=Math.sin(b),I=Math.sin((1-_)*b)/P,H=Math.sin(_*b)/P):(I=1-_,H=_),i[0]=I*W+H*Re,i[1]=I*q+H*Be,i[2]=I*$+H*Ge,i[3]=I*ye+H*je}(i,_.PREVIOUS,_.NEXT,_.INTERPOLATION);break}case"STEP":{const _=this.L(Vt,g,m,1);_&&(i=q(i,..._.PREVIOUS));break}case"CUBICSPLINE":{const _=this.L(Vt,g,m,3);if(_){for(let i=0;i<_.PREVIOUS.length;i++)_.PREVIOUS[i]=Math.acos(_.PREVIOUS[i]),_.NEXT[i]=Math.acos(_.NEXT[i]);i=this.q(i,_,g.input.array,3);for(let g=0;g<i.length;g++)i[g]=Math.cos(i[g])}break}}return i},F(i,g){const m=i.length;let _,b,T,P=0,I=m-1,H=Math.floor((P+I)/2);for(;P<=m-1&&I>=0;){if(P===I)return null;if(i[H]<=g&&g<=i[H+1]){const m=i[H];return _=H,b=H+1,T=(g-m)/(i[H+1]-m),{preIndx:_,nextIndex:b,interpolation:T}}g<i[H]?(I=H,H=Math.floor((P+I)/2)):i[H+1]<g&&(P=H,H=Math.floor((P+I)/2))}return null},L(i,g,m,_){const b=g.input.array,T=g.output.array,P=g.output.itemSize;(m<b[0]||m>b[b.length-1])&&(m=Math.max(b[0],Math.min(b[b.length-1],m))),m===b[b.length-1]&&(m=b[0]);const I=this.F(b,m);if(!I||!I.nextIndex)return null;const{preIndx:H,nextIndex:W,interpolation:q}=I;i.PREINDEX=H,i.NEXTINDEX=W,i.INTERPOLATION=q;const $=P*_;return i.PREVIOUS=T.subarray(i.PREINDEX*$,(i.PREINDEX+1)*$),i.NEXT=T.subarray(i.NEXTINDEX*$,(i.NEXTINDEX+1)*$),i},q(i,g,m,_){const b=g.INTERPOLATION,T=m[g.PREINDEX],P=m[g.NEXTINDEX];for(let m=0;m<3;m++){const I=g.PREVIOUS[_+m],H=(P-T)*g.PREVIOUS[2*_+m],W=g.NEXT[3+m],q=(P-T)*g.NEXT[m],$=(2*Math.pow(b,3)-3*Math.pow(b,2)+1)*I+(Math.pow(b,3)-2*Math.pow(b,2)+b)*H+(2*-Math.pow(b,3)+3*Math.pow(b,2))*W+(Math.pow(b,3)-Math.pow(b,2))*q;i[m]=$}return i},getAnimationClip(i,g,m,_){const b=i.nodes[g]&&i.nodes[g].weights;return I(Ft,...zt.TRANSLATION),q(Ht,...zt.ROTATION),I(Bt,...zt.SCALE),this.C(_,i,g,m,Ft,Ht,Bt,b)},getTimeSpan(i){if(!i.animations)return null;if(i.timeSpan)return i.timeSpan;const g=i.animations;return i.timeSpan={},g.forEach(((g,m)=>{let _=-1/0,b=1/0;const T=g.channels;for(let i=0;i<T.length;i++){const m=g.samplers[T[i].sampler].input.array;m[m.length-1]>_&&(_=m[m.length-1]),m[0]<b&&(b=m[0])}i.timeSpan[g.name||m]={max:_,min:b}})),i.timeSpan},getTimeSpanByName(i,g){const m=this.getTimeSpan(i);return m?Xe(g)?m[g]:m[Object.keys(m)[0]]:null}};let Gt=!1;if("undefined"!=typeof OffscreenCanvas){let i;try{i=new OffscreenCanvas(2,2).getContext("2d")}catch(m){}i&&"undefined"!=typeof createImageBitmap&&(Gt=!0)}const jt="undefined"==typeof document?null:document.createElement("canvas");function Wt(i,g,m){const _=new Image;_.crossOrigin="",_.onload=()=>{if(!jt)return void m(new Error("There is no canvas to draw image!"));jt.width=_.width,jt.height=_.height;const i=jt.getContext("2d",{willReadFrequently:!0});i.drawImage(_,0,0,_.width,_.height);const g=i.getImageData(0,0,_.width,_.height),b={width:_.width,height:_.height,data:new Uint8Array(g.data)};m(null,b)},_.onerror=function(i){m(i)},_.src=i}const qt=[],Xt=[];let Zt,$t;function Yt(i,g,m){Zt||(Zt=new OffscreenCanvas(2,2),$t=Zt.getContext("2d",{willReadFrequently:!0}));let _=null;if(Ze(i))this.options.urlModifier&&(i=this.options.urlModifier(i)),qt.push([i,g,m,this]),Qt();else{const g=new Blob([i]);_=createImageBitmap(g),_.then(Jt.bind(this)).then((i=>{m(null,i)})).catch((i=>{console.warn(i),m(i)}))}}function Qt(){if(!qt.length||Xt.length>30)return;const i=qt.shift(),[g,m,_,b]=i;Xt.push(i),fetch(g,m).then((i=>i.arrayBuffer())).then((i=>{const g=new Blob([new Uint8Array(i)]);return createImageBitmap(g)})).then(Jt.bind(b)).then((g=>{_.call(b,null,g);const m=Xt.indexOf(i);Xt.splice(m,1),Qt()})).catch((g=>{console.warn(g),_.call(b,g);const m=Xt.indexOf(i);Xt.splice(m,1),Qt()}))}function Jt(i){let{width:g,height:m}=i;Kt(g)||(g=en(g)),Kt(m)||(m=en(m));const _=this.options.maxTextureSize;_&&(g=Math.min(_,g),m=Math.min(_,m)),Zt.width=g,Zt.height=m,$t.drawImage(i,0,0,g,m),i.close();const b=$t.getImageData(0,0,g,m);return{width:g,height:m,data:new Uint8Array(b.data)}}function Kt(i){return!(i&i-1)&&0!==i}function en(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function tn(i,g){for(const m in i)if(i[m]===g)return m;return g}i.Ajax=Tt,i.GLTFLoader=class{constructor(i,g,m){if(this.options=m||{},this.options.decoders||(this.options.decoders={}),this.u=this.options.fetchOptions||{},g.buffer instanceof ArrayBuffer){const{json:m,glbBuffer:_}=V.read(g.buffer,g.byteOffset,g.byteLength);this.D(i,m,_)}else this.D(i,g);this.V=new k(this.rootPath,this.gltf,this.glbBuffer,this.u,this.options.urlModifier),this.j()}j(){const i=this.gltf.extensionsRequired;if(i){if(i.indexOf("KHR_draco_mesh_compression")>=0&&!this.options.decoders.draco)throw new Error("KHR_draco_mesh_compression is required but @maptalks/transcoders.draco is not loaded");if(i.indexOf("KHR_texture_basisu")>=0&&!this.options.decoders["image/ktx2"])throw new Error("KHR_texture_basisu is required but @maptalks/transcoders.ktx2 is not loaded");if(i.indexOf("EXT_meshopt_compression")>=0)throw new Error("EXT_meshopt_compression extension is not supported yet.")}}K(){const i=this.gltf.extensions;return i&&i.KHR_techniques_webgl?this.V.requestKHRTechniquesWebgl(i.KHR_techniques_webgl).then((g=>(i.KHR_techniques_webgl=g,i))):Promise.resolve(i)}H(){if(!Array.isArray(this.gltf.programs))return;const i=this.gltf.materials;for(let g=0;g<i.length;g++)i[g]&&i[g].extensions&&i[g].extensions.KHR_technique_webgl&&(i[g].extensions.KHR_techniques_webgl=i[g].extensions.KHR_technique_webgl,delete i[g].extensions.KHR_technique_webgl);const g=this.gltf.extensions||{},m=this.gltf.techniques;g.KHR_techniques_webgl={programs:this.gltf.programs,shaders:this.gltf.shaders,techniques:m};for(let g=0;g<i.length;g++){const b=(_=i[g])&&_.extensions&&_.extensions.KHR_techniques_webgl;if(b){const{values:i,technique:g}=b,_=m[g];if(!_||!i)continue;const{uniforms:T,parameters:P}=_,I={};for(const g in i){const m=tn(T,g);I[m]=i[g],P[g]&&35678===P[g].type&&(I[m]={index:i[g]})}b.values=I}}var _;for(let i=0;i<m.length;i++){const g=m[i];if(!g)continue;const{attributes:_,uniforms:b,parameters:T}=g;if(_)for(const i in _){_[i]=T[_[i]]}if(b)for(const i in b){b[i]=T[b[i]]}delete g.parameters}return delete this.gltf.programs,delete this.gltf.shaders,delete this.gltf.techniques,this.gltf.extensions=g,g}load(i){i=i||{},this.H();const g=this.X(i),m=this.$(),_=this.G(),b=this.K();return Promise.all([g,m,_,b]).then((i=>(i[0].animations=i[1],i[0].textures=i[2],i[0].extensions=i[3],i[0].transferables=this.transferables||[],this.createChannelsMap(i[0]),i[0])))}createChannelsMap(i){const g=i.animations;if(g)for(let i=0;i<g.length;i++){const m=g[i];m.channelsMap={};for(let i=0;i<m.channels.length;i++){const g=m.channels[i];m.channelsMap[g.target.node]||(m.channelsMap[g.target.node]=[]),m.channelsMap[g.target.node].push(g)}}}getExternalResources(){const i=[];if(this.gltf){const{buffers:g,images:m}=this.gltf;for(let m=0;m<g.length;m++)g[m].uri&&g[m].uri.indexOf("data:application/octet-stream;base64")<0&&i.push({type:"buffer",uri:g[m].uri});for(let g=0;g<m.length;g++)m[g].uri&&m[g].uri.indexOf("data:image/")<0&&i.push({type:"image",uri:m[g].uri})}return i}static getAnimationClip(i,g,m,_){return Ut.getAnimationClip(i,g,m,_)}static getAnimationTimeSpan(i,g){return Ut.getTimeSpanByName(i,g)}static getTypedArrayCtor(i){return Qe(i)}static readInterleavedArray(i,g,m,_,b,T,P){return vt(i,g,m,_,b,T,P)}D(i,g,m){this.gltf=g,this.glbBuffer=m,this.version=g.asset?+g.asset.version:1,this.rootPath=i,this.buffers={},this.requests={},this.options.requestImage=Gt?Yt.bind(this):this.options.requestImage||Wt,this.options.transferable&&(this.transferables=[]),2===this.version?(this.adapter=new F(i,g,m,this.options.requestImage,this.options.decoders||{},this.options.supportedFormats||{},this.u,this.options.urlModifier),this.adapter.iterate(((i,g,m)=>{g.id="buffer_"+m}),"buffers"),this.adapter.iterate(((i,g,m)=>{g.id="image_"+m}),"images"),this.adapter.iterate(((i,g,m)=>{g.id="accessor_"+m}),"accessors")):(this.adapter=new L(i,g,m,this.options.requestImage,this.options.decoders||{},this.options.supportedFormats||{},this.u,this.options.urlModifier),this.adapter.iterate(((i,g,m)=>{g.id="accessor_"+m}),"accessors"),this.adapter.iterate(((i,g,m)=>{g.id="image_"+m}),"images"))}J(i,g){if(i.children&&i.children.length>0){if(!("number"==typeof(m=i.children[0])&&isFinite(m)||Ze(i.children[0])))return i;const _=i.children.map((i=>{const m=g[i];return m.nodeIndex=i,this.J(m,g)}));i.children=_}var m;return i}X(i){return this.W(i).then((i=>{const g=this.scenes=[];let m;for(const g in i)i[g]=this.J(i[g],i),i[g].nodeIndex=Number(g)?Number(g):g;this.adapter.iterate(((_,b,T)=>{const P={};b.name&&(P.name=b.name),b.nodes&&(P.nodes=b.nodes.map((g=>i[g]))),this.gltf.scene===_&&(m=T),g.push(P)}),"scenes");const _={textures:this.gltf.textures,asset:this.gltf.asset,scene:m,scenes:g,nodes:i,meshes:this.meshes,materials:this.gltf.materials,skins:this.skins,extensionsRequired:this.gltf.extensionsRequired,extensionsUsed:this.gltf.extensionsUsed};if(this.gltf.extensions&&(_.extensions=this.gltf.extensions),1===this.version){const i=this.adapter.O(this.gltf.materials);_.materials=i}return delete this.gltf.buffers,_.json=this.gltf,_}))}W(i){return this.Y(i).then((()=>{const i=this.nodes={};return this.adapter.iterate(((g,m)=>{const _=this.adapter.createNode(m,this.meshes,this.skins);i[g]=_}),"nodes"),i}))}Z(){this.skins=[];const i=[];return this.adapter.iterate(((g,m,_)=>{i.push(this.tt(m).then((i=>{i.index=_,this.skins.push(i)})))}),"skins"),i}tt(i){return this.adapter.accessor.T("inverseBindMatrices",i.inverseBindMatrices).then((g=>(i.inverseBindMatrices=g,g&&g.buffer&&this.transferables&&this.transferables.indexOf(g.buffer)<0&&this.transferables.push(g.buffer),i)))}$(){const i=this.gltf.animations;return Xe(i)?this.adapter.getAnimations(i):null}Y(i){this.meshes={};let g=[];return this.adapter.iterate(((m,_,b)=>{g.push(this.et(_,i).then((i=>{i.index=b,this.meshes[m]=i})))}),"meshes"),g=g.concat(this.Z()),Promise.all(g)}et(i,g){const m=i.primitives.map((i=>this.nt(i,g))).filter((i=>!!i));return Promise.all(m).then((g=>{const m={};return Ye(m,i),m.primitives=g,m}))}G(){const i=this.gltf.textures;if(!i)return null;const g=[];for(const m in i)g.push(this.adapter.S(m));return Promise.all(g).then((g=>{if(this.transferables)for(let i=0;i<g.length;i++){const m=g[i]&&g[i].image.array;if(m){let i;i=m instanceof ImageBitmap?m:m.buffer,i&&this.transferables.indexOf(i)<0&&this.transferables.push(i)}}if(!Array.isArray(i)){const m={},_=Object.keys(i);for(let i=0;i<g.length;i++)g[i]&&(m[_[i]]=g[i]);return m}return g}))}nt(i,g){let m;const _=[],b=i.extensions;if(Xe(i.targets))for(let g=0;g<i.targets.length;g++){const m=i.targets[g];for(const i in m){const b=this.adapter.accessor.T(`morphTargets_${i}_${g}`,m[i]);b&&_.push(b)}}if(b&&b.KHR_draco_mesh_compression){if(!this.options.decoders.draco&&(!this.gltf.extensionsRequired||!this.gltf.extensionsRequired.indexOf("KHR_draco_mesh_compression")<0))return null;const i=this.options.decoders.draco,{bufferView:T,attributes:P}=b.KHR_draco_mesh_compression,I=this.gltf.bufferViews[T],H=this.V.I(I).then((m=>{const{buffer:_,byteOffset:b}=m;let{byteOffset:T}=I;T||(T=0);const H=new DataView(_,b+T,I.byteLength);return i(H,{attributes:P,useUniqueIDs:!1,skipAttributeTransform:g.skipAttributeTransform}).then((i=>{const g=Object.values(i.attributes);return i.indices&&g.push(i.indices),g}))}));_.push(H),m=Promise.all(_)}else{const g=i.attributes;for(const i in g){const m=this.adapter.accessor.T(i,g[i]);m&&_.push(m)}if(Xe(i.indices)){const g=this.adapter.accessor.T("indices",i.indices);g&&_.push(g)}m=Promise.all(_)}return m.then((g=>{if(b&&b.KHR_draco_mesh_compression){const m=i.targets?i.targets.length:0;g[m]=g[m].concat(g.slice(0,m)),g=g[m]}let m,_;const T={attributes:g.reduce(((i,g)=>{if("indices"===g.name)m=g;else if(g.name.indexOf("morphTargets_")>-1)_=_||{},_[g.name.slice(13)]=g;else{if(!("POSITION"!==g.name||g.min&&g.max)){const i=[1/0,1/0,1/0],m=[-1/0,-1/0,-1/0],{itemSize:_,array:b}=g,T=b.length/_;for(let g=0;g<T;g++)for(let T=0;T<_;T++){const P=g*_+T;b[P]<i[T]&&(i[T]=b[P]),b[P]>m[T]&&(m[T]=b[P])}if(g.quantization){const _=g.quantization,b=_.range/(1<<_.quantizationBits),T=_.minValues;W(i,i,b),H(i,i,T),W(m,m,b),H(m,m,T)}g.min=i,g.max=m}i[g.name]=g}return this.transferables&&g.array.buffer&&this.transferables.indexOf(g.array.buffer)<0&&this.transferables.push(g.array.buffer),i}),{}),material:i.material};return m&&(T.indices=m),_&&(T.morphTargets=_),T.mode=Xe(i.mode)?i.mode:4,Xe(i.extras)&&(T.extras=i.extras),T}))}},g().maptalks_gltf_loader=i}rx.inject=function(i){const g=i.toString(),m=g.indexOf("{")+1,_=g.substring(0,m),b=nx.gl_trans__coders=nx.gl_trans__coders||{};let T=`${_}\n    const _____getGlobal = ${tx.toString()};\n    const g___lobals = _____getGlobal()\n    const tran_____scoders = g___lobals['gl_trans__coders'] = g___lobals['gl_trans__coders'] || {};`;for(const i in b)"inject"!==i&&"getTranscoder"!==i&&"registerTranscoder"!==i&&(T+='tran_____scoders["'+i+'"] ='+b[i].toString()+"\n;");return T+="\n("+tx().maptalks_gltf_loader_bundle.toString()+")({});\n",T+="\n"+g.substring(_.length),T},rx.registerTranscoder=function(i,g){rx[i]=g},rx.getTranscoder=function(i){return rx[i]},ix({});function ox(){return function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;throw new Error("unable to locate global object")}().maptalks_gltf_loader}function sx(i){return!ax(i)&&("string"==typeof i||null!==i.constructor&&i.constructor===String)}function ax(i){return null==i}function lx(i){return!ax(i)}function hx(i){return!ax(i)&&("function"==typeof i||null!==i.constructor&&i.constructor===Function)}function cx(i,...g){return Object.assign(i,...g),i}function ux(i,...g){for(let m=0;m<g.length;m++){const _=g[m];for(const g in _)null!=_[g]&&(i[g]=_[g])}return i}function fx(i){return"number"==typeof i&&!isNaN(i)}function dx(i,g,m){return i*(1-m)+g*m}function px(i){return Array.isArray(i)||i instanceof Uint8Array||i instanceof Int8Array||i instanceof Uint16Array||i instanceof Int16Array||i instanceof Uint32Array||i instanceof Int32Array||i instanceof Uint8ClampedArray||i instanceof Float32Array||i instanceof Float64Array}function gx(i){return Array.isArray(i)&&Array||i instanceof Uint8Array&&Uint8Array||i instanceof Int8Array&&Int8Array||i instanceof Uint16Array&&Uint16Array||i instanceof Int16Array&&Int16Array||i instanceof Uint32Array&&Uint32Array||i instanceof Int32Array&&Int32Array||i instanceof Uint8ClampedArray&&Uint8ClampedArray||i instanceof Float32Array&&Float32Array||i instanceof Float64Array&&Float64Array}function mx(i){return(i=Math.abs(i))<128?Int8Array:i<32768?Int16Array:Float32Array}function Ax(i,g,m){return Math.min(m,Math.max(g,i))}function yx(i){return!globalThis.MAPTALKS_DISABLE_VAO&&(!i.wgpu&&(i&&i.hasExtension&&i.hasExtension("oes_vertex_array_object")))}function _x(i,g){return Object.prototype.hasOwnProperty.call(i,g)}function vx(i){if(i.data){if(i.data.BYTES_PER_ELEMENT)return i.data.length*i.data.BYTES_PER_ELEMENT;if(i.data.length)return 4*i.data.length}else{if(i.BYTES_PER_ELEMENT)return i.length*i.BYTES_PER_ELEMENT;if(i.length)return 4*i.length;if(i.buffer&&i.buffer.destroy){const g=i.buffer._buffer;return g?g.byteLength:i.buffer.size}}return 0}function xx(i){return i.width*i.height*wx(i.format)*bx(i.type)*("textureCube"===i._reglType?6:1)}function bx(i){return"uint8"===i?1:"uint16"===i||"float16"===i||"half float"===i?2:"uint32"===i||"float"===i||"float32"===i?4:0}function wx(i){return"depth"===i||"alpha"===i||"luminance"===i?1:"luminance alpha"===i||"depth stencil"===i?2:"srgba"===i||"rgb5 a1"===i||"rgba"===i.substring(0,4)?4:"srgb"===i||"rgb"===i.substring(0,3)?3:1}function Tx(i){if(!i.componentType)return!1;const g=ox().GLTFLoader.getTypedArrayCtor(i.componentType);return i.byteStride>0&&i.byteStride!==i.itemSize*g.BYTES_PER_ELEMENT}function Sx(i){return i&&(i.stride>0||Tx(i))}function Mx(i){const g=i.getExtension&&i,m=!g&&i,_="WEBGL_compressed_texture_",b="texture-compression-",T={etc:g?!!g.getExtension(_+"etc"):!!m.features.has(b+"etc2"),etc1:g?!!g.getExtension(_+"etc1"):!!m.features.has(b+"etc2"),s3tc:g?!!g.getExtension(_+"s3tc"):!!m.features.has(b+"bc"),pvrtc:!!g&&!!g.getExtension(_+"pvrtc"),astc:g?!!g.getExtension(_+"astc"):!!m.features.has(b+"astc"),bc7:g?!!g.getExtension("EXT_texture_compression_bptc"):!!m.features.has(b+"bc")};return T[_+"etc"]=T.etc,T[_+"etc1"]=T.etc1,T[_+"s3tc"]=T.s3tc,T[_+"pvrtc"]=T.pvrtc,T[_+"astc"]=T.astc,T[_+"bc7"]=T.bc7,T}function Cx(i){let g=0;const m=i&&i.length||0;if(!m)return g;let _;for(let b=0;b<m;b++)_=i.charCodeAt(b),g=(g<<5)-g+_,g&=g;return g}function Px(i){return!(i&i-1)&&0!==i}function Ix(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function kx(i,g,m){if(px(i))return Px(g)&&Px(m)?i:function(i,g,m){let _=g,b=m;Px(g)||(_=Ix(g)),Px(m)||(b=Ix(m));const T=new ImageData(new Uint8ClampedArray(i),g,m),P=document.createElement("canvas");P.width=g,P.height=m,P.getContext("2d").putImageData(T,0,0);const I=document.createElement("canvas");I.width=_,I.height=b,I.getContext("2d").drawImage(P,0,0,g,m,0,0,b,b),console.warn(`Texture's size is not power of two, resize from (${g}, ${m}) to (${_}, ${b})`);let H=document.getElementById("_debug_resize_canvas");return H||(H=document.createElement("canvas"),H.id="_debug_resize_canvas",document.body.appendChild(H)),H.width=_,H.height=b,H.getContext("2d").drawImage(I,0,0),I}(i,g,m);if(Px(i.width)&&Px(i.height))return i;m=i.height,Px(g=i.width)||(g=Ix(g)),Px(m)||(m=Ix(m));const _=document.createElement("canvas");_.width=g,_.height=m,_.getContext("2d").drawImage(i,0,0,g,m);const b=i.src,T=b.lastIndexOf("/")+1,P=b.substring(T);return console.warn(`Texture(${P})'s size is not power of two, resize from (${i.width}, ${i.height}) to (${g}, ${m})`),_}function Ox(i){return!!i.wgpu||(!i._gl||i._gl instanceof WebGL2RenderingContext)}var Ex=Object.freeze({__proto__:null,clamp:Ax,defined:lx,extend:cx,extendWithoutNil:ux,getArrayCtor:gx,getBufferSize:vx,getPosArrayType:mx,getSupportedFormats:Mx,getTexMemorySize:xx,getTextureByteWidth:bx,getTextureChannels:wx,hasOwn:_x,hashCode:Cx,interpolate:dx,isArray:px,isFunction:hx,isInStride:Tx,isInterleaved:Sx,isNil:ax,isNumber:fx,isPowerOfTwo:Px,isString:sx,isSupportVAO:yx,isTextureDestroyed:function(i){return i.device?!i.texture:!i._texture||!i._texture.texture},lerp:function(i,g,m,_){for(let b=0;b<i.length;b++)i[b]=g[b]+_*(m[b]-g[b]);return i},log2:function(i){return Math.log2(i)},normalize:function(i,g){let m=0;for(let i=0,_=g.length;i<_;i++)m+=g[i];for(let _=0,b=g.length;_<b;_++)i[_]=g[_]/m;return i},resizeToPowerOfTwo:kx,set:function(i,g){for(let m=0;m<i.length;m++)i[m]=g[m];return i},supportNPOT:Ox});function Rx(i){return class EventableMixin extends i{on(i,g){return this._events||(this._events={type:[g]}),this._events[i]=this._events[i]||[],this._events[i].push(g),this}once(i,g){return this.on(i,this._wrapOnce(i,g))}off(i,g){return this._events&&this._events[i]?(this._events[i].splice(this._events[i].indexOf(g),1),this):this}fire(i,g={}){if(!this._events||!this._events[i])return this;g.target||(g.target=this);const m=this._events[i].slice(0);for(const i of m)i(g);return this}_wrapOnce(i,g){const m=this;let _=!1;return function b(T){_||(_=!0,g(T),m.off(i,b))}}}}const Lx="__reshader_disposed",Dx="not implemented";var Fx=Object.freeze({__proto__:null,ERROR_NOT_IMPLEMENTED:Dx,KEY_DISPOSED:Lx,WEBGL_EXTENSIONS:["ANGLE_instanced_arrays","OES_element_index_uint","OES_standard_derivatives"],WEBGL_OPTIONAL_EXTENSIONS:["OES_vertex_array_object","OES_texture_half_float","OES_texture_half_float_linear","OES_texture_float","OES_texture_float_linear","WEBGL_depth_texture","EXT_shader_texture_lod","EXT_texture_filter_anisotropic"]});const Nx="_reshader_refCount";let Hx=class Base{};class AbstractTexture extends(Rx(Hx)){constructor(i,g){if(super(),hx(i)){this._texture=i,i=this.config={};for(const g in this._texture)_x(this._texture,g)&&(hx(this._texture[g])||(i[g]=this._texture[g]))}else if(this.config=i||{},this.resLoader=g,(i.url||i.promise)&&!i.data){this._loading=!0;const m=this;let _;if(i.promise)_=i.promise;else{let m;m=i.arrayBuffer?g.getArrayBuffer:g.get,_=m.call(g,i.url)}i.data=g.getDefaultTexture(i.url),this.promise=_,_.then((i=>(delete this.promise,m._loading=!1,m.config?(m.onLoad(i),Array.isArray(i)||(i=[i]),m.fire("complete",{target:this,resources:i}),i):i))).catch((i=>{console.error("error when loading texture image.",i),m.fire("error",{target:this,error:i})}))}}onLoad(i){}isReady(){return!this._loading}set(i,g){return this.config[i]=g,this.dirty=!0,this}get(i){return this.config[i]}createREGLTexture(i){return null}getREGLTexture(i){return this._texture||(this._texture=this.createREGLTexture(i),this.config.persistent||(this.config.data&&(this.config.data instanceof ImageBitmap||(this.config.data=[])),this.config.image&&(this.config.image.array=[]),this.config.mipmap&&delete this.config.mipmap)),this.dirty&&this._update(),this._texture}getMemorySize(){if(!this.config)return 0;const{width:i,height:g,type:m,format:_}=this.config;return i*g*bx(m||"uint8")*wx(_||"rgba")}_update(){throw new Error(Dx)}dispose(){this.config&&this.config.url&&(URL.revokeObjectURL(this.config.url),this.resLoader.disposeRes(this.config.url)),this.config&&this.config.data instanceof ImageBitmap&&(this.config.data.close(),this.config.data=[]),this._texture&&!this._texture[Lx]&&(this._texture[Nx]&&this._texture[Nx]--,this._texture[Nx]||(this._texture.destroy(),this._texture[Lx]=!0,delete this._texture)),delete this.resLoader,delete this._regl;const i=this.config&&this.config.url;delete this.config,i&&this.fire("disposed",{target:this,url:i})}}const Bx=mA([]),zx=mA([]);class BoundingBox{constructor(i,g){this.min=i||[1/0,1/0,1/0],this.max=g||[-1/0,-1/0,-1/0],this.updateVertex()}static copy(i,g){WA(i.min,g.min),WA(i.max,g.max);for(let m=0;m<g.vertex.length;m++)WA(i.vertex[m],g.vertex[m]);return i}combine(i){if(!i)return this;let g,m;return Array.isArray(i)?(g=i[0],m=i[1]):(g=i.min,m=i.max),g[0]<this.min[0]&&(this.min[0]=g[0],this._dirty=!0),g[1]<this.min[1]&&(this.min[1]=g[1],this._dirty=!0),g[2]<this.min[2]&&(this.min[2]=g[2],this._dirty=!0),m[0]>this.max[0]&&(this.max[0]=m[0],this._dirty=!0),m[1]>this.max[1]&&(this.max[1]=m[1],this._dirty=!0),m[2]>this.max[2]&&(this.max[2]=m[2],this._dirty=!0),this}dirty(){return this._dirty=!0,this}getCenter(){return this.center||(this.center=[0,0,0],this._dirty=!0),this._dirty&&(XA(this.center,this.min,this.max),QA(this.center,this.center,.5)),this._dirty=!1,this.center}containPoint(i){const g=this.min,m=this.max;return g[0]<=i[0]&&g[1]<=i[1]&&g[2]<=i[2]&&m[0]>=i[0]&&m[1]>=i[1]&&m[2]>=i[2]}isFinite(){const i=this.min,g=this.max;return isFinite(i[0])&&isFinite(i[1])&&isFinite(i[2])&&isFinite(g[0])&&isFinite(g[1])&&isFinite(g[2])}updateVertex(){if(!this.vertex){this.vertex=[];for(let i=0;i<8;i++)this.vertex.push([0,0,0])}return this.vertex[0][0]=this.min[0],this.vertex[0][1]=this.min[1],this.vertex[0][2]=this.min[2],this.vertex[1][0]=this.min[0],this.vertex[1][1]=this.min[1],this.vertex[1][2]=this.max[2],this.vertex[2][0]=this.min[0],this.vertex[2][1]=this.max[1],this.vertex[2][2]=this.max[2],this.vertex[3][0]=this.min[0],this.vertex[3][1]=this.max[1],this.vertex[3][2]=this.min[2],this.vertex[4][0]=this.max[0],this.vertex[4][1]=this.min[1],this.vertex[4][2]=this.min[2],this.vertex[5][0]=this.max[0],this.vertex[5][1]=this.min[1],this.vertex[5][2]=this.max[2],this.vertex[6][0]=this.max[0],this.vertex[6][1]=this.max[1],this.vertex[6][2]=this.max[2],this.vertex[7][0]=this.max[0],this.vertex[7][1]=this.max[1],this.vertex[7][2]=this.min[2],this.vertex}copy(i){return i?BoundingBox.copy(i,this):new BoundingBox(this.min.slice(),this.max.slice())}equals(i){if(!hy(this.min,i.min)||!hy(this.max,i.max))return!1;const g=i.vertex;for(let i=0;i<this.vertex.length;i++)if(!hy(g[i],this.vertex[i]))return!1;return!0}transform(i,g){if(i=i||zx,(g=g||zx)[1]||g[2]||g[4]||g[6]||g[8]||g[9]){const m=this.vertex,_=_A(Bx,g,i);for(let i=0;i<m.length;i++)oy(this.vertex[i],this.vertex[i],_);const b=this.vertex.map((i=>i[0])),T=this.vertex.map((i=>i[1])),P=this.vertex.map((i=>i[2])),I=Math.min(...b),H=Math.max(...b),W=Math.min(...T),q=Math.max(...T),$=Math.min(...P),ye=Math.max(...P);qA(this.min,I,W,$),qA(this.max,H,q,ye)}else{const m=_A(Bx,g,i);oy(this.min,this.min,m),oy(this.max,this.max,m)}return this}}function Vx(i,g,m=2){const _=g&&g.length,b=_?g[0]*m:i.length;let T=Ux(i,0,b,m,!0);const P=[];if(!T||T.next===T.prev)return P;let I,H,W;if(_&&(T=function(i,g,m,_){const b=[];for(let m=0,T=g.length;m<T;m++){const P=Ux(i,g[m]*_,m<T-1?g[m+1]*_:i.length,_,!1);P===P.next&&(P.steiner=!0),b.push(Kx(P))}b.sort($x);for(let i=0;i<b.length;i++)m=Yx(b[i],m);return m}(i,g,T,m)),i.length>80*m){I=1/0,H=1/0;let g=-1/0,_=-1/0;for(let T=m;T<b;T+=m){const m=i[T],b=i[T+1];m<I&&(I=m),b<H&&(H=b),m>g&&(g=m),b>_&&(_=b)}W=Math.max(g-I,_-H),W=0!==W?32767/W:0}return jx(T,P,m,I,H,W,0),P}function Ux(i,g,m,_,b){let T;if(b===function(i,g,m,_){let b=0;for(let T=g,P=m-_;T<m;T+=_)b+=(i[P]-i[T])*(i[T+1]+i[P+1]),P=T;return b}(i,g,m,_)>0)for(let b=g;b<m;b+=_)T=cb(b/_|0,i[b],i[b+1],T);else for(let b=m-_;b>=g;b-=_)T=cb(b/_|0,i[b],i[b+1],T);return T&&ib(T,T.next)&&(ub(T),T=T.next),T}function Gx(i,g){if(!i)return i;g||(g=i);let m,_=i;do{if(m=!1,_.steiner||!ib(_,_.next)&&0!==rb(_.prev,_,_.next))_=_.next;else{if(ub(_),_=g=_.prev,_===_.next)break;m=!0}}while(m||_!==g);return g}function jx(i,g,m,_,b,T,P){if(!i)return;!P&&T&&function(i,g,m,_){let b=i;do{0===b.z&&(b.z=Jx(b.x,b.y,g,m,_)),b.prevZ=b.prev,b.nextZ=b.next,b=b.next}while(b!==i);b.prevZ.nextZ=null,b.prevZ=null,function(i){let g,m=1;do{let _,b=i;i=null;let T=null;for(g=0;b;){g++;let P=b,I=0;for(let i=0;i<m&&(I++,P=P.nextZ,P);i++);let H=m;for(;I>0||H>0&&P;)0!==I&&(0===H||!P||b.z<=P.z)?(_=b,b=b.nextZ,I--):(_=P,P=P.nextZ,H--),T?T.nextZ=_:i=_,_.prevZ=T,T=_;b=P}T.nextZ=null,m*=2}while(g>1)}(b)}(i,_,b,T);let I=i;for(;i.prev!==i.next;){const H=i.prev,W=i.next;if(T?qx(i,_,b,T):Wx(i))g.push(H.i,i.i,W.i),ub(i),i=W.next,I=W.next;else if((i=W)===I){P?1===P?jx(i=Xx(Gx(i),g),g,m,_,b,T,2):2===P&&Zx(i,g,m,_,b,T):jx(Gx(i),g,m,_,b,T,1);break}}}function Wx(i){const g=i.prev,m=i,_=i.next;if(rb(g,m,_)>=0)return!1;const b=g.x,T=m.x,P=_.x,I=g.y,H=m.y,W=_.y,q=Math.min(b,T,P),$=Math.min(I,H,W),ye=Math.max(b,T,P),Re=Math.max(I,H,W);let Be=_.next;for(;Be!==g;){if(Be.x>=q&&Be.x<=ye&&Be.y>=$&&Be.y<=Re&&tb(b,I,T,H,P,W,Be.x,Be.y)&&rb(Be.prev,Be,Be.next)>=0)return!1;Be=Be.next}return!0}function qx(i,g,m,_){const b=i.prev,T=i,P=i.next;if(rb(b,T,P)>=0)return!1;const I=b.x,H=T.x,W=P.x,q=b.y,$=T.y,ye=P.y,Re=Math.min(I,H,W),Be=Math.min(q,$,ye),Ge=Math.max(I,H,W),je=Math.max(q,$,ye),Xe=Jx(Re,Be,g,m,_),Ze=Jx(Ge,je,g,m,_);let Ye=i.prevZ,Qe=i.nextZ;for(;Ye&&Ye.z>=Xe&&Qe&&Qe.z<=Ze;){if(Ye.x>=Re&&Ye.x<=Ge&&Ye.y>=Be&&Ye.y<=je&&Ye!==b&&Ye!==P&&tb(I,q,H,$,W,ye,Ye.x,Ye.y)&&rb(Ye.prev,Ye,Ye.next)>=0)return!1;if(Ye=Ye.prevZ,Qe.x>=Re&&Qe.x<=Ge&&Qe.y>=Be&&Qe.y<=je&&Qe!==b&&Qe!==P&&tb(I,q,H,$,W,ye,Qe.x,Qe.y)&&rb(Qe.prev,Qe,Qe.next)>=0)return!1;Qe=Qe.nextZ}for(;Ye&&Ye.z>=Xe;){if(Ye.x>=Re&&Ye.x<=Ge&&Ye.y>=Be&&Ye.y<=je&&Ye!==b&&Ye!==P&&tb(I,q,H,$,W,ye,Ye.x,Ye.y)&&rb(Ye.prev,Ye,Ye.next)>=0)return!1;Ye=Ye.prevZ}for(;Qe&&Qe.z<=Ze;){if(Qe.x>=Re&&Qe.x<=Ge&&Qe.y>=Be&&Qe.y<=je&&Qe!==b&&Qe!==P&&tb(I,q,H,$,W,ye,Qe.x,Qe.y)&&rb(Qe.prev,Qe,Qe.next)>=0)return!1;Qe=Qe.nextZ}return!0}function Xx(i,g){let m=i;do{const _=m.prev,b=m.next.next;!ib(_,b)&&ob(_,m,m.next,b)&&lb(_,b)&&lb(b,_)&&(g.push(_.i,m.i,b.i),ub(m),ub(m.next),m=i=b),m=m.next}while(m!==i);return Gx(m)}function Zx(i,g,m,_,b,T){let P=i;do{let i=P.next.next;for(;i!==P.prev;){if(P.i!==i.i&&nb(P,i)){let I=hb(P,i);return P=Gx(P,P.next),I=Gx(I,I.next),jx(P,g,m,_,b,T,0),void jx(I,g,m,_,b,T,0)}i=i.next}P=P.next}while(P!==i)}function $x(i,g){let m=i.x-g.x;if(0===m&&(m=i.y-g.y,0===m)){m=(i.next.y-i.y)/(i.next.x-i.x)-(g.next.y-g.y)/(g.next.x-g.x)}return m}function Yx(i,g){const m=function(i,g){let m=g;const _=i.x,b=i.y;let T,P=-1/0;if(ib(i,m))return m;do{if(ib(i,m.next))return m.next;if(b<=m.y&&b>=m.next.y&&m.next.y!==m.y){const i=m.x+(b-m.y)*(m.next.x-m.x)/(m.next.y-m.y);if(i<=_&&i>P&&(P=i,T=m.x<m.next.x?m:m.next,i===_))return T}m=m.next}while(m!==g);if(!T)return null;const I=T,H=T.x,W=T.y;let q=1/0;m=T;do{if(_>=m.x&&m.x>=H&&_!==m.x&&eb(b<W?_:P,b,H,W,b<W?P:_,b,m.x,m.y)){const g=Math.abs(b-m.y)/(_-m.x);lb(m,i)&&(g<q||g===q&&(m.x>T.x||m.x===T.x&&Qx(T,m)))&&(T=m,q=g)}m=m.next}while(m!==I);return T}(i,g);if(!m)return g;const _=hb(m,i);return Gx(_,_.next),Gx(m,m.next)}function Qx(i,g){return rb(i.prev,i,g.prev)<0&&rb(g.next,i,i.next)<0}function Jx(i,g,m,_,b){return(i=1431655765&((i=858993459&((i=252645135&((i=16711935&((i=(i-m)*b|0)|i<<8))|i<<4))|i<<2))|i<<1))|(g=1431655765&((g=858993459&((g=252645135&((g=16711935&((g=(g-_)*b|0)|g<<8))|g<<4))|g<<2))|g<<1))<<1}function Kx(i){let g=i,m=i;do{(g.x<m.x||g.x===m.x&&g.y<m.y)&&(m=g),g=g.next}while(g!==i);return m}function eb(i,g,m,_,b,T,P,I){return(b-P)*(g-I)>=(i-P)*(T-I)&&(i-P)*(_-I)>=(m-P)*(g-I)&&(m-P)*(T-I)>=(b-P)*(_-I)}function tb(i,g,m,_,b,T,P,I){return!(i===P&&g===I)&&eb(i,g,m,_,b,T,P,I)}function nb(i,g){return i.next.i!==g.i&&i.prev.i!==g.i&&!function(i,g){let m=i;do{if(m.i!==i.i&&m.next.i!==i.i&&m.i!==g.i&&m.next.i!==g.i&&ob(m,m.next,i,g))return!0;m=m.next}while(m!==i);return!1}(i,g)&&(lb(i,g)&&lb(g,i)&&function(i,g){let m=i,_=!1;const b=(i.x+g.x)/2,T=(i.y+g.y)/2;do{m.y>T!=m.next.y>T&&m.next.y!==m.y&&b<(m.next.x-m.x)*(T-m.y)/(m.next.y-m.y)+m.x&&(_=!_),m=m.next}while(m!==i);return _}(i,g)&&(rb(i.prev,i,g.prev)||rb(i,g.prev,g))||ib(i,g)&&rb(i.prev,i,i.next)>0&&rb(g.prev,g,g.next)>0)}function rb(i,g,m){return(g.y-i.y)*(m.x-g.x)-(g.x-i.x)*(m.y-g.y)}function ib(i,g){return i.x===g.x&&i.y===g.y}function ob(i,g,m,_){const b=ab(rb(i,g,m)),T=ab(rb(i,g,_)),P=ab(rb(m,_,i)),I=ab(rb(m,_,g));return b!==T&&P!==I||(!(0!==b||!sb(i,m,g))||(!(0!==T||!sb(i,_,g))||(!(0!==P||!sb(m,i,_))||!(0!==I||!sb(m,g,_)))))}function sb(i,g,m){return g.x<=Math.max(i.x,m.x)&&g.x>=Math.min(i.x,m.x)&&g.y<=Math.max(i.y,m.y)&&g.y>=Math.min(i.y,m.y)}function ab(i){return i>0?1:i<0?-1:0}function lb(i,g){return rb(i.prev,i,i.next)<0?rb(i,g,i.next)>=0&&rb(i,i.prev,g)>=0:rb(i,g,i.prev)<0||rb(i,i.next,g)<0}function hb(i,g){const m=fb(i.i,i.x,i.y),_=fb(g.i,g.x,g.y),b=i.next,T=g.prev;return i.next=g,g.prev=i,m.next=b,b.prev=m,_.next=m,m.prev=_,T.next=_,_.prev=T,_}function cb(i,g,m,_){const b=fb(i,g,m);return _?(b.next=_.next,b.prev=_,_.next.prev=b,_.next=b):(b.prev=b,b.next=b),b}function ub(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function fb(i,g,m){return{i,x:g,y:m,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function db(i){const g=[],m=[],_=i[0][0].length;let b=0,T=0;for(const P of i){for(const i of P)for(let m=0;m<_;m++)g.push(i[m]);T&&(b+=T,m.push(b)),T=P.length}return{vertices:g,holes:m,dimensions:_}}function pb(i){let g;return Array.isArray(i)||i instanceof Float32Array?g="float32":i instanceof Uint32Array?g="uint32":i instanceof Int32Array?g="sint32":i instanceof Uint16Array?g="uint16":i instanceof Int16Array?g="sint16":i instanceof Uint8Array?g="uint8":i instanceof Int8Array&&(g="sint8"),g}const gb={5120:{name:"sint8",bytes:1},5122:{name:"sint16",bytes:2},5124:{name:"sint32",bytes:4},5121:{name:"uint8",bytes:1},5123:{name:"uint16",bytes:2},5125:{name:"uint32",bytes:4},5126:{name:"float32",bytes:4}};function mb(i,g){const m=gb[i].name;return g>1?m+"x"+g:m}const Ab={mat2x3f:{pad:[3,1]},mat2x3h:{pad:[3,1]},mat3x3f:{pad:[3,1]},mat3x3h:{pad:[3,1]},mat4x3f:{pad:[3,1]},mat4x3h:{pad:[3,1]},mat3x4f:{pad:[3,1]},mat3x4h:{pad:[3,1]}};function yb(i,g){return 0===g?i:Math.ceil(i/g)*g}const _b=[],vb={5120:"int8",5122:"int16",5124:"int32",5121:"uint8",5123:"uint16",5125:"uint32",5126:"float"},xb={5120:1,5122:2,5124:4,5121:1,5123:2,5125:4,5126:4},bb={positionSize:3,primitive:"triangles",positionAttribute:"aPosition",normalAttribute:"aNormal",uv0Attribute:"aTexCoord",uv1Attribute:"aTexCoord1",color0Attribute:"aColor0",tangentAttribute:"aTangent",pickingIdAttribute:"aPickingId",textureCoordMatrixAttribute:"aTextureCoordMatrix"};let wb=1;const Tb="_reshader_refCount";class Geometry{static createElementBuffer(i,g){if(i.wgpu){if(Array.isArray(g)){g=new(Ob(g))(g)}return kb(i,g,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,"index buffer")}return i.elements(g)}static createBuffer(i,g,m){return i.wgpu?kb(i,g,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,m):i.buffer(g)}static padGPUBufferAlignment(i,g){const m=i.byteLength/g;if(m%4==0)return i;const _=i.constructor,b=i.length/g,T=Eb(b,m/b),P=new _(T*g);for(let m=0;m<g;m++)for(let g=0;g<b;g++)P[m*T+g]=i[m*b+g];return P}constructor(i,g,m,_){this._version=0,this.data=i,this.elements=g,this.desc=cx({},bb,_),this.semantic=function(i){const g={};for(const m in bb)m.endsWith("Attribute")&&(g[i[m]]=bb[m]);return g}(this.desc);const b=this._getPosAttribute();this.data[this.desc.positionAttribute]=b,m||(this.elements?m=Sb(this.elements):b&&b.length?m=b.length/this.desc.positionSize:b&&b.interleavedArray?m=b.interleavedArray.length/this.desc.positionSize:b&&b.array&&(m=b.array.length/this.desc.positionSize)),this.count=m,this.elements||(this.elements=m),this._isIndexed=!fx(this.elements),this.properties={},this._buffers={},this._vao={},this.getVertexCount(),this._prepareData(!0),this.updateBoundingBox()}set version(i){throw new Error("Geometry.version is read only.")}get version(){return this._version}_getPosAttribute(){return this.data[this.desc.positionAttribute]}_prepareData(i){if(!this.data)return;const g=this._buffers||{};for(const m in this.data){const _=this.data[m];if(_)if(_.buffer&&_.buffer.destroy){const g=_.buffer;g[Tb]||(g[Tb]=0),i&&g[Tb]++}else if(_&&_.array)if(Tx(_)){let i=_.array.buffer.__id;i||(i=_.array.buffer.__id=wb++),this.data[m]={buffer:i,offset:_.byteOffset,stride:_.byteStride,type:vb[_.componentType],size:_.itemSize,count:_.count,componentType:_.componentType},g[i]||(g[i]={data:_.array.buffer})}else this.data[m]=_.array}this._buffers=g;const m=this.elements;m&&m.array&&(this.elements=m.array)}getBuffer(i){return this.data[i]&&this.data[i].buffer}getAttrData(i){const g=i.key,m=!this._reglData||!this._reglData[g];if(this._reglData||(this._reglData={}),m){const i=this._reglData[g]={},m=this.data,{positionAttribute:_,normalAttribute:b,uv0Attribute:T,uv1Attribute:P,tangentAttribute:I,color0Attribute:H,pickingIdAttribute:W,textureCoordMatrixAttribute:q}=this.desc;cx(i,this.data),i.aPosition=m[_],m[b]&&(i.aNormal=m[b]),m[T]&&(i.aTexCoord=m[T]),m[P]&&(i.aTexCoord1=m[P]),m[I]&&(i.aTangent=m[I]),m[H]&&(i.aColor0=m[H]),m[W]&&(i.aPickingId=m[W]),m[q]&&(i.aTextureCoordMatrix=m[q])}return this._reglData[g]}getREGLData(i,g,m){if(this.getAttrData(g),yx(i)&&!m){const m=g&&g.key||"default";if(!this._vao[m]||(!this._reglData||!this._reglData[g.key])||this._vao[m].dirty){const _=this._reglData[g.key],b=this._vertexCount,T=[];for(let i=0;i<g.length;i++){const m=g[i].name,P=_[m]&&_[m].buffer;if(P&&P.destroy)T.push(void 0!==_[m].stride?_[m]:P);else{const i=_[m];if(!i){T.push(this.desc.fillEmptyDataInMissingAttribute?new Uint8Array(4*b):_b);continue}const g=(i.data&&px(i.data)?i.data.length:i.length)/b;i.data?(i.dimension=g,T.push(i)):T.push({data:i,dimension:g})}}const P={attributes:T,primitive:this.getPrimitive()};if(this.elements&&!fx(this.elements))if(this.elements.destroy)P.elements=this.elements;else{P.elements={primitive:this.getPrimitive(),data:this.elements};const i=this.getElementsType(this.elements);i&&(P.elements.type=i)}this._vao[m]?this._vao[m].vao(P):this._vao[m]={vao:i.vao(P)}}return delete this._vao[m].dirty,this._vao[m]}return this._reglData[g.key]}_isAttrChanged(i){if(i===this._activeAttributes)return!1;if(i.length!==this._activeAttributes.length)return!0;for(let g=0;g<i.length;g++)if(i[g]!==this._activeAttributes[g])return!0;return!1}generateBuffers(i){const g=!!i.wgpu,m=this._buffers;for(const g in m)m[g].buffer||(m[g].buffer=Geometry.createBuffer(i,m[g].data,g)),delete m[g].data;const _=this.desc.positionAttribute,b=this.desc.altitudeAttribute,T=this.data,P=this._vertexCount,I={};for(const H in T)if(T[H]){if(Array.isArray(T[H])?T[H]=new Float32Array(T[H]):g&&px(T[H])&&(T[H]=Geometry.padGPUBufferAlignment(T[H],P)),void 0===T[H].buffer||T[H].buffer instanceof ArrayBuffer){const g=T[H].data?T[H]:{data:T[H]};g.dimension=(T[H].data?T[H].data:T[H]).length/P;const m=Geometry.createBuffer(i,g,H);m[Tb]=1,I[H]={buffer:m},H!==_&&H!==b||(I[H].array=T[H])}else T[H].buffer.destroy?I[H]=T[H]:m[T[H].buffer]&&(I[H]=cx({},T[H]),I[H].buffer=m[T[H].buffer].buffer);(this.desc.static||H!==_)&&delete T[H].array}if(this.data=I,delete this._reglData,this.elements&&!fx(this.elements)){if(this.getPrimitive(),this.getElementsType(this.elements),!this.desc.static&&!this.elements.destroy){const i=this.elements;let g;g=Array.isArray(this.elements)?Ob(this.elements):this.elements.constructor,this.indices=new g(i.length);for(let g=0;g<i.length;g++)this.indices[g]=i[g]}this.elements=this.elements.destroy?this.elements:Geometry.createElementBuffer(i,this.elements);const g=this.elements;g[Tb]||(g[Tb]=0),g[Tb]++}}getVertexCount(){const{positionAttribute:i,positionSize:g,color0Attribute:m}=this.desc;let _=this.data[i];_.data&&(_=_.data),_.array&&(_=_.array),px(_)?this._vertexCount=Math.ceil(_.length/g):_&&void 0!==_.count&&(this._vertexCount=_.count);const b=m;if(this.data[b]){const i=this.data[b].data||this.data[b].array||this.data[b];Array.isArray(i)?this._color0Size=i.length/this._vertexCount:this.data[b].buffer&&this.data[b].buffer.destroy?this._color0Size=this.data[b].buffer._buffer.dimension:i&&i.itemSize&&(this._color0Size=i.itemSize)}return this._vertexCount}getColor0Size(){return this._color0Size||0}deleteData(i){const g=this.data[i];return g?(this._incrVersion(),g.buffer&&g.buffer.destroy&&g.buffer.destroy(),delete this.data[i],delete this._reglData,this._markVAODirty(!1),this):this}updateData(i,g){const m=this.data[i];if(!m)return this;let _;return this._incrVersion(),this.data[i]=g,m.buffer&&m.buffer.destroy&&(_=m),i===this.desc.positionAttribute&&this.updateBoundingBox(),this.getVertexCount(),_&&(_.buffer.mapState?_.buffer=this._updateGPUBuffer(_.buffer,g):_.buffer(g),this.data[i]=_),this._prepareData(!1),this.desc.positionAttribute===i&&(this._posDirty=!0),delete this._reglData,this}_updateGPUBuffer(i,g){Array.isArray(g)&&(g=new Float32Array(g));const m=i.device;if(g.buffer.byteLength>i.size){const _=kb(m,g,i.usage,i.label);return delete i.device,i.destroy(),_}return m.wgpu.queue.writeBuffer(i,0,g.buffer,0,g.buffer.byteLength),i}updateSubData(i,g,m){const _=this.data[i];if(!_)return this;let b;if(this._incrVersion(),_.buffer&&_.buffer.destroy&&(b=_),i===this.desc.positionAttribute&&this._updateSubBoundingBox(g),b){const i=xb[b.buffer._buffer.dtype];if(g.BYTES_PER_ELEMENT!==i){const m=function(i,g){if(i instanceof Uint8Array||i instanceof Uint16Array||i instanceof Uint32Array||i instanceof Uint8ClampedArray)return 1===g?Uint8Array:2===g?Uint16Array:Uint32Array;if(i instanceof Int8Array||i instanceof Int16Array||i instanceof Int32Array)return 1===g?Int8Array:2===g?Int16Array:Int32Array;if(i instanceof Float32Array||i instanceof Float64Array)return 4===g?Float32Array:Float64Array;return null}(g,i);g=new m(g)}b.buffer.subdata(g,m*i)}else{const _=this.data[i].data?this.data[i].data:this.data[i];for(let i=0;i<g.length;i++)_[m+i]=g[i]}return this._prepareData(!1),this.desc.positionAttribute===i&&(this._posDirty=!0),delete this._reglData,this}getPrimitive(){return this.desc.primitive}getElements(){return this.elements}setElements(i,g){if(!i)throw new Error("elements data is invalid");this._incrVersion();const m=this.elements;if(this.count=void 0===g?Sb(i):g,i&&i.destroy)this.elements=i;else if(m.destroy)if(m.mapState){if(Array.isArray(i)){i=new(Ob(i))(i)}this.elements=this._updateGPUBuffer(m,i)}else this.elements=m(i);else this.elements=i;return this._markVAODirty(!0),this._isIndexed=!fx(i),this}isIndexedElements(){return this._isIndexed}deleteElements(){return this.elements&&0!==this.elements.length?(this._incrVersion(),this.elements&&this.elements.destroy&&!this.elements[Lx]&&(this.elements.destroy(),this.elements[Lx]=1),this.elements=[],this._markVAODirty(!0),this):this}_markVAODirty(i){if(this._vao){for(const g in this._vao)i?this._vao[g].vao.destroy():this._vao[g].dirty=!0;i&&(this._vao={})}}setDrawCount(i){return this._incrVersion(),this.count1=i,this}getDrawCount(){return this.count1>=0?this.count1:this.count}setDrawOffset(i){return this._incrVersion(),this.offset=i,this}getDrawOffset(){return this.offset||0}dispose(){if(this._deleteVAO(),this._forEachBuffer((i=>{if(!i[Lx]){let g=i[Tb];g&&g--,g<=0?(i[Lx]=!0,i.destroy()):i[Tb]=g}})),this.properties){const i=this.properties.oldElementsBeforeHighlight;i&&!i[Lx]&&i.destroy&&(i.destroy(),i[Lx]=!0),delete this.properties.oldElementsBeforeHighlight,delete this.properties.hasInvisible}this.data={},this._buffers={},delete this._reglData,this.count=0,this.elements=[],delete this._tempPosArray,this._disposed=!0}_deleteVAO(){for(const i in this._vao)this._vao[i].vao.destroy();this._vao={}}isDisposed(){return!!this._disposed}updateBoundingBox(){let i=this.boundingBox;i||(i=this.boundingBox=new BoundingBox);let g,m,_=this.data[this.desc.positionAttribute];if(px(_)||(_.data?_=_.data:Sx(_)?_=this._getAttributeData(this.desc.positionAttribute):_.array&&(g=_.min,m=_.max,_=_.array)),_&&_.length){const b=i.min,T=i.max;if(g&&m)qA(b,...g),qA(T,...m);else{qA(b,_[0],_[1],_[2]),qA(T,_[0],_[1],_[2]);for(let i=3;i<_.length;){const g=_[i++],m=_[i++],P=_[i++];g<b[0]&&(b[0]=g),m<b[1]&&(b[1]=m),P<b[2]&&(b[2]=P),g>T[0]&&(T[0]=g),m>T[1]&&(T[1]=m),P>T[2]&&(T[2]=P)}}i.updateVertex(),i.dirty()}}_updateSubBoundingBox(i){const g=this.boundingBox,m=g.min,_=g.max,b=this.desc.positionSize;for(let g=0;g<i.length;){const T=i[g++],P=i[g++];let I=0;3===b&&(I=i[g++]),T<m[0]&&(m[0]=T),P<m[1]&&(m[1]=P),I<m[2]&&(m[2]=I),T>_[0]&&(_[0]=T),P>_[1]&&(_[1]=P),I>_[2]&&(_[2]=I)}g.updateVertex(),g.dirty()}_getAttributeData(i){const g=ox(),m=this.data[i]&&this.data[i].array?this.data[i].array:this.data[i],_=m.buffer;if(Sx(m)){const b=this._buffers[_]?this._buffers[_].data:m.array,{count:T,size:P,stride:I,offset:H,componentType:W}=m,q=g.GLTFLoader.getTypedArrayCtor(W);if((0===I||I===P*q.BYTES_PER_ELEMENT)&&H%q.BYTES_PER_ELEMENT===0)return new q(b,H,T*P);if(i===this.desc.positionAttribute)return!this._tempPosArray||this._tempPosArray&&this._tempPosArray.length<P*T?(this._tempPosArray=new q(P*T),g.GLTFLoader.readInterleavedArray(this._tempPosArray,b,T,P,I,H,W)):this._posDirty?(this._posDirty=!1,g.GLTFLoader.readInterleavedArray(this._tempPosArray,b,T,P,I,H,W)):this._tempPosArray;{const i=new q(P*T);return g.GLTFLoader.readInterleavedArray(i,b,T,P,I,H,W)}}return m}createTangent(i="aTangent"){this._incrVersion();const{normalAttribute:g,positionAttribute:m,uv0Attribute:_}=this.desc,b=this._getAttributeData(g),T=Nv(this._getAttributeData(m),b,this.data[_],this.elements),P=this.data[i]=new Float32Array(T.length),I=[0,0,0,0],H=[0,0,0],W=[0,0,0,0];for(let i=0;i<T.length;i+=4){const g=i/4*3;qA(H,b[g],b[g+1],b[g+2]),wy(I,T[i],T[i+1],T[i+2],T[i+3]),Mv(W,H,I),by(P.subarray(i,i+4),W)}delete this._reglData}createNormal(i="aNormal"){this._incrVersion();const g=this._getAttributeData(this.desc.positionAttribute);this.data[i]=Pv(g.array||g,this.elements),delete this._reglData}createBarycentric(i="aBarycentric"){if("triangles"!==this.desc.primitive)throw new Error("Primitive must be triangles to create bary centric data");this._incrVersion();const g=new Uint8Array(3*this._vertexCount);for(let i=0,m=this.elements.length;i<m;)for(let m=0;m<3;m++){g[3*this.elements[i++]+m]=1}this.data[i]=g,delete this._reglData}buildUniqueVertex(){this._incrVersion();const i=this.data,g=this.elements;if(!px(g))throw new Error("elements must be array to build unique vertex.");const m=Object.keys(i),_={};let b=i[this.desc.positionAttribute];if(b=b.length?b:b.array,!px(b))throw new Error(this.desc.positionAttribute+" must be array to build unique vertex.");const T=this._vertexCount,P=g.length;for(let g=0;g<m.length;g++){const b=m[g],I=px(i[b])?i[b]:i[b].array,H=I.length/T;if(!px(I))throw new Error(b+" must be array to build unique vertex.");_[b]=I;const W=gx(I);i[b]=new W(P*H)}let I=0;for(let b=0;b<P;b++){const P=g[b];for(let g=0;g<m.length;g++){const b=m[g],H=i[b],W=_[b].length/T;for(let i=0;i<W;i++)H[I*W+i]=_[b][P*W+i]}g[b]=I++}b=this.data[this.desc.positionAttribute],this._vertexCount=Math.ceil(b.length/this.desc.positionSize),delete this._reglData}getMemorySize(){let i=0;for(const g in this.data)_x(this.data,g)&&(i+=vx(this.data[g]));if(this.elements){const g=this.elements;g.destroy?i+=g._elements?g._elements.buffer.byteLength:g.size:g.BYTES_PER_ELEMENT?i+=g.length*g.BYTES_PER_ELEMENT:g.length&&(i+=4*g.length)}return i}_forEachBuffer(i){this.elements&&this.elements.destroy&&i(this.elements);for(const g in this.data)_x(this.data,g)&&this.data[g]&&this.data[g].buffer&&this.data[g].buffer.destroy&&i(this.data[g].buffer);for(const g in this._buffers)_x(this._buffers,g)&&this._buffers[g]&&this._buffers[g].buffer&&this._buffers[g].buffer.destroy&&i(this._buffers[g].buffer)}getElementsType(i){return i instanceof Uint8Array?"uint8":i instanceof Uint16Array?"uint16":i instanceof Uint32Array?"uint32":void 0}_incrVersion(){this._version++}getCommandKey(i){if(i&&i.wgpu){const i=[];for(const g in this.data){const m=this.data[g];i.push(m.byteStride?`${g}(${m.byteOffset}/${m.byteStride}})`:g)}return i.sort().join("-")}return""}getBufferDescriptor(i){const g=[];for(const m in i){const _=i[m];g[_.location]=_}const m=this.data,_=[],b={};for(let T=0;T<g.length;T++){if(!g[T])continue;const P=g[T].geoAttrName,I=m[P];if(!I)continue;const H=i[this.semantic[P]||P];if(!H)continue;const W=I.accessorName,q=I.byteStride;if(q&&W){const i=mb(I.componentType,I.itemSize);let g=b[W];g?g.attributes.push({shaderLocation:H.location,format:i,offset:I.byteOffset}):(g={arrayStride:q,attributes:[{shaderLocation:H.location,format:i,offset:I.byteOffset}]},b[W]=g,_[T]=g)}else{const i=Mb(I,H);_[T]=i}}return _}}function Sb(i){if(fx(i))return i;if(void 0!==i.count)return i.count;if(i.destroy)return i._elements?i._elements.vertCount:i.itemCount;if(void 0!==i.length)return i.length;if(i.data)return i.data.length;throw new Error("invalid elements length")}function Mb(i,g){const m=i.data||i.array||i;let _=g.itemSize;if(i.buffer&&!px(i)){const m=i.buffer.bytesPerElement;_=Eb(_,m);const b=Pb(i,_);return{arrayStride:_*m,attributes:[{shaderLocation:g.location,format:b,offset:0}]}}if(px(m)){let b,T;return i.componentType?(b=mb(i.componentType,i.itemSize),T=gb[i.componentType].bytes):(b=Pb(m,_),T=Cb(m)),_=Eb(_,T),{arrayStride:_*T,attributes:[{shaderLocation:g.location,format:b,offset:0}]}}}function Cb(i){const g=Ib(i);if(g.destroy)return g.bytesPerElement;if(g.BYTES_PER_ELEMENT)return g.BYTES_PER_ELEMENT;if(Array.isArray(g))return 4;{const i=g;return ox().GLTFLoader.getTypedArrayCtor(i.componentType).BYTES_PER_ELEMENT}}function Pb(i,g){const m=Ib(i);let _;return _=m.destroy?m.itemType:pb(m),g>1?_+"x"+g:_}function Ib(i){return i.data||i.buffer.destroy&&i.buffer||i}function kb(i,g,m,_){g=g.data||g,Array.isArray(g[0])&&(g=db(g)),Array.isArray(g)&&(g=new Float32Array(g));const b=g.constructor,T=yb(g.byteLength,4),P=i.wgpu.createBuffer({label:_,size:T,usage:m,mappedAtCreation:!0});return P.device=i,new b(P.getMappedRange()).set(g),P.unmap(),P.itemCount=g.length,P.itemType=pb(g),P.bytesPerElement=Cb(g),P}function Ob(i){let g=-1/0;for(let m=0;m<i.length;m++)i[m]>g&&(g=i[m]);return function(i){return i<65536?Uint16Array:Uint32Array}(g)}function Eb(i,g){const m=i*g;return m%4==0?i:i+(4-m%4)/g}const Rb=["points","lines","line strip","line loop","triangles","triangle strip","triangle fan"];function Lb(i){return Rb[i]}const Db={5121:"uint8",5123:"uint16",5125:"uint32",5126:"float",36193:"half float"};function Fb(i){return Db[i]}function Nb(i){return i instanceof Uint8Array?"uint8":i instanceof Int8Array?"int8":i instanceof Uint16Array?"uint16":i instanceof Int16Array?"int16":"float"}const Hb={6406:"alpha",6407:"rgb",6408:"rgba",6409:"luminance",6410:"luminance alpha",33776:"rgb s3tc dxt1",33777:"rgba s3tc dxt1",33778:"rgba s3tc dxt3",33779:"rgba s3tc dxt5",35840:"rgb pvrtc 4bppv1",35841:"rgb pvrtc 2bppv1",35842:"rgba pvrtc 4bppv1",35843:"rgba pvrtc 2bppv1",35986:"rgb atc",35987:"rgba atc explicit alpha",34798:"rgba atc interpolated alpha",36196:"rgb etc1",37492:"rgb etc2"};function Bb(i){return Hb[i]}const zb={9729:"linear",9728:"nearest"};function Vb(i){return zb[i]}const Ub={9729:"linear",9728:"nearest",9984:"nearest mipmap nearest",9985:"linear mipmap nearest",9986:"nearest mipmap linear",9987:"linear mipmap linear"};function Gb(i){return Ub[i]}const jb={10497:"repeat",33071:"clamp",33648:"mirror"};function Wb(i){return jb[i]}const qb="__reshader_webgl_buffer",Xb="__reshader_webgl_tex";function Zb(i,g,m){let _;if(px(g)?g.buffer&&void 0!==g.byteOffset&&(_=g):g.array&&g.array.buffer&&void 0!==g.array.byteOffset&&(_=g.array),!_)return null;const b=_.buffer,T=_.byteOffset;b[qb]||(b[qb]={});let P=b[qb][T];if(!P){const g={};m&&cx(g,m),g.data=_,g.type||(g.type=Nb(_)),P=i.buffer(g),b[qb][T]=P}return P}function $b(i,g){const m=g.data;if(!m||!m.buffer)return i.texture(g);const _=m.buffer,b=m.byteOffset;_[Xb]||(_[Xb]={});let T=_[Xb][b];return T||(T=i.texture(g),_[Xb][b]=T),T}var Yb=Object.freeze({__proto__:null,getArrayType:Nb,getMaterialFormat:Bb,getMaterialType:Fb,getPrimitive:Lb,getTextureMagFilter:Vb,getTextureMinFilter:Gb,getTextureWrap:Wb,getUniqueREGLBuffer:Zb,getUniqueTexture:$b});const Qb=[0,0,0],Jb=[0,0,0],Kb=[0,0,0],ew=[],tw=[],nw=[],rw=["a","b","c"];class EdgeGeometry extends Geometry{constructor(i,g,m,_){super(i,g,m,{primitive:Lb(1),positionAttribute:_.positionAttribute})}_getPosAttribute(){const i=this.data[this.desc.positionAttribute];if(!i.length)return[];const g=Math.pow(10,4),m=Math.cos(Math.PI/180*.8),_=this.elements,b=i.length?i:i.array,T=_.length?_?_.length:b.length/3:_,P=[0,0,0],I=new Array(3),H={},W=[],q=new Triangle;for(let i=0;i<T;i+=3){_.length?(P[0]=_[i],P[1]=_[i+1],P[2]=_[i+2]):(P[0]=i,P[1]=i+1,P[2]=i+2),q.a=iw(ew,b,P[0]),q.b=iw(tw,b,P[1]),q.c=iw(nw,b,P[2]);const T=q.getNormal(),$=q.a,ye=q.b,Re=q.c;if(I[0]=`${Math.round($[0]*g)},${Math.round($[1]*g)},${Math.round($[2]*g)}`,I[1]=`${Math.round(ye[0]*g)},${Math.round(ye[1]*g)},${Math.round(ye[2]*g)}`,I[2]=`${Math.round(Re[0]*g)},${Math.round(Re[1]*g)},${Math.round(Re[2]*g)}`,I[0]!==I[1]&&I[1]!==I[2]&&I[2]!==I[0])for(let i=0;i<3;i++)this._calEdgeData(i,P,q,H,I,m,T,W)}for(const i in H)if(H[i]){const{index0:g,index1:m}=H[i];W.push(b[3*g],b[3*g+1],b[3*g+2]),W.push(b[3*m],b[3*m+1],b[3*m+2])}return this.elements=this._createElements(W),W}_calEdgeData(i,g,m,_,b,T,P,I){const H=(i+1)%3,W=b[i],q=b[H],$=m[rw[i]],ye=m[rw[H]],Re=`${W}_${q}`,Be=`${q}_${W}`;if(Be in _&&_[Be]){ry(P,_[Be].normal)<=T&&(I.push($[0],$[1],$[2]),I.push(ye[0],ye[1],ye[2])),_[Be]=null}else Re in _||(_[Re]={index0:g[i],index1:g[H],normal:WA([0,0,0],P)})}_createElements(i){const g=[],m=i.length/3;for(let i=0;i<m;i++)g.push(i);return g}}class Triangle{constructor(i=[0,0,0],g=[0,0,0],m=[0,0,0]){this.a=i,this.b=g,this.c=m}getNormal(){const i=cy(Qb,this.a,this.b),g=cy(Jb,this.a,this.c);iy(Kb,i,g);const m=GA(Kb);return qA(Kb,Kb[0]/m,Kb[1]/m,Kb[2]/m)}}function iw(i,g,m){return qA(i,g[3*m],g[3*m+1],g[3*m+2])}class Base{}class Material extends(Rx(Base)){constructor(i={},g){super(),this._version=0,this._propVerion=0,this.uniforms=ux({},g||{},i);for(const g in i){const m=Object.getOwnPropertyDescriptor(i,g).get;m&&Object.defineProperty(this.uniforms,g,{get:m})}this.unlit=!1,this._reglUniforms={},this.refCount=0,this._bindedOnTextureComplete=(...i)=>this._onTextureComplete.call(this,...i),this._genUniformKeys(),this._checkTextures()}set version(i){throw new Error("Material.version is read only.")}get version(){return this._version}get propVersion(){return this._propVerion}set doubleSided(i){this.uniforms.doubleSided=i}get doubleSided(){return!!this.uniforms.doubleSided}getUniforms(i){if(this._reglUniforms&&!this.isDirty())return this._reglUniforms;const g=this.uniforms,m={};for(const _ in g)if(this.isTexture(_))Object.defineProperty(m,_,{enumerable:!0,configurable:!0,get:function(){return g[_].getREGLTexture(i)}});else{Object.getOwnPropertyDescriptor(g,_).get?Object.defineProperty(m,_,{enumerable:!0,configurable:!0,get:function(){return g[_]}}):m[_]=g[_]}return this._reglUniforms=m,this._uniformVer=this.version,m}getMemorySize(){const i=this.uniforms;let g=0;for(const m in i)this.isTexture(m)?g+=i[m].getMemorySize():this.uniforms[m]&&this.uniforms[m].destroy&&(g+=xx(this.uniforms[m]));return g}isReady(){return this._loadingCount<=0}hasUniform(i){return Object.prototype.hasOwnProperty.call(this.uniforms,i)}setUniform(i,g){return this.set(i,g)}getUniform(i){return this.get(i)}set(i,g,m=!0){if(this.get(i)===g)return this;const _=ax(this.uniforms[i])&&!ax(g)||!ax(this.uniforms[i])&&ax(g);if(this.uniforms[i]&&this.isTexture(i)&&m&&this.uniforms[i].dispose(),ax(g))ax(this.uniforms[i])||delete this.uniforms[i];else if(this.uniforms[i]=g,this._reglUniforms){const m=Object.getOwnPropertyDescriptor(this._reglUniforms,i);m&&!m.get&&(this._propVerion++,this._reglUniforms[i]=g)}return this.isTexture(i)&&this._checkTextures(),_&&(this._genUniformKeys(),this._incrVersion()),this}setFunctionUniform(i,g){return this._genUniformKeys(),this._incrVersion(),Object.defineProperty(this.uniforms,i,{enumerable:!0,get:g}),this}hasFunctionUniform(i){return!!this.uniforms&&Object.prototype.hasOwnProperty.call(this.uniforms,i)}get(i){return this.uniforms[i]}isDirty(){return this._uniformVer!==this.version}appendDefines(i,g){const m=this.uniforms;return m?(m.jointTexture&&(i.HAS_SKIN=1),m.morphWeights1&&(i.HAS_MORPH=1),(m.khr_offset||m.khr_rotation||m.khr_scale)&&(i.HAS_KHR_TEXTURE_TRANSFORM=1),i):i}hasSkinAnimation(){return!!(this.uniforms&&this.uniforms.jointTexture&&this.uniforms.skinAnimation)}isTexture(i){return this.uniforms[i]instanceof AbstractTexture}dispose(){for(const i in this.uniforms){const g=this.uniforms[i];g&&(g.dispose?g.dispose():g.destroy&&!g[Lx]&&(g.destroy(),g[Lx]=!0))}delete this.uniforms,delete this._reglUniforms,delete this._bindedOnTextureComplete,this._disposed=!0}isDisposed(){return!!this._disposed}_checkTextures(){this._loadingCount=0;for(const i in this.uniforms)if(this.isTexture(i)){const g=this.uniforms[i];g.isReady()||(this._loadingCount++,g.on("complete",this._bindedOnTextureComplete))}}_onTextureComplete(){this._loadingCount--,this._incrVersion(),this._loadingCount<=0&&(this._disposed||this.fire("complete"))}getUniformKeys(){return this._uniformKeys}_genUniformKeys(){const i=[];for(const g in this.uniforms)_x(this.uniforms,g)&&!ax(this.uniforms[g])&&i.push(g);this._uniformKeys=i.join()}_incrVersion(){this._version++}}const ow={time:0,seeThrough:!0,thickness:.03,fill:[1,.5137254902,.98,1],stroke:[.7019607843,.9333333333,.2274509804,1],dashEnabled:!1,dashAnimate:!1,dashRepeats:1,dashLength:.8,dashOverlap:!0,insideAltColor:!1,squeeze:!1,squeezeMin:.5,squeezeMax:1,dualStroke:!1,secondThickness:.05,opacity:1,noiseEnable:!1};const sw={baseColorFactor:[1,1,1,1],materialShininess:32,environmentExposure:1,specularStrength:32,opacity:1,extrusionOpacity:0,extrusionOpacityRange:[0,1.8],baseColorTexture:null,normalTexture:null,emissiveTexture:null,occlusionTexture:null,uvScale:[1,1],uvOffset:[0,0],alphaTest:0};class PhongMaterial extends Material{constructor(i){super(i,sw)}static convertFrom(i){const g={};for(const m in sw)g[m]=i.get(m);return new PhongMaterial(g)}appendDefines(i,g){super.appendDefines(i,g);const m=this.uniforms;this.unlit&&(i.SHADING_MODEL_UNLIT=1),m.extrusionOpacity&&(i.HAS_EXTRUSION_OPACITY=1),g.data[g.desc.colorAttribute]&&(i.HAS_COLOR=1);return g.data[g.desc.color0Attribute]&&(i.HAS_COLOR0=1,i.COLOR0_SIZE=g.getColor0Size()),g.data.aVertexColorType&&(i.HAS_VERTEX_COLOR=1),g.data[g.desc.tangentAttribute]?i.HAS_TANGENT=1:g.data[g.desc.normalAttribute]&&(i.HAS_NORMAL=1),g.data[g.desc.uv0Attribute]?(m.baseColorTexture&&(i.HAS_BASECOLOR_MAP=1),m.occlusionTexture&&g.data[g.desc.uv1Attribute]&&(i.HAS_AO_MAP=1),m.emissiveTexture&&(i.HAS_EMISSIVE_MAP=1),m.normalTexture&&(i.HAS_NORMAL_MAP=1),(i.HAS_BASECOLOR_MAP||i.HAS_AO_MAP||i.HAS_EMISSIVE_MAP||i.HAS_NORMAL_MAP)&&(i.HAS_MAP=1),i):i}}const aw={baseColorFactor:[1,1,1,1],uvScale:[1,1],uvOffset:[0,0],opacity:1,envMapExposure:128,emissiveFactor:[.1,.1,.1],specularFactor:[0,0,0],envRotationSin:0,envRotationCos:1,reflectivity:.01,themingColor:[0,0,0,0],exposureBias:.6};const lw={diffuseFactor:[1,1,1,1],specularFactor:[1,1,1],glossinessFactor:1,diffuseTexture:null,specularGlossinessTexture:null,normalTexture:null,emissiveTexture:null,occlusionTexture:null};function hw(i){return class SpecularGlossinessMixin extends i{constructor(...i){let g=i[0];g=cx({},lw,g||{}),super(g,i)}appendDefines(i,g){if(super.appendDefines(i,g),i.SHADING_MODEL_SPECULAR_GLOSSINESS=1,!g.data[g.desc.uv0Attribute])return i;const m=this.uniforms;return m.diffuseTexture&&(i.HAS_DIFFUSE_MAP=1),m.specularGlossinessTexture&&(i.HAS_SPECULARGLOSSINESS_MAP=1),(i.HAS_SPECULARGLOSSINESS_MAP||i.HAS_DIFFUSE_MAP)&&(i.HAS_MAP=1),i}}}class PhongSpecularGlossinessMaterial extends(hw(PhongMaterial)){}let cw=class e{constructor(i,g){this.name=i,this.attributes=g,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}get isPointer(){return!1}getTypeName(){return this.name}};class t{constructor(i,g,m){this.name=i,this.type=g,this.attributes=m,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class n extends cw{constructor(i,g){super(i,g),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}}class s extends cw{constructor(i,g){super(i,g),this.count=0,this.stride=0}get isArray(){return!0}getTypeName(){return`array<${this.format.getTypeName()}, ${this.count}>`}}class r extends cw{constructor(i,g,m){super(i,m),this.format=g}get isPointer(){return!0}getTypeName(){return`&${this.format.getTypeName()}`}}class a extends cw{constructor(i,g,m,_){super(i,m),this.format=g,this.access=_}get isTemplate(){return!0}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}}var uw;(i=>{i[i.Uniform=0]="Uniform",i[i.Storage=1]="Storage",i[i.Texture=2]="Texture",i[i.Sampler=3]="Sampler",i[i.StorageTexture=4]="StorageTexture"})(uw||(uw={}));class o{constructor(i,g,m,_,b,T,P){this.name=i,this.type=g,this.group=m,this.binding=_,this.attributes=b,this.resourceType=T,this.access=P}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}let fw=class l{constructor(i,g){this.name=i,this.type=g}},dw=class c{constructor(i,g,m,_){this.name=i,this.type=g,this.locationType=m,this.location=_,this.interpolation=null}},pw=class u{constructor(i,g,m,_){this.name=i,this.type=g,this.locationType=m,this.location=_}};class h{constructor(i,g,m,_){this.name=i,this.type=g,this.attributes=m,this.id=_}}let gw=class f{constructor(i,g,m){this.name=i,this.type=g,this.attributes=m}},mw=class p{constructor(i,g=null,m){this.stage=null,this.inputs=[],this.outputs=[],this.arguments=[],this.returnType=null,this.resources=[],this.overrides=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=i,this.stage=g,this.attributes=m}},Aw=class d{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}};const yw=new Float32Array(1),_w=new Int32Array(yw.buffer),vw=new Uint16Array(1);function xw(i){yw[0]=i;const g=_w[0],m=g>>31&1;let _=g>>23&255,b=8388607&g;if(255===_)return vw[0]=m<<15|31744|(0!==b?512:0),vw[0];if(0===_){if(0===b)return vw[0]=m<<15,vw[0];b|=8388608;let i=113;for(;!(8388608&b);)b<<=1,i--;return _=127-i,b&=8388607,_>0?(b=(b>>126-_)+(b>>127-_&1),vw[0]=m<<15|_<<10|b>>13,vw[0]):(vw[0]=m<<15,vw[0])}return _=_-127+15,_>=31?(vw[0]=m<<15|31744,vw[0]):_<=0?_<-10?(vw[0]=m<<15,vw[0]):(b=(8388608|b)>>1-_,vw[0]=m<<15|b>>13,vw[0]):(b>>=13,vw[0]=m<<15|_<<10|b,vw[0])}const bw=new Uint32Array(1),ww=new Float32Array(bw.buffer,0,1);function Tw(i){return bw[0]=112+(i>>6&31)<<23|(63&i)<<17,ww[0]}function Sw(i,g,m,_){const b=[0,0,0,0];for(let W=0;W<_;++W)switch(m){case"8unorm":b[W]=i[g]/255,g++;break;case"8snorm":b[W]=i[g]/255*2-1,g++;break;case"8uint":b[W]=i[g],g++;break;case"8sint":b[W]=i[g]-127,g++;break;case"16uint":b[W]=i[g]|i[g+1]<<8,g+=2;break;case"16sint":b[W]=(i[g]|i[g+1]<<8)-32768,g+=2;break;case"16float":b[W]=(void 0,void 0,void 0,P=(32768&(T=i[g]|i[g+1]<<8))>>15,H=1023&T,0==(I=(31744&T)>>10)?(P?-1:1)*Math.pow(2,-14)*(H/Math.pow(2,10)):31==I?H?NaN:1/0*(P?-1:1):(P?-1:1)*Math.pow(2,I-15)*(1+H/Math.pow(2,10))),g+=2;break;case"32uint":case"32sint":b[W]=i[g]|i[g+1]<<8|i[g+2]<<16|i[g+3]<<24,g+=4;break;case"32float":b[W]=new Float32Array(i.buffer,g,1)[0],g+=4}var T,P,I,H;return b}function Mw(i,g,m,_,b){for(let T=0;T<_;++T)switch(m){case"8unorm":i[g]=255*b[T],g++;break;case"8snorm":i[g]=.5*(b[T]+1)*255,g++;break;case"8uint":i[g]=b[T],g++;break;case"8sint":i[g]=b[T]+127,g++;break;case"16uint":new Uint16Array(i.buffer,g,1)[0]=b[T],g+=2;break;case"16sint":new Int16Array(i.buffer,g,1)[0]=b[T],g+=2;break;case"16float":{const m=xw(b[T]);new Uint16Array(i.buffer,g,1)[0]=m,g+=2;break}case"32uint":new Uint32Array(i.buffer,g,1)[0]=b[T],g+=4;break;case"32sint":new Int32Array(i.buffer,g,1)[0]=b[T],g+=4;break;case"32float":new Float32Array(i.buffer,g,1)[0]=b[T],g+=4}return b}const Cw={r8unorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8snorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8uint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8sint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg8unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8snorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"rgba8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8snorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},bgra8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bgra8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r16uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16float:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg16uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba16uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r32uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg32uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba32uint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32sint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32float:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rg11b10ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},stencil8:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!1,hasStencil:!0,channels:1},depth16unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},depth24plus:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,depthOnlyFormat:"depth32float",channels:1},"depth24plus-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,depthOnlyFormat:"depth32float",channels:1},depth32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},"depth32float-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,stencilOnlyFormat:"depth32float",channels:1},rgb9e5ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bc1-rgba-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc1-rgba-unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc4-r-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc4-r-snorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc5-rg-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc5-rg-snorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc6h-rgb-ufloat":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc6h-rgb-float":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"eac-r11unorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-r11snorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-rg11unorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"eac-rg11snorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"astc-4x4-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-4x4-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x5-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-5x5-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x6-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-6x6-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-8x5-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x5-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x6-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x6-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x8-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-8x8-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-10x5-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x5-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x6-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x6-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x8-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x8-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x10-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-10x10-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x12-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4},"astc-12x12-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4}};let Pw=class S{constructor(){this.id=S._id++,this.line=0}get isAstNode(){return!0}get astNodeType(){return""}search(i){i(this)}searchBlock(i,g){if(i){g(Iw.instance);for(const m of i)m instanceof Array?this.searchBlock(m,g):m.search(g);g(kw.instance)}}constEvaluate(i,g){throw new Error("Cannot evaluate node")}constEvaluateString(i){return this.constEvaluate(i).toString()}};Pw._id=0;let Iw=class A extends Pw{};Iw.instance=new Iw;let kw=class E extends Pw{};kw.instance=new kw;const Ow=new Set(["all","all","any","select","arrayLength","abs","acos","acosh","asin","asinh","atan","atanh","atan2","ceil","clamp","cos","cosh","countLeadingZeros","countOneBits","countTrailingZeros","cross","degrees","determinant","distance","dot","dot4U8Packed","dot4I8Packed","exp","exp2","extractBits","faceForward","firstLeadingBit","firstTrailingBit","floor","fma","fract","frexp","insertBits","inverseSqrt","ldexp","length","log","log2","max","min","mix","modf","normalize","pow","quantizeToF16","radians","reflect","refract","reverseBits","round","saturate","sign","sin","sinh","smoothStep","sqrt","step","tan","tanh","transpose","trunc","dpdx","dpdxCoarse","dpdxFine","dpdy","dpdyCoarse","dpdyFine","fwidth","fwidthCoarse","fwidthFine","textureDimensions","textureGather","textureGatherCompare","textureLoad","textureNumLayers","textureNumLevels","textureNumSamples","textureSample","textureSampleBias","textureSampleCompare","textureSampleCompareLevel","textureSampleGrad","textureSampleLevel","textureSampleBaseClampToEdge","textureStore","atomicLoad","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","atomicExchange","atomicCompareExchangeWeak","pack4x8snorm","pack4x8unorm","pack4xI8","pack4xU8","pack4x8Clamp","pack4xU8Clamp","pack2x16snorm","pack2x16unorm","pack2x16float","unpack4x8snorm","unpack4x8unorm","unpack4xI8","unpack4xU8","unpack2x16snorm","unpack2x16unorm","unpack2x16float","storageBarrier","textureBarrier","workgroupBarrier","workgroupUniformLoad","subgroupAdd","subgroupExclusiveAdd","subgroupInclusiveAdd","subgroupAll","subgroupAnd","subgroupAny","subgroupBallot","subgroupBroadcast","subgroupBroadcastFirst","subgroupElect","subgroupMax","subgroupMin","subgroupMul","subgroupExclusiveMul","subgroupInclusiveMul","subgroupOr","subgroupShuffle","subgroupShuffleDown","subgroupShuffleUp","subgroupShuffleXor","subgroupXor","quadBroadcast","quadSwapDiagonal","quadSwapX","quadSwapY"]);let Ew=class L extends Pw{constructor(){super()}},Rw=class C extends Ew{constructor(i,g,m,_,b,T){super(),this.calls=new Set,this.name=i,this.args=g,this.returnType=m,this.body=_,this.startLine=b,this.endLine=T}get astNodeType(){return"function"}search(i){if(this.attributes)for(const g of this.attributes)i(g);i(this);for(const g of this.args)i(g);this.searchBlock(this.body,i)}},Lw=class D extends Ew{constructor(i){super(),this.expression=i}get astNodeType(){return"staticAssert"}search(i){this.expression.search(i)}},Dw=class N extends Ew{constructor(i,g){super(),this.condition=i,this.body=g}get astNodeType(){return"while"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}},Fw=class V extends Ew{constructor(i,g){super(),this.body=i,this.loopId=g}get astNodeType(){return"continuing"}search(i){this.searchBlock(this.body,i)}},Nw=class O extends Ew{constructor(i,g,m,_){super(),this.init=i,this.condition=g,this.increment=m,this.body=_}get astNodeType(){return"for"}search(i){var g,m,_;null===(g=this.init)||void 0===g||g.search(i),null===(m=this.condition)||void 0===m||m.search(i),null===(_=this.increment)||void 0===_||_.search(i),this.searchBlock(this.body,i)}},Hw=class B extends Ew{constructor(i,g,m,_,b){super(),this.attributes=null,this.name=i,this.type=g,this.storage=m,this.access=_,this.value=b}get astNodeType(){return"var"}search(i){var g;i(this),null===(g=this.value)||void 0===g||g.search(i)}},Bw=class F extends Ew{constructor(i,g,m){super(),this.attributes=null,this.name=i,this.type=g,this.value=m}get astNodeType(){return"override"}search(i){var g;null===(g=this.value)||void 0===g||g.search(i)}},zw=class M extends Ew{constructor(i,g,m,_,b){super(),this.attributes=null,this.name=i,this.type=g,this.storage=m,this.access=_,this.value=b}get astNodeType(){return"let"}search(i){var g;i(this),null===(g=this.value)||void 0===g||g.search(i)}},Vw=class U extends Ew{constructor(i,g,m,_,b){super(),this.attributes=null,this.name=i,this.type=g,this.storage=m,this.access=_,this.value=b}get astNodeType(){return"const"}constEvaluate(i,g){return this.value.constEvaluate(i,g)}search(i){var g;i(this),null===(g=this.value)||void 0===g||g.search(i)}};var Uw,Gw,jw,Ww;(i=>{i.increment="++",i.decrement="--"})(Uw||(Uw={})),(i=>{i.parse=function(g){const m=g;if("parse"==m)throw new Error("Invalid value for IncrementOperator");return i[m]}})(Uw||(Uw={}));let qw=class z extends Ew{constructor(i,g){super(),this.operator=i,this.variable=g}get astNodeType(){return"increment"}search(i){this.variable.search(i)}};(i=>{i.assign="=",i.addAssign="+=",i.subtractAssin="-=",i.multiplyAssign="*=",i.divideAssign="/=",i.moduloAssign="%=",i.andAssign="&=",i.orAssign="|=",i.xorAssign="^=",i.shiftLeftAssign="<<=",i.shiftRightAssign=">>="})(Gw||(Gw={})),(i=>{i.parse=function(i){const g=i;if("parse"==g)throw new Error("Invalid value for AssignOperator");return g}})(Gw||(Gw={}));let Xw=class R extends Ew{constructor(i,g,m){super(),this.operator=i,this.variable=g,this.value=m}get astNodeType(){return"assign"}search(i){this.variable.search(i),this.value.search(i)}},Zw=class G extends Ew{constructor(i,g){super(),this.name=i,this.args=g}get astNodeType(){return"call"}isBuiltin(){return Ow.has(this.name)}search(i){for(const g of this.args)g.search(i);i(this)}},$w=class X extends Ew{constructor(i,g){super(),this.body=i,this.continuing=g}get astNodeType(){return"loop"}},Yw=class j extends Ew{constructor(i,g){super(),this.condition=i,this.cases=g}get astNodeType(){return"switch"}search(i){i(this);for(const g of this.cases)g.search(i)}},Qw=class Z extends Ew{constructor(i,g,m,_){super(),this.condition=i,this.body=g,this.elseif=m,this.else=_}get astNodeType(){return"if"}search(i){this.condition.search(i),this.searchBlock(this.body,i),this.searchBlock(this.elseif,i),this.searchBlock(this.else,i)}},Jw=class Q extends Ew{constructor(i){super(),this.value=i}get astNodeType(){return"return"}search(i){var g;null===(g=this.value)||void 0===g||g.search(i)}},Kw=class Y extends Ew{constructor(i){super(),this.name=i}get astNodeType(){return"enable"}},eT=class K extends Ew{constructor(i){super(),this.extensions=i}get astNodeType(){return"requires"}},tT=class J extends Ew{constructor(i,g){super(),this.severity=i,this.rule=g}get astNodeType(){return"diagnostic"}},nT=class ee extends Ew{constructor(i,g){super(),this.name=i,this.type=g}get astNodeType(){return"alias"}},rT=class te extends Ew{constructor(){super()}get astNodeType(){return"discard"}},iT=class ne extends Ew{constructor(){super(),this.condition=null,this.loopId=-1}get astNodeType(){return"break"}},oT=class se extends Ew{constructor(){super(),this.loopId=-1}get astNodeType(){return"continue"}},sT=class re extends Ew{constructor(i){super(),this.attributes=null,this.name=i}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}static maxFormatType(i){let g=i[0];if("f32"===g.name)return g;for(let m=1;m<i.length;++m){const _=re._priority.get(g.name);re._priority.get(i[m].name)<_&&(g=i[m])}return"x32"===g.name?re.i32:g}getTypeName(){return this.name}};sT.x32=new sT("x32"),sT.f32=new sT("f32"),sT.i32=new sT("i32"),sT.u32=new sT("u32"),sT.f16=new sT("f16"),sT.bool=new sT("bool"),sT.void=new sT("void"),sT._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);let aT=class ae extends sT{constructor(i){super(i)}},lT=class ie extends sT{constructor(i,g,m,_){super(i),this.members=g,this.startLine=m,this.endLine=_}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(i){for(let g=0;g<this.members.length;g++)if(this.members[g].name==i)return g;return-1}search(i){for(const g of this.members)i(g)}},hT=class oe extends sT{constructor(i,g,m){super(i),this.format=g,this.access=m}get astNodeType(){return"template"}getTypeName(){let i=this.name;if(null!==this.format){if("vec2"===i||"vec3"===i||"vec4"===i||"mat2x2"===i||"mat2x3"===i||"mat2x4"===i||"mat3x2"===i||"mat3x3"===i||"mat3x4"===i||"mat4x2"===i||"mat4x3"===i||"mat4x4"===i){if("f32"===this.format.name)return i+="f",i;if("i32"===this.format.name)return i+="i",i;if("u32"===this.format.name)return i+="u",i;if("bool"===this.format.name)return i+="b",i;if("f16"===this.format.name)return i+="h",i}i+=`<${this.format.name}>`}else if("vec2"===i||"vec3"===i||"vec4"===i)return i;return i}};hT.vec2f=new hT("vec2",sT.f32,null),hT.vec3f=new hT("vec3",sT.f32,null),hT.vec4f=new hT("vec4",sT.f32,null),hT.vec2i=new hT("vec2",sT.i32,null),hT.vec3i=new hT("vec3",sT.i32,null),hT.vec4i=new hT("vec4",sT.i32,null),hT.vec2u=new hT("vec2",sT.u32,null),hT.vec3u=new hT("vec3",sT.u32,null),hT.vec4u=new hT("vec4",sT.u32,null),hT.vec2h=new hT("vec2",sT.f16,null),hT.vec3h=new hT("vec3",sT.f16,null),hT.vec4h=new hT("vec4",sT.f16,null),hT.vec2b=new hT("vec2",sT.bool,null),hT.vec3b=new hT("vec3",sT.bool,null),hT.vec4b=new hT("vec4",sT.bool,null),hT.mat2x2f=new hT("mat2x2",sT.f32,null),hT.mat2x3f=new hT("mat2x3",sT.f32,null),hT.mat2x4f=new hT("mat2x4",sT.f32,null),hT.mat3x2f=new hT("mat3x2",sT.f32,null),hT.mat3x3f=new hT("mat3x3",sT.f32,null),hT.mat3x4f=new hT("mat3x4",sT.f32,null),hT.mat4x2f=new hT("mat4x2",sT.f32,null),hT.mat4x3f=new hT("mat4x3",sT.f32,null),hT.mat4x4f=new hT("mat4x4",sT.f32,null),hT.mat2x2h=new hT("mat2x2",sT.f16,null),hT.mat2x3h=new hT("mat2x3",sT.f16,null),hT.mat2x4h=new hT("mat2x4",sT.f16,null),hT.mat3x2h=new hT("mat3x2",sT.f16,null),hT.mat3x3h=new hT("mat3x3",sT.f16,null),hT.mat3x4h=new hT("mat3x4",sT.f16,null),hT.mat4x2h=new hT("mat4x2",sT.f16,null),hT.mat4x3h=new hT("mat4x3",sT.f16,null),hT.mat4x4h=new hT("mat4x4",sT.f16,null),hT.mat2x2i=new hT("mat2x2",sT.i32,null),hT.mat2x3i=new hT("mat2x3",sT.i32,null),hT.mat2x4i=new hT("mat2x4",sT.i32,null),hT.mat3x2i=new hT("mat3x2",sT.i32,null),hT.mat3x3i=new hT("mat3x3",sT.i32,null),hT.mat3x4i=new hT("mat3x4",sT.i32,null),hT.mat4x2i=new hT("mat4x2",sT.i32,null),hT.mat4x3i=new hT("mat4x3",sT.i32,null),hT.mat4x4i=new hT("mat4x4",sT.i32,null),hT.mat2x2u=new hT("mat2x2",sT.u32,null),hT.mat2x3u=new hT("mat2x3",sT.u32,null),hT.mat2x4u=new hT("mat2x4",sT.u32,null),hT.mat3x2u=new hT("mat3x2",sT.u32,null),hT.mat3x3u=new hT("mat3x3",sT.u32,null),hT.mat3x4u=new hT("mat3x4",sT.u32,null),hT.mat4x2u=new hT("mat4x2",sT.u32,null),hT.mat4x3u=new hT("mat4x3",sT.u32,null),hT.mat4x4u=new hT("mat4x4",sT.u32,null);let cT=class le extends sT{constructor(i,g,m,_){super(i),this.storage=g,this.type=m,this.access=_}get astNodeType(){return"pointer"}},uT=class ce extends sT{constructor(i,g,m,_){super(i),this.attributes=g,this.format=m,this.count=_}get astNodeType(){return"array"}get isArray(){return!0}},fT=class ue extends sT{constructor(i,g,m){super(i),this.format=g,this.access=m}get astNodeType(){return"sampler"}},dT=class he extends Pw{constructor(){super(),this.postfix=null}},pT=class fe extends dT{constructor(i){super(),this.value=i}get astNodeType(){return"stringExpr"}toString(){return this.value}constEvaluateString(){return this.value}},gT=class pe extends dT{constructor(i,g){super(),this.type=i,this.args=g}get astNodeType(){return"createExpr"}search(i){if(i(this),this.args)for(const g of this.args)g.search(i)}constEvaluate(i,g){return g&&(g[0]=this.type),i.evalExpression(this,i.context)}},mT=class de extends dT{constructor(i,g){super(),this.cachedReturnValue=null,this.name=i,this.args=g}get astNodeType(){return"callExpr"}setCachedReturnValue(i){this.cachedReturnValue=i}get isBuiltin(){return Ow.has(this.name)}constEvaluate(i,g){return i.evalExpression(this,i.context)}search(i){for(const g of this.args)g.search(i);i(this)}},AT=class me extends dT{constructor(i){super(),this.name=i}get astNodeType(){return"varExpr"}search(i){i(this),this.postfix&&this.postfix.search(i)}constEvaluate(i,g){return i.evalExpression(this,i.context)}},yT=class _e extends dT{constructor(i,g){super(),this.name=i,this.initializer=g}get astNodeType(){return"constExpr"}constEvaluate(i,g){if(this.initializer){const g=i.evalExpression(this.initializer,i.context);return null!==g&&this.postfix?g.getSubData(i,this.postfix,i.context):g}return null}search(i){this.initializer.search(i)}},_T=class ge extends dT{constructor(i,g){super(),this.value=i,this.type=g}get astNodeType(){return"literalExpr"}constEvaluate(i,g){return void 0!==g&&(g[0]=this.type),this.value}get isScalar(){return this.value instanceof FT}get isVector(){return this.value instanceof HT||this.value instanceof BT}get scalarValue(){return this.value instanceof FT?this.value.value:(console.error("Value is not scalar."),0)}get vectorValue(){return this.value instanceof HT||this.value instanceof BT?this.value.data:(console.error("Value is not a vector or matrix."),new Float32Array(0))}},vT=class xe extends dT{constructor(i,g){super(),this.type=i,this.value=g}get astNodeType(){return"bitcastExpr"}search(i){this.value.search(i)}},xT=class be extends dT{constructor(i){super(),this.index=i}search(i){this.index.search(i)}},bT=class ve extends dT{constructor(){super()}},wT=class we extends bT{constructor(i,g){super(),this.operator=i,this.right=g}get astNodeType(){return"unaryOp"}constEvaluate(i,g){return i.evalExpression(this,i.context)}search(i){this.right.search(i)}},TT=class ke extends bT{constructor(i,g,m){super(),this.operator=i,this.left=g,this.right=m}get astNodeType(){return"binaryOp"}_getPromotedType(i,g){return i.name===g.name?i:"f32"===i.name||"f32"===g.name?sT.f32:"u32"===i.name||"u32"===g.name?sT.u32:sT.i32}constEvaluate(i,g){return i.evalExpression(this,i.context)}search(i){this.left.search(i),this.right.search(i)}},ST=class Ie extends Pw{constructor(i){super(),this.body=i}search(i){i(this),this.searchBlock(this.body,i)}},MT=class Te extends dT{constructor(){super()}get astNodeType(){return"default"}},CT=class Se extends ST{constructor(i,g){super(g),this.selectors=i}get astNodeType(){return"case"}search(i){this.searchBlock(this.body,i)}},PT=class Ae extends ST{constructor(i){super(i)}get astNodeType(){return"default"}search(i){this.searchBlock(this.body,i)}},IT=class Ee extends Pw{constructor(i,g,m){super(),this.name=i,this.type=g,this.attributes=m}get astNodeType(){return"argument"}},kT=class $e extends Pw{constructor(i,g){super(),this.condition=i,this.body=g}get astNodeType(){return"elseif"}search(i){this.condition.search(i),this.searchBlock(this.body,i)}},OT=class Le extends Pw{constructor(i,g,m){super(),this.name=i,this.type=g,this.attributes=m}get astNodeType(){return"member"}},ET=class Ce extends Pw{constructor(i,g){super(),this.name=i,this.value=g}get astNodeType(){return"attribute"}},RT=class De{constructor(i,g){this.parent=null,this.typeInfo=i,this.parent=g,this.id=De._id++}clone(){throw`Clone: Not implemented for ${this.constructor.name}`}setDataValue(i,g,m,_){console.error(`SetDataValue: Not implemented for ${this.constructor.name}`)}getSubData(i,g,m){return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`),null}toString(){return`<${this.typeInfo.getTypeName()}>`}};RT._id=0;let LT=class Ne extends RT{constructor(){super(new cw("void",null),null)}toString(){return"void"}};LT.void=new LT;let DT=class Ve extends RT{constructor(i){super(new r("pointer",i.typeInfo,null),null),this.reference=i}clone(){return this}setDataValue(i,g,m,_){this.reference.setDataValue(i,g,m,_)}getSubData(i,g,m){return g?this.reference.getSubData(i,g,m):this}toString(){return`&${this.reference.toString()}`}},FT=class Oe extends RT{constructor(i,g,m=null){super(g,m),i instanceof Int32Array||i instanceof Uint32Array||i instanceof Float32Array?this.data=i:"x32"===this.typeInfo.name?this.data=i-Math.floor(i)!=0?new Float32Array([i]):i>=0?new Uint32Array([i]):new Int32Array([i]):"i32"===this.typeInfo.name||"bool"===this.typeInfo.name?this.data=new Int32Array([i]):"u32"===this.typeInfo.name?this.data=new Uint32Array([i]):"f32"===this.typeInfo.name||"f16"===this.typeInfo.name?this.data=new Float32Array([i]):console.error("ScalarData2: Invalid type",g)}clone(){if(this.data instanceof Float32Array)return new Oe(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Oe(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Oe(new Uint32Array(this.data),this.typeInfo,null);throw"ScalarData: Invalid data type"}get value(){return this.data[0]}set value(i){this.data[0]=i}setDataValue(i,g,m,_){if(m)return void console.error("SetDataValue: Scalar data does not support postfix",m);if(!(g instanceof Oe))return void console.error("SetDataValue: Invalid value",g);let b=g.data[0];"i32"===this.typeInfo.name||"u32"===this.typeInfo.name?b=Math.floor(b):"bool"===this.typeInfo.name&&(b=b?1:0),this.data[0]=b}getSubData(i,g,m){return g?(console.error("getSubData: Scalar data does not support postfix",g),null):this}toString(){return`${this.value}`}};function NT(i,g,m){const _=g.length;return 2===_?"f32"===m?new HT(new Float32Array(g),i.getTypeInfo("vec2f")):"i32"===m||"bool"===m?new HT(new Int32Array(g),i.getTypeInfo("vec2i")):"u32"===m?new HT(new Uint32Array(g),i.getTypeInfo("vec2u")):"f16"===m?new HT(new Float32Array(g),i.getTypeInfo("vec2h")):(console.error(`getSubData: Unknown format ${m}`),null):3===_?"f32"===m?new HT(new Float32Array(g),i.getTypeInfo("vec3f")):"i32"===m||"bool"===m?new HT(new Int32Array(g),i.getTypeInfo("vec3i")):"u32"===m?new HT(new Uint32Array(g),i.getTypeInfo("vec3u")):"f16"===m?new HT(new Float32Array(g),i.getTypeInfo("vec3h")):(console.error(`getSubData: Unknown format ${m}`),null):4===_?"f32"===m?new HT(new Float32Array(g),i.getTypeInfo("vec4f")):"i32"===m||"bool"===m?new HT(new Int32Array(g),i.getTypeInfo("vec4i")):"u32"===m?new HT(new Uint32Array(g),i.getTypeInfo("vec4u")):"f16"===m?new HT(new Float32Array(g),i.getTypeInfo("vec4h")):(console.error(`getSubData: Unknown format ${m}`),null):(console.error(`getSubData: Invalid vector size ${g.length}`),null)}let HT=class Fe extends RT{constructor(i,g,m=null){if(super(g,m),i instanceof Float32Array||i instanceof Uint32Array||i instanceof Int32Array)this.data=i;else{const g=this.typeInfo.name;"vec2f"===g||"vec3f"===g||"vec4f"===g?this.data=new Float32Array(i):"vec2i"===g||"vec3i"===g||"vec4i"===g?this.data=new Int32Array(i):"vec2u"===g||"vec3u"===g||"vec4u"===g?this.data=new Uint32Array(i):"vec2h"===g||"vec3h"===g||"vec4h"===g?this.data=new Float32Array(i):"vec2b"===g||"vec3b"===g||"vec4b"===g?this.data=new Int32Array(i):"vec2"===g||"vec3"===g||"vec4"===g?this.data=new Float32Array(i):console.error(`VectorData: Invalid type ${g}`)}}clone(){if(this.data instanceof Float32Array)return new Fe(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Fe(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Fe(new Uint32Array(this.data),this.typeInfo,null);throw"VectorData: Invalid data type"}setDataValue(i,g,m,_){m instanceof pT?console.error("TODO: Set vector postfix"):g instanceof Fe?this.data=g.data:console.error("SetDataValue: Invalid value",g)}getSubData(i,g,m){if(null===g)return this;let _=i.getTypeInfo("f32");if(this.typeInfo instanceof a)_=this.typeInfo.format||_;else{const g=this.typeInfo.name;"vec2f"===g||"vec3f"===g||"vec4f"===g?_=i.getTypeInfo("f32"):"vec2i"===g||"vec3i"===g||"vec4i"===g?_=i.getTypeInfo("i32"):"vec2b"===g||"vec3b"===g||"vec4b"===g?_=i.getTypeInfo("bool"):"vec2u"===g||"vec3u"===g||"vec4u"===g?_=i.getTypeInfo("u32"):"vec2h"===g||"vec3h"===g||"vec4h"===g?_=i.getTypeInfo("f16"):console.error(`GetSubData: Unknown type ${g}`)}let b=this;for(;null!==g&&null!==b;){if(g instanceof xT){const T=g.index;let P=-1;if(T instanceof _T){if(!(T.value instanceof FT))return console.error(`GetSubData: Invalid array index ${T.value}`),null;P=T.value.value}else{const g=i.evalExpression(T,m);if(!(g instanceof FT))return console.error("GetSubData: Unknown index type",T),null;P=g.value}if(P<0||P>=b.data.length)return console.error("GetSubData: Index out of range",P),null;if(b.data instanceof Float32Array){const i=new Float32Array(b.data.buffer,b.data.byteOffset+4*P,1);return new FT(i,_)}if(b.data instanceof Int32Array){const i=new Int32Array(b.data.buffer,b.data.byteOffset+4*P,1);return new FT(i,_)}if(b.data instanceof Uint32Array){const i=new Uint32Array(b.data.buffer,b.data.byteOffset+4*P,1);return new FT(i,_)}throw"GetSubData: Invalid data type"}if(!(g instanceof pT))return console.error("GetSubData: Unknown postfix",g),null;{const m=g.value.toLowerCase();if(1===m.length){let i=0;if("x"===m||"r"===m)i=0;else if("y"===m||"g"===m)i=1;else if("z"===m||"b"===m)i=2;else{if("w"!==m&&"a"!==m)return console.error(`GetSubData: Unknown member ${m}`),null;i=3}if(this.data instanceof Float32Array){let g=new Float32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new FT(g,_,this)}if(this.data instanceof Int32Array){let g=new Int32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new FT(g,_,this)}if(this.data instanceof Uint32Array){let g=new Uint32Array(this.data.buffer,this.data.byteOffset+4*i,1);return new FT(g,_,this)}}const T=[];for(const i of m)"x"===i||"r"===i?T.push(this.data[0]):"y"===i||"g"===i?T.push(this.data[1]):"z"===i||"b"===i?T.push(this.data[2]):"w"===i||"a"===i?T.push(this.data[3]):console.error(`GetDataValue: Unknown member ${i}`);b=NT(i,T,_.name)}g=g.postfix}return b}toString(){let i=`${this.data[0]}`;for(let g=1;g<this.data.length;++g)i+=`, ${this.data[g]}`;return i}},BT=class Me extends RT{constructor(i,g,m=null){super(g,m),this.data=i instanceof Float32Array?i:new Float32Array(i)}clone(){return new Me(new Float32Array(this.data),this.typeInfo,null)}setDataValue(i,g,m,_){m instanceof pT?console.error("TODO: Set matrix postfix"):g instanceof Me?this.data=g.data:console.error("SetDataValue: Invalid value",g)}getSubData(i,g,m){if(null===g)return this;const _=this.typeInfo.name;if(i.getTypeInfo("f32"),this.typeInfo instanceof a);else if(_.endsWith("f"))i.getTypeInfo("f32");else if(_.endsWith("i"))i.getTypeInfo("i32");else if(_.endsWith("u"))i.getTypeInfo("u32");else{if(!_.endsWith("h"))return console.error(`GetDataValue: Unknown type ${_}`),null;i.getTypeInfo("f16")}if(g instanceof xT){const b=g.index;let T=-1;if(b instanceof _T){if(!(b.value instanceof FT))return console.error(`GetDataValue: Invalid array index ${b.value}`),null;T=b.value.value}else{const g=i.evalExpression(b,m);if(!(g instanceof FT))return console.error("GetDataValue: Unknown index type",b),null;T=g.value}if(T<0||T>=this.data.length)return console.error("GetDataValue: Index out of range",T),null;const P=_.endsWith("h")?"h":"f";let I;if("mat2x2"===_||"mat2x2f"===_||"mat2x2h"===_||"mat3x2"===_||"mat3x2f"===_||"mat3x2h"===_||"mat4x2"===_||"mat4x2f"===_||"mat4x2h"===_)I=new HT(new Float32Array(this.data.buffer,this.data.byteOffset+2*T*4,2),i.getTypeInfo(`vec2${P}`));else if("mat2x3"===_||"mat2x3f"===_||"mat2x3h"===_||"mat3x3"===_||"mat3x3f"===_||"mat3x3h"===_||"mat4x3"===_||"mat4x3f"===_||"mat4x3h"===_)I=new HT(new Float32Array(this.data.buffer,this.data.byteOffset+3*T*4,3),i.getTypeInfo(`vec3${P}`));else{if("mat2x4"!==_&&"mat2x4f"!==_&&"mat2x4h"!==_&&"mat3x4"!==_&&"mat3x4f"!==_&&"mat3x4h"!==_&&"mat4x4"!==_&&"mat4x4f"!==_&&"mat4x4h"!==_)return console.error(`GetDataValue: Unknown type ${_}`),null;I=new HT(new Float32Array(this.data.buffer,this.data.byteOffset+4*T*4,4),i.getTypeInfo(`vec4${P}`))}return g.postfix?I.getSubData(i,g.postfix,m):I}return console.error("GetDataValue: Invalid postfix",g),null}toString(){let i=`${this.data[0]}`;for(let g=1;g<this.data.length;++g)i+=`, ${this.data[g]}`;return i}},zT=class Ue extends RT{constructor(i,g,m=0,_=null){super(g,_),this.buffer=i instanceof ArrayBuffer?i:i.buffer,this.offset=m}clone(){const i=new Uint8Array(new Uint8Array(this.buffer,this.offset,this.typeInfo.size));return new Ue(i.buffer,this.typeInfo,0,null)}setDataValue(i,g,m,_){if(null===g)return void console.log("setDataValue: NULL data.");let b=this.offset,T=this.typeInfo;for(;m;){if(m instanceof xT)if(T instanceof s){const g=m.index;if(g instanceof _T){if(!(g.value instanceof FT))return void console.error(`SetDataValue: Invalid index type ${g.value}`);b+=g.value.value*T.stride}else{const m=i.evalExpression(g,_);if(!(m instanceof FT))return void console.error("SetDataValue: Unknown index type",g);b+=m.value*T.stride}T=T.format}else console.error(`SetDataValue: Type ${T.getTypeName()} is not an array`);else{if(!(m instanceof pT))return void console.error("SetDataValue: Unknown postfix type",m);{const i=m.value;if(T instanceof n){let g=!1;for(const m of T.members)if(m.name===i){b+=m.offset,T=m.type,g=!0;break}if(!g)return void console.error(`SetDataValue: Member ${i} not found`)}else if(T instanceof cw){const m=T.getTypeName();let _=0;if("x"===i||"r"===i)_=0;else if("y"===i||"g"===i)_=1;else if("z"===i||"b"===i)_=2;else{if("w"!==i&&"a"!==i)return void console.error(`SetDataValue: Unknown member ${i}`);_=3}if(!(g instanceof FT))return void console.error("SetDataValue: Invalid value",g);const P=g.value;return"vec2f"===m?void(new Float32Array(this.buffer,b,2)[_]=P):"vec3f"===m?void(new Float32Array(this.buffer,b,3)[_]=P):"vec4f"===m?void(new Float32Array(this.buffer,b,4)[_]=P):"vec2i"===m?void(new Int32Array(this.buffer,b,2)[_]=P):"vec3i"===m?void(new Int32Array(this.buffer,b,3)[_]=P):"vec4i"===m?void(new Int32Array(this.buffer,b,4)[_]=P):"vec2u"===m?void(new Uint32Array(this.buffer,b,2)[_]=P):"vec3u"===m?void(new Uint32Array(this.buffer,b,3)[_]=P):"vec4u"===m?void(new Uint32Array(this.buffer,b,4)[_]=P):void console.error(`SetDataValue: Type ${m} is not a struct`)}}}m=m.postfix}this.setData(i,g,T,b,_)}setData(i,g,m,_,b){const T=m.getTypeName();if("f32"!==T&&"f16"!==T)if("i32"!==T&&"atomic<i32>"!==T&&"x32"!==T)if("u32"!==T&&"atomic<u32>"!==T)if("bool"!==T)if("vec2f"!==T&&"vec2h"!==T)if("vec3f"!==T&&"vec3h"!==T)if("vec4f"!==T&&"vec4h"!==T)if("vec2i"!==T)if("vec3i"!==T)if("vec4i"!==T)if("vec2u"!==T)if("vec3u"!==T)if("vec4u"!==T)if("vec2b"!==T)if("vec3b"!==T)if("vec4b"!==T)if("mat2x2f"!==T&&"mat2x2h"!==T)if("mat2x3f"!==T&&"mat2x3h"!==T)if("mat2x4f"!==T&&"mat2x4h"!==T)if("mat3x2f"!==T&&"mat3x2h"!==T)if("mat3x3f"!==T&&"mat3x3h"!==T)if("mat3x4f"!==T&&"mat3x4h"!==T)if("mat4x2f"!==T&&"mat4x2h"!==T)if("mat4x3f"!==T&&"mat4x3h"!==T)if("mat4x4f"!==T&&"mat4x4h"!==T)if(g instanceof Ue){if(m===g.typeInfo)return void new Uint8Array(this.buffer,_,g.buffer.byteLength).set(new Uint8Array(g.buffer));console.error("SetDataValue: Type mismatch",T,g.typeInfo.getTypeName())}else console.error(`SetData: Unknown type ${T}`);else{const i=new Float32Array(this.buffer,_,16);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8],i[9]=g.data[9],i[10]=g.data[10],i[11]=g.data[11],i[12]=g.data[12],i[13]=g.data[13],i[14]=g.data[14],i[15]=g.data[15]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11],i[12]=g[12],i[13]=g[13],i[14]=g[14],i[15]=g[15])}else{const i=new Float32Array(this.buffer,_,12);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8],i[9]=g.data[9],i[10]=g.data[10],i[11]=g.data[11]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11])}else{const i=new Float32Array(this.buffer,_,8);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7])}else{const i=new Float32Array(this.buffer,_,12);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8],i[9]=g.data[9],i[10]=g.data[10],i[11]=g.data[11]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8],i[9]=g[9],i[10]=g[10],i[11]=g[11])}else{const i=new Float32Array(this.buffer,_,9);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7],i[8]=g.data[8]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7],i[8]=g[8])}else{const i=new Float32Array(this.buffer,_,6);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5])}else{const i=new Float32Array(this.buffer,_,8);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5],i[6]=g.data[6],i[7]=g.data[7]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5],i[6]=g[6],i[7]=g[7])}else{const i=new Float32Array(this.buffer,_,6);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3],i[4]=g.data[4],i[5]=g.data[5]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=g[4],i[5]=g[5])}else{const i=new Float32Array(this.buffer,_,4);g instanceof BT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3])}else{const i=new Uint32Array(this.buffer,_,4);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3])}else{const i=new Uint32Array(this.buffer,_,3);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2])}else{const i=new Uint32Array(this.buffer,_,2);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1])}else{const i=new Uint32Array(this.buffer,_,4);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3])}else{const i=new Uint32Array(this.buffer,_,3);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2])}else{const i=new Uint32Array(this.buffer,_,2);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1])}else{const i=new Int32Array(this.buffer,_,4);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3])}else{const i=new Int32Array(this.buffer,_,3);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2])}else{const i=new Int32Array(this.buffer,_,2);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1])}else{const i=new Float32Array(this.buffer,_,4);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2],i[3]=g.data[3]):(i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3])}else{const i=new Float32Array(this.buffer,_,3);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1],i[2]=g.data[2]):(i[0]=g[0],i[1]=g[1],i[2]=g[2])}else{const i=new Float32Array(this.buffer,_,2);g instanceof HT?(i[0]=g.data[0],i[1]=g.data[1]):(i[0]=g[0],i[1]=g[1])}else g instanceof FT&&(new Int32Array(this.buffer,_,1)[0]=g.value);else g instanceof FT&&(new Uint32Array(this.buffer,_,1)[0]=g.value);else g instanceof FT&&(new Int32Array(this.buffer,_,1)[0]=g.value);else g instanceof FT&&(new Float32Array(this.buffer,_,1)[0]=g.value)}getSubData(i,g,m){var _,b,T;if(null===g)return this;let P=this.offset,I=this.typeInfo;for(;g;){if(g instanceof xT){const _=g.index,b=_ instanceof dT?i.evalExpression(_,m):_;let T=0;if(b instanceof FT?T=b.value:"number"==typeof b?T=b:console.error("GetDataValue: Invalid index type",_),I instanceof s)P+=T*I.stride,I=I.format;else{const g=I.getTypeName();"mat4x4"===g||"mat4x4f"===g||"mat4x4h"===g?(P+=16*T,I=i.getTypeInfo("vec4f")):console.error(`getDataValue: Type ${I.getTypeName()} is not an array`)}}else{if(!(g instanceof pT))return console.error("GetDataValue: Unknown postfix type",g),null;{const m=g.value;if(I instanceof n){let i=!1;for(const g of I.members)if(g.name===m){P+=g.offset,I=g.type,i=!0;break}if(!i)return console.error(`GetDataValue: Member ${m} not found`),null}else if(I instanceof cw){const g=I.getTypeName();if("vec2f"===g||"vec3f"===g||"vec4f"===g||"vec2i"===g||"vec3i"===g||"vec4i"===g||"vec2u"===g||"vec3u"===g||"vec4u"===g||"vec2b"===g||"vec3b"===g||"vec4b"===g||"vec2h"===g||"vec3h"===g||"vec4h"===g||"vec2"===g||"vec3"===g||"vec4"===g){if(m.length>0&&m.length<5){let _="f";const b=[];for(let T=0;T<m.length;++T){const I=m[T].toLowerCase();let H=0;if("x"===I||"r"===I)H=0;else if("y"===I||"g"===I)H=1;else if("z"===I||"b"===I)H=2;else{if("w"!==I&&"a"!==I)return console.error(`Unknown member ${m}`),null;H=3}if(1===m.length){if(g.endsWith("f"))return this.buffer.byteLength<P+4*H+4?(console.log("Insufficient buffer data"),null):new FT(new Float32Array(this.buffer,P+4*H,1),i.getTypeInfo("f32"),this);if(g.endsWith("h"))return new FT(new Float32Array(this.buffer,P+4*H,1),i.getTypeInfo("f16"),this);if(g.endsWith("i"))return new FT(new Int32Array(this.buffer,P+4*H,1),i.getTypeInfo("i32"),this);if(g.endsWith("b"))return new FT(new Int32Array(this.buffer,P+4*H,1),i.getTypeInfo("bool"),this);if(g.endsWith("u"))return new FT(new Uint32Array(this.buffer,P+4*H,1),i.getTypeInfo("i32"),this)}if("vec2f"===g)b.push(new Float32Array(this.buffer,P,2)[H]);else if("vec3f"===g){if(P+12>=this.buffer.byteLength)return console.log("Insufficient buffer data"),null;const i=new Float32Array(this.buffer,P,3);b.push(i[H])}else if("vec4f"===g)b.push(new Float32Array(this.buffer,P,4)[H]);else if("vec2i"===g)_="i",b.push(new Int32Array(this.buffer,P,2)[H]);else if("vec3i"===g)_="i",b.push(new Int32Array(this.buffer,P,3)[H]);else if("vec4i"===g)_="i",b.push(new Int32Array(this.buffer,P,4)[H]);else if("vec2u"===g){_="u";const i=new Uint32Array(this.buffer,P,2);b.push(i[H])}else"vec3u"===g?(_="u",b.push(new Uint32Array(this.buffer,P,3)[H])):"vec4u"===g&&(_="u",b.push(new Uint32Array(this.buffer,P,4)[H]))}return 2===b.length?I=i.getTypeInfo(`vec2${_}`):3===b.length?I=i.getTypeInfo(`vec3${_}`):4===b.length?I=i.getTypeInfo(`vec4${_}`):console.error(`GetDataValue: Invalid vector length ${b.length}`),new HT(b,I,null)}return console.error(`GetDataValue: Unknown member ${m}`),null}return console.error(`GetDataValue: Type ${g} is not a struct`),null}}}g=g.postfix}const H=I.getTypeName();return"f32"===H?new FT(new Float32Array(this.buffer,P,1),I,this):"i32"===H?new FT(new Int32Array(this.buffer,P,1),I,this):"u32"===H?new FT(new Uint32Array(this.buffer,P,1),I,this):"vec2f"===H?new HT(new Float32Array(this.buffer,P,2),I,this):"vec3f"===H?new HT(new Float32Array(this.buffer,P,3),I,this):"vec4f"===H?new HT(new Float32Array(this.buffer,P,4),I,this):"vec2i"===H?new HT(new Int32Array(this.buffer,P,2),I,this):"vec3i"===H?new HT(new Int32Array(this.buffer,P,3),I,this):"vec4i"===H?new HT(new Int32Array(this.buffer,P,4),I,this):"vec2u"===H?new HT(new Uint32Array(this.buffer,P,2),I,this):"vec3u"===H?new HT(new Uint32Array(this.buffer,P,3),I,this):"vec4u"===H?new HT(new Uint32Array(this.buffer,P,4),I,this):I instanceof a&&"atomic"===I.name?"u32"===(null===(_=I.format)||void 0===_?void 0:_.name)?new FT(new Uint32Array(this.buffer,P,1)[0],I.format,this):"i32"===(null===(b=I.format)||void 0===b?void 0:b.name)?new FT(new Int32Array(this.buffer,P,1)[0],I.format,this):(console.error(`GetDataValue: Invalid atomic format ${null===(T=I.format)||void 0===T?void 0:T.name}`),null):new Ue(this.buffer,I,P,this)}toString(){let i="";if(this.typeInfo instanceof s)if("f32"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]}`;for(let m=1;m<g.length;++m)i+=`, ${g[m]}`}else if("i32"===this.typeInfo.format.name){const g=new Int32Array(this.buffer,this.offset);i=`[${g[0]}`;for(let m=1;m<g.length;++m)i+=`, ${g[m]}`}else if("u32"===this.typeInfo.format.name){const g=new Uint32Array(this.buffer,this.offset);i=`[${g[0]}`;for(let m=1;m<g.length;++m)i+=`, ${g[m]}`}else if("vec2f"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]}, ${g[1]}]`;for(let m=1;m<g.length/2;++m)i+=`, [${g[2*m]}, ${g[2*m+1]}]`}else if("vec3f"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]}, ${g[1]}, ${g[2]}]`;for(let m=4;m<g.length;m+=4)i+=`, [${g[m]}, ${g[m+1]}, ${g[m+2]}]`}else if("vec4f"===this.typeInfo.format.name){const g=new Float32Array(this.buffer,this.offset);i=`[${g[0]}, ${g[1]}, ${g[2]}, ${g[3]}]`;for(let m=4;m<g.length;m+=4)i+=`, [${g[m]}, ${g[m+1]}, ${g[m+2]}, ${g[m+3]}]`}else i="[...]";else this.typeInfo instanceof n?i+="{...}":i="[...]";return i}},VT=class Pe extends RT{constructor(i,g,m,_){super(g,null),this.data=i,this.descriptor=m,this.view=_}clone(){return new Pe(this.data,this.typeInfo,this.descriptor,this.view)}get width(){var i,g;const m=this.descriptor.size;return m instanceof Array&&m.length>0?null!==(i=m[0])&&void 0!==i?i:0:m instanceof Object&&null!==(g=m.width)&&void 0!==g?g:0}get height(){var i,g;const m=this.descriptor.size;return m instanceof Array&&m.length>1?null!==(i=m[1])&&void 0!==i?i:0:m instanceof Object&&null!==(g=m.height)&&void 0!==g?g:0}get depthOrArrayLayers(){var i,g;const m=this.descriptor.size;return m instanceof Array&&m.length>2?null!==(i=m[2])&&void 0!==i?i:0:m instanceof Object&&null!==(g=m.depthOrArrayLayers)&&void 0!==g?g:0}get format(){var i;return this.descriptor&&null!==(i=this.descriptor.format)&&void 0!==i?i:"rgba8unorm"}get sampleCount(){var i;return this.descriptor&&null!==(i=this.descriptor.sampleCount)&&void 0!==i?i:1}get mipLevelCount(){var i;return this.descriptor&&null!==(i=this.descriptor.mipLevelCount)&&void 0!==i?i:1}get dimension(){var i;return this.descriptor&&null!==(i=this.descriptor.dimension)&&void 0!==i?i:"2d"}getMipLevelSize(i){if(i>=this.mipLevelCount)return[0,0,0];const g=[this.width,this.height,this.depthOrArrayLayers];for(let m=0;m<g.length;++m)g[m]=Math.max(1,g[m]>>i);return g}get texelByteSize(){const i=Cw[this.format];return i?i.isDepthStencil?4:i.bytesPerBlock:0}get bytesPerRow(){return this.width*this.texelByteSize}get isDepthStencil(){const i=Cw[this.format];return!!i&&i.isDepthStencil}getGpuSize(){const i=this.format,g=Cw[i],m=this.width;if(!i||m<=0||!g)return-1;return m/g.blockWidth*("1d"===this.dimension?1:this.height/g.blockHeight)*g.bytesPerBlock*this.depthOrArrayLayers}getPixel(i,g,m=0,_=0){const b=this.texelByteSize,T=this.bytesPerRow,P=this.height;return function(i,g,m,_,b,T,P,I,H){const W=_*(P>>=b)*(T>>=b)+m*P+g*I;switch(H){case"r8unorm":return[Sw(i,W,"8unorm",1)[0]];case"r8snorm":return[Sw(i,W,"8snorm",1)[0]];case"r8uint":return[Sw(i,W,"8uint",1)[0]];case"r8sint":return[Sw(i,W,"8sint",1)[0]];case"rg8unorm":{const g=Sw(i,W,"8unorm",2);return[g[0],g[1]]}case"rg8snorm":{const g=Sw(i,W,"8snorm",2);return[g[0],g[1]]}case"rg8uint":{const g=Sw(i,W,"8uint",2);return[g[0],g[1]]}case"rg8sint":{const g=Sw(i,W,"8sint",2);return[g[0],g[1]]}case"rgba8unorm-srgb":case"rgba8unorm":{const g=Sw(i,W,"8unorm",4);return[g[0],g[1],g[2],g[3]]}case"rgba8snorm":{const g=Sw(i,W,"8snorm",4);return[g[0],g[1],g[2],g[3]]}case"rgba8uint":{const g=Sw(i,W,"8uint",4);return[g[0],g[1],g[2],g[3]]}case"rgba8sint":{const g=Sw(i,W,"8sint",4);return[g[0],g[1],g[2],g[3]]}case"bgra8unorm-srgb":case"bgra8unorm":{const g=Sw(i,W,"8unorm",4);return[g[2],g[1],g[0],g[3]]}case"r16uint":return[Sw(i,W,"16uint",1)[0]];case"r16sint":return[Sw(i,W,"16sint",1)[0]];case"r16float":return[Sw(i,W,"16float",1)[0]];case"rg16uint":{const g=Sw(i,W,"16uint",2);return[g[0],g[1]]}case"rg16sint":{const g=Sw(i,W,"16sint",2);return[g[0],g[1]]}case"rg16float":{const g=Sw(i,W,"16float",2);return[g[0],g[1]]}case"rgba16uint":{const g=Sw(i,W,"16uint",4);return[g[0],g[1],g[2],g[3]]}case"rgba16sint":{const g=Sw(i,W,"16sint",4);return[g[0],g[1],g[2],g[3]]}case"rgba16float":{const g=Sw(i,W,"16float",4);return[g[0],g[1],g[2],g[3]]}case"r32uint":return[Sw(i,W,"32uint",1)[0]];case"r32sint":return[Sw(i,W,"32sint",1)[0]];case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return[Sw(i,W,"32float",1)[0]];case"rg32uint":{const g=Sw(i,W,"32uint",2);return[g[0],g[1]]}case"rg32sint":{const g=Sw(i,W,"32sint",2);return[g[0],g[1]]}case"rg32float":{const g=Sw(i,W,"32float",2);return[g[0],g[1]]}case"rgba32uint":{const g=Sw(i,W,"32uint",4);return[g[0],g[1],g[2],g[3]]}case"rgba32sint":{const g=Sw(i,W,"32sint",4);return[g[0],g[1],g[2],g[3]]}case"rgba32float":{const g=Sw(i,W,"32float",4);return[g[0],g[1],g[2],g[3]]}case"rg11b10ufloat":{const g=new Uint32Array(i.buffer,W,1)[0],m=(4192256&g)>>11,_=(4290772992&g)>>22;return[Tw(2047&g),Tw(m),function(i){return bw[0]=112+(i>>5&31)<<23|(31&i)<<18,ww[0]}(_),1]}}return null}(new Uint8Array(this.data[_]),i,g,m,_,P,T,b,this.format)}setPixel(i,g,m,_,b){const T=this.texelByteSize,P=this.bytesPerRow,I=this.height;!function(i,g,m,_,b,T,P,I,H,W){const q=_*(P>>=b)*(T>>=b)+m*P+g*I;switch(H){case"r8unorm":return void Mw(i,q,"8unorm",1,W);case"r8snorm":return void Mw(i,q,"8snorm",1,W);case"r8uint":return void Mw(i,q,"8uint",1,W);case"r8sint":return void Mw(i,q,"8sint",1,W);case"rg8unorm":return void Mw(i,q,"8unorm",2,W);case"rg8snorm":return void Mw(i,q,"8snorm",2,W);case"rg8uint":return void Mw(i,q,"8uint",2,W);case"rg8sint":return void Mw(i,q,"8sint",2,W);case"rgba8unorm-srgb":case"rgba8unorm":case"bgra8unorm-srgb":case"bgra8unorm":return void Mw(i,q,"8unorm",4,W);case"rgba8snorm":return void Mw(i,q,"8snorm",4,W);case"rgba8uint":return void Mw(i,q,"8uint",4,W);case"rgba8sint":return void Mw(i,q,"8sint",4,W);case"r16uint":return void Mw(i,q,"16uint",1,W);case"r16sint":return void Mw(i,q,"16sint",1,W);case"r16float":return void Mw(i,q,"16float",1,W);case"rg16uint":return void Mw(i,q,"16uint",2,W);case"rg16sint":return void Mw(i,q,"16sint",2,W);case"rg16float":return void Mw(i,q,"16float",2,W);case"rgba16uint":return void Mw(i,q,"16uint",4,W);case"rgba16sint":return void Mw(i,q,"16sint",4,W);case"rgba16float":return void Mw(i,q,"16float",4,W);case"r32uint":return void Mw(i,q,"32uint",1,W);case"r32sint":return void Mw(i,q,"32sint",1,W);case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return void Mw(i,q,"32float",1,W);case"rg32uint":return void Mw(i,q,"32uint",2,W);case"rg32sint":return void Mw(i,q,"32sint",2,W);case"rg32float":return void Mw(i,q,"32float",2,W);case"rgba32uint":return void Mw(i,q,"32uint",4,W);case"rgba32sint":return void Mw(i,q,"32sint",4,W);case"rgba32float":return void Mw(i,q,"32float",4,W);case"rg11b10ufloat":console.error("TODO: rg11b10ufloat not supported for writing")}}(new Uint8Array(this.data[_]),i,g,m,_,I,P,T,this.format,b)}};(i=>{i[i.token=0]="token",i[i.keyword=1]="keyword",i[i.reserved=2]="reserved"})(Ww||(Ww={}));let UT=class We{constructor(i,g,m){this.name=i,this.type=g,this.rule=m}toString(){return this.name}},GT=class qe{};jw=GT,GT.none=new UT("",Ww.reserved,""),GT.eof=new UT("EOF",Ww.token,""),GT.reserved={asm:new UT("asm",Ww.reserved,"asm"),bf16:new UT("bf16",Ww.reserved,"bf16"),do:new UT("do",Ww.reserved,"do"),enum:new UT("enum",Ww.reserved,"enum"),f16:new UT("f16",Ww.reserved,"f16"),f64:new UT("f64",Ww.reserved,"f64"),handle:new UT("handle",Ww.reserved,"handle"),i8:new UT("i8",Ww.reserved,"i8"),i16:new UT("i16",Ww.reserved,"i16"),i64:new UT("i64",Ww.reserved,"i64"),mat:new UT("mat",Ww.reserved,"mat"),premerge:new UT("premerge",Ww.reserved,"premerge"),regardless:new UT("regardless",Ww.reserved,"regardless"),typedef:new UT("typedef",Ww.reserved,"typedef"),u8:new UT("u8",Ww.reserved,"u8"),u16:new UT("u16",Ww.reserved,"u16"),u64:new UT("u64",Ww.reserved,"u64"),unless:new UT("unless",Ww.reserved,"unless"),using:new UT("using",Ww.reserved,"using"),vec:new UT("vec",Ww.reserved,"vec"),void:new UT("void",Ww.reserved,"void")},GT.keywords={array:new UT("array",Ww.keyword,"array"),atomic:new UT("atomic",Ww.keyword,"atomic"),bool:new UT("bool",Ww.keyword,"bool"),f32:new UT("f32",Ww.keyword,"f32"),i32:new UT("i32",Ww.keyword,"i32"),mat2x2:new UT("mat2x2",Ww.keyword,"mat2x2"),mat2x3:new UT("mat2x3",Ww.keyword,"mat2x3"),mat2x4:new UT("mat2x4",Ww.keyword,"mat2x4"),mat3x2:new UT("mat3x2",Ww.keyword,"mat3x2"),mat3x3:new UT("mat3x3",Ww.keyword,"mat3x3"),mat3x4:new UT("mat3x4",Ww.keyword,"mat3x4"),mat4x2:new UT("mat4x2",Ww.keyword,"mat4x2"),mat4x3:new UT("mat4x3",Ww.keyword,"mat4x3"),mat4x4:new UT("mat4x4",Ww.keyword,"mat4x4"),ptr:new UT("ptr",Ww.keyword,"ptr"),sampler:new UT("sampler",Ww.keyword,"sampler"),sampler_comparison:new UT("sampler_comparison",Ww.keyword,"sampler_comparison"),struct:new UT("struct",Ww.keyword,"struct"),texture_1d:new UT("texture_1d",Ww.keyword,"texture_1d"),texture_2d:new UT("texture_2d",Ww.keyword,"texture_2d"),texture_2d_array:new UT("texture_2d_array",Ww.keyword,"texture_2d_array"),texture_3d:new UT("texture_3d",Ww.keyword,"texture_3d"),texture_cube:new UT("texture_cube",Ww.keyword,"texture_cube"),texture_cube_array:new UT("texture_cube_array",Ww.keyword,"texture_cube_array"),texture_multisampled_2d:new UT("texture_multisampled_2d",Ww.keyword,"texture_multisampled_2d"),texture_storage_1d:new UT("texture_storage_1d",Ww.keyword,"texture_storage_1d"),texture_storage_2d:new UT("texture_storage_2d",Ww.keyword,"texture_storage_2d"),texture_storage_2d_array:new UT("texture_storage_2d_array",Ww.keyword,"texture_storage_2d_array"),texture_storage_3d:new UT("texture_storage_3d",Ww.keyword,"texture_storage_3d"),texture_depth_2d:new UT("texture_depth_2d",Ww.keyword,"texture_depth_2d"),texture_depth_2d_array:new UT("texture_depth_2d_array",Ww.keyword,"texture_depth_2d_array"),texture_depth_cube:new UT("texture_depth_cube",Ww.keyword,"texture_depth_cube"),texture_depth_cube_array:new UT("texture_depth_cube_array",Ww.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new UT("texture_depth_multisampled_2d",Ww.keyword,"texture_depth_multisampled_2d"),texture_external:new UT("texture_external",Ww.keyword,"texture_external"),u32:new UT("u32",Ww.keyword,"u32"),vec2:new UT("vec2",Ww.keyword,"vec2"),vec3:new UT("vec3",Ww.keyword,"vec3"),vec4:new UT("vec4",Ww.keyword,"vec4"),bitcast:new UT("bitcast",Ww.keyword,"bitcast"),block:new UT("block",Ww.keyword,"block"),break:new UT("break",Ww.keyword,"break"),case:new UT("case",Ww.keyword,"case"),continue:new UT("continue",Ww.keyword,"continue"),continuing:new UT("continuing",Ww.keyword,"continuing"),default:new UT("default",Ww.keyword,"default"),diagnostic:new UT("diagnostic",Ww.keyword,"diagnostic"),discard:new UT("discard",Ww.keyword,"discard"),else:new UT("else",Ww.keyword,"else"),enable:new UT("enable",Ww.keyword,"enable"),fallthrough:new UT("fallthrough",Ww.keyword,"fallthrough"),false:new UT("false",Ww.keyword,"false"),fn:new UT("fn",Ww.keyword,"fn"),for:new UT("for",Ww.keyword,"for"),function:new UT("function",Ww.keyword,"function"),if:new UT("if",Ww.keyword,"if"),let:new UT("let",Ww.keyword,"let"),const:new UT("const",Ww.keyword,"const"),loop:new UT("loop",Ww.keyword,"loop"),while:new UT("while",Ww.keyword,"while"),private:new UT("private",Ww.keyword,"private"),read:new UT("read",Ww.keyword,"read"),read_write:new UT("read_write",Ww.keyword,"read_write"),return:new UT("return",Ww.keyword,"return"),requires:new UT("requires",Ww.keyword,"requires"),storage:new UT("storage",Ww.keyword,"storage"),switch:new UT("switch",Ww.keyword,"switch"),true:new UT("true",Ww.keyword,"true"),alias:new UT("alias",Ww.keyword,"alias"),type:new UT("type",Ww.keyword,"type"),uniform:new UT("uniform",Ww.keyword,"uniform"),var:new UT("var",Ww.keyword,"var"),override:new UT("override",Ww.keyword,"override"),workgroup:new UT("workgroup",Ww.keyword,"workgroup"),write:new UT("write",Ww.keyword,"write"),r8unorm:new UT("r8unorm",Ww.keyword,"r8unorm"),r8snorm:new UT("r8snorm",Ww.keyword,"r8snorm"),r8uint:new UT("r8uint",Ww.keyword,"r8uint"),r8sint:new UT("r8sint",Ww.keyword,"r8sint"),r16uint:new UT("r16uint",Ww.keyword,"r16uint"),r16sint:new UT("r16sint",Ww.keyword,"r16sint"),r16float:new UT("r16float",Ww.keyword,"r16float"),rg8unorm:new UT("rg8unorm",Ww.keyword,"rg8unorm"),rg8snorm:new UT("rg8snorm",Ww.keyword,"rg8snorm"),rg8uint:new UT("rg8uint",Ww.keyword,"rg8uint"),rg8sint:new UT("rg8sint",Ww.keyword,"rg8sint"),r32uint:new UT("r32uint",Ww.keyword,"r32uint"),r32sint:new UT("r32sint",Ww.keyword,"r32sint"),r32float:new UT("r32float",Ww.keyword,"r32float"),rg16uint:new UT("rg16uint",Ww.keyword,"rg16uint"),rg16sint:new UT("rg16sint",Ww.keyword,"rg16sint"),rg16float:new UT("rg16float",Ww.keyword,"rg16float"),rgba8unorm:new UT("rgba8unorm",Ww.keyword,"rgba8unorm"),rgba8unorm_srgb:new UT("rgba8unorm_srgb",Ww.keyword,"rgba8unorm_srgb"),rgba8snorm:new UT("rgba8snorm",Ww.keyword,"rgba8snorm"),rgba8uint:new UT("rgba8uint",Ww.keyword,"rgba8uint"),rgba8sint:new UT("rgba8sint",Ww.keyword,"rgba8sint"),bgra8unorm:new UT("bgra8unorm",Ww.keyword,"bgra8unorm"),bgra8unorm_srgb:new UT("bgra8unorm_srgb",Ww.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new UT("rgb10a2unorm",Ww.keyword,"rgb10a2unorm"),rg11b10float:new UT("rg11b10float",Ww.keyword,"rg11b10float"),rg32uint:new UT("rg32uint",Ww.keyword,"rg32uint"),rg32sint:new UT("rg32sint",Ww.keyword,"rg32sint"),rg32float:new UT("rg32float",Ww.keyword,"rg32float"),rgba16uint:new UT("rgba16uint",Ww.keyword,"rgba16uint"),rgba16sint:new UT("rgba16sint",Ww.keyword,"rgba16sint"),rgba16float:new UT("rgba16float",Ww.keyword,"rgba16float"),rgba32uint:new UT("rgba32uint",Ww.keyword,"rgba32uint"),rgba32sint:new UT("rgba32sint",Ww.keyword,"rgba32sint"),rgba32float:new UT("rgba32float",Ww.keyword,"rgba32float"),static_assert:new UT("static_assert",Ww.keyword,"static_assert")},GT.tokens={decimal_float_literal:new UT("decimal_float_literal",Ww.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),hex_float_literal:new UT("hex_float_literal",Ww.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),int_literal:new UT("int_literal",Ww.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new UT("uint_literal",Ww.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),name:new UT("name",Ww.token,/([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),ident:new UT("ident",Ww.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new UT("and",Ww.token,"&"),and_and:new UT("and_and",Ww.token,"&&"),arrow:new UT("arrow ",Ww.token,"->"),attr:new UT("attr",Ww.token,"@"),forward_slash:new UT("forward_slash",Ww.token,"/"),bang:new UT("bang",Ww.token,"!"),bracket_left:new UT("bracket_left",Ww.token,"["),bracket_right:new UT("bracket_right",Ww.token,"]"),brace_left:new UT("brace_left",Ww.token,"{"),brace_right:new UT("brace_right",Ww.token,"}"),colon:new UT("colon",Ww.token,":"),comma:new UT("comma",Ww.token,","),equal:new UT("equal",Ww.token,"="),equal_equal:new UT("equal_equal",Ww.token,"=="),not_equal:new UT("not_equal",Ww.token,"!="),greater_than:new UT("greater_than",Ww.token,">"),greater_than_equal:new UT("greater_than_equal",Ww.token,">="),shift_right:new UT("shift_right",Ww.token,">>"),less_than:new UT("less_than",Ww.token,"<"),less_than_equal:new UT("less_than_equal",Ww.token,"<="),shift_left:new UT("shift_left",Ww.token,"<<"),modulo:new UT("modulo",Ww.token,"%"),minus:new UT("minus",Ww.token,"-"),minus_minus:new UT("minus_minus",Ww.token,"--"),period:new UT("period",Ww.token,"."),plus:new UT("plus",Ww.token,"+"),plus_plus:new UT("plus_plus",Ww.token,"++"),or:new UT("or",Ww.token,"|"),or_or:new UT("or_or",Ww.token,"||"),paren_left:new UT("paren_left",Ww.token,"("),paren_right:new UT("paren_right",Ww.token,")"),semicolon:new UT("semicolon",Ww.token,";"),star:new UT("star",Ww.token,"*"),tilde:new UT("tilde",Ww.token,"~"),underscore:new UT("underscore",Ww.token,"_"),xor:new UT("xor",Ww.token,"^"),plus_equal:new UT("plus_equal",Ww.token,"+="),minus_equal:new UT("minus_equal",Ww.token,"-="),times_equal:new UT("times_equal",Ww.token,"*="),division_equal:new UT("division_equal",Ww.token,"/="),modulo_equal:new UT("modulo_equal",Ww.token,"%="),and_equal:new UT("and_equal",Ww.token,"&="),or_equal:new UT("or_equal",Ww.token,"|="),xor_equal:new UT("xor_equal",Ww.token,"^="),shift_right_equal:new UT("shift_right_equal",Ww.token,">>="),shift_left_equal:new UT("shift_left_equal",Ww.token,"<<=")},GT.simpleTokens={"@":jw.tokens.attr,"{":jw.tokens.brace_left,"}":jw.tokens.brace_right,":":jw.tokens.colon,",":jw.tokens.comma,"(":jw.tokens.paren_left,")":jw.tokens.paren_right,";":jw.tokens.semicolon},GT.literalTokens={"&":jw.tokens.and,"&&":jw.tokens.and_and,"->":jw.tokens.arrow,"/":jw.tokens.forward_slash,"!":jw.tokens.bang,"[":jw.tokens.bracket_left,"]":jw.tokens.bracket_right,"=":jw.tokens.equal,"==":jw.tokens.equal_equal,"!=":jw.tokens.not_equal,">":jw.tokens.greater_than,">=":jw.tokens.greater_than_equal,">>":jw.tokens.shift_right,"<":jw.tokens.less_than,"<=":jw.tokens.less_than_equal,"<<":jw.tokens.shift_left,"%":jw.tokens.modulo,"-":jw.tokens.minus,"--":jw.tokens.minus_minus,".":jw.tokens.period,"+":jw.tokens.plus,"++":jw.tokens.plus_plus,"|":jw.tokens.or,"||":jw.tokens.or_or,"*":jw.tokens.star,"~":jw.tokens.tilde,_:jw.tokens.underscore,"^":jw.tokens.xor,"+=":jw.tokens.plus_equal,"-=":jw.tokens.minus_equal,"*=":jw.tokens.times_equal,"/=":jw.tokens.division_equal,"%=":jw.tokens.modulo_equal,"&=":jw.tokens.and_equal,"|=":jw.tokens.or_equal,"^=":jw.tokens.xor_equal,">>=":jw.tokens.shift_right_equal,"<<=":jw.tokens.shift_left_equal},GT.regexTokens={decimal_float_literal:jw.tokens.decimal_float_literal,hex_float_literal:jw.tokens.hex_float_literal,int_literal:jw.tokens.int_literal,uint_literal:jw.tokens.uint_literal,ident:jw.tokens.ident},GT.storage_class=[jw.keywords.function,jw.keywords.private,jw.keywords.workgroup,jw.keywords.uniform,jw.keywords.storage],GT.access_mode=[jw.keywords.read,jw.keywords.write,jw.keywords.read_write],GT.sampler_type=[jw.keywords.sampler,jw.keywords.sampler_comparison],GT.sampled_texture_type=[jw.keywords.texture_1d,jw.keywords.texture_2d,jw.keywords.texture_2d_array,jw.keywords.texture_3d,jw.keywords.texture_cube,jw.keywords.texture_cube_array],GT.multisampled_texture_type=[jw.keywords.texture_multisampled_2d],GT.storage_texture_type=[jw.keywords.texture_storage_1d,jw.keywords.texture_storage_2d,jw.keywords.texture_storage_2d_array,jw.keywords.texture_storage_3d],GT.depth_texture_type=[jw.keywords.texture_depth_2d,jw.keywords.texture_depth_2d_array,jw.keywords.texture_depth_cube,jw.keywords.texture_depth_cube_array,jw.keywords.texture_depth_multisampled_2d],GT.texture_external_type=[jw.keywords.texture_external],GT.any_texture_type=[...jw.sampled_texture_type,...jw.multisampled_texture_type,...jw.storage_texture_type,...jw.depth_texture_type,...jw.texture_external_type],GT.texel_format=[jw.keywords.r8unorm,jw.keywords.r8snorm,jw.keywords.r8uint,jw.keywords.r8sint,jw.keywords.r16uint,jw.keywords.r16sint,jw.keywords.r16float,jw.keywords.rg8unorm,jw.keywords.rg8snorm,jw.keywords.rg8uint,jw.keywords.rg8sint,jw.keywords.r32uint,jw.keywords.r32sint,jw.keywords.r32float,jw.keywords.rg16uint,jw.keywords.rg16sint,jw.keywords.rg16float,jw.keywords.rgba8unorm,jw.keywords.rgba8unorm_srgb,jw.keywords.rgba8snorm,jw.keywords.rgba8uint,jw.keywords.rgba8sint,jw.keywords.bgra8unorm,jw.keywords.bgra8unorm_srgb,jw.keywords.rgb10a2unorm,jw.keywords.rg11b10float,jw.keywords.rg32uint,jw.keywords.rg32sint,jw.keywords.rg32float,jw.keywords.rgba16uint,jw.keywords.rgba16sint,jw.keywords.rgba16float,jw.keywords.rgba32uint,jw.keywords.rgba32sint,jw.keywords.rgba32float],GT.const_literal=[jw.tokens.int_literal,jw.tokens.uint_literal,jw.tokens.decimal_float_literal,jw.tokens.hex_float_literal,jw.keywords.true,jw.keywords.false],GT.literal_or_ident=[jw.tokens.ident,jw.tokens.int_literal,jw.tokens.uint_literal,jw.tokens.decimal_float_literal,jw.tokens.hex_float_literal,jw.tokens.name],GT.element_count_expression=[jw.tokens.int_literal,jw.tokens.uint_literal,jw.tokens.ident],GT.template_types=[jw.keywords.vec2,jw.keywords.vec3,jw.keywords.vec4,jw.keywords.mat2x2,jw.keywords.mat2x3,jw.keywords.mat2x4,jw.keywords.mat3x2,jw.keywords.mat3x3,jw.keywords.mat3x4,jw.keywords.mat4x2,jw.keywords.mat4x3,jw.keywords.mat4x4,jw.keywords.atomic,jw.keywords.bitcast,...jw.any_texture_type],GT.attribute_name=[jw.tokens.ident,jw.keywords.block,jw.keywords.diagnostic],GT.assignment_operators=[jw.tokens.equal,jw.tokens.plus_equal,jw.tokens.minus_equal,jw.tokens.times_equal,jw.tokens.division_equal,jw.tokens.modulo_equal,jw.tokens.and_equal,jw.tokens.or_equal,jw.tokens.xor_equal,jw.tokens.shift_right_equal,jw.tokens.shift_left_equal],GT.increment_operators=[jw.tokens.plus_plus,jw.tokens.minus_minus];let jT=class He{constructor(i,g,m,_,b){this.type=i,this.lexeme=g,this.line=m,this.start=_,this.end=b}toString(){return this.lexeme}isTemplateType(){return-1!=GT.template_types.indexOf(this.type)}isArrayType(){return this.type==GT.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}},WT=class ze{constructor(i){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=i?i:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new jT(GT.eof,"",this._line,this._current,this._current)),this._tokens}scanToken(){let i=this._advance();if("\n"==i)return this._line++,!0;if(this._isWhitespace(i))return!0;if("/"==i){if("/"==this._peekAhead()){for(;"\n"!=i;){if(this._isAtEnd())return!0;i=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let g=1;for(;g>0;){if(this._isAtEnd())return!0;if(i=this._advance(),"\n"==i)this._line++;else if("*"==i){if("/"==this._peekAhead()&&(this._advance(),g--,0==g))return!0}else"/"==i&&"*"==this._peekAhead()&&(this._advance(),g++)}return!0}}const g=GT.simpleTokens[i];if(g)return this._addToken(g),!0;let m=GT.none;const _=this._isAlpha(i),b="_"===i;if(this._isAlphaNumeric(i)){let g=this._peekAhead();for(;this._isAlphaNumeric(g);)i+=this._advance(),g=this._peekAhead()}if(_){const g=GT.keywords[i];if(g)return this._addToken(g),!0}if(_||b)return this._addToken(GT.tokens.ident),!0;for(;;){let g=this._findType(i);const _=this._peekAhead();if("-"==i&&this._tokens.length>0){if("="==_)return this._current++,i+=_,this._addToken(GT.tokens.minus_equal),!0;if("-"==_)return this._current++,i+=_,this._addToken(GT.tokens.minus_minus),!0;const m=this._tokens.length-1;if((-1!=GT.literal_or_ident.indexOf(this._tokens[m].type)||this._tokens[m].type==GT.tokens.paren_right)&&">"!=_)return this._addToken(g),!0}if(">"==i&&(">"==_||"="==_)){let i=!1,m=this._tokens.length-1;for(let g=0;g<5&&m>=0&&-1===GT.assignment_operators.indexOf(this._tokens[m].type);++g,--m)if(this._tokens[m].type===GT.tokens.less_than){m>0&&this._tokens[m-1].isArrayOrTemplateType()&&(i=!0);break}if(i)return this._addToken(g),!0}if(g===GT.none){let _=i,b=0;const T=2;for(let i=0;i<T;++i)if(_+=this._peekAhead(i),g=this._findType(_),g!==GT.none){b=i;break}if(g===GT.none)return m!==GT.none&&(this._current--,this._addToken(m),!0);i=_,this._current+=b+1}if(m=g,this._isAtEnd())break;i+=this._advance()}return m!==GT.none&&(this._addToken(m),!0)}_findType(i){for(const g in GT.regexTokens){const m=GT.regexTokens[g];if(this._match(i,m.rule))return m}return GT.literalTokens[i]||GT.none}_match(i,g){const m=g.exec(i);return m&&0==m.index&&m[0]==i}_isAtEnd(){return this._current>=this._source.length}_isAlpha(i){return!this._isNumeric(i)&&!this._isWhitespace(i)&&"_"!==i&&"."!==i&&"("!==i&&")"!==i&&"["!==i&&"]"!==i&&"{"!==i&&"}"!==i&&","!==i&&";"!==i&&":"!==i&&"="!==i&&"!"!==i&&"<"!==i&&">"!==i&&"+"!==i&&"-"!==i&&"*"!==i&&"/"!==i&&"%"!==i&&"&"!==i&&"|"!==i&&"^"!==i&&"~"!==i&&"@"!==i&&"#"!==i&&"?"!==i&&"'"!==i&&"`"!==i&&'"'!==i&&"\\"!==i&&"\n"!==i&&"\r"!==i&&"\t"!==i&&"\0"!==i}_isNumeric(i){return i>="0"&&i<="9"}_isAlphaNumeric(i){return this._isAlpha(i)||this._isNumeric(i)||"_"===i}_isWhitespace(i){return" "==i||"\t"==i||"\r"==i}_advance(i=0){let g=this._source[this._current];return i=i||0,i++,this._current+=i,g}_peekAhead(i=0){return this._current+(i=i||0)>=this._source.length?"\0":this._source[this._current+i]}_addToken(i){const g=this._source.substring(this._start,this._current);this._tokens.push(new jT(i,g,this._line,this._start,this._current))}};function qT(i){return Array.isArray(i)||(null==i?void 0:i.buffer)instanceof ArrayBuffer}const XT=new Float32Array(1),ZT=new Uint32Array(XT.buffer),$T=new Uint32Array(XT.buffer),YT=new Int32Array(1),QT=new Float32Array(YT.buffer),JT=new Uint32Array(YT.buffer),KT=new Uint32Array(1),eS=new Float32Array(KT.buffer),tS=new Int32Array(KT.buffer);function nS(i,g,m){if(g===m)return i;if("f32"===g){if("i32"===m||"x32"===m)return XT[0]=i,ZT[0];if("u32"===m)return XT[0]=i,$T[0]}else if("i32"===g||"x32"===g){if("f32"===m)return YT[0]=i,QT[0];if("u32"===m)return YT[0]=i,JT[0]}else if("u32"===g){if("f32"===m)return KT[0]=i,eS[0];if("i32"===m||"x32"===m)return KT[0]=i,tS[0]}return console.error(`Unsupported cast from ${g} to ${m}`),i}let rS=class nt{constructor(i){this.resources=null,this.inUse=!1,this.info=null,this.node=i}},iS=class st{constructor(i,g){this.align=i,this.size=g}},oS=class rt{constructor(){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new Aw,this.functions=[],this._types=new Map,this._functions=new Map}_isStorageTexture(i){return"texture_storage_1d"==i.name||"texture_storage_2d"==i.name||"texture_storage_2d_array"==i.name||"texture_storage_3d"==i.name}updateAST(i){for(const g of i)g instanceof Rw&&this._functions.set(g.name,new rS(g));for(const g of i)if(g instanceof lT){const i=this.getTypeInfo(g,null);i instanceof n&&this.structs.push(i)}for(const g of i)if(g instanceof nT)this.aliases.push(this._getAliasInfo(g));else if(g instanceof Bw){const i=g,m=this._getAttributeNum(i.attributes,"id",0),_=null!=i.type?this.getTypeInfo(i.type,i.attributes):null;this.overrides.push(new h(i.name,_,i.attributes,m))}else if(this._isUniformVar(g)){const i=g,m=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),T=new o(i.name,b,m,_,i.attributes,uw.Uniform,i.access);T.access||(T.access="read"),this.uniforms.push(T)}else if(this._isStorageVar(g)){const i=g,m=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),T=this._isStorageTexture(b),P=new o(i.name,b,m,_,i.attributes,T?uw.StorageTexture:uw.Storage,i.access);P.access||(P.access="read"),this.storage.push(P)}else if(this._isTextureVar(g)){const i=g,m=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),T=this._isStorageTexture(b),P=new o(i.name,b,m,_,i.attributes,T?uw.StorageTexture:uw.Texture,i.access);P.access||(P.access="read"),T?this.storage.push(P):this.textures.push(P)}else if(this._isSamplerVar(g)){const i=g,m=this._getAttributeNum(i.attributes,"group",0),_=this._getAttributeNum(i.attributes,"binding",0),b=this.getTypeInfo(i.type,i.attributes),T=new o(i.name,b,m,_,i.attributes,uw.Sampler,i.access);this.samplers.push(T)}for(const g of i)if(g instanceof Rw){const i=this._getAttribute(g,"vertex"),m=this._getAttribute(g,"fragment"),_=this._getAttribute(g,"compute"),b=i||m||_,T=new mw(g.name,null==b?void 0:b.name,g.attributes);T.attributes=g.attributes,T.startLine=g.startLine,T.endLine=g.endLine,this.functions.push(T),this._functions.get(g.name).info=T,b&&(this._functions.get(g.name).inUse=!0,T.inUse=!0,T.resources=this._findResources(g,!!b),T.inputs=this._getInputs(g.args),T.outputs=this._getOutputs(g.returnType),this.entry[b.name].push(T)),T.arguments=g.args.map((i=>new gw(i.name,this.getTypeInfo(i.type,i.attributes),i.attributes))),T.returnType=g.returnType?this.getTypeInfo(g.returnType,g.attributes):null}for(const i of this._functions.values())i.info&&(i.info.inUse=i.inUse,this._addCalls(i.node,i.info.calls));for(const i of this._functions.values())i.node.search((g=>{var m,_,b;if(g instanceof ET){if(g.value)if(qT(g.value))for(const _ of g.value)for(const g of this.overrides)_===g.name&&(null===(m=i.info)||void 0===m||m.overrides.push(g));else for(const m of this.overrides)g.value===m.name&&(null===(_=i.info)||void 0===_||_.overrides.push(m))}else if(g instanceof AT)for(const m of this.overrides)g.name===m.name&&(null===(b=i.info)||void 0===b||b.overrides.push(m))}));for(const i of this.uniforms)this._markStructsInUse(i.type);for(const i of this.storage)this._markStructsInUse(i.type)}getStructInfo(i){for(const g of this.structs)if(g.name==i)return g;return null}getOverrideInfo(i){for(const g of this.overrides)if(g.name==i)return g;return null}_markStructsInUse(i){if(i)if(i.isStruct){if(i.inUse=!0,i.members)for(const g of i.members)this._markStructsInUse(g.type)}else if(i.isArray)this._markStructsInUse(i.format);else if(i.isTemplate)i.format&&this._markStructsInUse(i.format);else{const g=this._getAlias(i.name);g&&this._markStructsInUse(g)}}_addCalls(i,g){var m;for(const _ of i.calls){const i=null===(m=this._functions.get(_.name))||void 0===m?void 0:m.info;i&&g.add(i)}}findResource(i,g,m){if(m){for(const _ of this.entry.compute)if(_.name===m)for(const m of _.resources)if(m.group==i&&m.binding==g)return m;for(const _ of this.entry.vertex)if(_.name===m)for(const m of _.resources)if(m.group==i&&m.binding==g)return m;for(const _ of this.entry.fragment)if(_.name===m)for(const m of _.resources)if(m.group==i&&m.binding==g)return m}for(const m of this.uniforms)if(m.group==i&&m.binding==g)return m;for(const m of this.storage)if(m.group==i&&m.binding==g)return m;for(const m of this.textures)if(m.group==i&&m.binding==g)return m;for(const m of this.samplers)if(m.group==i&&m.binding==g)return m;return null}_findResource(i){for(const g of this.uniforms)if(g.name==i)return g;for(const g of this.storage)if(g.name==i)return g;for(const g of this.textures)if(g.name==i)return g;for(const g of this.samplers)if(g.name==i)return g;return null}_markStructsFromAST(i){const g=this.getTypeInfo(i,null);this._markStructsInUse(g)}_findResources(i,g){const m=[],_=this,b=[];return i.search((T=>{if(T instanceof Iw)b.push({});else if(T instanceof kw)b.pop();else if(T instanceof Hw){const i=T;g&&null!==i.type&&this._markStructsFromAST(i.type),b.length>0&&(b[b.length-1][i.name]=i)}else if(T instanceof gT){g&&null!==T.type&&this._markStructsFromAST(T.type)}else if(T instanceof zw){const i=T;g&&null!==i.type&&this._markStructsFromAST(i.type),b.length>0&&(b[b.length-1][i.name]=i)}else if(T instanceof AT){if(b.length>0&&b[b.length-1][T.name])return;const i=_._findResource(T.name);i&&m.push(i)}else if(T instanceof mT){const b=_._functions.get(T.name);b&&(g&&(b.inUse=!0),i.calls.add(b.node),null===b.resources&&(b.resources=_._findResources(b.node,g)),m.push(...b.resources))}else if(T instanceof Zw){const b=_._functions.get(T.name);b&&(g&&(b.inUse=!0),i.calls.add(b.node),null===b.resources&&(b.resources=_._findResources(b.node,g)),m.push(...b.resources))}})),[...new Map(m.map((i=>[i.name,i]))).values()]}getBindGroups(){const i=[];function g(g,m){g>=i.length&&(i.length=g+1),void 0===i[g]&&(i[g]=[]),m>=i[g].length&&(i[g].length=m+1)}for(const m of this.uniforms)g(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.storage)g(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.textures)g(m.group,m.binding),i[m.group][m.binding]=m;for(const m of this.samplers)g(m.group,m.binding),i[m.group][m.binding]=m;return i}_getOutputs(i,g=void 0){if(void 0===g&&(g=[]),i instanceof lT)this._getStructOutputs(i,g);else{const m=this._getOutputInfo(i);null!==m&&g.push(m)}return g}_getStructOutputs(i,g){for(const m of i.members)if(m.type instanceof lT)this._getStructOutputs(m.type,g);else{const i=this._getAttribute(m,"location")||this._getAttribute(m,"builtin");if(null!==i){const _=this.getTypeInfo(m.type,m.type.attributes),b=this._parseInt(i.value),T=new pw(m.name,_,i.name,b);g.push(T)}}}_getOutputInfo(i){const g=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==g){const m=this.getTypeInfo(i,i.attributes),_=this._parseInt(g.value);return new pw("",m,g.name,_)}return null}_getInputs(i,g=void 0){void 0===g&&(g=[]);for(const m of i)if(m.type instanceof lT)this._getStructInputs(m.type,g);else{const i=this._getInputInfo(m);null!==i&&g.push(i)}return g}_getStructInputs(i,g){for(const m of i.members)if(m.type instanceof lT)this._getStructInputs(m.type,g);else{const i=this._getInputInfo(m);null!==i&&g.push(i)}}_getInputInfo(i){const g=this._getAttribute(i,"location")||this._getAttribute(i,"builtin");if(null!==g){const m=this._getAttribute(i,"interpolation"),_=this.getTypeInfo(i.type,i.attributes),b=this._parseInt(g.value),T=new dw(i.name,_,g.name,b);return null!==m&&(T.interpolation=this._parseString(m.value)),T}return null}_parseString(i){return i instanceof Array&&(i=i[0]),i}_parseInt(i){i instanceof Array&&(i=i[0]);const g=parseInt(i);return isNaN(g)?i:g}_getAlias(i){for(const g of this.aliases)if(g.name==i)return g.type;return null}_getAliasInfo(i){return new fw(i.name,this.getTypeInfo(i.type,null))}getTypeInfoByName(i){for(const g of this.structs)if(g.name==i)return g;for(const g of this.aliases)if(g.name==i)return g.type;return null}getTypeInfo(i,g=null){if(this._types.has(i))return this._types.get(i);if(i instanceof cT){const m=i.type?this.getTypeInfo(i.type,i.attributes):null,_=new r(i.name,m,g);return this._types.set(i,_),this._updateTypeInfo(_),_}if(i instanceof uT){const m=i,_=m.format?this.getTypeInfo(m.format,m.attributes):null,b=new s(m.name,g);return b.format=_,b.count=m.count,this._types.set(i,b),this._updateTypeInfo(b),b}if(i instanceof lT){const m=i,_=new n(m.name,g);_.startLine=m.startLine,_.endLine=m.endLine;for(const i of m.members){const g=this.getTypeInfo(i.type,i.attributes);_.members.push(new t(i.name,g,i.attributes))}return this._types.set(i,_),this._updateTypeInfo(_),_}if(i instanceof fT){const m=i,_=m.format?m.format instanceof sT?this.getTypeInfo(m.format,null):new cw(m.format,null):null,b=new a(m.name,_,g,m.access);return this._types.set(i,b),this._updateTypeInfo(b),b}if(i instanceof hT){const m=i,_=m.format?this.getTypeInfo(m.format,null):null,b=new a(m.name,_,g,m.access);return this._types.set(i,b),this._updateTypeInfo(b),b}const m=new cw(i.name,g);return this._types.set(i,m),this._updateTypeInfo(m),m}_updateTypeInfo(i){var g,m,_;const b=this._getTypeSize(i);if(i.size=null!==(g=null==b?void 0:b.size)&&void 0!==g?g:0,i instanceof s&&i.format){const g=this._getTypeSize(i.format);i.stride=Math.max(null!==(m=null==g?void 0:g.size)&&void 0!==m?m:0,null!==(_=null==g?void 0:g.align)&&void 0!==_?_:0),this._updateTypeInfo(i.format)}i instanceof r&&this._updateTypeInfo(i.format),i instanceof n&&this._updateStructInfo(i)}_updateStructInfo(i){let g=0,m=0,_=0,b=0;for(let T=0,P=i.members.length;T<P;++T){const P=i.members[T],I=this._getTypeSize(P);if(!I)continue;this._getAlias(P.type.name);const H=I.align,W=I.size;g=this._roundUp(H,g+m),m=W,_=g,b=Math.max(b,H),P.offset=g,P.size=W,this._updateTypeInfo(P.type)}i.size=this._roundUp(b,_+m),i.align=b}_getTypeSize(i){var g,m;if(null==i)return null;const _=this._getAttributeNum(i.attributes,"size",0),b=this._getAttributeNum(i.attributes,"align",0);if(i instanceof t&&(i=i.type),i instanceof cw){const g=this._getAlias(i.name);null!==g&&(i=g)}{const m=rt._typeInfo[i.name];if(void 0!==m){const T="f16"===(null===(g=i.format)||void 0===g?void 0:g.name)?2:1;return new iS(Math.max(b,m.align/T),Math.max(_,m.size/T))}}{const g=rt._typeInfo[i.name.substring(0,i.name.length-1)];if(g){const m="h"===i.name[i.name.length-1]?2:1;return new iS(Math.max(b,g.align/m),Math.max(_,g.size/m))}}if(i instanceof s){let g=i,T=8,P=8;const I=this._getTypeSize(g.format);return null!==I&&(P=I.size,T=I.align),P=g.count*this._getAttributeNum(null!==(m=null==i?void 0:i.attributes)&&void 0!==m?m:null,"stride",this._roundUp(T,P)),_&&(P=_),new iS(Math.max(b,T),Math.max(_,P))}if(i instanceof n){let g=0,m=0,T=0,P=0,I=0;for(const m of i.members){const i=this._getTypeSize(m.type);null!==i&&(g=Math.max(i.align,g),T=this._roundUp(i.align,T+P),P=i.size,I=T)}return m=this._roundUp(g,I+P),new iS(Math.max(b,g),Math.max(_,m))}return null}_isUniformVar(i){return i instanceof Hw&&"uniform"==i.storage}_isStorageVar(i){return i instanceof Hw&&"storage"==i.storage}_isTextureVar(i){return i instanceof Hw&&null!==i.type&&-1!=rt._textureTypes.indexOf(i.type.name)}_isSamplerVar(i){return i instanceof Hw&&null!==i.type&&-1!=rt._samplerTypes.indexOf(i.type.name)}_getAttribute(i,g){if(!i||!i.attributes)return null;const m=i.attributes;for(let i of m)if(i.name==g)return i;return null}_getAttributeNum(i,g,m){if(null===i)return m;for(let _ of i)if(_.name==g){let i=null!==_&&null!==_.value?_.value:m;return i instanceof Array&&(i=i[0]),"number"==typeof i?i:"string"==typeof i?parseInt(i):m}return m}_roundUp(i,g){return Math.ceil(g/i)*i}};oS._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},oS._textureTypes=GT.any_texture_type.map((i=>i.name)),oS._samplerTypes=GT.sampler_type.map((i=>i.name));let sS=0,aS=class it{constructor(i,g,m){this.id=sS++,this.name=i,this.value=g,this.node=m}clone(){return new it(this.name,this.value,this.node)}},lS=class ot{constructor(i){this.id=sS++,this.name=i.name,this.node=i}clone(){return new ot(this.node)}},hS=class lt{constructor(i){this.parent=null,this.variables=new Map,this.functions=new Map,this.currentFunctionName="",this.id=sS++,i&&(this.parent=i,this.currentFunctionName=i.currentFunctionName)}getVariable(i){var g;return this.variables.has(i)?null!==(g=this.variables.get(i))&&void 0!==g?g:null:this.parent?this.parent.getVariable(i):null}getFunction(i){var g;return this.functions.has(i)?null!==(g=this.functions.get(i))&&void 0!==g?g:null:this.parent?this.parent.getFunction(i):null}createVariable(i,g,m){this.variables.set(i,new aS(i,g,null!=m?m:null))}setVariable(i,g,m){const _=this.getVariable(i);null!==_?_.value=g:this.createVariable(i,g,m)}getVariableValue(i){var g;const m=this.getVariable(i);return null!==(g=null==m?void 0:m.value)&&void 0!==g?g:null}clone(){return new lt(this)}},cS=class ct{evalExpression(i,g){return null}getTypeInfo(i){return null}getVariableName(i,g){return""}},uS=class ut{constructor(i){this.exec=i}getTypeInfo(i){return this.exec.getTypeInfo(i)}All(i,g){const m=this.exec.evalExpression(i.args[0],g);let _=!0;if(m instanceof HT)return m.data.forEach((i=>{i||(_=!1)})),new FT(_?1:0,this.getTypeInfo("bool"));throw new Error(`All() expects a vector argument. Line ${i.line}`)}Any(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT){const i=m.data.some((i=>i));return new FT(i?1:0,this.getTypeInfo("bool"))}throw new Error(`Any() expects a vector argument. Line ${i.line}`)}Select(i,g){const m=this.exec.evalExpression(i.args[2],g);if(!(m instanceof FT))throw new Error(`Select() expects a bool condition. Line ${i.line}`);return this.exec.evalExpression(m.value?i.args[1]:i.args[0],g)}ArrayLength(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.evalExpression(m,g);if(_ instanceof zT&&0===_.typeInfo.size){return new FT(_.buffer.byteLength/_.typeInfo.stride,this.getTypeInfo("u32"))}return new FT(_.typeInfo.size,this.getTypeInfo("u32"))}Abs(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.abs(i))),m.typeInfo);const _=m;return new FT(Math.abs(_.value),_.typeInfo)}Acos(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.acos(i))),m.typeInfo);return new FT(Math.acos(m.value),m.typeInfo)}Acosh(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.acosh(i))),m.typeInfo);return new FT(Math.acosh(m.value),m.typeInfo)}Asin(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.asin(i))),m.typeInfo);return new FT(Math.asin(m.value),m.typeInfo)}Asinh(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.asinh(i))),m.typeInfo);return new FT(Math.asinh(m.value),m.typeInfo)}Atan(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.atan(i))),m.typeInfo);return new FT(Math.atan(m.value),m.typeInfo)}Atanh(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.atanh(i))),m.typeInfo);return new FT(Math.atanh(m.value),m.typeInfo)}Atan2(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT)return new HT(m.data.map(((i,g)=>Math.atan2(i,_.data[g]))),m.typeInfo);return new FT(Math.atan2(m.value,_.value),m.typeInfo)}Ceil(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.ceil(i))),m.typeInfo);return new FT(Math.ceil(m.value),m.typeInfo)}_clamp(i,g,m){return Math.min(Math.max(i,g),m)}Clamp(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g);if(m instanceof HT&&_ instanceof HT&&b instanceof HT)return new HT(m.data.map(((i,g)=>this._clamp(i,_.data[g],b.data[g]))),m.typeInfo);return new FT(this._clamp(m.value,_.value,b.value),m.typeInfo)}Cos(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.cos(i))),m.typeInfo);return new FT(Math.cos(m.value),m.typeInfo)}Cosh(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.cosh(i))),m.typeInfo);return new FT(Math.cos(m.value),m.typeInfo)}CountLeadingZeros(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.clz32(i))),m.typeInfo);return new FT(Math.clz32(m.value),m.typeInfo)}_countOneBits(i){let g=0;for(;0!==i;)1&i&&g++,i>>=1;return g}CountOneBits(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>this._countOneBits(i))),m.typeInfo);return new FT(this._countOneBits(m.value),m.typeInfo)}_countTrailingZeros(i){if(0===i)return 32;let g=0;for(;!(1&i);)i>>=1,g++;return g}CountTrailingZeros(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>this._countTrailingZeros(i))),m.typeInfo);return new FT(this._countTrailingZeros(m.value),m.typeInfo)}Cross(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT){if(3!==m.data.length||3!==_.data.length)return console.error(`Cross() expects 3D vectors. Line ${i.line}`),null;const g=m.data,b=_.data;return new HT([g[1]*b[2]-b[1]*g[2],g[2]*b[0]-b[2]*g[0],g[0]*b[1]-b[0]*g[1]],m.typeInfo)}return console.error(`Cross() expects vector arguments. Line ${i.line}`),null}Degrees(i,g){const m=this.exec.evalExpression(i.args[0],g),_=180/Math.PI;return m instanceof HT?new HT(m.data.map((i=>i*_)),m.typeInfo):new FT(m.value*_,this.getTypeInfo("f32"))}Determinant(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof BT){const i=m.data,g=m.typeInfo.getTypeName(),_=g.endsWith("h")?this.getTypeInfo("f16"):this.getTypeInfo("f32");if("mat2x2"===g||"mat2x2f"===g||"mat2x2h"===g)return new FT(i[0]*i[3]-i[1]*i[2],_);if("mat2x3"===g||"mat2x3f"===g||"mat2x3h"===g)return new FT(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),_);if("mat2x4"===g||"mat2x4f"===g||"mat2x4h"===g)console.error(`TODO: Determinant for ${g}`);else if("mat3x2"===g||"mat3x2f"===g||"mat3x2h"===g)console.error(`TODO: Determinant for ${g}`);else{if("mat3x3"===g||"mat3x3f"===g||"mat3x3h"===g)return new FT(i[0]*(i[4]*i[8]-i[5]*i[7])-i[1]*(i[3]*i[8]-i[5]*i[6])+i[2]*(i[3]*i[7]-i[4]*i[6]),_);"mat3x4"===g||"mat3x4f"===g||"mat3x4h"===g||"mat4x2"===g||"mat4x2f"===g||"mat4x2h"===g||"mat4x3"===g||"mat4x3f"===g||"mat4x3h"===g?console.error(`TODO: Determinant for ${g}`):"mat4x4"!==g&&"mat4x4f"!==g&&"mat4x4h"!==g||console.error(`TODO: Determinant for ${g}`)}}return console.error(`Determinant expects a matrix argument. Line ${i.line}`),null}Distance(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT){let i=0;for(let g=0;g<m.data.length;++g)i+=(m.data[g]-_.data[g])*(m.data[g]-_.data[g]);return new FT(Math.sqrt(i),this.getTypeInfo("f32"))}return new FT(Math.abs(m.value-_.value),m.typeInfo)}_dot(i,g){let m=0;for(let _=0;_<i.length;++_)m+=g[_]*i[_];return m}Dot(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);return m instanceof HT&&_ instanceof HT?new FT(this._dot(m.data,_.data),this.getTypeInfo("f32")):(console.error(`Dot() expects vector arguments. Line ${i.line}`),null)}Dot4U8Packed(i,g){return console.error(`TODO: dot4U8Packed. Line ${i.line}`),null}Dot4I8Packed(i,g){return console.error(`TODO: dot4I8Packed. Line ${i.line}`),null}Exp(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.exp(i))),m.typeInfo);return new FT(Math.exp(m.value),m.typeInfo)}Exp2(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.pow(2,i))),m.typeInfo);return new FT(Math.pow(2,m.value),m.typeInfo)}ExtractBits(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g);if("u32"!==_.typeInfo.name&&"x32"!==_.typeInfo.name)return console.error(`ExtractBits() expects an i32 offset argument. Line ${i.line}`),null;if("u32"!==b.typeInfo.name&&"x32"!==b.typeInfo.name)return console.error(`ExtractBits() expects an i32 count argument. Line ${i.line}`),null;const T=_.value,P=b.value;if(m instanceof HT)return new HT(m.data.map((i=>i>>T&(1<<P)-1)),m.typeInfo);if("i32"!==m.typeInfo.name&&"x32"!==m.typeInfo.name)return console.error(`ExtractBits() expects an i32 argument. Line ${i.line}`),null;return new FT(m.value>>T&(1<<P)-1,this.getTypeInfo("i32"))}FaceForward(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g);if(m instanceof HT&&_ instanceof HT&&b instanceof HT){const i=this._dot(_.data,b.data);return new HT(i<0?Array.from(m.data):m.data.map((i=>-i)),m.typeInfo)}return console.error(`FaceForward() expects vector arguments. Line ${i.line}`),null}_firstLeadingBit(i){return 0===i?-1:31-Math.clz32(i)}FirstLeadingBit(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>this._firstLeadingBit(i))),m.typeInfo);return new FT(this._firstLeadingBit(m.value),m.typeInfo)}_firstTrailingBit(i){return 0===i?-1:Math.log2(i&-i)}FirstTrailingBit(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>this._firstTrailingBit(i))),m.typeInfo);return new FT(this._firstTrailingBit(m.value),m.typeInfo)}Floor(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.floor(i))),m.typeInfo);return new FT(Math.floor(m.value),m.typeInfo)}Fma(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g);if(m instanceof HT&&_ instanceof HT&&b instanceof HT)return m.data.length!==_.data.length||m.data.length!==b.data.length?(console.error(`Fma() expects vectors of the same length. Line ${i.line}`),null):new HT(m.data.map(((i,g)=>i*_.data[g]+b.data[g])),m.typeInfo);return new FT(m.value*_.value+b.value,m.typeInfo)}Fract(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>i-Math.floor(i))),m.typeInfo);return new FT(m.value-Math.floor(m.value),m.typeInfo)}Frexp(i,g){return console.error(`TODO: frexp. Line ${i.line}`),null}InsertBits(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g),T=this.exec.evalExpression(i.args[3],g);if("u32"!==b.typeInfo.name&&"x32"!==b.typeInfo.name)return console.error(`InsertBits() expects an i32 offset argument. Line ${i.line}`),null;const P=b.value,I=(1<<T.value)-1<<P,H=~I;if(m instanceof HT&&_ instanceof HT)return new HT(m.data.map(((i,g)=>i&H|_.data[g]<<P&I)),m.typeInfo);return new FT(m.value&H|_.value<<P&I,m.typeInfo)}InverseSqrt(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>1/Math.sqrt(i))),m.typeInfo);return new FT(1/Math.sqrt(m.value),m.typeInfo)}Ldexp(i,g){return console.error(`TODO: ldexp. Line ${i.line}`),null}Length(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT){let i=0;return m.data.forEach((g=>{i+=g*g})),new FT(Math.sqrt(i),this.getTypeInfo("f32"))}return new FT(Math.abs(m.value),m.typeInfo)}Log(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.log(i))),m.typeInfo);return new FT(Math.log(m.value),m.typeInfo)}Log2(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.log2(i))),m.typeInfo);return new FT(Math.log2(m.value),m.typeInfo)}Max(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT)return new HT(m.data.map(((i,g)=>Math.max(i,_.data[g]))),m.typeInfo);return new FT(Math.max(m.value,_.value),m.typeInfo)}Min(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT)return new HT(m.data.map(((i,g)=>Math.min(i,_.data[g]))),m.typeInfo);return new FT(Math.min(m.value,_.value),m.typeInfo)}Mix(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g);if(m instanceof HT&&_ instanceof HT&&b instanceof HT)return new HT(m.data.map(((i,g)=>m.data[g]*(1-b.data[g])+_.data[g]*b.data[g])),m.typeInfo);return new FT(m.value*(1-b.value)+_.value*b.value,m.typeInfo)}Modf(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT)return new HT(m.data.map(((i,g)=>i%_.data[g])),m.typeInfo);return new FT(m.value%_.value,m.typeInfo)}Normalize(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT){const _=this.Length(i,g).value;return new HT(m.data.map((i=>i/_)),m.typeInfo)}return console.error(`Normalize() expects a vector argument. Line ${i.line}`),null}Pow(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT)return new HT(m.data.map(((i,g)=>Math.pow(i,_.data[g]))),m.typeInfo);return new FT(Math.pow(m.value,_.value),m.typeInfo)}QuantizeToF16(i,g){const m=this.exec.evalExpression(i.args[0],g);return m instanceof HT?new HT(m.data.map((i=>i)),m.typeInfo):new FT(m.value,m.typeInfo)}Radians(i,g){const m=this.exec.evalExpression(i.args[0],g);return m instanceof HT?new HT(m.data.map((i=>i*Math.PI/180)),m.typeInfo):new FT(m.value*Math.PI/180,this.getTypeInfo("f32"))}Reflect(i,g){let m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(m instanceof HT&&_ instanceof HT){const i=this._dot(m.data,_.data);return new HT(m.data.map(((g,m)=>g-2*i*_.data[m])),m.typeInfo)}return console.error(`Reflect() expects vector arguments. Line ${i.line}`),null}Refract(i,g){let m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g);if(m instanceof HT&&_ instanceof HT&&b instanceof FT){const i=this._dot(_.data,m.data);return new HT(m.data.map(((g,m)=>{const T=1-b.value*b.value*(1-i*i);if(T<0)return 0;const P=Math.sqrt(T);return b.value*g-(b.value*i+P)*_.data[m]})),m.typeInfo)}return console.error(`Refract() expects vector arguments and a scalar argument. Line ${i.line}`),null}ReverseBits(i,g){return console.error(`TODO: reverseBits. Line ${i.line}`),null}Round(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.round(i))),m.typeInfo);return new FT(Math.round(m.value),m.typeInfo)}Saturate(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.min(Math.max(i,0),1))),m.typeInfo);return new FT(Math.min(Math.max(m.value,0),1),m.typeInfo)}Sign(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.sign(i))),m.typeInfo);return new FT(Math.sign(m.value),m.typeInfo)}Sin(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.sin(i))),m.typeInfo);return new FT(Math.sin(m.value),m.typeInfo)}Sinh(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.sinh(i))),m.typeInfo);return new FT(Math.sinh(m.value),m.typeInfo)}_smoothstep(i,g,m){const _=Math.min(Math.max((m-i)/(g-i),0),1);return _*_*(3-2*_)}SmoothStep(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g),b=this.exec.evalExpression(i.args[2],g);if(b instanceof HT&&m instanceof HT&&_ instanceof HT)return new HT(b.data.map(((i,g)=>this._smoothstep(m.data[g],_.data[g],i))),b.typeInfo);return new FT(this._smoothstep(m.value,_.value,b.value),b.typeInfo)}Sqrt(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.sqrt(i))),m.typeInfo);return new FT(Math.sqrt(m.value),m.typeInfo)}Step(i,g){const m=this.exec.evalExpression(i.args[0],g),_=this.exec.evalExpression(i.args[1],g);if(_ instanceof HT&&m instanceof HT)return new HT(_.data.map(((i,g)=>i<m.data[g]?0:1)),_.typeInfo);return new FT(_.value<m.value?0:1,m.typeInfo)}Tan(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.tan(i))),m.typeInfo);return new FT(Math.tan(m.value),m.typeInfo)}Tanh(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.tanh(i))),m.typeInfo);return new FT(Math.tanh(m.value),m.typeInfo)}_getTransposeType(i){const g=i.getTypeName();return"mat2x2f"===g||"mat2x2h"===g?i:"mat2x3f"===g?this.getTypeInfo("mat3x2f"):"mat2x3h"===g?this.getTypeInfo("mat3x2h"):"mat2x4f"===g?this.getTypeInfo("mat4x2f"):"mat2x4h"===g?this.getTypeInfo("mat4x2h"):"mat3x2f"===g?this.getTypeInfo("mat2x3f"):"mat3x2h"===g?this.getTypeInfo("mat2x3h"):"mat3x3f"===g||"mat3x3h"===g?i:"mat3x4f"===g?this.getTypeInfo("mat4x3f"):"mat3x4h"===g?this.getTypeInfo("mat4x3h"):"mat4x2f"===g?this.getTypeInfo("mat2x4f"):"mat4x2h"===g?this.getTypeInfo("mat2x4h"):"mat4x3f"===g?this.getTypeInfo("mat3x4f"):"mat4x3h"===g?this.getTypeInfo("mat3x4h"):("mat4x4f"===g||"mat4x4h"===g||console.error(`Invalid matrix type ${g}`),i)}Transpose(i,g){const m=this.exec.evalExpression(i.args[0],g);if(!(m instanceof BT))return console.error(`Transpose() expects a matrix argument. Line ${i.line}`),null;const _=this._getTransposeType(m.typeInfo);if("mat2x2"===m.typeInfo.name||"mat2x2f"===m.typeInfo.name||"mat2x2h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[2],i[1],i[3]],_)}if("mat2x3"===m.typeInfo.name||"mat2x3f"===m.typeInfo.name||"mat2x3h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[3],i[6],i[1],i[4],i[7]],_)}if("mat2x4"===m.typeInfo.name||"mat2x4f"===m.typeInfo.name||"mat2x4h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13]],_)}if("mat3x2"===m.typeInfo.name||"mat3x2f"===m.typeInfo.name||"mat3x2h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[3],i[1],i[4],i[2],i[5]],_)}if("mat3x3"===m.typeInfo.name||"mat3x3f"===m.typeInfo.name||"mat3x3h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[3],i[6],i[1],i[4],i[7],i[2],i[5],i[8]],_)}if("mat3x4"===m.typeInfo.name||"mat3x4f"===m.typeInfo.name||"mat3x4h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14]],_)}if("mat4x2"===m.typeInfo.name||"mat4x2f"===m.typeInfo.name||"mat4x2h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[4],i[1],i[5],i[2],i[6]],_)}if("mat4x3"===m.typeInfo.name||"mat4x3f"===m.typeInfo.name||"mat4x3h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[4],i[8],i[1],i[5],i[9],i[2],i[6],i[10]],_)}if("mat4x4"===m.typeInfo.name||"mat4x4f"===m.typeInfo.name||"mat4x4h"===m.typeInfo.name){const i=m.data;return new BT([i[0],i[4],i[8],i[12],i[1],i[5],i[9],i[13],i[2],i[6],i[10],i[14],i[3],i[7],i[11],i[15]],_)}return console.error(`Invalid matrix type ${m.typeInfo.name}`),null}Trunc(i,g){const m=this.exec.evalExpression(i.args[0],g);if(m instanceof HT)return new HT(m.data.map((i=>Math.trunc(i))),m.typeInfo);return new FT(Math.trunc(m.value),m.typeInfo)}Dpdx(i,g){return console.error(`TODO: dpdx. Line ${i.line}`),null}DpdxCoarse(i,g){return console.error(`TODO: dpdxCoarse. Line ${i.line}`),null}DpdxFine(i,g){return console.error("TODO: dpdxFine"),null}Dpdy(i,g){return console.error("TODO: dpdy"),null}DpdyCoarse(i,g){return console.error("TODO: dpdyCoarse"),null}DpdyFine(i,g){return console.error("TODO: dpdyFine"),null}Fwidth(i,g){return console.error("TODO: fwidth"),null}FwidthCoarse(i,g){return console.error("TODO: fwidthCoarse"),null}FwidthFine(i,g){return console.error("TODO: fwidthFine"),null}TextureDimensions(i,g){const m=i.args[0],_=i.args.length>1?this.exec.evalExpression(i.args[1],g).value:0;if(m instanceof AT){const b=m.name,T=g.getVariableValue(b);if(T instanceof VT){if(_<0||_>=T.mipLevelCount)return console.error(`Invalid mip level for textureDimensions. Line ${i.line}`),null;const g=T.getMipLevelSize(_),m=T.dimension;return"1d"===m?new FT(g[0],this.getTypeInfo("u32")):"3d"===m?new HT(g,this.getTypeInfo("vec3u")):"2d"===m?new HT(g.slice(0,2),this.getTypeInfo("vec2u")):(console.error(`Invalid texture dimension ${m} not found. Line ${i.line}`),null)}return console.error(`Texture ${b} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureDimensions. Line ${i.line}`),null}TextureGather(i,g){return console.error("TODO: textureGather"),null}TextureGatherCompare(i,g){return console.error("TODO: textureGatherCompare"),null}TextureLoad(i,g){const m=i.args[0],_=this.exec.evalExpression(i.args[1],g),b=i.args.length>2?this.exec.evalExpression(i.args[2],g).value:0;if(!(_ instanceof HT)||2!==_.data.length)return console.error(`Invalid UV argument for textureLoad. Line ${i.line}`),null;if(m instanceof AT){const T=m.name,P=g.getVariableValue(T);if(P instanceof VT){const g=Math.floor(_.data[0]),m=Math.floor(_.data[1]);if(g<0||g>=P.width||m<0||m>=P.height)return console.error(`Texture ${T} out of bounds. Line ${i.line}`),null;const I=P.getPixel(g,m,0,b);return null===I?(console.error(`Invalid texture format for textureLoad. Line ${i.line}`),null):new HT(I,this.getTypeInfo("vec4f"))}return console.error(`Texture ${T} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureLoad. Line ${i.line}`),null}TextureNumLayers(i,g){const m=i.args[0];if(m instanceof AT){const _=m.name,b=g.getVariableValue(_);return b instanceof VT?new FT(b.depthOrArrayLayers,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLayers. Line ${i.line}`),null}TextureNumLevels(i,g){const m=i.args[0];if(m instanceof AT){const _=m.name,b=g.getVariableValue(_);return b instanceof VT?new FT(b.mipLevelCount,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumLevels. Line ${i.line}`),null}TextureNumSamples(i,g){const m=i.args[0];if(m instanceof AT){const _=m.name,b=g.getVariableValue(_);return b instanceof VT?new FT(b.sampleCount,this.getTypeInfo("u32")):(console.error(`Texture ${_} not found. Line ${i.line}`),null)}return console.error(`Invalid texture argument for textureNumSamples. Line ${i.line}`),null}TextureSample(i,g){return console.error("TODO: textureSample"),null}TextureSampleBias(i,g){return console.error("TODO: textureSampleBias"),null}TextureSampleCompare(i,g){return console.error("TODO: textureSampleCompare"),null}TextureSampleCompareLevel(i,g){return console.error("TODO: textureSampleCompareLevel"),null}TextureSampleGrad(i,g){return console.error("TODO: textureSampleGrad"),null}TextureSampleLevel(i,g){return console.error("TODO: textureSampleLevel"),null}TextureSampleBaseClampToEdge(i,g){return console.error("TODO: textureSampleBaseClampToEdge"),null}TextureStore(i,g){const m=i.args[0],_=this.exec.evalExpression(i.args[1],g),b=4===i.args.length?this.exec.evalExpression(i.args[2],g).value:0,T=4===i.args.length?this.exec.evalExpression(i.args[3],g).data:this.exec.evalExpression(i.args[2],g).data;if(4!==T.length)return console.error(`Invalid value argument for textureStore. Line ${i.line}`),null;if(!(_ instanceof HT)||2!==_.data.length)return console.error(`Invalid UV argument for textureStore. Line ${i.line}`),null;if(m instanceof AT){const P=m.name,I=g.getVariableValue(P);if(I instanceof VT){const g=I.getMipLevelSize(0),m=Math.floor(_.data[0]),H=Math.floor(_.data[1]);return m<0||m>=g[0]||H<0||H>=g[1]?(console.error(`Texture ${P} out of bounds. Line ${i.line}`),null):(I.setPixel(m,H,0,b,Array.from(T)),null)}return console.error(`Texture ${P} not found. Line ${i.line}`),null}return console.error(`Invalid texture argument for textureStore. Line ${i.line}`),null}AtomicLoad(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g);return g.getVariable(_).value.getSubData(this.exec,m.postfix,g)}AtomicStore(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g);return P instanceof FT&&T instanceof FT&&(P.value=T.value),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),null}AtomicAdd(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value+=T.value),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicSub(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value-=T.value),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicMax(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value=Math.max(P.value,T.value)),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicMin(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value=Math.min(P.value,T.value)),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicAnd(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value=P.value&T.value),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicOr(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value=P.value|T.value),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicXor(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value=P.value^T.value),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicExchange(i,g){let m=i.args[0];m instanceof wT&&(m=m.right);const _=this.exec.getVariableName(m,g),b=g.getVariable(_);const T=this.exec.evalExpression(i.args[1],g),P=b.value.getSubData(this.exec,m.postfix,g),I=new FT(P.value,P.typeInfo);return P instanceof FT&&T instanceof FT&&(P.value=T.value),b.value instanceof zT&&b.value.setDataValue(this.exec,P,m.postfix,g),I}AtomicCompareExchangeWeak(i,g){return console.error("TODO: atomicCompareExchangeWeak"),null}Pack4x8snorm(i,g){return console.error("TODO: pack4x8snorm"),null}Pack4x8unorm(i,g){return console.error("TODO: pack4x8unorm"),null}Pack4xI8(i,g){return console.error("TODO: pack4xI8"),null}Pack4xU8(i,g){return console.error("TODO: pack4xU8"),null}Pack4x8Clamp(i,g){return console.error("TODO: pack4x8Clamp"),null}Pack4xU8Clamp(i,g){return console.error("TODO: pack4xU8Clamp"),null}Pack2x16snorm(i,g){return console.error("TODO: pack2x16snorm"),null}Pack2x16unorm(i,g){return console.error("TODO: pack2x16unorm"),null}Pack2x16float(i,g){return console.error("TODO: pack2x16float"),null}Unpack4x8snorm(i,g){return console.error("TODO: unpack4x8snorm"),null}Unpack4x8unorm(i,g){return console.error("TODO: unpack4x8unorm"),null}Unpack4xI8(i,g){return console.error("TODO: unpack4xI8"),null}Unpack4xU8(i,g){return console.error("TODO: unpack4xU8"),null}Unpack2x16snorm(i,g){return console.error("TODO: unpack2x16snorm"),null}Unpack2x16unorm(i,g){return console.error("TODO: unpack2x16unorm"),null}Unpack2x16float(i,g){return console.error("TODO: unpack2x16float"),null}StorageBarrier(i,g){return null}TextureBarrier(i,g){return null}WorkgroupBarrier(i,g){return null}WorkgroupUniformLoad(i,g){return null}SubgroupAdd(i,g){return console.error("TODO: subgroupAdd"),null}SubgroupExclusiveAdd(i,g){return console.error("TODO: subgroupExclusiveAdd"),null}SubgroupInclusiveAdd(i,g){return console.error("TODO: subgroupInclusiveAdd"),null}SubgroupAll(i,g){return console.error("TODO: subgroupAll"),null}SubgroupAnd(i,g){return console.error("TODO: subgroupAnd"),null}SubgroupAny(i,g){return console.error("TODO: subgroupAny"),null}SubgroupBallot(i,g){return console.error("TODO: subgroupBallot"),null}SubgroupBroadcast(i,g){return console.error("TODO: subgroupBroadcast"),null}SubgroupBroadcastFirst(i,g){return console.error("TODO: subgroupBroadcastFirst"),null}SubgroupElect(i,g){return console.error("TODO: subgroupElect"),null}SubgroupMax(i,g){return console.error("TODO: subgroupMax"),null}SubgroupMin(i,g){return console.error("TODO: subgroupMin"),null}SubgroupMul(i,g){return console.error("TODO: subgroupMul"),null}SubgroupExclusiveMul(i,g){return console.error("TODO: subgroupExclusiveMul"),null}SubgroupInclusiveMul(i,g){return console.error("TODO: subgroupInclusiveMul"),null}SubgroupOr(i,g){return console.error("TODO: subgroupOr"),null}SubgroupShuffle(i,g){return console.error("TODO: subgroupShuffle"),null}SubgroupShuffleDown(i,g){return console.error("TODO: subgroupShuffleDown"),null}SubgroupShuffleUp(i,g){return console.error("TODO: subgroupShuffleUp"),null}SubgroupShuffleXor(i,g){return console.error("TODO: subgroupShuffleXor"),null}SubgroupXor(i,g){return console.error("TODO: subgroupXor"),null}QuadBroadcast(i,g){return console.error("TODO: quadBroadcast"),null}QuadSwapDiagonal(i,g){return console.error("TODO: quadSwapDiagonal"),null}QuadSwapX(i,g){return console.error("TODO: quadSwapX"),null}QuadSwapY(i,g){return console.error("TODO: quadSwapY"),null}};const fS={vec2:2,vec2f:2,vec2i:2,vec2u:2,vec2b:2,vec2h:2,vec3:3,vec3f:3,vec3i:3,vec3u:3,vec3b:3,vec3h:3,vec4:4,vec4f:4,vec4i:4,vec4u:4,vec4b:4,vec4h:4},dS={mat2x2:[2,2,4],mat2x2f:[2,2,4],mat2x2h:[2,2,4],mat2x3:[2,3,6],mat2x3f:[2,3,6],mat2x3h:[2,3,6],mat2x4:[2,4,8],mat2x4f:[2,4,8],mat2x4h:[2,4,8],mat3x2:[3,2,6],mat3x2f:[3,2,6],mat3x2h:[3,2,6],mat3x3:[3,3,9],mat3x3f:[3,3,9],mat3x3h:[3,3,9],mat3x4:[3,4,12],mat3x4f:[3,4,12],mat3x4h:[3,4,12],mat4x2:[4,2,8],mat4x2f:[4,2,8],mat4x2h:[4,2,8],mat4x3:[4,3,12],mat4x3f:[4,3,12],mat4x3h:[4,3,12],mat4x4:[4,4,16],mat4x4f:[4,4,16],mat4x4h:[4,4,16]};let pS=class pt extends cS{constructor(i,g){var m;super(),this.ast=null!=i?i:[],this.reflection=new oS,this.reflection.updateAST(this.ast),this.context=null!==(m=null==g?void 0:g.clone())&&void 0!==m?m:new hS,this.builtins=new uS(this),this.typeInfo={bool:this.getTypeInfo(sT.bool),i32:this.getTypeInfo(sT.i32),u32:this.getTypeInfo(sT.u32),f32:this.getTypeInfo(sT.f32),f16:this.getTypeInfo(sT.f16),vec2f:this.getTypeInfo(hT.vec2f),vec2u:this.getTypeInfo(hT.vec2u),vec2i:this.getTypeInfo(hT.vec2i),vec2h:this.getTypeInfo(hT.vec2h),vec3f:this.getTypeInfo(hT.vec3f),vec3u:this.getTypeInfo(hT.vec3u),vec3i:this.getTypeInfo(hT.vec3i),vec3h:this.getTypeInfo(hT.vec3h),vec4f:this.getTypeInfo(hT.vec4f),vec4u:this.getTypeInfo(hT.vec4u),vec4i:this.getTypeInfo(hT.vec4i),vec4h:this.getTypeInfo(hT.vec4h),mat2x2f:this.getTypeInfo(hT.mat2x2f),mat2x3f:this.getTypeInfo(hT.mat2x3f),mat2x4f:this.getTypeInfo(hT.mat2x4f),mat3x2f:this.getTypeInfo(hT.mat3x2f),mat3x3f:this.getTypeInfo(hT.mat3x3f),mat3x4f:this.getTypeInfo(hT.mat3x4f),mat4x2f:this.getTypeInfo(hT.mat4x2f),mat4x3f:this.getTypeInfo(hT.mat4x3f),mat4x4f:this.getTypeInfo(hT.mat4x4f)}}getVariableValue(i){var g,m;const _=null!==(m=null===(g=this.context.getVariable(i))||void 0===g?void 0:g.value)&&void 0!==m?m:null;if(null===_)return null;if(_ instanceof FT)return _.value;if(_ instanceof HT)return Array.from(_.data);if(_ instanceof BT)return Array.from(_.data);if(_ instanceof zT&&_.typeInfo instanceof s){if("u32"===_.typeInfo.format.name)return Array.from(new Uint32Array(_.buffer,_.offset,_.typeInfo.count));if("i32"===_.typeInfo.format.name)return Array.from(new Int32Array(_.buffer,_.offset,_.typeInfo.count));if("f32"===_.typeInfo.format.name)return Array.from(new Float32Array(_.buffer,_.offset,_.typeInfo.count))}return console.error(`Unsupported return variable type ${_.typeInfo.name}`),null}execute(i){(i=null!=i?i:{}).constants&&this._setOverrides(i.constants,this.context),this._execStatements(this.ast,this.context)}dispatchWorkgroups(i,g,m,_){const b=this.context.clone();(_=null!=_?_:{}).constants&&this._setOverrides(_.constants,b),this._execStatements(this.ast,b);const T=b.getFunction(i);if(!T)return void console.error(`Function ${i} not found`);if("number"==typeof g)g=[g,1,1];else{if(0===g.length)return void console.error("Invalid dispatch count");1===g.length?g=[g[0],1,1]:2===g.length?g=[g[0],g[1],1]:g.length>3&&(g=[g[0],g[1],g[2]])}const P=g[0],I=g[1],H=g[2],W=this.getTypeInfo("vec3u");b.setVariable("@num_workgroups",new HT(g,W));for(const i in m)for(const g in m[i]){const _=m[i][g];b.variables.forEach((m=>{var b;const T=m.node;if(null==T?void 0:T.attributes){let P=null,I=null;for(const i of T.attributes)"binding"===i.name?P=i.value:"group"===i.name&&(I=i.value);if(g==P&&i==I)if(void 0!==_.texture&&void 0!==_.descriptor){const i=new VT(_.texture,this.getTypeInfo(T.type),_.descriptor,null!==(b=_.texture.view)&&void 0!==b?b:null);m.value=i}else m.value=new zT(void 0!==_.uniform?_.uniform:_,this.getTypeInfo(T.type))}}))}for(let i=0;i<H;++i)for(let g=0;g<I;++g)for(let m=0;m<P;++m)b.setVariable("@workgroup_id",new HT([m,g,i],this.getTypeInfo("vec3u"))),this._dispatchWorkgroup(T,[m,g,i],b)}execStatement(i,g){if(i instanceof Jw)return this.evalExpression(i.value,g);if(i instanceof iT){if(i.condition){const m=this.evalExpression(i.condition,g);if(!(m instanceof FT))throw new Error("Invalid break-if condition");if(!m.value)return null}return pt._breakObj}if(i instanceof oT)return pt._continueObj;if(i instanceof zw)this._let(i,g);else if(i instanceof Hw)this._var(i,g);else if(i instanceof Vw)this._const(i,g);else if(i instanceof Rw)this._function(i,g);else{if(i instanceof Qw)return this._if(i,g);if(i instanceof Yw)return this._switch(i,g);if(i instanceof Nw)return this._for(i,g);if(i instanceof Dw)return this._while(i,g);if(i instanceof $w)return this._loop(i,g);if(i instanceof Fw){const m=g.clone();return m.currentFunctionName=g.currentFunctionName,this._execStatements(i.body,m)}if(i instanceof Xw)this._assign(i,g);else if(i instanceof qw)this._increment(i,g);else{if(i instanceof lT)return null;if(i instanceof Bw){const m=i.name;null===g.getVariable(m)&&g.setVariable(m,new FT(0,this.getTypeInfo("u32")))}else if(i instanceof Zw)this._call(i,g);else{if(i instanceof tT)return null;if(i instanceof nT)return null;console.error("Invalid statement type.",i,`Line ${i.line}`)}}}return null}evalExpression(i,g){return i instanceof TT?this._evalBinaryOp(i,g):i instanceof _T?this._evalLiteral(i,g):i instanceof AT?this._evalVariable(i,g):i instanceof mT?this._evalCall(i,g):i instanceof gT?this._evalCreate(i,g):i instanceof yT?this._evalConst(i,g):i instanceof vT?this._evalBitcast(i,g):i instanceof wT?this._evalUnaryOp(i,g):(console.error("Invalid expression type",i,`Line ${i.line}`),null)}getTypeInfo(i){var g;if(i instanceof sT){const g=this.reflection.getTypeInfo(i);if(null!==g)return g}let m=null!==(g=this.typeInfo[i])&&void 0!==g?g:null;return null!==m||(m=this.reflection.getTypeInfoByName(i)),m}_setOverrides(i,g){for(const m in i){const _=i[m],b=this.reflection.getOverrideInfo(m);null!==b?(null===b.type&&(b.type=this.getTypeInfo("u32")),"u32"===b.type.name||"i32"===b.type.name||"f32"===b.type.name||"f16"===b.type.name?g.setVariable(m,new FT(_,b.type)):"bool"===b.type.name?g.setVariable(m,new FT(_?1:0,b.type)):"vec2"===b.type.name||"vec3"===b.type.name||"vec4"===b.type.name||"vec2f"===b.type.name||"vec3f"===b.type.name||"vec4f"===b.type.name||"vec2i"===b.type.name||"vec3i"===b.type.name||"vec4i"===b.type.name||"vec2u"===b.type.name||"vec3u"===b.type.name||"vec4u"===b.type.name||"vec2h"===b.type.name||"vec3h"===b.type.name||"vec4h"===b.type.name?g.setVariable(m,new HT(_,b.type)):console.error(`Invalid constant type for ${m}`)):console.error(`Override ${m} does not exist in the shader.`)}}_dispatchWorkgroup(i,g,m){const _=[1,1,1];for(const g of i.node.attributes)if("workgroup_size"===g.name){if(g.value.length>0){const i=m.getVariableValue(g.value[0]);_[0]=i instanceof FT?i.value:parseInt(g.value[0])}if(g.value.length>1){const i=m.getVariableValue(g.value[1]);_[1]=i instanceof FT?i.value:parseInt(g.value[1])}if(g.value.length>2){const i=m.getVariableValue(g.value[2]);_[2]=i instanceof FT?i.value:parseInt(g.value[2])}}const b=this.getTypeInfo("vec3u"),T=this.getTypeInfo("u32");m.setVariable("@workgroup_size",new HT(_,b));const P=_[0],I=_[1],H=_[2];for(let W=0,q=0;W<H;++W)for(let H=0;H<I;++H)for(let I=0;I<P;++I,++q){const P=[I+g[0]*_[0],H+g[1]*_[1],W+g[2]*_[2]];m.setVariable("@local_invocation_id",new HT([I,H,W],b)),m.setVariable("@global_invocation_id",new HT(P,b)),m.setVariable("@local_invocation_index",new FT(q,T)),this._dispatchExec(i,m)}}_dispatchExec(i,g){for(const m of i.node.args)for(const i of m.attributes)if("builtin"===i.name){const _=g.getVariable(`@${i.value}`);void 0!==_&&g.variables.set(m.name,_)}this._execStatements(i.node.body,g)}getVariableName(i,g){for(;i instanceof wT;)i=i.right;return i instanceof AT?i.name:(console.error("Unknown variable type",i,"Line",i.line),null)}_execStatements(i,g){for(const m of i){if(m instanceof Array){const i=g.clone(),_=this._execStatements(m,i);if(_)return _;continue}const i=this.execStatement(m,g);if(i)return i}return null}_call(i,g){const m=g.clone();m.currentFunctionName=i.name;const _=g.getFunction(i.name);if(_){for(let g=0;g<_.node.args.length;++g){const b=_.node.args[g],T=this.evalExpression(i.args[g],m);m.setVariable(b.name,T,b)}this._execStatements(_.node.body,m)}else i.isBuiltin?this._callBuiltinFunction(i,m):this.getTypeInfo(i.name)&&this._evalCreate(i,g)}_increment(i,g){const m=this.getVariableName(i.variable,g),_=g.getVariable(m);_?"++"===i.operator?_.value instanceof FT?_.value.value++:console.error(`Variable ${m} is not a scalar. Line ${i.line}`):"--"===i.operator?_.value instanceof FT?_.value.value--:console.error(`Variable ${m} is not a scalar. Line ${i.line}`):console.error(`Unknown increment operator ${i.operator}. Line ${i.line}`):console.error(`Variable ${m} not found. Line ${i.line}`)}_getVariableData(i,g){if(i instanceof AT){const m=this.getVariableName(i,g),_=g.getVariable(m);return null===_?(console.error(`Variable ${m} not found. Line ${i.line}`),null):_.value.getSubData(this,i.postfix,g)}if(i instanceof wT){if("*"===i.operator){const m=this._getVariableData(i.right,g);return m instanceof DT?m.reference.getSubData(this,i.postfix,g):(console.error(`Variable ${i.right} is not a pointer. Line ${i.line}`),null)}if("&"===i.operator){const m=this._getVariableData(i.right,g);return new DT(m)}}return null}_assign(i,g){let m=null,_="<var>",b=null;if(i.variable instanceof wT){const m=this._getVariableData(i.variable,g),_=this.evalExpression(i.value,g),b=i.operator;if("="===b){if(m instanceof FT||m instanceof HT||m instanceof BT){if(_ instanceof FT||_ instanceof HT||_ instanceof BT&&m.data.length===_.data.length)return void m.data.set(_.data);console.error(`Invalid assignment. Line ${i.line}`)}else if(m instanceof zT&&_ instanceof zT&&m.buffer.byteLength-m.offset>=_.buffer.byteLength-_.offset)return void(m.buffer.byteLength%4==0?new Uint32Array(m.buffer,m.offset,m.typeInfo.size/4).set(new Uint32Array(_.buffer,_.offset,_.typeInfo.size/4)):new Uint8Array(m.buffer,m.offset,m.typeInfo.size).set(new Uint8Array(_.buffer,_.offset,_.typeInfo.size)));return console.error(`Invalid assignment. Line ${i.line}`),null}if("+="===b)return m instanceof FT||m instanceof HT||m instanceof BT?_ instanceof FT||_ instanceof HT||_ instanceof BT?void m.data.set(_.data.map(((i,g)=>m.data[g]+i))):void console.error(`Invalid assignment . Line ${i.line}`):void console.error(`Invalid assignment. Line ${i.line}`);if("-="===b)return(m instanceof FT||m instanceof HT||m instanceof BT)&&(_ instanceof FT||_ instanceof HT||_ instanceof BT)?void m.data.set(_.data.map(((i,g)=>m.data[g]-i))):void console.error(`Invalid assignment. Line ${i.line}`)}if(i.variable instanceof wT){if("*"===i.variable.operator){_=this.getVariableName(i.variable.right,g);const b=g.getVariable(_);if(!(b&&b.value instanceof DT))return void console.error(`Variable ${_} is not a pointer. Line ${i.line}`);m=b.value.reference;let T=i.variable.postfix;if(!T){let g=i.variable.right;for(;g instanceof wT;){if(g.postfix){T=g.postfix;break}g=g.right}}T&&(m=m.getSubData(this,T,g))}}else{b=i.variable.postfix,_=this.getVariableName(i.variable,g);const T=g.getVariable(_);if(null===T)return void console.error(`Variable ${_} not found. Line ${i.line}`);m=T.value}if(m instanceof DT&&(m=m.reference),null===m)return void console.error(`Variable ${_} not found. Line ${i.line}`);const T=this.evalExpression(i.value,g),P=i.operator;if("="===P)if(m instanceof zT)m.setDataValue(this,T,b,g);else if(b){if(!(m instanceof HT||m instanceof BT))return void console.error(`Variable ${_} is not a vector or matrix. Line ${i.line}`);if(b instanceof xT){const P=this.evalExpression(b.index,g).value;if(m instanceof HT){if(!(T instanceof FT))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[P]=T.value}else{if(!(m instanceof BT))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);{const P=this.evalExpression(b.index,g).value;if(P<0)return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(!(T instanceof HT))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);{const g=m.typeInfo.getTypeName();if("mat2x2"===g||"mat2x2f"===g||"mat2x2h"===g){if(!(P<2&&2===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[2*P]=T.data[0],m.data[2*P+1]=T.data[1]}else if("mat2x3"===g||"mat2x3f"===g||"mat2x3h"===g){if(!(P<2&&3===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[3*P]=T.data[0],m.data[3*P+1]=T.data[1],m.data[3*P+2]=T.data[2]}else if("mat2x4"===g||"mat2x4f"===g||"mat2x4h"===g){if(!(P<2&&4===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[4*P]=T.data[0],m.data[4*P+1]=T.data[1],m.data[4*P+2]=T.data[2],m.data[4*P+3]=T.data[3]}else if("mat3x2"===g||"mat3x2f"===g||"mat3x2h"===g){if(!(P<3&&2===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[2*P]=T.data[0],m.data[2*P+1]=T.data[1]}else if("mat3x3"===g||"mat3x3f"===g||"mat3x3h"===g){if(!(P<3&&3===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[3*P]=T.data[0],m.data[3*P+1]=T.data[1],m.data[3*P+2]=T.data[2]}else if("mat3x4"===g||"mat3x4f"===g||"mat3x4h"===g){if(!(P<3&&4===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[4*P]=T.data[0],m.data[4*P+1]=T.data[1],m.data[4*P+2]=T.data[2],m.data[4*P+3]=T.data[3]}else if("mat4x2"===g||"mat4x2f"===g||"mat4x2h"===g){if(!(P<4&&2===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[2*P]=T.data[0],m.data[2*P+1]=T.data[1]}else if("mat4x3"===g||"mat4x3f"===g||"mat4x3h"===g){if(!(P<4&&3===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[3*P]=T.data[0],m.data[3*P+1]=T.data[1],m.data[3*P+2]=T.data[2]}else{if("mat4x4"!==g&&"mat4x4f"!==g&&"mat4x4h"!==g)return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(!(P<4&&4===T.data.length))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);m.data[4*P]=T.data[0],m.data[4*P+1]=T.data[1],m.data[4*P+2]=T.data[2],m.data[4*P+3]=T.data[3]}}}}}else if(b instanceof pT){const g=b.value;if(!(m instanceof HT))return void console.error(`Invalid assignment to ${g}. Variable ${_} is not a vector. Line ${i.line}`);if(T instanceof FT){if(g.length>1)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);if("x"===g)m.data[0]=T.value;else if("y"===g){if(m.data.length<2)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);m.data[1]=T.value}else if("z"===g){if(m.data.length<3)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);m.data[2]=T.value}else if("w"===g){if(m.data.length<4)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);m.data[3]=T.value}}else{if(!(T instanceof HT))return void console.error(`Invalid assignment to ${_}. Line ${i.line}`);if(g.length!==T.data.length)return void console.error(`Invalid assignment to ${g} for variable ${_}. Line ${i.line}`);for(let b=0;b<g.length;++b){const P=g[b];if("x"===P||"r"===P)m.data[0]=T.data[b];else if("y"===P||"g"===P){if(T.data.length<2)return void console.error(`Invalid assignment to ${P} for variable ${_}. Line ${i.line}`);m.data[1]=T.data[b]}else if("z"===P||"b"===P){if(T.data.length<3)return void console.error(`Invalid assignment to ${P} for variable ${_}. Line ${i.line}`);m.data[2]=T.data[b]}else{if("w"!==P&&"a"!==P)return void console.error(`Invalid assignment to ${P} for variable ${_}. Line ${i.line}`);if(T.data.length<4)return void console.error(`Invalid assignment to ${P} for variable ${_}. Line ${i.line}`);m.data[3]=T.data[b]}}}}}else m instanceof FT&&T instanceof FT?m.value=T.value:m instanceof HT&&T instanceof HT||m instanceof BT&&T instanceof BT?m.data.set(T.data):console.error(`Invalid assignment to ${_}. Line ${i.line}`);else{const _=m.getSubData(this,b,g);if(_ instanceof HT&&T instanceof FT){const g=_.data,m=T.value;if("+="===P)for(let i=0;i<g.length;++i)g[i]+=m;else if("-="===P)for(let i=0;i<g.length;++i)g[i]-=m;else if("*="===P)for(let i=0;i<g.length;++i)g[i]*=m;else if("/="===P)for(let i=0;i<g.length;++i)g[i]/=m;else if("%="===P)for(let i=0;i<g.length;++i)g[i]%=m;else if("&="===P)for(let i=0;i<g.length;++i)g[i]&=m;else if("|="===P)for(let i=0;i<g.length;++i)g[i]|=m;else if("^="===P)for(let i=0;i<g.length;++i)g[i]^=m;else if("<<="===P)for(let i=0;i<g.length;++i)g[i]<<=m;else if(">>="===P)for(let i=0;i<g.length;++i)g[i]>>=m;else console.error(`Invalid operator ${P}. Line ${i.line}`)}else if(_ instanceof HT&&T instanceof HT){const g=_.data,m=T.data;if(g.length!==m.length)return void console.error(`Vector length mismatch. Line ${i.line}`);if("+="===P)for(let i=0;i<g.length;++i)g[i]+=m[i];else if("-="===P)for(let i=0;i<g.length;++i)g[i]-=m[i];else if("*="===P)for(let i=0;i<g.length;++i)g[i]*=m[i];else if("/="===P)for(let i=0;i<g.length;++i)g[i]/=m[i];else if("%="===P)for(let i=0;i<g.length;++i)g[i]%=m[i];else if("&="===P)for(let i=0;i<g.length;++i)g[i]&=m[i];else if("|="===P)for(let i=0;i<g.length;++i)g[i]|=m[i];else if("^="===P)for(let i=0;i<g.length;++i)g[i]^=m[i];else if("<<="===P)for(let i=0;i<g.length;++i)g[i]<<=m[i];else if(">>="===P)for(let i=0;i<g.length;++i)g[i]>>=m[i];else console.error(`Invalid operator ${P}. Line ${i.line}`)}else{if(!(_ instanceof FT&&T instanceof FT))return void console.error(`Invalid type for ${i.operator} operator. Line ${i.line}`);"+="===P?_.value+=T.value:"-="===P?_.value-=T.value:"*="===P?_.value*=T.value:"/="===P?_.value/=T.value:"%="===P?_.value%=T.value:"&="===P?_.value&=T.value:"|="===P?_.value|=T.value:"^="===P?_.value^=T.value:"<<="===P?_.value<<=T.value:">>="===P?_.value>>=T.value:console.error(`Invalid operator ${P}. Line ${i.line}`)}m instanceof zT&&m.setDataValue(this,_,b,g)}}_function(i,g){const m=new lS(i);g.functions.set(i.name,m)}_const(i,g){let m=null;null!==i.value&&(m=this.evalExpression(i.value,g)),g.createVariable(i.name,m,i)}_let(i,g){let m=null;if(null!==i.value){if(m=this.evalExpression(i.value,g),null===m)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof wT||(m=m.clone())}else{const _=i.type.name;if("f32"===_||"i32"===_||"u32"===_||"bool"===_||"f16"===_||"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2b"===_||"vec3b"===_||"vec4b"===_||"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_||"array"===_){const _=new gT(i.type,[]);m=this._evalCreate(_,g)}}g.createVariable(i.name,m,i)}_var(i,g){let m=null;if(null!==i.value){if(m=this.evalExpression(i.value,g),null===m)return void console.error(`Invalid value for variable ${i.name}. Line ${i.line}`);i.value instanceof wT||(m=m.clone())}else{if(null===i.type)return void console.error(`Variable ${i.name} has no type. Line ${i.line}`);const _=i.type.name;if("f32"===_||"i32"===_||"u32"===_||"bool"===_||"f16"===_||"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2b"===_||"vec3b"===_||"vec4b"===_||"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_||i.type instanceof uT||i.type instanceof lT||i.type instanceof hT){const _=new gT(i.type,[]);m=this._evalCreate(_,g)}}g.createVariable(i.name,m,i)}_switch(i,g){g=g.clone();const m=this.evalExpression(i.condition,g);if(!(m instanceof FT))return console.error(`Invalid if condition. Line ${i.line}`),null;let _=null;for(const b of i.cases)if(b instanceof CT)for(const T of b.selectors){if(T instanceof MT){_=b;continue}const P=this.evalExpression(T,g);if(!(P instanceof FT))return console.error(`Invalid case selector. Line ${i.line}`),null;if(P.value===m.value)return this._execStatements(b.body,g)}else b instanceof PT&&(_=b);return _?this._execStatements(_.body,g):null}_if(i,g){g=g.clone();const m=this.evalExpression(i.condition,g);if(!(m instanceof FT))return console.error(`Invalid if condition. Line ${i.line}`),null;if(m.value)return this._execStatements(i.body,g);for(const m of i.elseif){const _=this.evalExpression(m.condition,g);if(!(_ instanceof FT))return console.error(`Invalid if condition. Line ${i.line}`),null;if(_.value)return this._execStatements(m.body,g)}return i.else?this._execStatements(i.else,g):null}_getScalarValue(i){return i instanceof FT?i.value:(console.error("Expected scalar value.",i),0)}_for(i,g){for(g=g.clone(),this.execStatement(i.init,g);this._getScalarValue(this.evalExpression(i.condition,g));){const m=this._execStatements(i.body,g);if(m===pt._breakObj)break;if(null!==m&&m!==pt._continueObj)return m;this.execStatement(i.increment,g)}return null}_loop(i,g){for(g=g.clone();;){const m=this._execStatements(i.body,g);if(m===pt._breakObj)break;if(m===pt._continueObj){if(i.continuing&&this._execStatements(i.continuing.body,g)===pt._breakObj)break}else if(null!==m)return m}return null}_while(i,g){for(g=g.clone();this._getScalarValue(this.evalExpression(i.condition,g));){const m=this._execStatements(i.body,g);if(m===pt._breakObj)break;if(m!==pt._continueObj&&null!==m)return m}return null}_evalBitcast(i,g){const m=this.evalExpression(i.value,g),_=i.type;if(m instanceof FT){const i=nS(m.value,m.typeInfo.name,_.name);return new FT(i,this.getTypeInfo(_))}if(m instanceof HT){const g=m.typeInfo.getTypeName();let b="";if(g.endsWith("f"))b="f32";else if(g.endsWith("i"))b="i32";else if(g.endsWith("u"))b="u32";else if(g.endsWith("b"))b="bool";else{if(!g.endsWith("h"))return console.error(`Unknown vector type ${g}. Line ${i.line}`),null;b="f16"}const T=_.getTypeName();let P="";if(T.endsWith("f"))P="f32";else if(T.endsWith("i"))P="i32";else if(T.endsWith("u"))P="u32";else if(T.endsWith("b"))P="bool";else{if(!T.endsWith("h"))return console.error(`Unknown vector type ${P}. Line ${i.line}`),null;P="f16"}const I=function(i,g,m){if(g===m)return i;const _=new Array(i.length);for(let b=0;b<i.length;b++)_[b]=nS(i[b],g,m);return _}(Array.from(m.data),b,P);return new HT(I,this.getTypeInfo(_))}return console.error(`TODO: bitcast for ${m.typeInfo.name}. Line ${i.line}`),null}_evalConst(i,g){return g.getVariableValue(i.name).clone().getSubData(this,i.postfix,g)}_evalCreate(i,g){var m;if(i instanceof gT){if(null===i.type)return LT.void;switch(i.type.getTypeName()){case"bool":case"i32":case"u32":case"f32":case"f16":return this._callConstructorValue(i,g);case"vec2":case"vec3":case"vec4":case"vec2f":case"vec3f":case"vec4f":case"vec2h":case"vec3h":case"vec4h":case"vec2i":case"vec3i":case"vec4i":case"vec2u":case"vec3u":case"vec4u":case"vec2b":case"vec3b":case"vec4b":return this._callConstructorVec(i,g);case"mat2x2":case"mat2x2f":case"mat2x2h":case"mat2x3":case"mat2x3f":case"mat2x3h":case"mat2x4":case"mat2x4f":case"mat2x4h":case"mat3x2":case"mat3x2f":case"mat3x2h":case"mat3x3":case"mat3x3f":case"mat3x3h":case"mat3x4":case"mat3x4f":case"mat3x4h":case"mat4x2":case"mat4x2f":case"mat4x2h":case"mat4x3":case"mat4x3f":case"mat4x3h":case"mat4x4":case"mat4x4f":case"mat4x4h":return this._callConstructorMatrix(i,g)}}const _=i instanceof gT?i.type.name:i.name,b=this.getTypeInfo(i instanceof gT?i.type:i.name);if(null===b)return console.error(`Unknown type ${_}. Line ${i.line}`),null;if(0===b.size)return null;const T=new zT(new ArrayBuffer(b.size),b,0);if(b instanceof n){if(i.args)for(let m=0;m<i.args.length;++m){const _=b.members[m],P=this.evalExpression(i.args[m],g);T.setData(this,P,_.type,_.offset,g)}}else if(b instanceof s){let _=0;if(i.args)for(let P=0;P<i.args.length;++P){const I=this.evalExpression(i.args[P],g);null===b.format&&(b.format="x32"===(null===(m=I.typeInfo)||void 0===m?void 0:m.name)?this.getTypeInfo("i32"):I.typeInfo),T.setData(this,I,b.format,_,g),_+=b.stride}}else console.error(`Unknown type "${_}". Line ${i.line}`);return i instanceof gT?T.getSubData(this,i.postfix,g):T}_evalLiteral(i,g){const m=this.getTypeInfo(i.type),_=m.name;return"x32"===_||"u32"===_||"f32"===_||"f16"===_||"i32"===_||"bool"===_?new FT(i.scalarValue,m):"vec2"===_||"vec3"===_||"vec4"===_||"vec2f"===_||"vec3f"===_||"vec4f"===_||"vec2h"===_||"vec3h"===_||"vec4h"===_||"vec2i"===_||"vec3i"===_||"vec4i"===_||"vec2u"===_||"vec3u"===_||"vec4u"===_?this._callConstructorVec(i,g):"mat2x2"===_||"mat2x3"===_||"mat2x4"===_||"mat3x2"===_||"mat3x3"===_||"mat3x4"===_||"mat4x2"===_||"mat4x3"===_||"mat4x4"===_||"mat2x2f"===_||"mat2x3f"===_||"mat2x4f"===_||"mat3x2f"===_||"mat3x3f"===_||"mat3x4f"===_||"mat4x2f"===_||"mat4x3f"===_||"mat4x4f"===_||"mat2x2h"===_||"mat2x3h"===_||"mat2x4h"===_||"mat3x2h"===_||"mat3x3h"===_||"mat3x4h"===_||"mat4x2h"===_||"mat4x3h"===_||"mat4x4h"===_?this._callConstructorMatrix(i,g):i.value}_evalVariable(i,g){const m=g.getVariableValue(i.name);return null===m?m:m.getSubData(this,i.postfix,g)}_maxFormatTypeInfo(i){let g=i[0];if("f32"===g.name)return g;for(let m=1;m<i.length;++m){const _=pt._priority.get(g.name);pt._priority.get(i[m].name)<_&&(g=i[m])}return"x32"===g.name?this.getTypeInfo("i32"):g}_evalUnaryOp(i,g){const m=this.evalExpression(i.right,g);if("&"===i.operator)return new DT(m);if("*"===i.operator)return m instanceof DT?m.reference.getSubData(this,i.postfix,g):(console.error(`Invalid dereference. Line ${i.line}`),null);const _=m instanceof FT?m.value:m instanceof HT?Array.from(m.data):null;switch(i.operator){case"+":{if(qT(_)){const i=_.map(((i,g)=>+i));return new HT(i,m.typeInfo)}const i=_,g=this._maxFormatTypeInfo([m.typeInfo,m.typeInfo]);return new FT(+i,g)}case"-":{if(qT(_)){const i=_.map(((i,g)=>-i));return new HT(i,m.typeInfo)}const i=_,g=this._maxFormatTypeInfo([m.typeInfo,m.typeInfo]);return new FT(-i,g)}case"!":{if(qT(_)){const i=_.map(((i,g)=>i?0:1));return new HT(i,m.typeInfo)}const i=_,g=this._maxFormatTypeInfo([m.typeInfo,m.typeInfo]);return new FT(i?0:1,g)}case"~":{if(qT(_)){const i=_.map(((i,g)=>~i));return new HT(i,m.typeInfo)}const i=_,g=this._maxFormatTypeInfo([m.typeInfo,m.typeInfo]);return new FT(~i,g)}}return console.error(`Invalid unary operator ${i.operator}. Line ${i.line}`),null}_evalBinaryOp(i,g){const m=this.evalExpression(i.left,g),_=this.evalExpression(i.right,g),b=m instanceof FT?m.value:m instanceof HT||m instanceof BT?Array.from(m.data):null,T=_ instanceof FT?_.value:_ instanceof HT||_ instanceof BT?Array.from(_.data):null;switch(i.operator){case"+":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i+_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g+i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i+g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g+P,I)}case"-":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i-_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g-i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i-g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g-P,I)}case"*":{if(qT(b)&&qT(T)){const g=b,P=T;if(m instanceof BT&&_ instanceof BT){const b=function(i,g,m,_){if(void 0===dS[g.name]||void 0===dS[_.name])return null;const b=dS[g.name][0],T=dS[g.name][1],P=dS[_.name][0];if(b!==dS[_.name][1])return null;const I=new Array(P*T);for(let g=0;g<T;g++)for(let _=0;_<P;_++){let H=0;for(let P=0;P<b;P++)H+=i[P*T+g]*m[_*b+P];I[g*P+_]=H}return I}(g,m.typeInfo,P,_.typeInfo);if(null===b)return console.error(`Matrix multiplication failed. Line ${i.line}.`),null;const T=this.getTypeInfo(`mat${dS[_.typeInfo.name][0]}x${dS[m.typeInfo.name][1]}f`);return new BT(b,T)}if(m instanceof BT&&_ instanceof HT){const b=function(i,g,m,_){if(void 0===dS[g.name]||void 0===fS[_.name])return null;const b=dS[g.name][0],T=dS[g.name][1];if(b!==m.length)return null;const P=new Array(T);for(let g=0;g<T;g++){let _=0;for(let P=0;P<b;P++)_+=i[P*T+g]*m[P];P[g]=_}return P}(g,m.typeInfo,P,_.typeInfo);return null===b?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new HT(b,_.typeInfo)}if(m instanceof HT&&_ instanceof BT){const b=function(i,g,m,_){if(void 0===fS[g.name]||void 0===dS[_.name])return null;const b=dS[_.name][0],T=dS[_.name][1];if(T!==i.length)return null;const P=[];for(let g=0;g<b;g++){let _=0;for(let P=0;P<T;P++)_+=i[P]*m[P*b+g];P[g]=_}return P}(g,m.typeInfo,P,_.typeInfo);return null===b?(console.error(`Matrix vector multiplication failed. Line ${i.line}.`),null):new HT(b,m.typeInfo)}{if(g.length!==P.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const _=g.map(((i,g)=>i*P[g]));return new HT(_,m.typeInfo)}}if(qT(b)){const i=T,g=b.map(((g,m)=>g*i));return m instanceof BT?new BT(g,m.typeInfo):new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i*g));return _ instanceof BT?new BT(g,_.typeInfo):new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g*P,I)}case"%":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i%_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g%i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i%g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g%P,I)}case"/":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i/_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g/i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i/g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g/P,I)}case"&":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i&_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g&i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i&g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g&P,I)}case"|":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i|_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g|i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i|g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g|P,I)}case"^":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i^_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g^i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i^g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g^P,I)}case"<<":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i<<_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g<<i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i<<g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g<<P,I)}case">>":{if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i>>_[g]));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g>>i));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i>>g));return new HT(g,_.typeInfo)}const g=b,P=T,I=this._maxFormatTypeInfo([m.typeInfo,_.typeInfo]);return new FT(g>>P,I)}case">":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i>_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g>i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i>g?1:0));return new HT(g,_.typeInfo)}return new FT(b>T?1:0,this.getTypeInfo("bool"));case"<":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i<_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g<i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i<g?1:0));return new HT(g,_.typeInfo)}return new FT(b<T?1:0,this.getTypeInfo("bool"));case"==":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i===_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g==i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i==g?1:0));return new HT(g,_.typeInfo)}return new FT(b===T?1:0,this.getTypeInfo("bool"));case"!=":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i!==_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g!==i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i!==g?1:0));return new HT(g,_.typeInfo)}return new FT(b!==T?1:0,this.getTypeInfo("bool"));case">=":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i>=_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g>=i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i>=g?1:0));return new HT(g,_.typeInfo)}return new FT(b>=T?1:0,this.getTypeInfo("bool"));case"<=":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i<=_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g<=i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i<=g?1:0));return new HT(g,_.typeInfo)}return new FT(b<=T?1:0,this.getTypeInfo("bool"));case"&&":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i&&_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g&&i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i&&g?1:0));return new HT(g,_.typeInfo)}return new FT(b&&T?1:0,this.getTypeInfo("bool"));case"||":if(qT(b)&&qT(T)){const g=b,_=T;if(g.length!==_.length)return console.error(`Vector length mismatch. Line ${i.line}.`),null;const P=g.map(((i,g)=>i||_[g]?1:0));return new HT(P,m.typeInfo)}if(qT(b)){const i=T,g=b.map(((g,m)=>g||i?1:0));return new HT(g,m.typeInfo)}if(qT(T)){const i=b,g=T.map(((g,m)=>i||g?1:0));return new HT(g,_.typeInfo)}return new FT(b||T?1:0,this.getTypeInfo("bool"))}return console.error(`Unknown operator ${i.operator}. Line ${i.line}`),null}_evalCall(i,g){if(null!==i.cachedReturnValue)return i.cachedReturnValue;const m=g.clone();m.currentFunctionName=i.name;const _=g.getFunction(i.name);if(!_)return i.isBuiltin?this._callBuiltinFunction(i,m):this.getTypeInfo(i.name)?this._evalCreate(i,g):(console.error(`Unknown function "${i.name}". Line ${i.line}`),null);for(let g=0;g<_.node.args.length;++g){const b=_.node.args[g],T=this.evalExpression(i.args[g],m);m.createVariable(b.name,T,b)}return this._execStatements(_.node.body,m)}_callBuiltinFunction(i,g){switch(i.name){case"all":return this.builtins.All(i,g);case"any":return this.builtins.Any(i,g);case"select":return this.builtins.Select(i,g);case"arrayLength":return this.builtins.ArrayLength(i,g);case"abs":return this.builtins.Abs(i,g);case"acos":return this.builtins.Acos(i,g);case"acosh":return this.builtins.Acosh(i,g);case"asin":return this.builtins.Asin(i,g);case"asinh":return this.builtins.Asinh(i,g);case"atan":return this.builtins.Atan(i,g);case"atanh":return this.builtins.Atanh(i,g);case"atan2":return this.builtins.Atan2(i,g);case"ceil":return this.builtins.Ceil(i,g);case"clamp":return this.builtins.Clamp(i,g);case"cos":return this.builtins.Cos(i,g);case"cosh":return this.builtins.Cosh(i,g);case"countLeadingZeros":return this.builtins.CountLeadingZeros(i,g);case"countOneBits":return this.builtins.CountOneBits(i,g);case"countTrailingZeros":return this.builtins.CountTrailingZeros(i,g);case"cross":return this.builtins.Cross(i,g);case"degrees":return this.builtins.Degrees(i,g);case"determinant":return this.builtins.Determinant(i,g);case"distance":return this.builtins.Distance(i,g);case"dot":return this.builtins.Dot(i,g);case"dot4U8Packed":return this.builtins.Dot4U8Packed(i,g);case"dot4I8Packed":return this.builtins.Dot4I8Packed(i,g);case"exp":return this.builtins.Exp(i,g);case"exp2":return this.builtins.Exp2(i,g);case"extractBits":return this.builtins.ExtractBits(i,g);case"faceForward":return this.builtins.FaceForward(i,g);case"firstLeadingBit":return this.builtins.FirstLeadingBit(i,g);case"firstTrailingBit":return this.builtins.FirstTrailingBit(i,g);case"floor":return this.builtins.Floor(i,g);case"fma":return this.builtins.Fma(i,g);case"fract":return this.builtins.Fract(i,g);case"frexp":return this.builtins.Frexp(i,g);case"insertBits":return this.builtins.InsertBits(i,g);case"inverseSqrt":return this.builtins.InverseSqrt(i,g);case"ldexp":return this.builtins.Ldexp(i,g);case"length":return this.builtins.Length(i,g);case"log":return this.builtins.Log(i,g);case"log2":return this.builtins.Log2(i,g);case"max":return this.builtins.Max(i,g);case"min":return this.builtins.Min(i,g);case"mix":return this.builtins.Mix(i,g);case"modf":return this.builtins.Modf(i,g);case"normalize":return this.builtins.Normalize(i,g);case"pow":return this.builtins.Pow(i,g);case"quantizeToF16":return this.builtins.QuantizeToF16(i,g);case"radians":return this.builtins.Radians(i,g);case"reflect":return this.builtins.Reflect(i,g);case"refract":return this.builtins.Refract(i,g);case"reverseBits":return this.builtins.ReverseBits(i,g);case"round":return this.builtins.Round(i,g);case"saturate":return this.builtins.Saturate(i,g);case"sign":return this.builtins.Sign(i,g);case"sin":return this.builtins.Sin(i,g);case"sinh":return this.builtins.Sinh(i,g);case"smoothStep":return this.builtins.SmoothStep(i,g);case"sqrt":return this.builtins.Sqrt(i,g);case"step":return this.builtins.Step(i,g);case"tan":return this.builtins.Tan(i,g);case"tanh":return this.builtins.Tanh(i,g);case"transpose":return this.builtins.Transpose(i,g);case"trunc":return this.builtins.Trunc(i,g);case"dpdx":return this.builtins.Dpdx(i,g);case"dpdxCoarse":return this.builtins.DpdxCoarse(i,g);case"dpdxFine":return this.builtins.DpdxFine(i,g);case"dpdy":return this.builtins.Dpdy(i,g);case"dpdyCoarse":return this.builtins.DpdyCoarse(i,g);case"dpdyFine":return this.builtins.DpdyFine(i,g);case"fwidth":return this.builtins.Fwidth(i,g);case"fwidthCoarse":return this.builtins.FwidthCoarse(i,g);case"fwidthFine":return this.builtins.FwidthFine(i,g);case"textureDimensions":return this.builtins.TextureDimensions(i,g);case"textureGather":return this.builtins.TextureGather(i,g);case"textureGatherCompare":return this.builtins.TextureGatherCompare(i,g);case"textureLoad":return this.builtins.TextureLoad(i,g);case"textureNumLayers":return this.builtins.TextureNumLayers(i,g);case"textureNumLevels":return this.builtins.TextureNumLevels(i,g);case"textureNumSamples":return this.builtins.TextureNumSamples(i,g);case"textureSample":return this.builtins.TextureSample(i,g);case"textureSampleBias":return this.builtins.TextureSampleBias(i,g);case"textureSampleCompare":return this.builtins.TextureSampleCompare(i,g);case"textureSampleCompareLevel":return this.builtins.TextureSampleCompareLevel(i,g);case"textureSampleGrad":return this.builtins.TextureSampleGrad(i,g);case"textureSampleLevel":return this.builtins.TextureSampleLevel(i,g);case"textureSampleBaseClampToEdge":return this.builtins.TextureSampleBaseClampToEdge(i,g);case"textureStore":return this.builtins.TextureStore(i,g);case"atomicLoad":return this.builtins.AtomicLoad(i,g);case"atomicStore":return this.builtins.AtomicStore(i,g);case"atomicAdd":return this.builtins.AtomicAdd(i,g);case"atomicSub":return this.builtins.AtomicSub(i,g);case"atomicMax":return this.builtins.AtomicMax(i,g);case"atomicMin":return this.builtins.AtomicMin(i,g);case"atomicAnd":return this.builtins.AtomicAnd(i,g);case"atomicOr":return this.builtins.AtomicOr(i,g);case"atomicXor":return this.builtins.AtomicXor(i,g);case"atomicExchange":return this.builtins.AtomicExchange(i,g);case"atomicCompareExchangeWeak":return this.builtins.AtomicCompareExchangeWeak(i,g);case"pack4x8snorm":return this.builtins.Pack4x8snorm(i,g);case"pack4x8unorm":return this.builtins.Pack4x8unorm(i,g);case"pack4xI8":return this.builtins.Pack4xI8(i,g);case"pack4xU8":return this.builtins.Pack4xU8(i,g);case"pack4x8Clamp":return this.builtins.Pack4x8Clamp(i,g);case"pack4xU8Clamp":return this.builtins.Pack4xU8Clamp(i,g);case"pack2x16snorm":return this.builtins.Pack2x16snorm(i,g);case"pack2x16unorm":return this.builtins.Pack2x16unorm(i,g);case"pack2x16float":return this.builtins.Pack2x16float(i,g);case"unpack4x8snorm":return this.builtins.Unpack4x8snorm(i,g);case"unpack4x8unorm":return this.builtins.Unpack4x8unorm(i,g);case"unpack4xI8":return this.builtins.Unpack4xI8(i,g);case"unpack4xU8":return this.builtins.Unpack4xU8(i,g);case"unpack2x16snorm":return this.builtins.Unpack2x16snorm(i,g);case"unpack2x16unorm":return this.builtins.Unpack2x16unorm(i,g);case"unpack2x16float":return this.builtins.Unpack2x16float(i,g);case"storageBarrier":return this.builtins.StorageBarrier(i,g);case"textureBarrier":return this.builtins.TextureBarrier(i,g);case"workgroupBarrier":return this.builtins.WorkgroupBarrier(i,g);case"workgroupUniformLoad":return this.builtins.WorkgroupUniformLoad(i,g);case"subgroupAdd":return this.builtins.SubgroupAdd(i,g);case"subgroupExclusiveAdd":return this.builtins.SubgroupExclusiveAdd(i,g);case"subgroupInclusiveAdd":return this.builtins.SubgroupInclusiveAdd(i,g);case"subgroupAll":return this.builtins.SubgroupAll(i,g);case"subgroupAnd":return this.builtins.SubgroupAnd(i,g);case"subgroupAny":return this.builtins.SubgroupAny(i,g);case"subgroupBallot":return this.builtins.SubgroupBallot(i,g);case"subgroupBroadcast":return this.builtins.SubgroupBroadcast(i,g);case"subgroupBroadcastFirst":return this.builtins.SubgroupBroadcastFirst(i,g);case"subgroupElect":return this.builtins.SubgroupElect(i,g);case"subgroupMax":return this.builtins.SubgroupMax(i,g);case"subgroupMin":return this.builtins.SubgroupMin(i,g);case"subgroupMul":return this.builtins.SubgroupMul(i,g);case"subgroupExclusiveMul":return this.builtins.SubgroupExclusiveMul(i,g);case"subgroupInclusiveMul":return this.builtins.SubgroupInclusiveMul(i,g);case"subgroupOr":return this.builtins.SubgroupOr(i,g);case"subgroupShuffle":return this.builtins.SubgroupShuffle(i,g);case"subgroupShuffleDown":return this.builtins.SubgroupShuffleDown(i,g);case"subgroupShuffleUp":return this.builtins.SubgroupShuffleUp(i,g);case"subgroupShuffleXor":return this.builtins.SubgroupShuffleXor(i,g);case"subgroupXor":return this.builtins.SubgroupXor(i,g);case"quadBroadcast":return this.builtins.QuadBroadcast(i,g);case"quadSwapDiagonal":return this.builtins.QuadSwapDiagonal(i,g);case"quadSwapX":return this.builtins.QuadSwapX(i,g);case"quadSwapY":return this.builtins.QuadSwapY(i,g)}const m=g.getFunction(i.name);if(m){const _=g.clone();for(let g=0;g<m.node.args.length;++g){const b=m.node.args[g],T=this.evalExpression(i.args[g],_);_.setVariable(b.name,T,b)}return this._execStatements(m.node.body,_)}return null}_callConstructorValue(i,g){if(!i.args||0===i.args.length)return new FT(0,this.getTypeInfo(i.type));const m=this.evalExpression(i.args[0],g);return m.typeInfo=this.getTypeInfo(i.type),m.getSubData(this,i.postfix,g).clone()}_callConstructorVec(i,g){const m=this.getTypeInfo(i.type),_=i.type.getTypeName(),b=fS[_];if(void 0===b)return console.error(`Invalid vec constructor ${_}. Line ${i.line}`),null;const T=[];if(i instanceof _T)if(i.isVector){const g=i.vectorValue;for(const i of g)T.push(i)}else T.push(i.scalarValue);else if(i.args)for(const m of i.args){const i=this.evalExpression(m,g);if(i instanceof HT){const g=i.data;for(let i=0;i<g.length;++i){T.push(g[i])}}else if(i instanceof FT){T.push(i.value)}}if(i.type instanceof hT&&null===i.type.format&&(i.type.format=hT.f32),0===T.length){const _=new Array(b).fill(0);return new HT(_,m).getSubData(this,i.postfix,g)}if(1===T.length)for(;T.length<b;)T.push(T[0]);return T.length<b?(console.error(`Invalid vec constructor. Line ${i.line}`),null):new HT(T.length>b?T.slice(0,b):T,m).getSubData(this,i.postfix,g)}_callConstructorMatrix(i,g){const m=this.getTypeInfo(i.type),_=i.type.getTypeName(),b=dS[_];if(void 0===b)return console.error(`Invalid matrix constructor ${_}. Line ${i.line}`),null;const T=[];if(i instanceof _T)if(i.isVector){const g=i.vectorValue;for(const i of g)T.push(i)}else T.push(i.scalarValue);else if(i.args)for(const m of i.args){const i=this.evalExpression(m,g);i instanceof HT?T.push(...i.data):i instanceof FT?T.push(i.value):i instanceof BT&&T.push(...i.data)}if(m instanceof a&&null===m.format&&(m.format=this.getTypeInfo("f32")),0===T.length){const _=new Array(b[2]).fill(0);return new BT(_,m).getSubData(this,i.postfix,g)}return T.length!==b[2]?(console.error(`Invalid matrix constructor. Line ${i.line}`),null):new BT(T,m).getSubData(this,i.postfix,g)}};pS._breakObj=new RT(new cw("BREAK",null),null),pS._continueObj=new RT(new cw("CONTINUE",null),null),pS._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);let gS=class dt{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}},mS=class mt{constructor(){this._tokens=[],this._current=0,this._currentLine=1,this._deferArrayCountEval=[],this._currentLoop=[],this._context=new gS,this._exec=new pS,this._forwardTypeCount=0}parse(i){this._initialize(i),this._deferArrayCountEval.length=0;const g=[];for(;!this._isAtEnd();){const i=this._global_decl_or_directive();if(!i)break;g.push(i)}if(this._deferArrayCountEval.length>0){for(const g of this._deferArrayCountEval){const m=g.arrayType,_=g.countNode;if(_ instanceof AT){const g=this._context.constants.get(_.name);if(g)try{const i=g.constEvaluate(this._exec);m.count=i}catch(i){}}}this._deferArrayCountEval.length=0}if(this._forwardTypeCount>0)for(const i of g)i.search((i=>{i instanceof OT||i instanceof cT?i.type=this._forwardType(i.type):i instanceof uT?i.format=this._forwardType(i.format):i instanceof Hw||i instanceof zw||i instanceof Vw?i.type=this._forwardType(i.type):i instanceof Rw?i.returnType=this._forwardType(i.returnType):i instanceof IT&&(i.type=this._forwardType(i.type))}));return g}_forwardType(i){if(i instanceof aT){const g=this._getType(i.name);if(g)return g}else i instanceof cT?i.type=this._forwardType(i.type):i instanceof uT&&(i.format=this._forwardType(i.format));return i}_initialize(i){if(i)if("string"==typeof i){const g=new WT(i);this._tokens=g.scanTokens()}else this._tokens=i;else this._tokens=[];this._current=0}_updateNode(i,g){return i.line=null!=g?g:this._currentLine,i}_error(i,g){return{token:i,message:g,toString:()=>`${g}`}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==GT.eof}_match(i){if(i instanceof UT)return!!this._check(i)&&(this._advance(),!0);for(let g=0,m=i.length;g<m;++g){if(this._check(i[g]))return this._advance(),!0}return!1}_consume(i,g){if(this._check(i))return this._advance();throw this._error(this._peek(),`${g}. Line:${this._currentLine}`)}_check(i){if(this._isAtEnd())return!1;const g=this._peek();if(i instanceof Array){const m=g.type;let _=!1;for(const g of i){if(m===g)return!0;g===GT.tokens.name&&(_=!0)}if(_){const i=GT.tokens.name.rule.exec(g.lexeme);if(i&&0==i.index&&i[0]==g.lexeme)return!0}return!1}if(g.type===i)return!0;if(i===GT.tokens.name){const i=GT.tokens.name.rule.exec(g.lexeme);return i&&0==i.index&&i[0]==g.lexeme}return!1}_advance(){var i,g;return this._currentLine=null!==(g=null===(i=this._peek())||void 0===i?void 0:i.line)&&void 0!==g?g:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(GT.tokens.semicolon)&&!this._isAtEnd(););if(this._match(GT.keywords.alias)){const i=this._type_alias();return this._consume(GT.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(GT.keywords.diagnostic)){const i=this._diagnostic();return this._consume(GT.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(GT.keywords.requires)){const i=this._requires_directive();return this._consume(GT.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}if(this._match(GT.keywords.enable)){const i=this._enable_directive();return this._consume(GT.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([i]),i}const i=this._attribute();if(this._check(GT.keywords.var)){const g=this._global_variable_decl();return null!=g&&(g.attributes=i),this._consume(GT.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(GT.keywords.override)){const g=this._override_variable_decl();return null!=g&&(g.attributes=i),this._consume(GT.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(GT.keywords.let)){const g=this._global_let_decl();return null!=g&&(g.attributes=i),this._consume(GT.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(GT.keywords.const)){const g=this._global_const_decl();return null!=g&&(g.attributes=i),this._consume(GT.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([g]),g}if(this._check(GT.keywords.struct)){const g=this._struct_decl();return null!=g&&(g.attributes=i),this._exec.reflection.updateAST([g]),g}if(this._check(GT.keywords.fn)){const g=this._function_decl();return null!=g&&(g.attributes=i),this._exec.reflection.updateAST([g]),g}return null}_function_decl(){if(!this._match(GT.keywords.fn))return null;const i=this._currentLine,g=this._consume(GT.tokens.ident,"Expected function name.").toString();this._consume(GT.tokens.paren_left,"Expected '(' for function arguments.");const m=[];if(!this._check(GT.tokens.paren_right))do{if(this._check(GT.tokens.paren_right))break;const i=this._attribute(),g=this._consume(GT.tokens.name,"Expected argument name.").toString();this._consume(GT.tokens.colon,"Expected ':' for argument type.");const _=this._attribute(),b=this._type_decl();null!=b&&(b.attributes=_,m.push(this._updateNode(new IT(g,b,i))))}while(this._match(GT.tokens.comma));this._consume(GT.tokens.paren_right,"Expected ')' after function arguments.");let _=null;if(this._match(GT.tokens.arrow)){const i=this._attribute();_=this._type_decl(),null!=_&&(_.attributes=i)}const b=this._compound_statement();return this._updateNode(new Rw(g,m,_,b,i,this._currentLine),i)}_compound_statement(){const i=[];for(this._consume(GT.tokens.brace_left,"Expected '{' for block.");!this._check(GT.tokens.brace_right);){const g=this._statement();null!==g&&i.push(g)}return this._consume(GT.tokens.brace_right,"Expected '}' for block."),i}_statement(){for(;this._match(GT.tokens.semicolon)&&!this._isAtEnd(););if(this._check(GT.tokens.attr)&&this._attribute(),this._check(GT.keywords.if))return this._if_statement();if(this._check(GT.keywords.switch))return this._switch_statement();if(this._check(GT.keywords.loop))return this._loop_statement();if(this._check(GT.keywords.for))return this._for_statement();if(this._check(GT.keywords.while))return this._while_statement();if(this._check(GT.keywords.continuing))return this._continuing_statement();if(this._check(GT.keywords.static_assert))return this._static_assert_statement();if(this._check(GT.tokens.brace_left))return this._compound_statement();let i=null;if(this._check(GT.keywords.return))i=this._return_statement();else if(this._check([GT.keywords.var,GT.keywords.let,GT.keywords.const]))i=this._variable_statement();else if(this._match(GT.keywords.discard))i=this._updateNode(new rT);else if(this._match(GT.keywords.break)){const g=this._updateNode(new iT);if(this._currentLoop.length>0){g.loopId=this._currentLoop[this._currentLoop.length-1].id}i=g,this._check(GT.keywords.if)&&(this._advance(),g.condition=this._optional_paren_expression())}else if(this._match(GT.keywords.continue)){const g=this._updateNode(new oT);if(!(this._currentLoop.length>0))throw this._error(this._peek(),`Continue statement must be inside a loop. Line: ${g.line}`);g.loopId=this._currentLoop[this._currentLoop.length-1].id;i=g}else i=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement();return null!=i&&this._consume(GT.tokens.semicolon,"Expected ';' after statement."),i}_static_assert_statement(){if(!this._match(GT.keywords.static_assert))return null;const i=this._currentLine,g=this._optional_paren_expression();return this._updateNode(new Lw(g),i)}_while_statement(){if(!this._match(GT.keywords.while))return null;const i=this._updateNode(new Dw(null,null));return this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(GT.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_continuing_statement(){const i=this._currentLoop.length>0?this._currentLoop[this._currentLoop.length-1].id:-1;if(!this._match(GT.keywords.continuing))return null;const g=this._currentLine,m=this._compound_statement();return this._updateNode(new Fw(m,i),g)}_for_statement(){if(!this._match(GT.keywords.for))return null;this._consume(GT.tokens.paren_left,"Expected '('.");const i=this._updateNode(new Nw(null,null,null,null));return this._currentLoop.push(i),i.init=this._check(GT.tokens.semicolon)?null:this._for_init(),this._consume(GT.tokens.semicolon,"Expected ';'."),i.condition=this._check(GT.tokens.semicolon)?null:this._short_circuit_or_expression(),this._consume(GT.tokens.semicolon,"Expected ';'."),i.increment=this._check(GT.tokens.paren_right)?null:this._for_increment(),this._consume(GT.tokens.paren_right,"Expected ')'."),this._check(GT.tokens.attr)&&this._attribute(),i.body=this._compound_statement(),this._currentLoop.pop(),i}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(GT.keywords.var)){const i=this._variable_decl();if(null===i)throw this._error(this._peek(),"Variable declaration expected.");let g=null;return this._match(GT.tokens.equal)&&(g=this._short_circuit_or_expression()),this._updateNode(new Hw(i.name,i.type,i.storage,i.access,g),i.line)}if(this._match(GT.keywords.let)){const i=this._currentLine,g=this._consume(GT.tokens.name,"Expected name for let.").toString();let m=null;if(this._match(GT.tokens.colon)){const i=this._attribute();m=this._type_decl(),null!=m&&(m.attributes=i)}this._consume(GT.tokens.equal,"Expected '=' for let.");const _=this._short_circuit_or_expression();return this._updateNode(new zw(g,m,null,null,_),i)}if(this._match(GT.keywords.const)){const i=this._currentLine,g=this._consume(GT.tokens.name,"Expected name for const.").toString();let m=null;if(this._match(GT.tokens.colon)){const i=this._attribute();m=this._type_decl(),null!=m&&(m.attributes=i)}this._consume(GT.tokens.equal,"Expected '=' for const.");const _=this._short_circuit_or_expression();return null===m&&_ instanceof _T&&(m=_.type),this._updateNode(new Vw(g,m,null,null,_),i)}return null}_increment_decrement_statement(){const i=this._current,g=this._unary_expression();if(null==g)return null;if(!this._check(GT.increment_operators))return this._current=i,null;const m=this._consume(GT.increment_operators,"Expected increment operator");return this._updateNode(new qw(m.type===GT.tokens.plus_plus?Uw.increment:Uw.decrement,g))}_assignment_statement(){let i=null;const g=this._currentLine;if(this._check(GT.tokens.brace_right))return null;let m=this._match(GT.tokens.underscore);if(m||(i=this._unary_expression()),!m&&null==i)return null;const _=this._consume(GT.assignment_operators,"Expected assignment operator."),b=this._short_circuit_or_expression();return this._updateNode(new Xw(Gw.parse(_.lexeme),i,b),g)}_func_call_statement(){if(!this._check(GT.tokens.ident))return null;const i=this._currentLine,g=this._current,m=this._consume(GT.tokens.ident,"Expected function name."),_=this._argument_expression_list();return null===_?(this._current=g,null):this._updateNode(new Zw(m.lexeme,_),i)}_loop_statement(){if(!this._match(GT.keywords.loop))return null;this._check(GT.tokens.attr)&&this._attribute(),this._consume(GT.tokens.brace_left,"Expected '{' for loop.");const i=this._updateNode(new $w([],null));this._currentLoop.push(i);let g=this._statement();for(;null!==g;){if(Array.isArray(g))for(let m of g)i.body.push(m);else i.body.push(g);if(g instanceof Fw){i.continuing=g;break}g=this._statement()}return this._currentLoop.pop(),this._consume(GT.tokens.brace_right,"Expected '}' for loop."),i}_switch_statement(){if(!this._match(GT.keywords.switch))return null;const i=this._updateNode(new Yw(null,[]));if(this._currentLoop.push(i),i.condition=this._optional_paren_expression(),this._check(GT.tokens.attr)&&this._attribute(),this._consume(GT.tokens.brace_left,"Expected '{' for switch."),i.cases=this._switch_body(),null==i.cases||0==i.cases.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(GT.tokens.brace_right,"Expected '}' for switch."),this._currentLoop.pop(),i}_switch_body(){const i=[];let g=!1;for(;this._check([GT.keywords.default,GT.keywords.case]);){if(this._match(GT.keywords.case)){const m=this._case_selectors();for(const i of m)if(i instanceof MT){if(g)throw this._error(this._previous(),"Multiple default cases in switch statement.");g=!0;break}this._match(GT.tokens.colon),this._check(GT.tokens.attr)&&this._attribute(),this._consume(GT.tokens.brace_left,"Exected '{' for switch case.");const _=this._case_body();this._consume(GT.tokens.brace_right,"Exected '}' for switch case."),i.push(this._updateNode(new CT(m,_)))}if(this._match(GT.keywords.default)){if(g)throw this._error(this._previous(),"Multiple default cases in switch statement.");this._match(GT.tokens.colon),this._check(GT.tokens.attr)&&this._attribute(),this._consume(GT.tokens.brace_left,"Exected '{' for switch default.");const m=this._case_body();this._consume(GT.tokens.brace_right,"Exected '}' for switch default."),i.push(this._updateNode(new PT(m)))}}return i}_case_selectors(){const i=[];for(this._match(GT.keywords.default)?i.push(this._updateNode(new MT)):i.push(this._shift_expression());this._match(GT.tokens.comma);)this._match(GT.keywords.default)?i.push(this._updateNode(new MT)):i.push(this._shift_expression());return i}_case_body(){if(this._match(GT.keywords.fallthrough))return this._consume(GT.tokens.semicolon,"Expected ';'"),[];let i=this._statement();if(null==i)return[];i instanceof Array||(i=[i]);const g=this._case_body();return 0==g.length?i:[...i,g[0]]}_if_statement(){if(!this._match(GT.keywords.if))return null;const i=this._currentLine,g=this._optional_paren_expression();this._check(GT.tokens.attr)&&this._attribute();const m=this._compound_statement();let _=[];this._match_elseif()&&(this._check(GT.tokens.attr)&&this._attribute(),_=this._elseif_statement(_));let b=null;return this._match(GT.keywords.else)&&(this._check(GT.tokens.attr)&&this._attribute(),b=this._compound_statement()),this._updateNode(new Qw(g,m,_,b),i)}_match_elseif(){return this._tokens[this._current].type===GT.keywords.else&&this._tokens[this._current+1].type===GT.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(i=[]){const g=this._optional_paren_expression(),m=this._compound_statement();return i.push(this._updateNode(new kT(g,m))),this._match_elseif()&&(this._check(GT.tokens.attr)&&this._attribute(),this._elseif_statement(i)),i}_return_statement(){if(!this._match(GT.keywords.return))return null;const i=this._short_circuit_or_expression();return this._updateNode(new Jw(i))}_short_circuit_or_expression(){let i=this._short_circuit_and_expr();for(;this._match(GT.tokens.or_or);)i=this._updateNode(new TT(this._previous().toString(),i,this._short_circuit_and_expr()));return i}_short_circuit_and_expr(){let i=this._inclusive_or_expression();for(;this._match(GT.tokens.and_and);)i=this._updateNode(new TT(this._previous().toString(),i,this._inclusive_or_expression()));return i}_inclusive_or_expression(){let i=this._exclusive_or_expression();for(;this._match(GT.tokens.or);)i=this._updateNode(new TT(this._previous().toString(),i,this._exclusive_or_expression()));return i}_exclusive_or_expression(){let i=this._and_expression();for(;this._match(GT.tokens.xor);)i=this._updateNode(new TT(this._previous().toString(),i,this._and_expression()));return i}_and_expression(){let i=this._equality_expression();for(;this._match(GT.tokens.and);)i=this._updateNode(new TT(this._previous().toString(),i,this._equality_expression()));return i}_equality_expression(){const i=this._relational_expression();return this._match([GT.tokens.equal_equal,GT.tokens.not_equal])?this._updateNode(new TT(this._previous().toString(),i,this._relational_expression())):i}_relational_expression(){let i=this._shift_expression();for(;this._match([GT.tokens.less_than,GT.tokens.greater_than,GT.tokens.less_than_equal,GT.tokens.greater_than_equal]);)i=this._updateNode(new TT(this._previous().toString(),i,this._shift_expression()));return i}_shift_expression(){let i=this._additive_expression();for(;this._match([GT.tokens.shift_left,GT.tokens.shift_right]);)i=this._updateNode(new TT(this._previous().toString(),i,this._additive_expression()));return i}_additive_expression(){let i=this._multiplicative_expression();for(;this._match([GT.tokens.plus,GT.tokens.minus]);)i=this._updateNode(new TT(this._previous().toString(),i,this._multiplicative_expression()));return i}_multiplicative_expression(){let i=this._unary_expression();for(;this._match([GT.tokens.star,GT.tokens.forward_slash,GT.tokens.modulo]);)i=this._updateNode(new TT(this._previous().toString(),i,this._unary_expression()));return i}_unary_expression(){return this._match([GT.tokens.minus,GT.tokens.bang,GT.tokens.tilde,GT.tokens.star,GT.tokens.and])?this._updateNode(new wT(this._previous().toString(),this._unary_expression())):this._singular_expression()}_singular_expression(){const i=this._primary_expression(),g=this._postfix_expression();return g&&(i.postfix=g),i}_postfix_expression(){if(this._match(GT.tokens.bracket_left)){const i=this._short_circuit_or_expression();this._consume(GT.tokens.bracket_right,"Expected ']'.");const g=this._updateNode(new xT(i)),m=this._postfix_expression();return m&&(g.postfix=m),g}if(this._match(GT.tokens.period)){const i=this._consume(GT.tokens.name,"Expected member name."),g=this._postfix_expression(),m=this._updateNode(new pT(i.lexeme));return g&&(m.postfix=g),m}return null}_getStruct(i){return this._context.aliases.has(i)?this._context.aliases.get(i).type:this._context.structs.has(i)?this._context.structs.get(i):null}_getType(i){const g=this._getStruct(i);if(null!==g)return g;switch(i){case"void":return sT.void;case"bool":return sT.bool;case"i32":return sT.i32;case"u32":return sT.u32;case"f32":return sT.f32;case"f16":return sT.f16;case"vec2f":return hT.vec2f;case"vec3f":return hT.vec3f;case"vec4f":return hT.vec4f;case"vec2i":return hT.vec2i;case"vec3i":return hT.vec3i;case"vec4i":return hT.vec4i;case"vec2u":return hT.vec2u;case"vec3u":return hT.vec3u;case"vec4u":return hT.vec4u;case"vec2h":return hT.vec2h;case"vec3h":return hT.vec3h;case"vec4h":return hT.vec4h;case"mat2x2f":return hT.mat2x2f;case"mat2x3f":return hT.mat2x3f;case"mat2x4f":return hT.mat2x4f;case"mat3x2f":return hT.mat3x2f;case"mat3x3f":return hT.mat3x3f;case"mat3x4f":return hT.mat3x4f;case"mat4x2f":return hT.mat4x2f;case"mat4x3f":return hT.mat4x3f;case"mat4x4f":return hT.mat4x4f;case"mat2x2h":return hT.mat2x2h;case"mat2x3h":return hT.mat2x3h;case"mat2x4h":return hT.mat2x4h;case"mat3x2h":return hT.mat3x2h;case"mat3x3h":return hT.mat3x3h;case"mat3x4h":return hT.mat3x4h;case"mat4x2h":return hT.mat4x2h;case"mat4x3h":return hT.mat4x3h;case"mat4x4h":return hT.mat4x4h;case"mat2x2i":return hT.mat2x2i;case"mat2x3i":return hT.mat2x3i;case"mat2x4i":return hT.mat2x4i;case"mat3x2i":return hT.mat3x2i;case"mat3x3i":return hT.mat3x3i;case"mat3x4i":return hT.mat3x4i;case"mat4x2i":return hT.mat4x2i;case"mat4x3i":return hT.mat4x3i;case"mat4x4i":return hT.mat4x4i;case"mat2x2u":return hT.mat2x2u;case"mat2x3u":return hT.mat2x3u;case"mat2x4u":return hT.mat2x4u;case"mat3x2u":return hT.mat3x2u;case"mat3x3u":return hT.mat3x3u;case"mat3x4u":return hT.mat3x4u;case"mat4x2u":return hT.mat4x2u;case"mat4x3u":return hT.mat4x3u;case"mat4x4u":return hT.mat4x4u}return null}_validateTypeRange(i,g){if("i32"===g.name){if(i<-2147483648||i>2147483647)throw this._error(this._previous(),`Value out of range for i32: ${i}. Line: ${this._currentLine}.`)}else if("u32"===g.name&&(i<0||i>4294967295))throw this._error(this._previous(),`Value out of range for u32: ${i}. Line: ${this._currentLine}.`)}_primary_expression(){if(this._match(GT.tokens.ident)){const i=this._previous().toString();if(this._check(GT.tokens.paren_left)){const g=this._argument_expression_list(),m=this._getType(i);return this._updateNode(null!==m?new gT(m,g):new mT(i,g))}if(this._context.constants.has(i)){const g=this._context.constants.get(i);return this._updateNode(new yT(i,g.value))}return this._updateNode(new AT(i))}if(this._match(GT.tokens.int_literal)){const i=this._previous().toString();let g=i.endsWith("i")||i.endsWith("i")?sT.i32:i.endsWith("u")||i.endsWith("U")?sT.u32:sT.x32;const m=parseInt(i);return this._validateTypeRange(m,g),this._updateNode(new _T(new FT(m,this._exec.getTypeInfo(g)),g))}if(this._match(GT.tokens.uint_literal)){const i=parseInt(this._previous().toString());return this._validateTypeRange(i,sT.u32),this._updateNode(new _T(new FT(i,this._exec.getTypeInfo(sT.u32)),sT.u32))}if(this._match([GT.tokens.decimal_float_literal,GT.tokens.hex_float_literal])){let i=this._previous().toString(),g=i.endsWith("h");g&&(i=i.substring(0,i.length-1));const m=parseFloat(i);this._validateTypeRange(m,g?sT.f16:sT.f32);const _=g?sT.f16:sT.f32;return this._updateNode(new _T(new FT(m,this._exec.getTypeInfo(_)),_))}if(this._match([GT.keywords.true,GT.keywords.false])){let i=this._previous().toString()===GT.keywords.true.rule;return this._updateNode(new _T(new FT(i?1:0,this._exec.getTypeInfo(sT.bool)),sT.bool))}if(this._check(GT.tokens.paren_left))return this._paren_expression();if(this._match(GT.keywords.bitcast)){this._consume(GT.tokens.less_than,"Expected '<'.");const i=this._type_decl();this._consume(GT.tokens.greater_than,"Expected '>'.");const g=this._paren_expression();return this._updateNode(new vT(i,g))}const i=this._type_decl(),g=this._argument_expression_list();return this._updateNode(new gT(i,g))}_argument_expression_list(){if(!this._match(GT.tokens.paren_left))return null;const i=[];do{if(this._check(GT.tokens.paren_right))break;const g=this._short_circuit_or_expression();i.push(g)}while(this._match(GT.tokens.comma));return this._consume(GT.tokens.paren_right,"Expected ')' for agument list"),i}_optional_paren_expression(){this._match(GT.tokens.paren_left);const i=this._short_circuit_or_expression();return this._match(GT.tokens.paren_right),i}_paren_expression(){this._consume(GT.tokens.paren_left,"Expected '('.");const i=this._short_circuit_or_expression();return this._consume(GT.tokens.paren_right,"Expected ')'."),i}_struct_decl(){if(!this._match(GT.keywords.struct))return null;const i=this._currentLine,g=this._consume(GT.tokens.ident,"Expected name for struct.").toString();this._consume(GT.tokens.brace_left,"Expected '{' for struct body.");const m=[];for(;!this._check(GT.tokens.brace_right);){const i=this._attribute(),g=this._consume(GT.tokens.name,"Expected variable name.").toString();this._consume(GT.tokens.colon,"Expected ':' for struct member type.");const _=this._attribute(),b=this._type_decl();null!=b&&(b.attributes=_),this._check(GT.tokens.brace_right)?this._match(GT.tokens.comma):this._consume(GT.tokens.comma,"Expected ',' for struct member."),m.push(this._updateNode(new OT(g,b,i)))}this._consume(GT.tokens.brace_right,"Expected '}' after struct body.");const _=this._updateNode(new lT(g,m,i,this._currentLine),i);return this._context.structs.set(g,_),_}_global_variable_decl(){const i=this._variable_decl();if(!i)return null;if(this._match(GT.tokens.equal)){const g=this._const_expression();i.value=g}if(null!==i.type&&i.value instanceof _T){if("x32"!==i.value.type.name&&i.type.getTypeName()!==i.value.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${i.value.type.name} to ${i.type.name}. Line:${this._currentLine}`);i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type),i.value.type=i.type}else null===i.type&&i.value instanceof _T&&(i.type="x32"===i.value.type.name?sT.i32:i.value.type,i.value.isScalar&&this._validateTypeRange(i.value.scalarValue,i.type));return i}_override_variable_decl(){const i=this._override_decl();return i&&this._match(GT.tokens.equal)&&(i.value=this._const_expression()),i}_global_const_decl(){var i;if(!this._match(GT.keywords.const))return null;const g=this._consume(GT.tokens.name,"Expected variable name"),m=this._currentLine;let _=null;if(this._match(GT.tokens.colon)){const i=this._attribute();_=this._type_decl(),null!=_&&(_.attributes=i)}let b=null;this._consume(GT.tokens.equal,"const declarations require an assignment");const T=this._short_circuit_or_expression();try{let i=[sT.f32],m=T.constEvaluate(this._exec,i);m instanceof FT&&this._validateTypeRange(m.value,i[0]),i[0]instanceof hT&&null===i[0].format&&m.typeInfo instanceof a&&null!==m.typeInfo.format&&("f16"===m.typeInfo.format.name?i[0].format=sT.f16:"f32"===m.typeInfo.format.name?i[0].format=sT.f32:"i32"===m.typeInfo.format.name?i[0].format=sT.i32:"u32"===m.typeInfo.format.name?i[0].format=sT.u32:"bool"===m.typeInfo.format.name?i[0].format=sT.bool:console.error(`TODO: impelement template format type ${m.typeInfo.format.name}`)),b=this._updateNode(new _T(m,i[0])),this._exec.context.setVariable(g.toString(),m)}catch(i){b=T}if(null!==_&&b instanceof _T){if("x32"!==b.type.name&&_.getTypeName()!==b.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${b.type.name} to ${_.name}. Line:${this._currentLine}`);b.type=_,b.isScalar&&this._validateTypeRange(b.scalarValue,b.type)}else null===_&&b instanceof _T&&(_=null!==(i=null==b?void 0:b.type)&&void 0!==i?i:sT.f32,_===sT.x32&&(_=sT.i32));const P=this._updateNode(new Vw(g.toString(),_,"","",b),m);return this._context.constants.set(P.name,P),P}_global_let_decl(){if(!this._match(GT.keywords.let))return null;const i=this._currentLine,g=this._consume(GT.tokens.name,"Expected variable name");let m=null;if(this._match(GT.tokens.colon)){const i=this._attribute();m=this._type_decl(),null!=m&&(m.attributes=i)}let _=null;if(this._match(GT.tokens.equal)&&(_=this._const_expression()),null!==m&&_ instanceof _T){if("x32"!==_.type.name&&m.getTypeName()!==_.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${_.type.name} to ${m.name}. Line:${this._currentLine}`);_.type=m}else null===m&&_ instanceof _T&&(m="x32"===_.type.name?sT.i32:_.type);return _ instanceof _T&&_.isScalar&&this._validateTypeRange(_.scalarValue,m),this._updateNode(new zw(g.toString(),m,"","",_),i)}_const_expression(){return this._short_circuit_or_expression()}_variable_decl(){if(!this._match(GT.keywords.var))return null;const i=this._currentLine;let g="",m="";this._match(GT.tokens.less_than)&&(g=this._consume(GT.storage_class,"Expected storage_class.").toString(),this._match(GT.tokens.comma)&&(m=this._consume(GT.access_mode,"Expected access_mode.").toString()),this._consume(GT.tokens.greater_than,"Expected '>'."));const _=this._consume(GT.tokens.name,"Expected variable name");let b=null;if(this._match(GT.tokens.colon)){const i=this._attribute();b=this._type_decl(),null!=b&&(b.attributes=i)}return this._updateNode(new Hw(_.toString(),b,g,m,null),i)}_override_decl(){if(!this._match(GT.keywords.override))return null;const i=this._consume(GT.tokens.name,"Expected variable name");let g=null;if(this._match(GT.tokens.colon)){const i=this._attribute();g=this._type_decl(),null!=g&&(g.attributes=i)}return this._updateNode(new Bw(i.toString(),g,null))}_diagnostic(){this._consume(GT.tokens.paren_left,"Expected '('");const i=this._consume(GT.tokens.ident,"Expected severity control name.");this._consume(GT.tokens.comma,"Expected ','");let g=this._consume(GT.tokens.ident,"Expected diagnostic rule name.").toString();return this._match(GT.tokens.period)&&(g+=`.${this._consume(GT.tokens.ident,"Expected diagnostic message.").toString()}`),this._consume(GT.tokens.paren_right,"Expected ')'"),this._updateNode(new tT(i.toString(),g))}_enable_directive(){const i=this._consume(GT.tokens.ident,"identity expected.");return this._updateNode(new Kw(i.toString()))}_requires_directive(){const i=[this._consume(GT.tokens.ident,"identity expected.").toString()];for(;this._match(GT.tokens.comma);){const g=this._consume(GT.tokens.ident,"identity expected.");i.push(g.toString())}return this._updateNode(new eT(i))}_type_alias(){const i=this._consume(GT.tokens.ident,"identity expected.");this._consume(GT.tokens.equal,"Expected '=' for type alias.");let g=this._type_decl();if(null===g)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(g.name)&&(g=this._context.aliases.get(g.name).type);const m=this._updateNode(new nT(i.toString(),g));return this._context.aliases.set(m.name,m),m}_type_decl(){if(this._check([GT.tokens.ident,...GT.texel_format,GT.keywords.bool,GT.keywords.f32,GT.keywords.i32,GT.keywords.u32])){const i=this._advance().toString();if(this._context.structs.has(i))return this._context.structs.get(i);if(this._context.aliases.has(i))return this._context.aliases.get(i).type;if(!this._getType(i)){const g=this._updateNode(new aT(i));return this._forwardTypeCount++,g}return this._updateNode(new sT(i))}let i=this._texture_sampler_types();if(i)return i;if(this._check(GT.template_types)){let i=this._advance().toString(),g=null,m=null;return this._match(GT.tokens.less_than)&&(g=this._type_decl(),m=null,this._match(GT.tokens.comma)&&(m=this._consume(GT.access_mode,"Expected access_mode for pointer").toString()),this._consume(GT.tokens.greater_than,"Expected '>' for type.")),this._updateNode(new hT(i,g,m))}if(this._match(GT.keywords.ptr)){let i=this._previous().toString();this._consume(GT.tokens.less_than,"Expected '<' for pointer.");const g=this._consume(GT.storage_class,"Expected storage_class for pointer");this._consume(GT.tokens.comma,"Expected ',' for pointer.");const m=this._type_decl();let _=null;return this._match(GT.tokens.comma)&&(_=this._consume(GT.access_mode,"Expected access_mode for pointer").toString()),this._consume(GT.tokens.greater_than,"Expected '>' for pointer."),this._updateNode(new cT(i,g.toString(),m,_))}const g=this._attribute();if(this._match(GT.keywords.array)){let m=null,_=-1;const b=this._previous();let T=null;if(this._match(GT.tokens.less_than)){m=this._type_decl(),this._context.aliases.has(m.name)&&(m=this._context.aliases.get(m.name).type);let g="";if(this._match(GT.tokens.comma)){T=this._shift_expression();try{g=T.constEvaluate(this._exec).toString(),T=null}catch(i){g="1"}}this._consume(GT.tokens.greater_than,"Expected '>' for array."),_=g?parseInt(g):0}const P=this._updateNode(new uT(b.toString(),g,m,_));return T&&this._deferArrayCountEval.push({arrayType:P,countNode:T}),P}return null}_texture_sampler_types(){if(this._match(GT.sampler_type))return this._updateNode(new fT(this._previous().toString(),null,null));if(this._match(GT.depth_texture_type))return this._updateNode(new fT(this._previous().toString(),null,null));if(this._match(GT.sampled_texture_type)||this._match(GT.multisampled_texture_type)){const i=this._previous();this._consume(GT.tokens.less_than,"Expected '<' for sampler type.");const g=this._type_decl();return this._consume(GT.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new fT(i.toString(),g,null))}if(this._match(GT.storage_texture_type)){const i=this._previous();this._consume(GT.tokens.less_than,"Expected '<' for sampler type.");const g=this._consume(GT.texel_format,"Invalid texel format.").toString();this._consume(GT.tokens.comma,"Expected ',' after texel format.");const m=this._consume(GT.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(GT.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new fT(i.toString(),g,m))}return null}_attribute(){let i=[];for(;this._match(GT.tokens.attr);){const g=this._consume(GT.attribute_name,"Expected attribute name"),m=this._updateNode(new ET(g.toString(),null));if(this._match(GT.tokens.paren_left)){if(m.value=this._consume(GT.literal_or_ident,"Expected attribute value").toString(),this._check(GT.tokens.comma)){this._advance();do{const i=this._consume(GT.literal_or_ident,"Expected attribute value").toString();m.value instanceof Array||(m.value=[m.value]),m.value.push(i)}while(this._match(GT.tokens.comma))}this._consume(GT.tokens.paren_right,"Expected ')'")}i.push(m)}return 0==i.length?null:i}},AS=class _t extends oS{constructor(i){super(),i&&this.update(i)}update(i){const g=(new mS).parse(i);this.updateAST(g)}};class DynamicBuffer{constructor(i,g){this.version=0,this.bindgroupMapping=i,this.pool=g,this.allocation={}}writeBuffer(i,g){const m=this.bindgroupMapping,_=this.allocation.gpuBuffer,b=this.pool.bufferAlignment;this.pool.alloc(this.allocation,m.totalSize),_!==this.allocation.gpuBuffer&&this.version++;let T=this.allocation.offset;const P=this.allocation.storage;for(let _=0;_<m.length;_++){const I=m[_],H=I.binding,W=I.members;if(W){g.addItem(H,T);for(let g=0;g<W.length;g++){const m=W[g],_=i[m.name];void 0===_&&console.warn(`Uniform value ${m.name} is not provided`);this._fillValue(m.type,P,T+m.offset,m.size,_)}T+=yb(I.size,b)}else if(I.resourceType===uw.Uniform){g.addItem(H,T);const m=i[I.name],_=hx(I.size)?I.size():I.size;this._fillValue(I.type,P,T,_,m),T+=yb(_,b)}}}_fillValue(i,g,m,_,b){const T=new Float32Array(g,m,_/4);if(px(b)){const g=function(i){return Ab[i.name]}(i);if(!g)return void T.set(b);for(let i=0;i<b.length;i++){T[4*Math.floor(i/3)+i%3]=b[i]}}else T[0]=b}dispose(){delete this.pool,delete this.allocation}}const yS=new Array(16);let _S=0;class Mesh{constructor(i,g,m={}){this._version=0,this._geometry=i,this._material=g,this.transparent=!!m.transparent,this.bloom=!!m.bloom,this.ssr=!!m.ssr,this._castShadow=ax(m.castShadow)||m.castShadow,this.needUpdateShadow=!1,this.picking=!!m.picking,this.disableVAO=!!m.disableVAO,this.uniforms={},this._localTransform=mA(new Array(16)),this._positionMatrix=mA(new Array(16)),this.properties={},this._dirtyUniforms=!0,this._dirtyGeometry=!0,Object.defineProperty(this,"uuid",{value:_S++}),_S>Number.MAX_VALUE-10&&(_S=0)}set material(i){this._material!==i&&this.setMaterial(i)}get material(){return this._material}set version(i){throw new Error("Mesh.version is read only.")}get version(){return this._version}get geometry(){return this._geometry}set geometry(i){this._geometry!==i&&(this._incrVersion(),this._dirtyGeometry=!0),this._geometry=i}set localTransform(i){this._prevTMat||(this._prevTMat=new Array(16)),Array.isArray(i)&&!BA(this._prevTMat,i)&&(this._incrVersion(),this._prevTMat=gA(this._prevTMat,i)),this._localTransform=i}get localTransform(){return hx(this._localTransform)?this._localTransform():this._localTransform}set positionMatrix(i){this._prevPMat||(this._prevPMat=new Array(16)),Array.isArray(i)&&!BA(this._prevPMat,i)&&(this._incrVersion(),this._prevPMat=gA(this._prevPMat,i)),this._positionMatrix=i}get positionMatrix(){return hx(this._positionMatrix)?this._positionMatrix():this._positionMatrix}get config(){return this._options||(this._options={}),this._options.transparent=this.transparent,this._options.castShadow=this.castShadow,this._options.bloom=this.bloom,this._options.ssr=this.ssr,this._options.picking=this.picking,this._options}get defines(){return this._getDefines()}set defines(i){this.setDefines(i)}get castShadow(){return this._castShadow&&(!this.material||!this.material.unlit)}set castShadow(i){this._castShadow=i}setMaterial(i){return this._material=i,this._dirtyUniforms=!0,delete this._materialVer,this.dirtyDefines=!0,this}setParent(i){return this.parent=i,this}setLocalTransform(i){return this.localTransform=i,this}setPositionMatrix(i){this.positionMatrix=i}setUniform(i,g){return this.uniforms[i]===g||(this._updateUniformState(i),this.uniforms[i]=g),this}setFunctionUniform(i,g){return this._updateUniformState(i),Object.defineProperty(this.uniforms,i,{enumerable:!0,get:g}),this}hasFunctionUniform(i){return!!this.uniforms&&Object.prototype.hasOwnProperty.call(this.uniforms,i)}_updateUniformState(i){void 0===this.uniforms[i]?this._dirtyUniforms=!0:(this._dirtyProps=this._dirtyProps||[],this._dirtyProps.push(i))}hasUniform(i){return void 0!==this.uniforms[i]}getUniform(i){return this.uniforms[i]}getDefines(){const i={};return cx(i,this._getDefines()),this._material&&this._geometry&&this._material.appendDefines(i,this._geometry),i}_getDefines(){this._defines||(this._defines={});const i=this._geometry,g=i.data[i.desc.positionAttribute],m=i.data[i.desc.uv0Attribute],_=i.data[i.desc.normalAttribute];return g&&g.quantization&&(this._defines.HAS_DRACO_POSITION=1),m&&m.quantization&&(this._defines.HAS_DRACO_TEXCOORD=1),_&&_.quantization&&(this._defines.HAS_DRACO_NORMAL=1),this._defines}setDefines(i){const g=this._bakDefines;return this._defines=i,this.dirtyDefines=!!g!=!!i||!function(i,g){if(!i&&!g)return!0;const m=Object.getOwnPropertyNames(i),_=Object.getOwnPropertyNames(g);if(m.length!==_.length)return!1;for(let _=0;_<m.length;_++)if(i[m[_]]!==g[m[_]])return!1;return!0}(g,i),this}hasSkinAnimation(){return this._material&&this._material.hasSkinAnimation()}_getDefinesKey(){return this._bakDefines=cx({},this._defines),this.dirtyDefines=!1,this._createDefinesKey(this.getDefines())}getCommandKey(i){if(!this._commandKey||this.dirtyDefines||this._material&&this._materialKeys!==this._material.getUniformKeys()){let g=this.geometry.getCommandKey(i)+"_"+this._getDefinesKey();g+="_"+(fx(this.getElements())?"count":"elements"),g+="_"+ +!!this.disableVAO,this._material&&(g+="_"+ +!!this._material.doubleSided),this._commandKey=g,this._material&&(this._materialKeys=this._material.getUniformKeys())}return this._commandKey}getRenderProps(i){const g=this.getUniforms(i);return g.meshProperties=this.properties,g.geometryProperties=this._geometry.properties,g.meshConfig=this.config,g.count=this._geometry.getDrawCount(),g.offset=this._geometry.getDrawOffset(),g.primitive=this._geometry.getPrimitive(),g}_getGeometryAttributes(i,g){return this._geometry.getREGLData(i,g,this.disableVAO)}appendGeoAttributes(i,g,m){cx(i,this._getGeometryAttributes(g,m)),yx(g)&&!this.disableVAO||(i.elements=this._geometry.getElements())}getUniforms(i){if(this._dirtyUniforms||this._dirtyGeometry||this._material&&this._materialVer!==this._material.version){this._uniformDescriptors=new Set,this._realUniforms={},this._prepareUniformsForDraco();const g=this.uniforms;for(const i in this.uniforms)if(_x(this.uniforms,i)){Object.getOwnPropertyDescriptor(g,i).get?(this._uniformDescriptors.add(i),Object.defineProperty(this._realUniforms,i,{enumerable:!0,configurable:!0,get:function(){return g[i]}})):this._realUniforms[i]=g[i]}if(this._material){const g=this._material.getUniforms(i);for(const i in g)if(_x(g,i)&&!_x(this._realUniforms,i)){Object.getOwnPropertyDescriptor(g,i).get?(this._uniformDescriptors.add(i),Object.defineProperty(this._realUniforms,i,{enumerable:!0,configurable:!0,get:function(){return g[i]}})):void 0===this._realUniforms[i]&&(this._realUniforms[i]=g[i])}}this._dirtyUniforms=!1,this._dirtyGeometry=!1,this._materialVer=this._material&&this._material.version,this._materialPropVer=this._material&&this._material.propVersion,this._dirtyProps=null}else if(this._dirtyProps||this._material&&this._material.propVersion!==this._materialPropVer){if(this._dirtyProps)for(const i of this._dirtyProps)this._realUniforms[i]=this.uniforms[i];if(this._material&&this._material.propVersion!==this._materialPropVer){const g=this._material.getUniforms(i);for(const i in g)if(_x(g,i)&&!this._uniformDescriptors.has(i)){Object.getOwnPropertyDescriptor(g,i).get||this._realUniforms[i]===g[i]||(this._realUniforms[i]=g[i])}this._materialPropVer=this._material.propVersion}this._dirtyProps=null}return this._realUniforms.modelMatrix=this.localTransform,this._realUniforms.positionMatrix=this.positionMatrix,this._realUniforms}_prepareUniformsForDraco(){const i=this._geometry,g=i.data[i.desc.positionAttribute],m=i.data[i.desc.uv0Attribute],_=i.data[i.desc.normalAttribute];if(g&&g.quantization){const i=g.quantization,m=i.range/(1<<i.quantizationBits);this._realUniforms.minValues_pos=i.minValues,this._realUniforms.gltf_u_dec_position_normConstant=m}if(m&&m.quantization){const i=m.quantization;this._realUniforms.minValues_tex=i.minValues;this._realUniforms.gltf_u_dec_texcoord_0_normConstant=i.range/(1<<i.quantizationBits)}if(_&&_.quantization){this._realUniforms.gltf_u_dec_normal_rangeConstant=(1<<_.quantization.quantizationBits)-1}}getMaterial(){return this._material}getElements(){return this._geometry.getElements()}dispose(){if(delete this._geometry,delete this._material,delete this._bindGroupCache,delete this._commandKeyCache,this.uniforms=null,this._meshBuffer){for(const i in this._meshBuffer)this._meshBuffer[i].dispose();delete this._meshBuffer}return this}isValid(){return this._geometry&&!this._geometry.isDisposed()&&(!this._material||!this._material.isDisposed())}getBoundingBox(){return this._geometry?(this._bbox||this.updateBoundingBox(),_A(yS,this.localTransform,this.positionMatrix),BA(yS,this._currentTransform)&&this._geometry.boundingBox.equals(this._geoBox)||this.updateBoundingBox(),this._bboxArr):null}updateBoundingBox(){const i=this._geometry.boundingBox;this._bbox||(this._bbox=new BoundingBox),this._bboxArr||(this._bboxArr=[[0,0,0],[0,0,0]]),this._geoBox||(this._geoBox=new BoundingBox),BoundingBox.copy(this._bbox,i),this._bbox.updateVertex(),"InstancedMesh"===this.constructor.name?(this._bbox.transform(this.localTransform,this.positionMatrix),this._currentTransform=_A(this._currentTransform||new Array(16),this.positionMatrix,this.localTransform)):(this._bbox.transform(this.positionMatrix,this.localTransform),this._currentTransform=_A(this._currentTransform||new Array(16),this.localTransform,this.positionMatrix)),BoundingBox.copy(this._geoBox,i),WA(this._bboxArr[0],this._bbox.min),WA(this._bboxArr[1],this._bbox.max)}_createDefinesKey(i){const g=[];for(const m in i)g.push(m,i[m]);return g.join(",")}_incrVersion(){this._version++}getMemorySize(){return(this.geometry&&this.geometry.getMemorySize()||0)+(this.material&&this.material.getMemorySize()||0)}getWorldTransform(){const i=this.parent;return i?_A(new Array(16),i.getWorldTransform(),this.localTransform):this.localTransform}writeDynamicBuffer(i,g,m,_,b){this._meshBuffer||(this._meshBuffer={});let T=this._meshBuffer[i];return T||(T=this._meshBuffer[i]=new DynamicBuffer(m,_)),T.writeBuffer(g,b),T}getBindGroup(i){return this._bindGroupCache||(this._bindGroupCache={}),this._bindGroupCache[i]}setBindGroup(i,g){return this._bindGroupCache[i]=g,this}getShaderFnValues(i){return this._commandKeyCache?this._commandKeyCache[i]:null}setShaderFnValues(i,g){return this._commandKeyCache||(this._commandKeyCache={}),this._commandKeyCache[i]=g,this}}class InstancedMesh extends Mesh{constructor(i,g,m,_,b={}){super(m,_,b),this._instanceCount=g,this.instancedData=i||{},this._checkInstancedProp(),this._vao={}}get instanceCount(){return this._instanceCount}set instanceCount(i){this._incrVersion(),this._instanceCount=i}getMemorySize(){return super.getMemorySize()+this._getInstanceMemorySize()}_getInstanceMemorySize(){let i=0;for(const g in this.instancedData)_x(this.instancedData,g)&&(i+=vx(this.instancedData[g]));return i}_checkInstancedProp(){for(const i in this.instancedData)if(this.geometry.data[i])throw new Error(`Duplicate attribute ${i} defined in geometry and instanced data`)}appendGeoAttributes(i,g,m){const _=this.geometry.getAttrData(m);if(yx(g)){const b=m.key;if(!this._vao[b]||this._vao[b].dirty){const i=m.map((i=>i.name)),T=[];for(let g=0;g<i.length;g++){const m=_[i[g]];T.push(m&&m.buffer||this.instancedData[i[g]])}const P={attributes:T,primitive:this.geometry.getPrimitive()};this._vao[b]?this._vao[b].vao(P):this._vao[b]={vao:g.vao(P)},delete this._vao[b].dirty}cx(i,this._vao[b])}else cx(i,_)}getDefines(){const i=super.getDefines();return i.HAS_INSTANCE=1,i}getCommandKey(i){return"i_"+super.getCommandKey(i)}updateInstancedData(i,g){const m=this.instancedData[i];if(this._incrVersion(),this.instancedData[i]=g,m&&m.buffer&&m.buffer.destroy&&m.buffer.destroy(),this._vao)for(const i in this._vao)this._vao[i].dirty=!0;return this}getInstancedBuffer(i){return this.instancedData[i]&&this.instancedData[i].buffer}generateInstancedBuffers(i){const g=!!i&&i.wgpu,m=this.instancedData,_=this.instanceCount,b={};for(const T in m){if(!m[T])continue;Array.isArray(m[T])?m[T]=new Float32Array(m[T]):g&&px(m[T])&&(m[T]=Geometry.padGPUBufferAlignment(m[T],_));const P=m[T];if(void 0!==P.buffer&&P.buffer.destroy)b[T]=P,b[T].divisor&&(b[T].divisor=1);else if(m[T].destroy)b[T]={buffer:m[T],divisor:1};else{b[T]={buffer:Geometry.createBuffer(i,{data:m[T],dimension:m[T].length/this._instanceCount},T),divisor:1}}}return this.instancedData=b,this}getRenderProps(i){const g=super.getRenderProps(i);return yx(i)||cx(g,this.instancedData),g.elements=this.geometry.getElements(),g.instances=this._instanceCount,g}disposeInstancedData(){const i=this.instancedData;if(i)for(const g in i){if(!i[g])continue;const m=i[g].destroy?i[g]:i[g].buffer;m.destroy&&!m[Lx]&&(m[Lx]=1,m.destroy())}this.instancedData={};for(const i in this._vao)this._vao[i].vao.destroy();this._vao={}}getBufferDescriptor(i){const g=[];for(const m in i){const _=i[m];g[_.location]=_}const m=this.instancedData,_=[];for(let b=0;b<g.length;b++){if(!g[b])continue;const T=g[b].geoAttrName,P=m[T];if(!P)continue;const I=Mb(P,i[T]);I.stepMode="instance",_[b]=I}return _}}const vS={};class Renderer{constructor(i){this.device=i}render(i,g,m,_){i.setUniforms(g||vS),i.setFramebuffer(_);let b=0;if(m){const{opaques:g,transparents:_}=m.getSortedMeshes();b+=i.draw(this.device,g),b+=i.draw(this.device,_)}else b+=i.draw(this.device);return b}clear(i){this.device.clear(i)}}const xS={getArrayBuffer:(i,g)=>xS.get(i,{responseType:"arraybuffer"},g),get:function(i,g,m){const _=xS._getClient(m);if(_.open("GET",i,!0),g){for(const i in g.headers)_.setRequestHeader(i,g.headers[i]);_.withCredentials="include"===g.credentials,g.responseType&&(_.responseType=g.responseType)}return _.send(null),_},_wrapCallback:function(i,g){return function(){if(4===i.readyState)if(200===i.status)if("arraybuffer"===i.responseType){0===i.response.byteLength?g(new Error("http status 200 returned without content.")):g(null,{data:i.response,cacheControl:i.getResponseHeader("Cache-Control"),expires:i.getResponseHeader("Expires"),contentType:i.getResponseHeader("Content-Type")})}else g(null,i.responseText);else g(new Error(i.statusText+","+i.status))}},_getClient:function(i){let g;try{g=new XMLHttpRequest}catch(i){try{g=new ActiveXObject("Msxml2.XMLHTTP")}catch(i){try{g=new ActiveXObject("Microsoft.XMLHTTP")}catch(i){}}}return g.onreadystatechange=xS._wrapCallback(g,i),g}};class InnerResourceLoader{constructor(i,g){this.defaultTexture=i,this.defaultCubeTexture=new Array(6),this.urlModifier=g,this.resources={}}setURLModifier(i){this.urlModifier=i}get(i){return Array.isArray(i)?this._loadImages(i):this._loadImage(i)}getArrayBuffer(i){if(Array.isArray(i)){const g=i.map((i=>this.getArrayBuffer(i)));return Promise.all(g)}return new Promise(((g,m)=>{let _=i;this.urlModifier&&(_=this.urlModifier(i)),xS.getArrayBuffer(_,((_,b)=>{_?m(_):g({url:i,data:b})}))}))}disposeRes(i){return Array.isArray(i)?i.forEach((i=>this._disposeOne(i))):this._disposeOne(i),this}isLoading(){return this._count&&this._count>0}getDefaultTexture(i){return Array.isArray(i)?this._getBlankTextures(i.length):this.defaultTexture}_disposeOne(i){const g=this.resources;g[i]&&(g[i].count--,g[i].count<=0&&delete g[i])}_loadImage(i){const g=this.resources;if(g[i])return Promise.resolve({url:i,data:g[i].image});return new Promise(((m,_)=>{const b=new Image;b.crossOrigin="anonymous",b.onload=function(){g[i]={image:b,count:1},m({url:i,data:b})},b.onerror=function(i){_(i)},b.onabort=function(){_(`image(${i}) loading aborted.`)},b.src=this.urlModifier?this.urlModifier(i):i}))}_loadImages(i){const g=i.map((i=>this._loadImage(i)));return Promise.all(g)}_getBlankTextures(i){const g=new Array(i);for(let i=0;i<6;i++)g.push(this.defaultTexture);return g}}class ResourceLoader extends(Rx(InnerResourceLoader)){}const bS=[0,0,0],wS=[0,0,0];let TS,SS=0;function MS(i,g){return oy(bS,i.geometry.boundingBox.getCenter(),i.localTransform),oy(wS,g.geometry.boundingBox.getCenter(),g.localTransform),dy(wS,TS)-dy(bS,TS)}class Scene{constructor(i){this._id=SS++,this.sortedMeshes={},this.setMeshes(i),this.dirty()}setMeshes(i){if(this.clear(),!i||Array.isArray(i)&&!i.length||i===this.meshes)return this;i=Array.isArray(i)?i:[i],this.meshes=[];for(let g=0;g<i.length;g++){const m=i[g];m&&(m._scenes=m._scenes||{},m._scenes[this._id]=1,this.meshes.push(m))}return this.dirty(),this}addMesh(i){if(!i||Array.isArray(i)&&!i.length)return this;if(Array.isArray(i))i.forEach((i=>{const g=i._scenes=i._scenes||{};g[this._id]||(g[this._id]=1,this.meshes.push(i),this.dirty())}));else{const g=i._scenes=i._scenes||{};g[this._id]||(g[this._id]=1,this.meshes.push(i),this.dirty())}return this}removeMesh(i){if(!i||Array.isArray(i)&&!i.length)return this;if(Array.isArray(i)){let g=!1;for(let m=0;m<i.length;m++){const _=i[m]._scenes;_&&_[this._id]&&(g=!0,this.dirty(),delete _[this._id])}g&&(this.meshes=this.meshes.filter((g=>i.indexOf(g)<0)))}else{const g=i._scenes;if(!g||!g[this._id])return this;const m=this.meshes.indexOf(i);m>=0&&this.meshes.splice(m,1),delete g[this._id],this.dirty()}return this}getMeshes(){return this.meshes||[]}clear(){if(this.meshes)for(let i=0;i<this.meshes.length;i++)delete this.meshes[i]._scenes[this._id];return this.meshes=[],this.sortedMeshes.opaques=[],this.sortedMeshes.transparents=[],this}dirty(){return this._dirty=!0,this}sortMeshes(i){const g=this.meshes;this.sortFunction&&g.sort(this.sortFunction);let m=this.sortedMeshes.transparents;if(this._dirty){const i=this.sortedMeshes.opaques=[];m=this.sortedMeshes.transparents=[];for(let _=0,b=g.length;_<b;_++)g[_].transparent?m.push(g[_]):i.push(g[_])}i&&m.length>1&&(TS=i,m.sort(MS)),this._dirty=!1}getSortedMeshes(){return this._dirty&&this.sortMeshes(),this.sortedMeshes||{}}}const CS=String.fromCharCode;function PS(i,g,m,_){if(i[3]>0){const b=Math.pow(2,i[3]-128-8+_);g[m+0]=i[0]*b,g[m+1]=i[1]*b,g[m+2]=i[2]*b}else g[m+0]=0,g[m+1]=0,g[m+2]=0;return g[m+3]=1,g}function IS(i,g){g[0]=i[0],g[1]=i[1],g[2]=i[2],g[3]=i[3]}function kS(i,g,m,_){let b=0,T=0,P=_;for(;P>0;)if(i[T][0]=g[m++],i[T][1]=g[m++],i[T][2]=g[m++],i[T][3]=g[m++],1===i[T][0]&&1===i[T][1]&&1===i[T][2]){for(let g=i[T][3]<<b>>>0;g>0;g--)IS(i[T-1],i[T]),T++,P--;b+=8}else T++,P--,b=0;return m}function OS(i,g,m,_){if(_<8|_>32767)return kS(i,g,m,_);let b=g[m++];if(2!==b)return kS(i,g,m-1,_);if(i[0][1]=g[m++],i[0][2]=g[m++],b=g[m++],(i[0][2]<<8>>>0|b)>>>0!==_)return null;for(let b=0;b<4;b++)for(let T=0;T<_;){let _=g[m++];if(_>128){_=(127&_)>>>0;const P=g[m++];for(;_--;)i[T++][b]=P}else for(;_--;)i[T++][b]=g[m++]}return m}function ES(i,g=0){const m=new Uint8Array(i),_=m.length;if("#?"!==function(i,g,m){let _="";for(let b=g;b<m;b++)_+=CS(i[b]);return _}(m,0,2))return null;for(var b=2;b<_&&("\n"!==CS(m[b])||"\n"!==CS(m[b+1]));b++);if(b>=_)return null;b+=2;let T="";for(;b<_;b++){const i=CS(m[b]);if("\n"===i)break;T+=i}const P=T.split(" "),I=parseInt(P[1]),H=parseInt(P[3]);if(!H||!I)return null;let W=b+1;const q=[];for(let i=0;i<H;i++){q[i]=[];for(let g=0;g<4;g++)q[i][g]=0}const $=new Float32Array(H*I*4);let ye=0;for(let i=0;i<I;i++){if(W=OS(q,m,W,H),!W)return null;for(let i=0;i<H;i++)PS(q[i],$,ye,g),ye+=4}return{width:H,height:I,pixels:$}}const RS=LS();function LS(){const i=new ArrayBuffer(4),g=new Float32Array(i),m=new Uint32Array(i),_=new Uint32Array(512),b=new Uint32Array(512);for(let i=0;i<256;++i){const g=i-127;g<-27?(_[i]=0,_[256|i]=32768,b[i]=24,b[256|i]=24):g<-14?(_[i]=1024>>-g-14,_[256|i]=1024>>-g-14|32768,b[i]=-g-1,b[256|i]=-g-1):g<=15?(_[i]=g+15<<10,_[256|i]=g+15<<10|32768,b[i]=13,b[256|i]=13):g<128?(_[i]=31744,_[256|i]=64512,b[i]=24,b[256|i]=24):(_[i]=31744,_[256|i]=64512,b[i]=13,b[256|i]=13)}const T=new Uint32Array(2048),P=new Uint32Array(64),I=new Uint32Array(64);for(let i=1;i<1024;++i){let g=i<<13,m=0;for(;!(8388608&g);)g<<=1,m-=8388608;g&=-8388609,m+=947912704,T[i]=g|m}for(let i=1024;i<2048;++i)T[i]=939524096+(i-1024<<13);for(let i=1;i<31;++i)P[i]=i<<23;P[31]=1199570944,P[32]=2147483648;for(let i=33;i<63;++i)P[i]=2147483648+(i-32<<23);P[63]=3347054592;for(let i=1;i<64;++i)32!==i&&(I[i]=1024);return{floatView:g,uint32View:m,baseTable:_,shiftTable:b,mantissaTable:T,exponentTable:P,offsetTable:I}}const DS={toHalfFloat:function(i){Math.abs(i)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),i=Ax(i,-65504,65504),RS.floatView[0]=i;const g=RS.uint32View[0],m=g>>23&511;return RS.baseTable[m]+((8388607&g)>>RS.shiftTable[m])},fromHalfFloat:function(i){const g=i>>10;return RS.uint32View[0]=RS.mantissaTable[RS.offsetTable[g]+(1023&i)]+RS.exponentTable[g],RS.floatView[0]}},FS=9728,NS=9729,HS=9987;var BS=Object.freeze({__proto__:null,GL_LINEAR:NS,GL_LINEAR_MIPMAP_LINEAR:9987,GL_NEAREST:FS,MAG_FILTER:10240,MIN_FILTER:10241});class Texture2D extends AbstractTexture{constructor(){super(...arguments),this._version=0}get version(){return this._version}set version(i){throw new Error("Texture2D.version is read only.")}onLoad({data:i}){const g=this.config;if(g){if(g.hdr){if(!(i=ES(i.data,0)))throw new Error("Invalid hdr data"+(g.url?":"+g.url:""));{const m=new Uint16Array(i.pixels.length);for(let g=0;g<i.pixels.length;g++)m[g]=Math.min(DS.toHalfFloat(i.pixels[g]),65504);g.data=m,g.type="float16",g.colorSpace="browser",g.min="linear",g.mag="linear"}}else g.data=i;g.width=g.width||i.width,g.height=g.height||i.height,this._regl&&this._checkNPOT(this._regl),this._update()}}setConfig(i){const g=i.data;i.image=g,i.width=i.width||g.width,i.height=i.height||g.height,this.config=i,this.dirty=!!this._texture}_update(){this._texture&&!this._texture[Lx]&&(this._version++,hx(this._texture)?this._texture(this.config):this._texture.update(this.config)),this.dirty=!1}setMinFilter(i){this.config.min=Gb(i),this._texture&&this._texture.updateFilter&&this._texture.updateFilter(),this._texture&&this._texture.texParameteri&&this._texture.texParameteri(10241,i)}setMagFilter(i){this.config.mag=Vb(i),this._texture&&this._texture.updateFilter&&this._texture.updateFilter(),this._texture&&this._texture.texParameteri&&this._texture.texParameteri(10240,i)}createREGLTexture(i){if(this._regl=i,this._checkNPOT(i),px(this.config.data)||px(this.config.mipmap)){const g=$b(i,this.config);return g[Nx]||(g[Nx]=0),g[Nx]++,g}return i.texture(this.config)}_checkNPOT(i){const g=this.config;g.data&&this._needPowerOf2(i)&&(g.data instanceof Image?(g.data=kx(g.data),g.width=g.data.width,g.height=g.data.height):g.hdr||!px(g.data)||Px(g.width)&&Px(g.height)||(g.data=kx(g.data,g.width,g.height),g.width=g.data.width,g.height=g.data.height))}_needPowerOf2(i){if(Ox(i))return!1;const g=this.config;return g.wrap&&"clamp"!==g.wrap||g.wrapS&&"clamp"!==g.wrapS||g.wrapT&&"clamp"!==g.wrapT||g.min&&"nearest"!==g.min&&"linear"!==g.min}}class Plane extends Geometry{constructor(i){super({aPosition:new(mx(i=i||0))([-1,-1,i,1,-1,i,-1,1,i,1,1,i]),aNormal:new Int8Array([0,0,1,0,0,1,0,0,1,0,0,1])},new Uint16Array([0,1,3,3,2,0]))}}const zS={vsm_shadow_vert:"\nuniform mat4 shadow_lightProjViewModelMatrix;\nvarying vec4 shadow_vLightSpacePos;\nvoid shadow_computeShadowPars(vec4 position) {\n    shadow_vLightSpacePos = shadow_lightProjViewModelMatrix * position;\n}",vsm_shadow_frag:"\nuniform sampler2D shadow_shadowMap;\nuniform float shadow_opacity;\nuniform vec3 shadow_color;\n#if defined(USE_ESM)\n    uniform float esm_shadow_threshold;\n#endif\nvarying vec4 shadow_vLightSpacePos;\n#ifdef PACK_FLOAT\n    #include <common_pack_float>\n#endif\n#if defined(USE_ESM)\nfloat esm(vec3 projCoords, vec4 shadowTexel) {\n    float compare = projCoords.z;\n    float c = 120.0;\n    #ifdef PACK_FLOAT\n        float depth = common_decodeDepth(shadowTexel);\n        if (depth >= 1.0 - 1E-6 || compare <= depth) {\n            return 1.0;\n        }\n    #else\n        float depth = shadowTexel.r;\n    #endif\n    depth = exp(-c * min(compare - depth, 0.05));\n    return clamp(depth, esm_shadow_threshold, 1.0);\n}\n#endif\nfloat shadow_computeShadow_coeff(sampler2D shadowMap, vec3 projCoords) {\n    vec2 uv = projCoords.xy;\n    vec4 shadowTexel = texture2D(shadowMap, uv);\n    #if defined(USE_ESM)\n        float esm_coeff = esm(projCoords, shadowTexel);\n        float coeff = esm_coeff * esm_coeff;\n    #endif\n    return 1.0 - (1.0 - coeff) * shadow_opacity;\n}\nfloat shadow_computeShadow() {\n    vec3 projCoords = shadow_vLightSpacePos.xyz / shadow_vLightSpacePos.w;\n    projCoords = projCoords * 0.5 + 0.5;\n    if(projCoords.z >= 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || projCoords.y < 0.0 || projCoords.y > 1.0) return 1.0;\n    return shadow_computeShadow_coeff(shadow_shadowMap, projCoords);\n}\nvec3 shadow_blend(vec3 color, float coeff) {\n    color = color * coeff + shadow_color * shadow_opacity * (1.0 - coeff);\n    return color;\n}",fbo_picking_vert:"\n#ifdef ENABLE_PICKING\n#if HAS_PICKING_ID == 1\n    attribute float aPickingId;\n#elif HAS_PICKING_ID == 2\n    uniform float uPickingId;\n#endif\n    varying float vPickingId;\n    varying float vFbo_picking_viewZ;\n    varying float vFbo_picking_visible;\n#endif\n    varying float vFbo_picking_fragDepth;\nvoid fbo_picking_setData(float viewPosZ, bool visible) {\n    #ifdef ENABLE_PICKING\n    #if HAS_PICKING_ID == 1\n        vPickingId = aPickingId;\n    #elif HAS_PICKING_ID == 2\n        vPickingId = uPickingId;\n    #endif\n        vFbo_picking_viewZ = viewPosZ;\n        vFbo_picking_visible = visible ? 1.0 : 0.0;\n    #endif\n    vFbo_picking_fragDepth = viewPosZ + 1.0;\n}",common_pack_float:"const float COMMON_FLOAT_MAX =  1.70141184e38;\nconst float COMMON_FLOAT_MIN = 1.17549435e-38;\nvec4 common_unpackFloat(highp float v) {\n    highp float av = abs(v);\n    if(av < COMMON_FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > COMMON_FLOAT_MAX) {\n        return vec4(127.0, 128.0, 0.0, 0.0) / 255.0;\n    } else if(v < -COMMON_FLOAT_MAX) {\n        return vec4(255.0, 128.0, 0.0, 0.0) / 255.0;\n    }\n    highp vec4 c = vec4(0,0,0,0);\n    highp float e = floor(log2(av));\n    highp float m = av * pow(2.0, -e) - 1.0;\n    c[1] = floor(128.0 * m);\n    m -= c[1] / 128.0;\n    c[2] = floor(32768.0 * m);\n    m -= c[2] / 32768.0;\n    c[3] = floor(8388608.0 * m);\n    highp float ebias = e + 127.0;\n    c[0] = floor(ebias / 2.0);\n    ebias -= c[0] * 2.0;\n    c[1] += floor(ebias) * 128.0;\n    c[0] += 128.0 * step(0.0, -v);\n    return c / 255.0;\n}\nvec4 common_encodeDepth(const in float depth) {\n    float alpha = 1.0;\n    vec4 pack = vec4(0.0);\n    pack.a = alpha;\n    const vec3 code = vec3(1.0, 255.0, 65025.0);\n    pack.rgb = vec3(code * depth);\n    pack.gb = fract(pack.gb);\n    pack.rg -= pack.gb * (1.0 / 256.0);\n    pack.b -= mod(pack.b, 4.0 / 255.0);\n    return pack;\n}\nfloat common_decodeDepth(const in vec4 pack) {\n    return pack.r + pack.g / 255.0;\n}\nvec4 encodeFloat32(float f) {\n    float e =5.0;\n    float F = abs(f);\n    float Sign = step(0.0,-f);\n    float Exponent = floor(log2(F));\n    float Mantissa = (exp2(- Exponent) * F);\n    Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n    vec4 rgba;\n    rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n    rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n    rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n    rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n    return rgba / 255.0;\n}\nfloat decodeFloat32(vec4 rgba) {\n    rgba *= 255.0;\n    float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n    return Result;\n}",invert_matrix:"mat4 invert_matrix(mat4 matrix) {\n    #if __VERSION__ == 300\n        return inverse(matrix);\n    #else\n        vec4 vector1 = matrix[0], vector2 = matrix[1], vector3 = matrix[2], vector4 = matrix[3];\n        float a00 = vector1.x, a01 = vector1.y, a02 = vector1.z, a03 = vector1.w;\n        float a10 = vector2.x, a11 = vector2.y, a12 = vector2.z, a13 = vector2.w;\n        float a20 = vector3.x, a21 = vector3.y, a22 = vector3.z, a23 = vector3.w;\n        float a30 = vector4.x, a31 = vector4.y, a32 = vector4.z, a33 = vector4.w;\n        float b00 = a00 * a11 - a01 * a10;\n        float b01 = a00 * a12 - a02 * a10;\n        float b02 = a00 * a13 - a03 * a10;\n        float b03 = a01 * a12 - a02 * a11;\n        float b04 = a01 * a13 - a03 * a11;\n        float b05 = a02 * a13 - a03 * a12;\n        float b06 = a20 * a31 - a21 * a30;\n        float b07 = a20 * a32 - a22 * a30;\n        float b08 = a20 * a33 - a23 * a30;\n        float b09 = a21 * a32 - a22 * a31;\n        float b10 = a21 * a33 - a23 * a31;\n        float b11 = a22 * a33 - a23 * a32;\n        float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n        det = 1.0 / det;\n        mat4 m = mat4(\n            (a11 * b11 - a12 * b10 + a13 * b09) * det,\n            (a02 * b10 - a01 * b11 - a03 * b09) * det,\n            (a31 * b05 - a32 * b04 + a33 * b03) * det,\n            (a22 * b04 - a21 * b05 - a23 * b03) * det,\n            (a12 * b08 - a10 * b11 - a13 * b07) * det,\n            (a00 * b11 - a02 * b08 + a03 * b07) * det,\n            (a32 * b02 - a30 * b05 - a33 * b01) * det,\n            (a20 * b05 - a22 * b02 + a23 * b01) * det,\n            (a10 * b10 - a11 * b08 + a13 * b06) * det,\n            (a01 * b08 - a00 * b10 - a03 * b06) * det,\n            (a30 * b04 - a31 * b02 + a33 * b00) * det,\n            (a21 * b02 - a20 * b04 - a23 * b00) * det,\n            (a11 * b07 - a10 * b09 - a12 * b06) * det,\n            (a00 * b09 - a01 * b07 + a02 * b06) * det,\n            (a31 * b01 - a30 * b03 - a32 * b00) * det,\n            (a20 * b03 - a21 * b01 + a22 * b00) * det\n        );\n        return m;\n    #endif\n}\nmat4 transpose_matrix(mat4 matrix) {\n    #if __VERSION__ == 300\n        return transpose(matrix);\n    #else\n        vec4 vector1 = matrix[0], vector2 = matrix[1], vector3 = matrix[2], vector4 = matrix[3];\n        float a01 = vector1.y, a02 = vector1.z, a03 = vector1.w;\n        float a12 = vector2.z, a13 = vector2.w;\n        float a23 = vector3.w;\n        mat4 m = mat4(\n            vector1.x,\n            vector2.x,\n            vector3.x,\n            vector4.x,\n            a01,\n            vector2.y,\n            vector3.y,\n            vector4.y,\n            a02,\n            a12,\n            vector3.z,\n            vector4.z,\n            a03,\n            a13,\n            a23,\n            vector4.w\n        );\n        return m;\n    #endif\n}",get_output:"#include <invert_matrix>\n#include <draco_decode_vert>\n#ifdef HAS_INSTANCE\n    #include <instance_vert>\n    #ifdef HAS_INSTANCE_COLOR\n        varying vec4 vInstanceColor;\n    #endif\n#endif\n#ifdef HAS_SKIN\n    uniform int skinAnimation;\n    #include <skin_vert>\n#endif\n#include <mask_vert>\n#ifdef HAS_MORPH\n    attribute vec3 POSITION0;\n    attribute vec3 POSITION1;\n    attribute vec3 POSITION2;\n    attribute vec3 POSITION3;\n    attribute vec3 POSITION4;\n    attribute vec3 POSITION5;\n    attribute vec3 POSITION6;\n    attribute vec3 POSITION7;\n    #ifdef HAS_MORPHNORMALS\n        attribute vec3 NORMAL0;\n        attribute vec3 NORMAL1;\n        attribute vec3 NORMAL2;\n        attribute vec3 NORMAL3;\n    #endif\n    uniform vec4 morphWeights1;\n    uniform vec4 morphWeights2;\n#endif\n#ifdef HAS_TERRAIN_ALTITUDE\nattribute float aTerrainAltitude;\n#endif\nmat4 getPositionMatrix() {\n    mat4 worldMatrix;\n    #ifdef HAS_INSTANCE\n        #ifdef HAS_INSTANCE_COLOR\n            vInstanceColor = instance_getInstanceColor();\n        #endif\n        mat4 attributeMatrix = instance_getAttributeMatrix();\n        #ifdef HAS_SKIN\n            if (skinAnimation == 1) {\n                worldMatrix = attributeMatrix * positionMatrix * skin_getSkinMatrix();\n            } else {\n                worldMatrix = attributeMatrix * positionMatrix;\n            }\n        #else\n            worldMatrix = attributeMatrix * positionMatrix;\n        #endif\n    #else\n        #ifdef HAS_SKIN\n            if (skinAnimation == 1) {\n                worldMatrix = skin_getSkinMatrix() * positionMatrix;\n            } else {\n                worldMatrix = positionMatrix;\n            }\n        #else\n            worldMatrix = positionMatrix;\n        #endif\n    #endif\n    return worldMatrix;\n}\n#ifdef HAS_MIN_ALTITUDE\n    uniform float minAltitude;\n#endif\n#ifdef HAS_TERRAIN_FLAT_MASK\n    uniform sampler2D flatMask;\n#endif\nvec4 getPosition(vec3 aPosition) {\n    vec3 position = decode_getPosition(aPosition);\n    #ifdef HAS_MORPH\n        vec4 POSITION = vec4(position + morphWeights1[0] * POSITION0 + morphWeights1[1] * POSITION1 + morphWeights1[2] * POSITION2 + morphWeights1[3] * POSITION3\n        + morphWeights2[0] * POSITION4 + morphWeights2[1] * POSITION5 + morphWeights2[2] * POSITION6 + morphWeights2[3] * POSITION7\n        , 1.0);\n    #else\n        vec4 POSITION = vec4(position, 1.0);\n    #endif\n    #ifdef HAS_TERRAIN_ALTITUDE\n        POSITION.z += aTerrainAltitude * 100.0;\n    #endif\n    #ifdef HAS_TERRAIN_FLAT_MASK\n        vec2 uv = aTexCoord;\n        uv.y = 1.0 - uv.y;\n        vec4 encodedHeight = texture2D(flatMask, uv);\n        if (length(encodedHeight) < 2.0) {\n            float maskHeight = decodeFloat32(encodedHeight);\n            POSITION.z = min(POSITION.z, maskHeight);\n        }\n    #endif\n    #ifdef HAS_MIN_ALTITUDE\n        POSITION.z += minAltitude * 100.0;\n    #endif\n    return POSITION;\n}\nvec3 appendMorphNormal(vec3 NORMAL) {\n    #ifdef HAS_MORPHNORMALS\n        vec3 normal = NORMAL + morphWeights1[0] * NORMAL0 + morphWeights1[1] * NORMAL1 + morphWeights1[2] * NORMAL2 + morphWeights1[3] * NORMAL3;\n    #else\n        vec3 normal = NORMAL;\n    #endif\n    return normal;\n}",instance_vert:"attribute vec4 instance_vectorA;\nattribute vec4 instance_vectorB;\nattribute vec4 instance_vectorC;\n#ifdef HAS_INSTANCE_TERRAIN_ALTITUDE\nattribute float aTerrainAltitude;\nuniform float terrainAltitudeScale;\n#endif\nmat4 instance_getAttributeMatrix() {\n    mat4 mat =  mat4(\n        instance_vectorA.x, instance_vectorB.x, instance_vectorC.x, 0.0,\n        instance_vectorA.y, instance_vectorB.y, instance_vectorC.y, 0.0,\n        instance_vectorA.z, instance_vectorB.z, instance_vectorC.z, 0.0,\n        instance_vectorA.w, instance_vectorB.w, instance_vectorC.w, 1.0\n    );\n    #ifdef HAS_INSTANCE_TERRAIN_ALTITUDE\n        mat4 terrainMat = mat4(\n            1., 0., 0., 0.,\n            0., 1., 0., 0.,\n            0., 0., 1., 0.,\n            0., 0., aTerrainAltitude * terrainAltitudeScale, 1.\n        );\n        mat = terrainMat * mat;\n    #endif\n    return mat;\n}\n#ifdef HAS_INSTANCE_HIGHLIGHT\n    attribute vec4 highlight_color;\n#endif\n#ifdef HAS_INSTANCE_COLOR\n   \n    attribute vec4 instance_color;\n    vec4 instance_getInstanceColor() {\n        vec4 color = instance_color;\n        #ifdef HAS_INSTANCE_HIGHLIGHT\n            color = instance_color * highlight_color;\n        #endif\n        return color;\n    }\n#endif",skin_vert:"attribute vec4 WEIGHTS_0;\nattribute vec4 JOINTS_0;\nuniform sampler2D jointTexture;\nuniform vec2 jointTextureSize;\nuniform float numJoints;\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\nmat4 skin_getBoneMatrix(float jointNdx) {\n    float v = (jointNdx + 0.5) / numJoints;\n    return mat4(\n        texture2D(jointTexture, vec2(ROW0_U, v)),\n        texture2D(jointTexture, vec2(ROW1_U, v)),\n        texture2D(jointTexture, vec2(ROW2_U, v)),\n        texture2D(jointTexture, vec2(ROW3_U, v)));\n}\nmat4 skin_getSkinMatrix() {\n        mat4 skinMatrix = skin_getBoneMatrix(JOINTS_0[0]) * WEIGHTS_0[0] +\n                        skin_getBoneMatrix(JOINTS_0[1]) * WEIGHTS_0[1] +\n                        skin_getBoneMatrix(JOINTS_0[2]) * WEIGHTS_0[2] +\n                        skin_getBoneMatrix(JOINTS_0[3]) * WEIGHTS_0[3];\n        return skinMatrix;\n}",heatmap_render_vert:"#ifdef HAS_HEATMAP\nvarying vec2 heatmap_vTexCoord;\nvoid heatmap_compute(mat4 matrix, vec3 position) {\n    vec4 pos = matrix * vec4(position.xy, 0., 1.);\n    heatmap_vTexCoord = (1. + pos.xy / pos.w) / 2.;\n}\n#endif",heatmap_render_frag:"#ifdef HAS_HEATMAP\nuniform sampler2D heatmap_inputTexture;\nuniform sampler2D heatmap_colorRamp;\nuniform float heatmap_heatmapOpacity;\nvarying vec2 heatmap_vTexCoord;\nvec4 heatmap_getColor(vec4 color) {\n    float t = texture2D(heatmap_inputTexture, heatmap_vTexCoord).r;\n    vec4 heatmapColor = texture2D(heatmap_colorRamp, vec2(t, 0.5)) * heatmap_heatmapOpacity;\n    return color * (1.0 - heatmapColor.a) + heatmapColor * heatmapColor.a;\n}\n#endif",line_extrusion_vert:"#ifdef IS_LINE_EXTRUSION\n    #define ALTITUDE_SCALE 32767.0;\n    #define EXTRUDE_SCALE 63.0;\n    attribute vec2 aExtrude;\n    #ifdef HAS_LINE_WIDTH\n        attribute float aLineWidth;\n    #else\n        uniform float lineWidth;\n    #endif\n    #ifdef HAS_LINE_HEIGHT\n        attribute float aLineHeight;\n    #else\n        uniform float lineHeight;\n    #endif\n    uniform float linePixelScale;\n    vec3 getLineExtrudePosition(vec3 position) {\n        #ifdef HAS_LINE_WIDTH\n            float lineWidth = aLineWidth / 2.0;\n        #endif\n        #ifdef HAS_LINE_HEIGHT\n            float lineHeight = aLineHeight / 10.0;\n        #endif\n        float halfwidth = lineWidth / 2.0;\n        float outset = halfwidth;\n        vec2 dist = outset * aExtrude / EXTRUDE_SCALE;\n        position.z *= lineHeight / ALTITUDE_SCALE;\n        return position + vec3(dist, 0.0) * linePixelScale;\n    }\n#endif",gl2_vert:"#if __VERSION__ == 300\n    #define texture2D texture\n    #define varying out\n    #define attribute in\n#endif",gl2_frag:"#if __VERSION__ == 300\n    #define varying in\n    #define gl_FragDepthEXT gl_FragDepth\n    #define texture2D texture\n    #define textureCube texture\n    #define texture2DProj textureProj\n    #define texture2DLodEXT textureLod\n    #define texture2DProjLodEXT textureProjLod\n    #define textureCubeLodEXT textureLod\n    #define texture2DGradEXT textureGrad\n    #define texture2DProjGradEXT textureProjGrad\n    #define textureCubeGradEXT textureGrad\n    out vec4 glFragColor;\n#else\n    vec4 glFragColor;\n#endif",hsv_frag:"\nconst mediump vec4 HSV_K0 = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nconst mediump vec4 HSV_K1 = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nconst mediump float HSV_E = 1.0e-10;\nvec3 hsv_rgb2hsv(vec3 c) {\n    vec4 K = HSV_K0;\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = HSV_E;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv_hsv2rgb(vec3 c) {\n    vec4 K = HSV_K1;\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec4 hsv_apply(vec4 c, vec3 hsvOffset) {\n    vec3 hsv = hsv_rgb2hsv(c.rgb);\n    hsv += hsv * hsvOffset;\n    hsv = clamp(hsv, 0.0, 1.0);\n    return vec4(hsv_hsv2rgb(hsv), c.a);\n}\nvec3 hsv_apply(vec3 c, vec3 hsvOffset) {\n    vec3 hsv = hsv_rgb2hsv(c.rgb);\n    hsv += hsv * hsvOffset;\n    hsv = clamp(hsv, 0.0, 1.0);\n    return hsv_hsv2rgb(hsv);\n}\nmat4 contrastMatrix(float contrast)\n{\n    float t = (1.0 - contrast) / 2.0;\n    return mat4(\n        contrast, 0., 0., 0.,\n        0., contrast, 0., 0.,\n        0., 0., contrast, 0.,\n        t, t, t, 1\n    );\n}",snow_frag:"#ifdef HAS_SNOW\n    float lerp(float a, float b, float w) {\n        return a + w * (b - a);\n    }\n    vec3 snow(vec4 sceneColor, vec3 normalColor, float height) {\n        float snowIntense = normalColor.b;\n        vec3 fixedC = vec3(1.0, 1.0, 1.0);\n        if (height < 1.0) {\n            float r = lerp(0.5, fixedC.x, snowIntense);\n            float g = lerp(0.5, fixedC.y, snowIntense);\n            float b = lerp(0.5, fixedC.z, snowIntense);\n            return vec3(r, g, b);\n        } else {\n            float r = lerp(sceneColor.r, fixedC.x, snowIntense);\n            float g = lerp(sceneColor.g, fixedC.y, snowIntense);\n            float b = lerp(sceneColor.b, fixedC.z, snowIntense);\n            return vec3(r, g, b);\n        }\n    }\n#endif",draco_decode_vert:"#if defined(HAS_TANGENT)\n    attribute vec4 aTangent;\n#elif defined(HAS_NORMAL)\n    #ifdef HAS_DRACO_NORMAL\n        attribute vec2 aNormal;\n        uniform float gltf_u_dec_normal_rangeConstant;\n    #else\n        attribute vec3 aNormal;\n    #endif\n#endif\n#ifdef HAS_DRACO_POSITION\n    uniform float gltf_u_dec_position_normConstant;\n    uniform vec3 minValues_pos;\n    vec3 decodeDracoPosition(vec3 aPosition) {\n        return minValues_pos + aPosition * gltf_u_dec_position_normConstant;\n    }\n#endif\n#ifdef HAS_DRACO_TEXCOORD\n    uniform vec2 minValues_tex;\n    uniform float gltf_u_dec_texcoord_0_normConstant;\n    vec2 decodeDracoTexcoord(vec2 aTexCoord) {\n        return minValues_tex + aTexCoord * gltf_u_dec_texcoord_0_normConstant;\n    }\n#endif\n#ifdef HAS_WEB3D_quantized_attributes_TEXCOORD\n    uniform mat3 decodeMatrix;\n#endif\n#ifdef HAS_DRACO_NORMAL\n    float czm_signNotZero(float value) {\n        return value >= 0.0 ? 1.0 : -1.0;\n    }\n    vec2 czm_signNotZero(vec2 value) {\n        return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n    }\n    vec3 decodeDracoNormal(vec2 encoded, float range)\n    {\n        if (encoded.x == 0.0 && encoded.y == 0.0) {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        encoded = encoded / range * 2.0 - 1.0;\n        vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n        if (v.z < 0.0) {\n            v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n        }\n        return normalize(v);\n    }\n    vec3 decode_getNormal(vec2 aNormal) {\n        return decodeDracoNormal(aNormal, gltf_u_dec_normal_rangeConstant).zxy;\n    }\n#endif\n#ifdef HAS_COMPRESSED_INT16\n    #ifdef HAS_COMPRESSED_INT16_POSITION\n      uniform vec2 compressedPositionRange;\n    #endif\n    #ifdef HAS_COMPRESSED_INT16_TEXCOORD_0\n      uniform vec2 compressedTexcoordRange_0;\n    #endif\n    #ifdef HAS_COMPRESSED_INT16_TEXCOORD_1\n      uniform vec2 compressedTexcoordRange_1;\n    #endif\n    #ifdef HAS_COMPRESSED_INT16_NORMAL\n      uniform vec2 compressedNormalRange;\n    #endif\n    #ifdef HAS_COMPRESSED_INT16_RATIO\n      uniform float compressed_ratio;\n    #endif\n    float int16ToFloat32(float value, vec2 range) {\n        float v = (value >= 32768.0) ? -(65536.0 - value) / 32768.0 : value / 32767.0;\n        return (v + 1.0) * (range.y - range.x) / 2.0 + range.x;\n    }\n#endif\nvec3 decode_getPosition(vec3 aPosition) {\n    vec3 position = aPosition;\n    #if defined(HAS_COMPRESSED_INT16) && defined(HAS_COMPRESSED_INT16_POSITION)\n        float x = int16ToFloat32(aPosition.x, compressedPositionRange);\n        float y = int16ToFloat32(aPosition.y, compressedPositionRange);\n        float z = int16ToFloat32(aPosition.z, compressedPositionRange);\n        #ifdef HAS_COMPRESSED_INT16_RATIO\n          position = vec3(x / compressed_ratio, y / compressed_ratio, z);\n        #else\n          position = vec3(x, y, z);\n        #endif\n    #endif\n    #ifdef HAS_DRACO_POSITION\n        return decodeDracoPosition(position);\n    #else\n        return position;\n    #endif\n}\nvec2 decode_getTexcoord(vec2 aTexCoord) {\n    vec2 texcoord = aTexCoord;\n    #if defined(HAS_COMPRESSED_INT16) && (defined(HAS_COMPRESSED_INT16_TEXCOORD_0) || defined(HAS_COMPRESSED_INT16_TEXCOORD_1))\n        float x = int16ToFloat32(aTexCoord.x, compressedTexcoordRange_0);\n        float y = int16ToFloat32(aTexCoord.y, compressedTexcoordRange_0);\n        texcoord = vec2(x, y);\n    #endif\n    #ifdef HAS_DRACO_TEXCOORD\n        return decodeDracoTexcoord(texcoord);\n    #elif defined(HAS_WEB3D_quantized_attributes_TEXCOORD)\n        vec3 web3dTexcoord = decodeMatrix * vec3(texcoord, 1.0);\n        return vec2(web3dTexcoord.x, web3dTexcoord.y);\n    #else\n        return texcoord;\n    #endif\n}\nvec3 decode_getNormal(vec3 aNormal) {\n    #ifdef HAS_COMPRESSED_INT16_NORMAL\n        aNormal.x = int16ToFloat32(aNormal.x, compressedNormalRange);\n        aNormal.y = int16ToFloat32(aNormal.y, compressedNormalRange);\n        aNormal.z = int16ToFloat32(aNormal.z, compressedNormalRange);\n    #endif\n    return aNormal;\n}",highlight_vert:"#if defined(HAS_HIGHLIGHT_COLOR)\n    attribute vec4 aHighlightColor;\n    varying vec4 vHighlightColor;\n#endif\n#if defined(HAS_HIGHLIGHT_OPACITY)\n    attribute float aHighlightOpacity;\n    varying float vHighlightOpacity;\n#endif\nvoid highlight_setVarying() {\n    #if defined(HAS_HIGHLIGHT_COLOR)\n        vHighlightColor = aHighlightColor / 255.0;\n    #endif\n    #if defined(HAS_HIGHLIGHT_OPACITY)\n        vHighlightOpacity = aHighlightOpacity / 255.0;\n    #endif\n}",highlight_frag:"#if defined(HAS_HIGHLIGHT_COLOR)\n\tvarying vec4 vHighlightColor;\n#endif\n#if defined(HAS_HIGHLIGHT_OPACITY)\n    varying float vHighlightOpacity;\n#endif\nvec4 highlight_blendColor(vec4 color) {\n\tvec4 outColor;\n\t#if defined(HAS_HIGHLIGHT_COLOR)\n\t\tcolor.rgb = color.rgb * (1.0 - vHighlightColor.a) + vHighlightColor.rgb * vHighlightColor.a;\n\t\t#ifndef HAS_HIGHLIGHT_COLOR_POINT\n        \tcolor.a = color.a * (1.0 - vHighlightColor.a) + vHighlightColor.a;\n        #endif\n        outColor = color;\n\t#else\n\t\toutColor = color;\n\t#endif\n\t#if defined(HAS_HIGHLIGHT_OPACITY)\n\t\toutColor *= vHighlightOpacity;\n\t#endif\n\treturn outColor;\n}",mask_vert:"#ifdef HAS_MASK_EXTENT\n    uniform vec4 mask_extent;\n    uniform sampler2D mask_colorExtent;\n    uniform sampler2D mask_modeExtent;\n    uniform float mask_maskMode;\n    uniform float mask_hasFlatOut;\n    uniform mat4 viewMatrix;\n    uniform float mask_heightRatio;\n    uniform float mask_heightOffset;\n    varying vec4 vWorldPosition;\n    varying vec2 vUVInExtent;\n    varying float vHeightRatio;\n    varying float vHeightOffset;\n    const float CLIPINSIDE_MODE = 0.2;\n    const float FLATINSIDE_MODE = 0.3;\n    const float FLATOUTSIDE_MODE = 0.4;\n    const float ELEVATE_MODE = 0.7;\n    float random (vec2 st) {\n        return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123) * 0.1;\n    }\n    bool isInExtent(vec4 color) {\n        return length(color.rgb) > 0.0;\n    }\n    float getFlatHeight(float maskMode, float flatHeight, float height) {\n      if (maskMode <= ELEVATE_MODE && maskMode > 0.6) {\n          return flatHeight + height;\n      } else {\n        return flatHeight;\n      }\n    }\n    vec4 getNoErrorPosition(vec4 position, vec4 wPosition) {\n      vec4 realPos = modelViewMatrix * position;      vec4 pos = viewMatrix * wPosition;      vec4 tempPos = viewMatrix * modelMatrix * position;      float deltaX = realPos.x - tempPos.x;\n      float deltaY = realPos.y - tempPos.y;\n      float deltaZ = realPos.z - tempPos.z;\n      pos.x = pos.x + deltaX;\n      pos.y = pos.y + deltaY;\n      pos.z = pos.z + deltaZ;\n      return pos;\n    }\n    vec4 getMaskPosition(vec4 position, mat4 modelMatrix) {\n        vWorldPosition = modelMatrix * position;\n        float w = mask_extent.z - mask_extent.x;\n        float h = mask_extent.y - mask_extent.w;\n        vec2 uvInExtent = vec2((vWorldPosition.x - mask_extent.x) / abs(w), 1.0 - (vWorldPosition.y - mask_extent.w) / h);\n        vec4 extentColor = texture2D(mask_colorExtent, uvInExtent);\n        vec3 maskOptionColor = texture2D(mask_modeExtent, uvInExtent).rgb;\n        float maskMode = maskOptionColor.r;\n        float flatHeight = maskOptionColor.g / mask_heightRatio + mask_heightOffset;\n        float height = getFlatHeight(maskMode, flatHeight, vWorldPosition.z);\n        vec4 wPosition = vec4(vWorldPosition.x, vWorldPosition.y, height, vWorldPosition.w);\n        vUVInExtent = uvInExtent;\n        vHeightRatio = mask_heightRatio;\n        vHeightOffset = mask_heightOffset;\n        if (maskMode <= FLATOUTSIDE_MODE && maskMode > FLATINSIDE_MODE) {\n            return modelViewMatrix * position;;\n        } else if (mask_hasFlatOut == 1.0) {\n            return getNoErrorPosition(position, wPosition);\n        }\n        if (isInExtent(extentColor) == true && maskMode <= FLATINSIDE_MODE && maskMode > CLIPINSIDE_MODE) {\n            return getNoErrorPosition(position, wPosition);\n        } if (isInExtent(extentColor) == true && maskMode <= ELEVATE_MODE && maskMode > 0.6) {\n            return getNoErrorPosition(position, wPosition);\n        } else {\n            return modelViewMatrix * position;\n        }\n    }\n#endif",mask_frag:"#ifdef HAS_MASK_EXTENT\n    uniform sampler2D mask_colorExtent;\n    uniform sampler2D mask_modeExtent;\n    uniform float mask_hasClipOut;\n    varying float vHeightRatio;\n    varying float vHeightOffset;\n    varying vec2 vUVInExtent;\n    varying vec4 vWorldPosition;\n    const float CLIPINSIDE_MODE = 0.1;\n    const float CLIPOUTSIDE_MODE = 0.2;\n    const float FLATINSIDE_MODE = 0.3;\n    const float FLATOUTSIDE_MODE = 0.4;\n    const float COLOR_MODE = 0.5;\n    const float VIDEO_MODE = 0.6;\n    bool isInExtent(vec4 color) {\n        return length(color.rgb) > 0.0;\n    }\n    vec4 setMask(vec4 glFragColor) {\n        vec4 extentColor = texture2D(mask_colorExtent, vUVInExtent);\n        vec4 modeColor = texture2D(mask_modeExtent, vUVInExtent);\n        float maskMode = modeColor.r;\n        float minHeight = modeColor.b / vHeightRatio + vHeightOffset;\n        float maxHeight = modeColor.a / vHeightRatio + vHeightOffset;\n        if (maskMode > CLIPINSIDE_MODE && maskMode <= CLIPOUTSIDE_MODE) {\n            if (minHeight == 0.0 && maxHeight == 0.0) {\n                return glFragColor;\n            } else if (vWorldPosition.z >= minHeight && vWorldPosition.z <= maxHeight) {\n                return glFragColor;\n            } else {\n              discard;\n            }\n        } else if (mask_hasClipOut == 1.0) {\n            discard;\n        }\n        if (isInExtent(extentColor) == true && maskMode <= CLIPINSIDE_MODE && maskMode > 0.0) {\n            if (minHeight == 0.0 && maxHeight == 0.0) {\n                discard;\n            } else if (vWorldPosition.z >= minHeight && vWorldPosition.z <= maxHeight) {\n                discard;\n            } else {\n              return glFragColor;\n            }\n        } else if (isInExtent(extentColor) == true && maskMode <= VIDEO_MODE && maskMode > FLATOUTSIDE_MODE) {\n            if (minHeight == 0.0 && maxHeight == 0.0) {\n                glFragColor = vec4(mix(extentColor.rgb, glFragColor.rgb, 1.0 - extentColor.a), glFragColor.a);\n            } else if (vWorldPosition.z >= minHeight && vWorldPosition.z <= maxHeight) {\n                glFragColor = vec4(mix(extentColor.rgb, glFragColor.rgb, 1.0 - extentColor.a), glFragColor.a);\n            }\n        }\n        return glFragColor;\n    }\n#endif",compute_texcoord_frag:"#ifdef HAS_KHR_TEXTURE_TRANSFORM\n    uniform vec2 khr_offset;\n    uniform float khr_rotation;\n    uniform vec2 khr_scale;\n    vec2 khr_tex_transformTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) {\n        rotation = -rotation;\n        mat3 transform = mat3(\n        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, offset.x, offset.y, 1.0);\n        vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy;\n        return transformedTexCoords;\n    }\n#endif\nvarying highp vec2 vTexCoord;\n#ifdef HAS_I3S_UVREGION\n    varying vec4 vUvRegion;\n#endif\nvec2 computeTexCoord(vec2 texCoord) {\n    #ifdef HAS_I3S_UVREGION\n        vec2 atlasScale = vUvRegion.zw - vUvRegion.xy;\n        vec2 uvAtlas = fract(texCoord) * atlasScale + vUvRegion.xy;\n        return uvAtlas;\n    #elif defined(HAS_KHR_TEXTURE_TRANSFORM)\n        return khr_tex_transformTexCoord(texCoord, khr_offset, khr_rotation, khr_scale);\n    #else\n        return texCoord;\n    #endif\n}",terrain_normal_frag:"#ifdef HAS_TERRAIN_NORMAL\n    uniform sampler2D terrainHeightTexture;\n    uniform vec2 terrainHeightMapResolution;\n    uniform vec2 terrainResolution;\n    uniform vec4 terrainUnpackFactors;\n    float getHeight(vec2 uv) {\n        vec4 color = texture2D(terrainHeightTexture, uv) * 255.0;\n        color.a = -1.0;\n        return dot(color, terrainUnpackFactors) / 4.0;\n    }\n    vec3 convertTerrainHeightToNormalMap(vec2 uv) {\n        uv.y = 1.0 - uv.y;\n        vec2 epsilon = 1.0 / terrainHeightMapResolution;\n        float a = getHeight(uv + vec2(-epsilon.x, -epsilon.y));\n        float b = getHeight(uv + vec2(0, -epsilon.y));\n        float c = getHeight(uv + vec2(epsilon.x, -epsilon.y));\n        float d = getHeight(uv + vec2(-epsilon.x, 0));\n        float e = getHeight(uv + vec2(epsilon.x, 0));\n        float f = getHeight(uv + vec2(-epsilon.x, epsilon.y));\n        float g = getHeight(uv + vec2(0, epsilon.y));\n        float h = getHeight(uv + vec2(epsilon.x, epsilon.y));\n        vec2 dxy = vec2(\n            (c + e + e + h) - (a + d + d + f),\n            (f + g + g + h) - (a + b + b + c)\n        );\n        return normalize(vec3(dxy / epsilon, terrainResolution ));\n    }\n#endif",vertex_color_vert:"#ifdef HAS_VERTEX_COLOR\nattribute float aVertexColorType;\nuniform vec4 vertexColorsOfType[VERTEX_TYPES_COUNT];\nvarying vec4 vertexColor_color;\nvoid vertexColor_update() {\n    vertexColor_color = vertexColorsOfType[int(aVertexColorType)];\n}\n#endif\n//用于识别顶点颜色类型: topPolygonFill 还是 bottomPolygonFill",vertex_color_frag:"#ifdef HAS_VERTEX_COLOR\nvarying vec4 vertexColor_color;\nvec4 vertexColor_get() {\n\treturn vertexColor_color;\n}\n#endif",excavate_vert:"#ifdef HAS_EXCAVATE_ANALYSIS\n  uniform vec4 excavateExtent;\n  varying vec2 vCoordinateTexcoord;\n  varying float vExcavateHeight;\n  float getWorldHeight(vec4 localPosition) {\n    vec4 wPosition = modelMatrix * localPosition;\n    return wPosition.z;\n  }\n  vec2 getCoordinateTexcoord(vec4 localPosition) {\n    vec4 wPosition = modelMatrix * localPosition;\n    float x = (wPosition.x - excavateExtent.x) / (excavateExtent.z - excavateExtent.x);\n    float y = (wPosition.y - excavateExtent.y) / (excavateExtent.w - excavateExtent.y);\n    return vec2(x, y);\n  }\n#endif",excavate_frag:"#ifdef HAS_EXCAVATE_ANALYSIS\n  uniform sampler2D heightmap;\n  uniform float excavateHeight;\n  varying vec2 vCoordinateTexcoord;\n  varying float vExcavateHeight;\n  const vec2 range = vec2(-100.0, 1000.0);\n  float decodeHeight(const in vec4 pack) {\n      return pack.r + pack.g / 255.0;\n  }\n  vec4 excavateColor(vec4 fragColor) {\n      float samplerHeight = decodeHeight(texture2D(heightmap, vCoordinateTexcoord));\n      float realHeight = samplerHeight * (range.y - range.x) + range.x;\n      if(realHeight < range.x || realHeight > range.y) {\n          realHeight = 0.0;\n      }\n      if(vExcavateHeight > realHeight) {\n          discard;\n      }\n      return fragColor;\n  }\n#endif",srgb_frag:"vec3 linearTosRGB(const in vec3 color) {\n    return vec3(\n        color.r < 0.0031308 ? color.r * 12.92 : 1.055 * pow(color.r, 1.0/2.4) - 0.055,\n        color.g < 0.0031308 ? color.g * 12.92 : 1.055 * pow(color.g, 1.0/2.4) - 0.055,\n        color.b < 0.0031308 ? color.b * 12.92 : 1.055 * pow(color.b, 1.0/2.4) - 0.055\n    );\n}\nvec3 sRGBToLinear(const in vec3 color) {\n    return vec3(\n        color.r < 0.04045 ? color.r * (1.0 / 12.92) : pow((color.r + 0.055) * (1.0 / 1.055), 2.4),\n        color.g < 0.04045 ? color.g * (1.0 / 12.92) : pow((color.g + 0.055) * (1.0 / 1.055), 2.4),\n        color.b < 0.04045 ? color.b * (1.0 / 12.92) : pow((color.b + 0.055) * (1.0 / 1.055), 2.4)\n    );\n}",mesh_picking_vert:"attribute vec3 aPosition;\nuniform mat4 projViewModelMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 modelViewMatrix;\n#include <fbo_picking_vert>\n#include <get_output>\nvoid main()\n{\n    mat4 localPositionMatrix = getPositionMatrix();\n    vec4 localPosition = getPosition(aPosition);\n    gl_Position = projViewModelMatrix * localPositionMatrix * localPosition;\n    fbo_picking_setData(gl_Position.w, true);\n}"};var VS={register(i,g){if(zS[i])throw new Error(`Key of ${i} is already registered in ShaderLib.`);zS[i]=g},compile:i=>GS(i),get:i=>zS[i]};const US=/^[ \t]*#include +<([\w\d.]+)>/gm;function GS(i){return i.replace(US,jS)}function jS(i,g){const m=zS[g];if(!m)throw new Error("Can not resolve #include <"+g+">");return GS(m)}const WS="\n// 矩阵求逆函数\nfn invert_matrix(matrix: mat4x4f) -> mat4x4f {\n    let vector1 = matrix[0];\n    let vector2 = matrix[1];\n    let vector3 = matrix[2];\n    let vector4 = matrix[3];\n\n    let a00 = vector1.x;\n    let a01 = vector1.y;\n    let a02 = vector1.z;\n    let a03 = vector1.w;\n\n    let a10 = vector2.x;\n    let a11 = vector2.y;\n    let a12 = vector2.z;\n    let a13 = vector2.w;\n\n    let a20 = vector3.x;\n    let a21 = vector3.y;\n    let a22 = vector3.z;\n    let a23 = vector3.w;\n\n    let a30 = vector4.x;\n    let a31 = vector4.y;\n    let a32 = vector4.z;\n    let a33 = vector4.w;\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // 计算行列式\n    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    det = 1.0 / det;\n\n    let m = mat4x4f(\n        (a11 * b11 - a12 * b10 + a13 * b09) * det,\n        (a02 * b10 - a01 * b11 - a03 * b09) * det,\n        (a31 * b05 - a32 * b04 + a33 * b03) * det,\n        (a22 * b04 - a21 * b05 - a23 * b03) * det,\n        (a12 * b08 - a10 * b11 - a13 * b07) * det,\n        (a00 * b11 - a02 * b08 + a03 * b07) * det,\n        (a32 * b02 - a30 * b05 - a33 * b01) * det,\n        (a20 * b05 - a22 * b02 + a23 * b01) * det,\n        (a10 * b10 - a11 * b08 + a13 * b06) * det,\n        (a01 * b08 - a00 * b10 - a03 * b06) * det,\n        (a30 * b04 - a31 * b02 + a33 * b00) * det,\n        (a21 * b02 - a20 * b04 - a23 * b00) * det,\n        (a11 * b07 - a10 * b09 - a12 * b06) * det,\n        (a00 * b09 - a01 * b07 + a02 * b06) * det,\n        (a31 * b01 - a30 * b03 - a32 * b00) * det,\n        (a20 * b03 - a21 * b01 + a22 * b00) * det\n    );\n\n    return m;\n}\n\n// 矩阵转置函数\nfn transpose_matrix(matrix: mat4x4f) -> mat4x4f {\n    let vector1 = matrix[0];\n    let vector2 = matrix[1];\n    let vector3 = matrix[2];\n    let vector4 = matrix[3];\n\n    let a01 = vector1.y;\n    let a02 = vector1.z;\n    let a03 = vector1.w;\n\n    let a12 = vector2.z;\n    let a13 = vector2.w;\n\n    let a23 = vector3.w;\n\n    let m = mat4x4f(\n        vector1.x,\n        vector2.x,\n        vector3.x,\n        vector4.x,\n        a01,\n        vector2.y,\n        vector3.y,\n        vector4.y,\n        a02,\n        a12,\n        vector3.z,\n        vector4.z,\n        a03,\n        a13,\n        a23,\n        vector4.w\n    );\n\n    return m;\n}\n";const qS="\nconst COMMON_FLOAT_MAX: f32 = 1.70141184e38;\nconst COMMON_FLOAT_MIN: f32 = 1.17549435e-38;\n\nfn common_packFloat(val: vec4f) -> f32 {\n    let scl = floor(255.0 * val + 0.5);\n    let sgn = select(-1.0, 1.0, scl.a < 128.0);\n    let exn = (scl.a * 2.0 % 256.0) + floor(scl.b / 128.0) - 127.0;\n    let man = 1.0 +\n        (scl.r / 8388608.0) +\n        (scl.g / 32768.0) +\n        (scl.b % 128.0) / 128.0;\n    return sgn * man * pow(2.0, exn);\n}\n\nfn common_unpackFloat(v: f32) -> vec4f {\n    let av = abs(v);\n\n    // Handle special cases\n    if (av < COMMON_FLOAT_MIN) {\n        return vec4f(0.0, 0.0, 0.0, 0.0);\n    } else if (v > COMMON_FLOAT_MAX) {\n        return vec4f(127.0, 128.0, 0.0, 0.0) / 255.0;\n    } else if (v < -COMMON_FLOAT_MAX) {\n        return vec4f(255.0, 128.0, 0.0, 0.0) / 255.0;\n    }\n\n    var c = vec4f(0.0, 0.0, 0.0, 0.0);\n\n    // Compute exponent and mantissa\n    let e = floor(log2(av));\n    var m = av * pow(2.0, -e) - 1.0;\n\n    // Unpack mantissa\n    c[1] = floor(128.0 * m);\n    m -= c[1] / 128.0;\n    c[2] = floor(32768.0 * m);\n    m -= c[2] / 32768.0;\n    c[3] = floor(8388608.0 * m);\n\n    // Unpack exponent\n    var ebias = e + 127.0;\n    c[0] = floor(ebias / 2.0);\n    ebias -= c[0] * 2.0;\n    c[1] += floor(ebias) * 128.0;\n\n    // Unpack sign bit\n    c[0] += 128.0 * step(0.0, -v);\n\n    // Scale back to range\n    return c / 255.0;\n}\n\nfn common_encodeDepth(depth: f32) -> vec4f {\n    let alpha = 1.0;\n    var pack = vec4f(0.0);\n    pack.a = alpha;\n    const code = vec3f(1.0, 255.0, 65025.0);\n    pack = vec4f(vec3f(code * depth), pack.a);\n    pack = vec4f(pack.r, fract(pack.gb), pack.a);\n    pack.r -= pack.g * (1.0 / 256.0);\n    pack.g -= pack.b * (1.0 / 256.0);\n    pack.b -= (pack.b % (4.0 / 255.0));\n    return pack;\n}\n\nfn common_decodeDepth(pack: vec4f) -> f32 {\n    return pack.r + pack.g / 255.0;\n}\n\n// https://cloud.tencent.com/developer/ask/sof/103481834\nfn encodeFloat32(f: f32) -> vec4f {\n    var e = 5.0;\n\n    var F = abs(f);\n    var Sign = step(0.0, -f);\n    var Exponent = floor(log2(F));\n    var Mantissa = (exp2(- Exponent) * F);\n    Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n    var rgba = vec4(0.0);\n    rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n    rgba[1] = 128.0 * (Exponent % 2.0) + (floor(Mantissa*128.0) % 128.0);\n    rgba[2] = floor((floor(Mantissa*exp2(23.0 -8.0)) % exp2(8.0)));\n    rgba[3] = floor(exp2(23.0)*(Mantissa % exp2(-15.0)));\n    return rgba / 255.0;\n}\n\nfn decodeFloat32(inputRgba: vec4f) -> f32 {\n    var rgba = inputRgba * 255.0;\n    var Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    var Exponent = 2.0 * (rgba[0] % 128.0) + step(128.0,rgba[1]) - 127.0;\n    var Mantissa = (rgba[1] % 128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + 0x800000;\n    var Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n    return Result;\n}\n";const XS={instance:{vert:"\n@group(0) @binding($b) var<uniform> terrainAltitudeScale: f32;\n\n// 获取实例属性矩阵函数\nfn instance_getAttributeMatrix(\n    input: VertexInput\n) -> mat4x4f {\n    let vectorA = input.instance_vectorA;\n    let vectorB = input.instance_vectorB;\n    let vectorC = input.instance_vectorC;\n    var mat = mat4x4f(\n        vectorA.x, vectorB.x, vectorC.x, 0.0,\n        vectorA.y, vectorB.y, vectorC.y, 0.0,\n        vectorA.z, vectorB.z, vectorC.z, 0.0,\n        vectorA.w, vectorB.w, vectorC.w, 1.0\n    );\n\n#ifdef HAS_INSTANCE_TERRAIN_ALTITUDE\n    var terrainMat = mat4x4f(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, aTerrainAltitude * terrainAltitudeScale, 1.0\n    );\n    mat = terrainMat * mat;\n#endif\n\n    return mat;\n}\n\n#ifdef HAS_INSTANCE_COLOR\n// 获取实例颜色函数\nfn instance_getInstanceColor(instance_color: vec4f) -> vec4f {\n    var color = instance_color;\n#ifdef HAS_INSTANCE_HIGHLIGHT\n    color = instance_color * highlight_color;\n#endif\n    return color;\n}\n#endif\n",attributes:[{name:"instance_vectorA",type:"vec4f"},{name:"instance_vectorB",type:"vec4f"},{name:"instance_vectorC",type:"vec4f"},{defines:["HAS_INSTANCE_TERRAIN_ALTITUDE"],name:"aTerrainAltitude",type:"f32"},{defines:["HAS_INSTANCE_HIGHLIGHT"],name:"highlight_color",type:"vec4f"},{defines:["HAS_INSTANCE_COLOR"],name:"instance_color",type:"vec4f"}],defines:["HAS_INSTANCE"]},invert_matrix:{vert:WS,frag:WS},line_extrusion:{vert:"\n    #define ALTITUDE_SCALE 32767.0;\n    #define EXTRUDE_SCALE 63.0;\n\n    struct LineExtrusionVertex {\n        linePixelScale: f32;\n        #if HAS_LINE_WIDTH\n        #else\n            lineWidth: f32;\n        #endif\n        #if HAS_LINE_HEIGHT\n        #else\n            lineHeight: f32;\n        #endif\n    }\n\n    @group(0) @binding($b) var<uniform> lineExtrusionVertex : LineExtrusionVertex;\n\n    fn getLineExtrudePosition(position: vec3f, input: VertexInput) -> vec3f {\n        #if HAS_LINE_WIDTH\n            let lineWidth: f32 = input.aLineWidth / 2.0;\n        #else\n            let lineWidth: f32 = lineExtrusionVertex.lineWidth;\n        #endif\n        #if HAS_LINE_HEIGHT\n            // aLineHeight单位是分米\n            let lineHeight: f32 = input.aLineHeight / 10.0;\n        #else\n            let lineHeight: f32 = lineExtrusionVertex.lineHeight\n        #endif\n\n        let halfwidth: f32 = lineWidth / 2.0;\n        let outset: f32 = halfwidth;\n        let dist: vec2f = outset * input.aExtrude / EXTRUDE_SCALE;\n        let z_scaled: f32 = position.z * (lineHeight / ALTITUDE_SCALE);\n    return position + vec3f(dist, 0.0) * linePixelScale;\n}\n",attributes:[{defines:["HAS_LINE_WIDTH"],name:"aLineWidth",type:"f32"},{defines:["HAS_LINE_HEIGHT"],name:"aLineHeight",type:"f32"}],defines:["IS_LINE_EXTRUSION"]},mask:{defines:["HAS_MASK_EXTENT"],vert:"\n#ifdef HAS_MASK_EXTENT\nstruct MaskUniforms {\n    mask_extent: vec4f,\n    mask_maskMode: f32,\n    mask_hasFlatOut: f32,\n    viewMatrix: mat4x4f,\n    mask_heightRatio: f32,\n    mask_heightOffset: f32,\n};\n\n@group(0) @binding($b) var<uniform> maskUniforms: MaskUniforms;\n@group(0) @binding($b) var mask_colorExtentSampler: sampler;\n@group(0) @binding($b) var mask_colorExtent: texture_2d<f32>;\n@group(0) @binding($b) var mask_modeExtentSampler: sampler;\n@group(0) @binding($b) var mask_modeExtent: texture_2d<f32>;\n\nconst CLIPINSIDE_MODE: f32 = 0.2;\nconst FLATINSIDE_MODE: f32 = 0.3;\nconst FLATOUTSIDE_MODE: f32 = 0.4;\nconst ELEVATE_MODE: f32 = 0.7;\n\nfn random(st: vec2f) -> f32 {\n    return fract(sin(dot(st, vec2f(12.9898, 78.233))) * 43758.5453123) * 0.1;\n}\n\nfn isInExtent(color: vec4f) -> bool {\n    return length(color.rgb) > 0.0;\n}\n\nfn getFlatHeight(maskMode: f32, flatHeight: f32, height: f32) -> f32 {\n    if (maskMode <= ELEVATE_MODE && maskMode > 0.6) {\n        return flatHeight + height;\n    } else {\n        return flatHeight;\n    }\n}\n\nfn getNoErrorPosition(position: vec4f, wPosition: vec4f) -> vec4f {\n    let realPos = uniforms.modelViewMatrix * position; // 未压平，采用 vm 矩阵的坐标\n    let pos = maskUniforms.viewMatrix * wPosition; // 压平的坐标\n    let tempPos = maskUniforms.viewMatrix * uniforms.modelMatrix * position; // 未压平而采用 v*m 矩阵的坐标\n    let deltaX = realPos.x - tempPos.x;\n    let deltaY = realPos.y - tempPos.y;\n    let deltaZ = realPos.z - tempPos.z;\n    pos.x = pos.x + deltaX;\n    pos.y = pos.y + deltaY;\n    pos.z = pos.z + deltaZ;\n    return pos;\n}\n\nfn getMaskPosition(position: vec4f, modelMatrix: mat4x4f, vertexOutput: VertexOutput) -> vec4f {\n    vertexOutput.vWorldPosition = modelMatrix * position;\n    let w = maskUniforms.mask_extent.z - maskUniforms.mask_extent.x;\n    let h = maskUniforms.mask_extent.y - maskUniforms.mask_extent.w;\n    let uvInExtent = vec2f((vertexOutput.vWorldPosition.x - maskUniforms.mask_extent.x) / abs(w), 1.0 - (vertexOutput.vWorldPosition.y - maskUniforms.mask_extent.w) / h);\n    let extentColor = textureSample(mask_colorExtent, mask_colorExtentSampler, uvInExtent);\n    let maskOptionColor = textureSample(mask_modeExtent, mask_modeExtentSampler, uvInExtent).rgb;\n    let maskMode = maskOptionColor.r;\n    let flatHeight = maskOptionColor.g / maskUniforms.mask_heightRatio + maskUniforms.mask_heightOffset;\n    let height = getFlatHeight(maskMode, flatHeight, vertexOutput.vWorldPosition.z);\n    let wPosition = vec4f(vertexOutput.vWorldPosition.x, vertexOutput.vWorldPosition.y, height, vertexOutput.vWorldPosition.w);\n    vertexOutput.vUVInExtent = uvInExtent;\n    vertexOutput.vHeightRatio = maskUniforms.mask_heightRatio;\n    vertexOutput.vHeightOffset = maskUniforms.mask_heightOffset;\n    if (maskMode <= FLATOUTSIDE_MODE && maskMode > FLATINSIDE_MODE) {\n        return uniforms.modelViewMatrix * position;\n    } else if (maskUniforms.mask_hasFlatOut == 1.0) {\n        return getNoErrorPosition(position, wPosition);\n    }\n    if (isInExtent(extentColor) && maskMode <= FLATINSIDE_MODE && maskMode > CLIPINSIDE_MODE) {\n        return getNoErrorPosition(position, wPosition);\n    }\n    if (isInExtent(extentColor) && maskMode <= ELEVATE_MODE && maskMode > 0.6) {\n        return getNoErrorPosition(position, wPosition);\n    } else {\n        return uniforms.modelViewMatrix * position;\n    }\n}\n#endif\n",varyings:[{name:"vWorldPosition",type:"vec4f"},{name:"vUVInExtent",type:"vec2f"},{name:"vHeightRatio",type:"f32"},{name:"vHeightOffset",type:"f32"}]},get_output:{attributes:[{defines:["HAS_MORPH"],name:"POSITION0",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION0",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION1",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION2",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION3",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION4",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION5",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION6",type:"vec3f"},{defines:["HAS_MORPH"],name:"POSITION7",type:"vec3f"},{defines:["HAS_MORPH","HAS_MORPHNORMALS"],name:"NORMAL0",type:"vec3f"},{defines:["HAS_MORPH","HAS_MORPHNORMALS"],name:"NORMAL0",type:"vec3f"},{defines:["HAS_MORPH","HAS_MORPHNORMALS"],name:"NORMAL1",type:"vec3f"},{defines:["HAS_MORPH","HAS_MORPHNORMALS"],name:"NORMAL2",type:"vec3f"},{defines:["HAS_TERRAIN_ALTITUDE"],name:"aTerrainAltitude",type:"f32"}],varyings:[{defines:["HAS_INSTANCE_COLOR","HAS_INSTANCE"],name:"vInstanceColor",type:"vec4f"}],vert:"\n#include <invert_matrix>\n#include <draco_decode_vert>\n\n\n#include <instance_vert>\n\n\n#ifdef HAS_SKIN\n    struct SkinUniforms {\n        skinAnimation: i32,\n    };\n    @group(0) @binding($b) var<uniform> skinUniforms: SkinUniforms;\n    #include <skin_vert>\n#endif\n\n#include <mask_vert>\n\n#ifdef HAS_MORPH\n    struct MorphUniforms {\n        morphWeights1: vec4f,\n        morphWeights2: vec4f,\n    };\n    @group(0) @binding($b) var<uniform> morphUniforms: MorphUniforms;\n#endif\n\n#ifdef HAS_MIN_ALTITUDE\n    struct AltitudeUniforms {\n        minAltitude: f32,\n    };\n    @group(0) @binding($b) var<uniform> altitudeUniforms: AltitudeUniforms;\n#endif\n\n#ifdef HAS_TERRAIN_FLAT_MASK\n    @group(0) @binding($b) var flatMask: texture_2d<f32>;\n    @group(0) @binding($b) var flatMaskSampler: sampler;\n#endif\n\nfn getPositionMatrix(input: VertexInput, vertexOutput: ptr<function, VertexOutput>, positionMatrix: mat4x4f) -> mat4x4f {\n    var worldMatrix: mat4x4f;\n#ifdef HAS_INSTANCE\n    let attributeMatrix = instance_getAttributeMatrix(input);\n    #ifdef HAS_INSTANCE_COLOR\n        vertexOutput.vInstanceColor = instance_getInstanceColor();\n    #endif\n    #ifdef HAS_SKIN\n        if (skinUniforms.skinAnimation == 1) {\n            worldMatrix = attributeMatrix * positionMatrix * skin_getSkinMatrix();\n        } else {\n            worldMatrix = attributeMatrix * positionMatrix;\n        }\n    #else\n        worldMatrix = attributeMatrix * positionMatrix;\n    #endif\n#else\n    #ifdef HAS_SKIN\n        if (skinUniforms.skinAnimation == 1) {\n            worldMatrix = skin_getSkinMatrix() * positionMatrix;\n        } else {\n            worldMatrix = positionMatrix;\n        }\n    #else\n        worldMatrix = positionMatrix;\n    #endif\n#endif\n    return worldMatrix;\n}\n\nfn getPosition(inputPosition: vec3f, vertexInput: VertexInput) -> vec4f {\n    var position = decode_getPosition(inputPosition);\n    #ifdef HAS_MORPH\n        let outputPosition = vec4f(position +\n            morphUniforms.morphWeights1[0] * vertexInput.POSITION0 +\n            morphUniforms.morphWeights1[1] * vertexInput.POSITION1 +\n            morphUniforms.morphWeights1[2] * vertexInput.POSITION2 +\n            morphUniforms.morphWeights1[3] * vertexInput.POSITION3 +\n            morphUniforms.morphWeights2[0] * vertexInput.POSITION4 +\n            morphUniforms.morphWeights2[1] * vertexInput.POSITION5 +\n            morphUniforms.morphWeights2[2] * vertexInput.POSITION6 +\n            morphUniforms.morphWeights2[3] * vertexInput.POSITION7, 1.0);\n    #else\n        var outputPosition = vec4f(position, 1.0);\n    #endif\n    #ifdef HAS_TERRAIN_ALTITUDE\n        outputPosition.z += vertexInput.aTerrainAltitude * 100.0;\n    #endif\n    #ifdef HAS_TERRAIN_FLAT_MASK\n        var uv = aTexCoord;\n        uv.y = 1.0 - uv.y;\n        let encodedHeight = textureSample(flatMask, flatMaskSampler, uv);\n        if (length(encodedHeight) < 2.0) {\n            float maskHeight = decodeFloat32(encodedHeight);\n            outputPosition.z = min(outputPosition.z, maskHeight);\n        }\n    #endif\n    #ifdef HAS_MIN_ALTITUDE\n        outputPosition.z += altitudeUniforms.minAltitude * 100.0;\n    #endif\n    return outputPosition;\n}\n\nfn appendMorphNormal(inputNormal: vec3f, vertexInput: VertexInput) -> vec3f {\n    #ifdef HAS_MORPHNORMALS\n        let normal = inputNormal +\n            morphUniforms.morphWeights1[0] * vertexInput.NORMAL0 +\n            morphUniforms.morphWeights1[1] * vertexInput.NORMAL1 +\n            morphUniforms.morphWeights1[2] * vertexInput.NORMAL2 +\n            morphUniforms.morphWeights1[3] * vertexInput.NORMAL3;\n    #else\n        let normal = inputNormal;\n    #endif\n    return normal;\n}\n"},skin:{vert:"\n// 定义 uniform 变量\nstruct JoinUniforms {\n    numJoints: f32,                     // 关节数量\n};\n\n@group(0) @binding($b) var<uniform> joinUniforms: JoinUniforms;\n\n// 定义采样器\n@group(0) @binding($b) var jointTextureSampler: sampler;\n@group(0) @binding($b) var jointTexture: texture_2df,      // 关节纹理\n\n// 定义采样点坐标\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\n\n// 获取骨骼矩阵函数\nfn skin_getBoneMatrix(jointNdx: f32) -> mat4x4f {\n    let v = (jointNdx + 0.5) / joinUniforms.numJoints;\n    return mat4x4f(\n        textureSample(jointTexture, jointTextureSampler, vec2f(ROW0_U, v)),\n        textureSample(jointTexture, jointTextureSampler, vec2f(ROW1_U, v)),\n        textureSample(jointTexture, jointTextureSampler, vec2f(ROW2_U, v)),\n        textureSample(jointTexture, jointTextureSampler, vec2f(ROW3_U, v))\n    );\n}\n\n// 获取皮肤矩阵函数\nfn skin_getSkinMatrix(JOINTS_0: vec4f, WEIGHTS_0: vec4f) -> mat4x4f {\n    var skinMatrix = skin_getBoneMatrix(JOINTS_0[0]) * WEIGHTS_0[0] +\n                     skin_getBoneMatrix(JOINTS_0[1]) * WEIGHTS_0[1] +\n                     skin_getBoneMatrix(JOINTS_0[2]) * WEIGHTS_0[2] +\n                     skin_getBoneMatrix(JOINTS_0[3]) * WEIGHTS_0[3];\n    return skinMatrix;\n}\n",attributes:[{name:"WEIGHTS_0",type:"vec4f"},{name:"JOINTS_0",type:"vec4f"}],defines:["HAS_SKIN"]},vertex_color:{vert:"\nstruct VertexColorsUniforms {\n    vertexColorsOfType: array<vec4f, VERTEX_TYPES_COUNT>\n}\n\n@group(0) @binding($b) var<uniform> vertexColors: VertexColorsUniforms;\n\nfn vertexColor_update(input: VertexInput, output: ptr<function, VertexOutput>) {\n    // 将 aVertexColorType 转换为整数索引\n    let index: i32 = i32(input.aVertexColorType);\n    // 获取对应的颜色\n    output.vertexColorColor = vertexColors.vertexColorsOfType[index];\n}\n\n",frag:"\nfn vertexColor_get(input: VertexOutput) -> vec4<f32> {\n    return input.vertexColorColor;\n}\n",attributes:[{name:"aVertexColorType",type:"u32"}],varyings:[{name:"vertexColorColor",type:"vec4f"}],defines:["HAS_VERTEX_COLOR"]},vsm_shadow:{defines:i=>i.HAS_SHADOWING&&!i.HAS_BLOOM,vert:"\nstruct ShadowUniforms {\n    shadow_lightProjViewModelMatrix: mat4x4f,\n};\n\n@group(0) @binding($b) var<uniform> shadowUniforms: ShadowUniforms;\n\nstruct VertexOutput {\n    shadow_vLightSpacePos: vec4f,\n};\n\nfn shadow_computeShadowPars(position: vec4f, vertexOutput: VertexOutput) {\n    vertexOutput.shadow_vLightSpacePos = shadowUniforms.shadow_lightProjViewModelMatrix * position;\n}\n",frag:"\nstruct ShadowUniforms {\n    shadow_opacity: f32,\n    shadow_color: vec3f,\n    esm_shadow_threshold: f32\n};\n\n@group(0) @binding($b) var<uniform> shadowUniforms: ShadowUniforms;\n@group(0) @binding($b) var shadow_shadowMapSampler: sampler;\n@group(0) @binding($b) var shadow_shadowMap: texture_2d<f32>;\n\n\n#ifdef PACK_FLOAT\n#include <common_pack_float>\n#endif\n\nfn esm(projCoords: vec3f, shadowTexel: vec4f) -> f32 {\n    let compare = projCoords.z;\n    let c = 120.0;\n#ifdef PACK_FLOAT\n    let depth = common_decodeDepth(shadowTexel);\n    if (depth >= 1.0 - 1E-6 || compare <= depth) {\n        return 1.0;\n    }\n#else\n    let depth = shadowTexel.r;\n#endif\n\n    let depth = exp(-c * min(compare - depth, 0.05));\n    return clamp(depth, shadowUniforms.esm_shadow_threshold, 1.0);\n}\n\nfn shadow_computeShadow_coeff(shadowMap: texture_2d<f32>, projCoords: vec3f) -> f32 {\n    let uv = projCoords.xy;\n    let shadowTexel = textureSample(shadowMap, shadow_shadowMapSampler, uv);\n    let esm_coeff = esm(projCoords, shadowTexel);\n    let coeff = esm_coeff * esm_coeff;\n    return 1.0 - (1.0 - coeff) * shadowUniforms.shadow_opacity;\n}\n\nfn shadow_computeShadow(vertexOutput: VertexOutput) -> f32 {\n    let projCoords = vertexOutput.shadow_vLightSpacePos.xyz / vertexOutput.shadow_vLightSpacePos.w;\n    projCoords = projCoords * 0.5 + 0.5;\n    if (projCoords.z >= 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || projCoords.y < 0.0 || projCoords.y > 1.0) {\n        return 1.0;\n    }\n    return shadow_computeShadow_coeff(shadow_shadowMap, projCoords);\n}\n\nfn shadow_blend(color: vec3f, coeff: f32) -> vec3f {\n    color = color * coeff + shadowUniforms.shadow_color * shadowUniforms.shadow_opacity * (1.0 - coeff);\n    return color;\n}\n",varyings:[{name:"shadow_vLightSpacePos",type:"vec4f",defines:["HAS_SHADOWING"]}]},draco_decode:{vert:"\n#if HAS_DRACO_NORMAL || HAS_DRACO_POSITION || HAS_DRACO_TEXCOORD || HAS_WEB3D_QUANTIZED_ATTRIBUTES_TEXCOORD || HAS_COMPRESSED_INT16\n    // 定义 uniform 变量\n    struct DracoUniforms {\n        #if HAS_DRACO_NORMAL\n            gltf_u_dec_normal_rangeConstant: f32,\n        #endif\n\n        #if HAS_DRACO_POSITION\n            minValues_pos: vec3f,\n            gltf_u_dec_position_normConstant: f32,\n        #endif\n\n        #if HAS_DRACO_TEXCOORD\n            minValues_tex: vec2f,\n            gltf_u_dec_texcoord_0_normConstant: f32,\n        #endif\n\n        #if HAS_WEB3D_QUANTIZED_ATTRIBUTES_TEXCOORD\n            decodeMatrix: mat3x3f,\n        #endif\n\n    #if HAS_COMPRESSED_INT16\n        #if HAS_COMPRESSED_INT16_POSITION\n            compressedPositionRange: vec2f, // 压缩位置范围\n        #endif\n        #if HAS_COMPRESSED_INT16_TEXCOORD_0\n            compressedTexcoordRange_0: vec2f, // 压缩纹理坐标范围 0\n        #endif\n        #if HAS_COMPRESSED_INT16_TEXCOORD_1\n            compressedTexcoordRange_1: vec2f, // 压缩纹理坐标范围 1\n        #endif\n        #if HAS_COMPRESSED_INT16_NORMAL\n            compressedNormalRange: vec2f, // 压缩法线范围\n        #endif\n        #if HAS_COMPRESSED_INT16_RATIO\n            compressed_ratio: f32, // 压缩比例\n        #endif\n    #endif\n    };\n\n    @group(0) @binding($b) var<uniform> dracoUniforms: DracoUniforms;\n#endif\n\n    // Draco 位置解码函数\n    #ifdef HAS_DRACO_POSITION\n    fn decodeDracoPosition(aPosition: vec3f) -> vec3f {\n        return dracoUniforms.minValues_pos + aPosition * dracoUniforms.gltf_u_dec_position_normConstant;\n    }\n    #endif\n\n    // Draco 纹理坐标解码函数\n    #ifdef HAS_DRACO_TEXCOORD\n    fn decodeDracoTexcoord(aTexCoord: vec2f) -> vec2f {\n        return dracoUniforms.minValues_tex + aTexCoord * dracoUniforms.gltf_u_dec_texcoord_0_normConstant;\n    }\n    #endif\n\n    // Draco 法线解码函数\n    #ifdef HAS_DRACO_NORMAL\n    fn czm_signNotZero(value: f32) -> f32 {\n        return select(-1.0, 1.0, value >= 0.0);\n    }\n\n    fn czm_signNotZero(value: vec2f) -> vec2f {\n        return vec2f(czm_signNotZero(value.x), czm_signNotZero(value.y));\n    }\n\n    fn decodeDracoNormal(encoded: vec2f, range: f32) -> vec3f {\n        if (encoded.x == 0.0 && encoded.y == 0.0) {\n            return vec3f(0.0, 0.0, 0.0);\n        }\n        encoded = encoded / range * 2.0 - 1.0;\n        var v = vec3f(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n        if (v.z < 0.0) {\n            v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n        }\n        return normalize(v);\n    }\n\n    fn decode_getNormal(aNormal: vec2f) -> vec3f {\n        return decodeDracoNormal(aNormal, dracoUniforms.gltf_u_dec_normal_rangeConstant).zxy;\n    }\n    #endif\n\n    // 压缩属性解码函数\n    #ifdef HAS_COMPRESSED_INT16\n    fn int16ToFloat32(value: f32, range: vec2f) -> f32 {\n        let v = select(value / 32767.0, -(65536.0 - value) / 32768.0, value >= 32768.0);\n        return (v + 1.0) * (range.y - range.x) / 2.0 + range.x;\n    }\n    #endif\n\n    // 顶点位置解码函数\n    fn decode_getPosition(aPosition: vec3f) -> vec3f {\n        var position = aPosition;\n    #if HAS_COMPRESSED_INT16 && HAS_COMPRESSED_INT16_POSITION\n        let x = int16ToFloat32(aPosition.x, dracoUniforms.compressedPositionRange);\n        let y = int16ToFloat32(aPosition.y, dracoUniforms.compressedPositionRange);\n        let z = int16ToFloat32(aPosition.z, dracoUniforms.compressedPositionRange);\n        #ifdef HAS_COMPRESSED_INT16_RATIO\n            position = vec3f(x / dracoUniforms.compressed_ratio, y / dracoUniforms.compressed_ratio, z);\n        #else\n            position = vec3f(x, y, z);\n        #endif\n    #endif\n    #ifdef HAS_DRACO_POSITION\n        return decodeDracoPosition(position);\n    #else\n        return position;\n    #endif\n    }\n\n    // 纹理坐标解码函数\n    fn decode_getTexcoord(aTexCoord: vec2f) -> vec2f {\n        var texcoord = aTexCoord;\n    // if HAS_COMPRESSED_INT16 && (HAS_COMPRESSED_INT16_TEXCOORD_0 || HAS_COMPRESSED_INT16_TEXCOORD_1)\n    #if HAS_COMPRESSED_INT16\n        #if HAS_COMPRESSED_INT16_TEXCOORD_0 || HAS_COMPRESSED_INT16_TEXCOORD_1\n            let x = int16ToFloat32(aTexCoord.x, dracoUniforms.compressedTexcoordRange_0);\n            let y = int16ToFloat32(aTexCoord.y, dracoUniforms.compressedTexcoordRange_0);\n            texcoord = vec2f(x, y);\n        #endif\n    #endif\n    #ifdef HAS_DRACO_TEXCOORD\n        return decodeDracoTexcoord(texcoord);\n    #else\n        #if HAS_WEB3D_QUANTIZED_ATTRIBUTES_TEXCOORD\n            let web3dTexcoord = dracoUniforms.decodeMatrix * vec3f(texcoord, 1.0);\n            return vec2f(web3dTexcoord.x, web3dTexcoord.y);\n        #else\n            return texcoord;\n        #endif\n    #endif\n    }\n\n    // 法线解码函数\n    fn decode_getNormal(aNormal: vec3f) -> vec3f {\n    #ifdef HAS_COMPRESSED_INT16_NORMAL\n        aNormal.x = int16ToFloat32(aNormal.x, dracoUniforms.compressedNormalRange);\n        aNormal.y = int16ToFloat32(aNormal.y, dracoUniforms.compressedNormalRange);\n        aNormal.z = int16ToFloat32(aNormal.z, dracoUniforms.compressedNormalRange);\n    #endif\n        return aNormal;\n    }\n"},highlight:{defines:i=>i.HAS_HIGHLIGHT_OPACITY||i.HAS_HIGHLIGHT_COLOR,vert:"\n\n    // 顶点着色器函数\n    fn highlight_setVarying(input: VertexInput, output: ptr<function, VertexOutput>) {\n        // 如果有高亮颜色\n    #if HAS_HIGHLIGHT_COLOR\n        output.vHighlightColor = input.aHighlightColor / 255.0;\n    #endif\n\n        // 如果有高亮透明度\n    #if HAS_HIGHLIGHT_OPACITY\n        output.vHighlightOpacity = input.aHighlightOpacity / 255.0;\n    #endif\n    }\n",frag:"\n    // 高亮颜色混合函数\n    fn highlight_blendColor(color: vec4f, output: VertexOutput) -> vec4f {\n        var outColor: vec4f = color;\n\n        // 如果有高亮颜色\n        #if HAS_HIGHLIGHT_COLOR\n            outColor.rgb = outColor.rgb * (1.0 - output.vHighlightColor.a) + output.vHighlightColor.rgb * output.vHighlightColor.a;\n            #if HAS_HIGHLIGHT_COLOR_POINT\n            #else\n            // 如果没有高亮颜色点\n                outColor.a = outColor.a * (1.0 - output.vHighlightColor.a) + output.vHighlightColor.a;\n            #endif\n        #endif\n\n            // 如果有高亮透明度\n        #if HAS_HIGHLIGHT_OPACITY\n            outColor *= output.vHighlightOpacity;\n        #endif\n\n        return outColor;\n    }\n",attributes:[{defines:["HAS_HIGHLIGHT_COLOR"],name:"aHighlightColor",type:"vec4f"},{defines:["HAS_HIGHLIGHT_OPACITY"],name:"aHighlightOpacity",type:"f32"}],varyings:[{defines:["HAS_HIGHLIGHT_COLOR"],name:"vHighlightColor",type:"vec4f"},{defines:["HAS_HIGHLIGHT_OPACITY"],name:"vHighlightOpacity",type:"f32"}]},compute_texcoord:{defines:["HAS_MAP"],frag:"\n#ifdef HAS_KHR_TEXTURE_TRANSFORM\n    struct TextureTransformUniforms {\n        offset: vec2f,\n        rotation: f32,\n        scale: vec2f,\n    };\n\n    @group(0) @binding($b) var<uniform> textureTransformUniforms: TextureTransformUniforms;\n\n    fn khr_tex_transformTexCoord(texCoords: vec2f, offset: vec2f, rotation: f32, scale: vec2f) -> vec2f {\n        rotation = -rotation;\n        let transform = mat3x3f(\n            cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0,\n            -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0,\n            offset.x, offset.y, 1.0\n        );\n        let transformedTexCoords = (transform * vec3f(fract(texCoords), 1.0)).xy;\n        return transformedTexCoords;\n    }\n#endif\n\nfn computeTexCoord(vertexOutput: VertexOutput) -> vec2f {\n    let texCoord = vertexOutput.vTexCoord;\n    #ifdef HAS_I3S_UVREGION\n        let atlasScale = vertexOutput.vUvRegion.zw - vertexOutput.vUvRegion.xy;\n        let uvAtlas = fract(texCoord) * atlasScale + vertexOutput.vUvRegion.xy;\n        return uvAtlas;\n    #elif HAS_KHR_TEXTURE_TRANSFORM\n        let uniforms = textureTransformUniforms;\n        return khr_tex_transformTexCoord(texCoord, uniforms.offset, uniforms.rotation, uniforms.scale);\n    #else\n        return texCoord;\n    #endif\n}\n"},fbo_picking:{vert:"\n//--------------------------\n// Picking\n//\n// #define ENABLE_PICKING 整型 是否开启PICKING\n//\n// uniform int batchId geometry的批次id\n//\n//\n// fn fbo_picking_setData(viewPosZ: f32, visible: bool)\n//   设置picking数据,必须在设置gl_Position后调用\n//\n// 示例：\n// fbo_picking_setData(output.position.w, true);\n//--------------------------\n\n#ifdef ENABLE_PICKING\n#if HAS_PICKING_ID == 2\n    struct PickingUniforms {\n        uPickingId: f32,\n    }\n    @group(0) @binding($b) var<uniform> pickingUniforms: PickingUniforms;\n#endif\n#endif\n\nfn fbo_picking_setData(input: VertexInput, output: ptr<function, VertexOutput>, viewPosZ: f32, visible: bool) {\n    #ifdef ENABLE_PICKING\n    #if HAS_PICKING_ID == 1\n       output.vPickingId = input.aPickingId;\n    #elif HAS_PICKING_ID == 2\n        output.vPickingId = pickingUniforms.uPickingId;\n    #endif\n        output.vFbo_picking_viewZ = viewPosZ;\n        output.vFbo_picking_visible = select(0.0, 1.0, visible);\n    #endif\n    output.vFbo_picking_fragDepth = viewPosZ + 1.0;\n}\n",attributes:[{defines:i=>1===i.HAS_PICKING_ID,name:"aPickingId",type:"f32"}],varyings:[{defines:["ENABLE_PICKING"],name:"vPickingId",type:"f32"},{defines:["ENABLE_PICKING"],name:"vFbo_picking_viewZ",type:"f32"},{defines:["ENABLE_PICKING"],name:"vFbo_picking_visible",type:"f32"},{name:"vFbo_picking_fragDepth",type:"f32"}]},common_pack_float:{vert:qS,frag:qS},excavate:{defines:["HAS_EXCAVATE_ANALYSIS"],vert:"\n#ifdef HAS_EXCAVATE_ANALYSIS\nstruct ExcavateUniforms {\n    excavateExtent: vec4f\n};\n\n@group(0) @binding($b) var<uniform> excavateUniforms: ExcavateUniforms;\n\nfn getWorldHeight(localPosition: vec4f, modelMatrix: mat4x4f) -> f32 {\n    let wPosition = uniforms.modelMatrix * localPosition;\n    return wPosition.z;\n}\n\nfn getCoordinateTexcoord(localPosition: vec4f, modelMatrix: mat4x4f) -> vec2f {\n    let wPosition = modelMatrix * localPositionMatrix;\n    let x = (wPosition.x - excavateUniforms.excavateExtent.x) /\n           (excavateUniforms.excavateExtent.z - excavateUniforms.excavateExtent.x);\n    let y = (wPosition.y - excavateUniforms.excavateExtent.y) /\n           (excavateUniforms.excavateExtent.w - excavateUniforms.excavateExtent.y);\n    return vec2f(x, y);\n}\n\n#endif\n",frag:"\n#ifdef HAS_EXCAVATE_ANALYSIS\nstruct ExcavateUniforms {\n    excavateHeight: f32,\n    heightRange: vec2f  // Replaces the const range\n};\n\n@group(0) @binding($b) var<uniform> excavateUniforms: ExcavateUniforms;\n@group(0) @binding($b) var heightmap: texture_2d<f32>;\n@group(0) @binding($b) var heightmapSampler: sampler;\n\n\nfn decodeHeight(pack: vec4f) -> f32 {\n    return pack.r + pack.g / 255.0;\n}\n\nfn excavateColor(fragColor: vec4f, vertexOutput: VertexOutput) -> vec4f {\n    let samplerHeight = decodeHeight(textureSample(heightmap, heightmapSampler, vertexOutput.vCoordinateTexcoord));\n    let realHeight = samplerHeight * (excavateUniforms.heightRange.y - excavateUniforms.heightRange.x) + excavateUniforms.heightRange.x;\n\n    let validHeight = select(\n        0.0,\n        realHeight,\n        realHeight >= excavateUniforms.heightRange.x && realHeight <= excavateUniforms.heightRange.y\n    );\n\n    if (vertexOutput.vExcavateHeight > validHeight) {\n        discard;\n    }\n    return fragColor;\n}\n#endif\n",varyings:[{name:"vCoordinateTexcoord",type:"vec2f"},{name:"vExcavateHeight",type:"f32"}]},hsv:{frag:"\nconst HSV_K0 = vec4f(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nconst HSV_K1 = vec4f(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nconst HSV_E = 1.0e-10;\n\nfn hsv_rgb2hsv(c: vec3f) -> vec3f {\n    var K = HSV_K0;\n    var p = mix(vec4f(c.bg, K.wz), vec4f(c.gb, K.xy), select(0.0, 1.0, c.b <= c.g));\n    var q = mix(vec4f(p.xyw, c.r), vec4f(c.r, p.yzx), select(0.0, 1.0, p.x <= c.r));\n\n    // Alternative implementation commented out\n    // var p = select(vec4f(c.gb, K.xy), vec4f(c.bg, K.wz), c.g < c.b);\n    // var q = select(vec4f(c.r, p.yzx), vec4f(p.xyw, c.r), c.r < p.x);\n\n    let d = q.x - min(q.w, q.y);\n    let e = HSV_E;\n    return vec3f(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nfn hsv_hsv2rgb(c: vec3f) -> vec3f {\n    let K = HSV_K1;\n    let p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, vec3f(0.0), vec3f(1.0)), c.y);\n}\n\nfn hsv_apply4(c: vec4f, hsvOffset: vec3f) -> vec4f {\n    var hsv = hsv_rgb2hsv(c.rgb);\n    hsv += hsv * hsvOffset;\n    hsv = clamp(hsv, vec3f(0), vec3f(1));\n    return vec4f(hsv_hsv2rgb(hsv), c.a);\n}\n\nfn hsv_apply3(c: vec3f, hsvOffset: vec3f) -> vec3f {\n    var hsv = hsv_rgb2hsv(c);\n    hsv += hsv * hsvOffset;\n    hsv = clamp(hsv, vec3f(0), vec3f(1));\n    return hsv_hsv2rgb(hsv);\n}\n\nfn contrastMatrix(contrast: f32) -> mat4x4f {\n    let t = (1.0 - contrast) / 2.0;\n    return mat4x4f(\n        vec4f(contrast, 0.0, 0.0, 0.0),\n        vec4f(0.0, contrast, 0.0, 0.0),\n        vec4f(0.0, 0.0, contrast, 0.0),\n        vec4f(t, t, t, 1.0)\n    );\n}\n"},srgb:{frag:"\nfn linearTosRGB(color: vec3f) -> vec3f {\n    return vec3f(\n        select(1.055 * pow(color.r, 1.0/2.4) - 0.055, color.r * 12.92, color.r < 0.0031308),\n        select(1.055 * pow(color.g, 1.0/2.4) - 0.055, color.g * 12.92, color.g < 0.0031308),\n        select(1.055 * pow(color.b, 1.0/2.4) - 0.055, color.b * 12.92, color.b < 0.0031308)\n    );\n}\n\nfn sRGBToLinear(color: vec3f) -> vec3f {\n    return vec3f(\n        select(pow((color.r + 0.055) * (1.0 / 1.055), 2.4), color.r * (1.0 / 12.92), color.r < 0.04045),\n        select(pow((color.g + 0.055) * (1.0 / 1.055), 2.4), color.g * (1.0 / 12.92), color.g < 0.04045),\n        select(pow((color.b + 0.055) * (1.0 / 1.055), 2.4), color.b * (1.0 / 12.92), color.b < 0.04045)\n    );\n}\n"},snow:{defines:["HAS_SNOW"],frag:"\n#ifdef HAS_SNOW\nstruct SnowUniforms {\n    snowHeightThreshold: f32  // Added as a configurable uniform\n};\n\n@group(0) @binding($b) var<uniform> snowUniforms: SnowUniforms;\n\nfn lerp(a: f32, b: f32, w: f32) -> f32 {\n    return a + w * (b - a);\n}\n\nfn snow(sceneColor: vec4f, normalColor: vec3f, height: f32) -> vec3f {\n    let snowIntense = normalColor.b;\n    let fixedC = vec3f(1.0, 1.0, 1.0);\n\n    if (height < snowUniforms.snowHeightThreshold) {\n        let r = lerp(0.5, fixedC.x, snowIntense);\n        let g = lerp(0.5, fixedC.y, snowIntense);\n        let b = lerp(0.5, fixedC.z, snowIntense);\n        return vec3f(r, g, b);\n    } else {\n        let r = lerp(sceneColor.r, fixedC.x, snowIntense);\n        let g = lerp(sceneColor.g, fixedC.y, snowIntense);\n        let b = lerp(sceneColor.b, fixedC.z, snowIntense);\n        return vec3f(r, g, b);\n    }\n}\n#endif\n"},terrain_normal:{defines:["HAS_TERRAIN_NORMAL"],frag:"\n#ifdef HAS_TERRAIN_NORMAL\nstruct TerrainNormalUniforms {\n    terrainHeightMapResolution: vec2f,\n    terrainResolution: vec2f,\n    terrainHeightScale: f32,\n    terrainTileResolution: f32,\n    terrainUnpackFactors: vec4f\n};\n\n@group(0) @binding($b) var<uniform> terrainNormalUniforms: TerrainNormalUniforms;\n@group(0) @binding($b) var terrainHeightTexture: texture_2d<f32>;\n@group(0) @binding($b) var terrainHeightSampler: sampler;\n\nfn getHeight(uv: vec2f) -> f32 {\n    let color = textureSample(terrainHeightTexture, terrainHeightSampler, uv) * 255.0;\n    let colorWithAlpha = vec4f(color.rgb, -1.0);\n    return dot(colorWithAlpha, terrainNormalUniforms.terrainUnpackFactors) / 4.0;\n}\n\nfn convertTerrainHeightToNormalMap(uv: vec2f) -> vec3f {\n    let flippedUV = vec2f(uv.x, 1.0 - uv.y);\n    let epsilon = 1.0 / terrainNormalUniforms.terrainHeightMapResolution;\n\n    let a = getHeight(flippedUV + vec2f(-epsilon.x, -epsilon.y));\n    let b = getHeight(flippedUV + vec2f(0.0, -epsilon.y));\n    let c = getHeight(flippedUV + vec2f(epsilon.x, -epsilon.y));\n    let d = getHeight(flippedUV + vec2f(-epsilon.x, 0.0));\n    let e = getHeight(flippedUV + vec2f(epsilon.x, 0.0));\n    let f = getHeight(flippedUV + vec2f(-epsilon.x, epsilon.y));\n    let g = getHeight(flippedUV + vec2f(0.0, epsilon.y));\n    let h = getHeight(flippedUV + vec2f(epsilon.x, epsilon.y));\n\n    let dxy = vec2f(\n        (c + e + e + h) - (a + d + d + f),\n        (f + g + g + h) - (a + b + b + c)\n    );\n    return normalize(vec3f(dxy / epsilon, terrainNormalUniforms.terrainResolution.x));\n}\n#endif\n"},mesh_picking:{vert:"\n#include <fbo_picking_vert>\n#include <get_output>\n\nstruct VertexInput {\n    @location($i) aPosition: vec3f,\n}\n\nstruct Uniforms {\n    projViewModelMatrix: mat4x4f,\n    modelMatrix: mat4x4f,\n    positionMatrix: mat4x4f,\n}\n\n@group(0) @binding($b) var<uniform> uniforms: Uniforms;\n\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    // 其他varying变量可以在这里添加\n}\n\n@vertex\nfn main(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n\n    let localPositionMatrix = getPositionMatrix(input, &output, uniforms.modelMatrix);\n    let localPosition = getPosition(vec3f(input.aPosition.xyz), input);\n\n    output.position = uniforms.projViewModelMatrix * localPositionMatrix * localPosition;\n    // 传入Position的depth值\n    fbo_picking_setData(input, &output, output.position.w, true);\n\n    return output;\n}\n"}};var ZS={register(i,g){if(XS[i])throw new Error(`Key of ${i} is already registered in WgslShaderLib.`);XS[i]=g},compile:(i,g)=>new SourceCompiler(i,g).compile(),get:i=>XS[i]};const $S=/^[ \t]*#include +<([\w\d.]+)>/gm,YS=/\bstruct\s+VertexInput\b/,QS=/\bstruct\s+VertexOutput\b/;class SourceCompiler{constructor(i,g){this.defines=g,this.source=i,this.isVert=i.indexOf("@vertex")>-1,this.varyings=[],this.attributes=[]}compile(){let i=this.source;return i=this.parseIncludes(i),this.isVert&&(i=this.fillAttributes(i)),i=this.fillVaryings(i),i}parseIncludes(i){return i.replace($S,((i,g)=>{let m=g;(g.endsWith("_vert")||g.endsWith("_frag"))&&(m=g.substring(0,g.length-5));const _=XS[m];if(!_)throw new Error("Can not resolve #include <"+g+">");if(_.defines&&!this.checkDefines(_.defines))return"";if(_.varyings)for(let i=0;i<_.varyings.length;i++){const g=_.varyings[i];g.defines&&!this.checkDefines(g.defines)||this.varyings.push(g)}if(_.attributes)for(let i=0;i<_.attributes.length;i++){const g=_.attributes[i];g.defines&&!this.checkDefines(g.defines)||this.attributes.push(g)}return this.parseIncludes(this.isVert?_.vert:_.frag)}))}fillAttributes(i){return this.fillStruct(i,YS,"$i",this.attributes)}fillVaryings(i){return this.fillStruct(i,QS,this.isVert?"$o":"$i",this.varyings)}fillStruct(i,g,m,_){if(!_.length)return i;const b=i.search(g),T=i.indexOf("}",b),P=i.substring(0,T),I=i.substring(T),H=[];for(let i=0;i<_.length;i++){const{name:g,type:b}=_[i];H.push(`@location(${m}) ${g}: ${b},`)}return P+H.join("\n")+"\n"+I}checkDefines(i){if(Array.isArray(i))for(let g=0;g<i.length;g++){if(!this.defines[i[g]])return!1}else if(!i(this.defines))return!1;return!0}}const JS={"=":"equal","<":"less","<=":"less-equal",lequal:"less-equal",">":"greater","!=":"not-equal",notequal:"not-equal",">=":"greater-equal",gequal:"greater-equal"};function KS(i){return JS[i]||i}const eM={triangles:"triangle-list","triangle strip":"triangle-strip",lines:"line-list"};const tM={0:"zero",1:"one","src color":"src","one minus src color":"one-minus-src","src alpha":"src-alpha","one minus src alpha":"one-minus-src-alpha","dst color":"dst","one minus dst color":"one-minus-dst","dst alpha":"dst-alpha","one minus dst alpha":"one-minus-dst-alpha"};function nM(i){return tM[i]||i}const rM={clamp:"clamp-to-edge",mirror:"mirror-repeat"};function iM(i,g,m,_,b){const T={magFilter:g};return"nearest"===i||"linear"===i?T.minFilter=i:"linear mipmap linear"===i||"mipmap"===i?(T.minFilter="linear",T.mipmapFilter="linear"):"nearest mipmap nearest"===i?(T.minFilter="linear",T.mipmapFilter="nearest"):"nearest mipmap linear"===i?(T.minFilter="nearest",T.mipmapFilter="linear"):"linear mipmap nearest"===i&&(T.minFilter="linear",T.mipmapFilter="nearest"),T.addressModeU=rM[m||"clamp"]||m,T.addressModeV=rM[_||"clamp"]||_,b&&(T.compare=b),T}function oM(i,g){if("depth stencil"===(i=i||"rgba")||"depth24 stencil8"===i)return{format:"depth24plus-stencil8",bytesPerTexel:4,isDepthStencil:!0};if("depth"===i)return{format:"depth24plus",bytesPerTexel:4,isDepthStencil:!1};if("alpha"===i)return{format:"r8unorm",bytesPerTexel:1,isDepthStencil:!1};if("uint8"===(g=g||"uint8")){let g=i;return"rgba"===i&&(g="rgba8unorm"),{format:g,bytesPerTexel:4,isDepthStencil:!1}}return"float16"===g||"half float"===g?{format:"r16float",bytesPerTexel:2,isDepthStencil:!1}:"float"===g?{format:"r32float",bytesPerTexel:4,isDepthStencil:!1}:{format:i,bytesPerTexel:4,isDepthStencil:!1}}class PipelineDescriptor{readFromREGLCommand(i,g,m,_){i||(i={});const b=g.getMaterial();let T=!1;b&&(T=b.doubleSided);this.topology=function(i){return eM[i]||"triangle-list"}(g.geometry.desc.primitive);const P=!_||!!_.depthTexture,I=!_||_.depthTexture&&_.depthTexture.gpuFormat.isDepthStencil;let H,W;if(this.functionProps=[],P&&i.polygonOffset&&sM(i.polygonOffset.enable,m))if(this.topology.startsWith("triangle")){const g=i.polygonOffset.offset;g&&!ax(g.units)&&(hx(g.units)?(H=g.units(null,m),this.functionProps.push({func:g.units,v:H})):H=g.units),g&&!ax(g.factor)&&(hx(g.factor)?(W=g.factor(null,m),this.functionProps.push({func:g.factor,v:W})):W=g.factor)}else H=0,W=0;this.depthBias=H,this.depthBiasSlopeScale=W;let q="always",$=!1;const ye=i.depth;if(P&&ye&&sM(ye.enable,m)){if(ye.func){let i=ye.func;hx(ye.func)&&(i=i(null,m),this.functionProps.push({func:ye.func,v:i})),q=KS(i)}$=!0,ax(ye.mask)||(hx(ye.mask)?($=ye.mask(null,m),this.functionProps.push({func:ye.mask,v:$})):$=!!ye.mask)}this.depthCompare=q,this.depthWriteEnabled=$;let Re="always",Be="keep";const Ge=i.stencil;if(I&&Ge&&sM(Ge.enable,m)){if(Ge.op&&(Be=Ge.op.zpass,hx(Be))){Be=Be(null,m),this.functionProps.push({func:Ge.op.zpass,v:Be})}if(Ge.func){let i=Ge.func.cmp;i||(i="always");let g=i;hx(g)&&(g=i(null,m),this.functionProps.push({func:i,v:g})),Re=KS(g)}}let je,Xe,Ze,Ye;this.stencilFrontCompare=Re,this.stencilFrontPassOp=Be;const Qe=i.blend;if(Qe&&sM(Qe.enable,m)&&Qe.func){const i=Qe.func;if(i.src){let g=i.src;hx(i.src)&&(g=i.src(null,m),this.functionProps.push({func:i.src,v:g})),je=nM(g),Ze=je}if(i.dst){let g=i.dst;hx(i.dst)&&(g=i.dst(null,m),this.functionProps.push({func:i.dst,v:g})),Xe=nM(g),Ye=Xe}if(i.srcAlpha){let g=i.srcAlpha;hx(i.srcAlpha)&&(g=i.srcAlpha(null,m)||this.functionProps.push({func:i.srcAlpha,v:g})),je=nM(g)}if(i.srcRGB){let g=i.srcRGB;hx(i.srcRGB)&&(g=i.srcRGB(null,m)||this.functionProps.push({func:i.srcRGB,v:g})),Ze=nM(g)}if(i.dstAlpha){let g=i.dstAlpha;hx(i.dstAlpha)&&(g=i.dstAlpha(null,m)||this.functionProps.push({func:i.dstAlpha,v:g})),Xe=nM(g)}if(i.dstRGB){let g=i.dstRGB;hx(i.dstRGB)&&(g=i.dstRGB(null,m)||this.functionProps.push({func:i.dstRGB,v:g})),Ye=nM(g)}}this.blendAlphaDst=Xe,this.blendAlphaSrc=je,this.blendColorDst=Ye,this.blendColorSrc=Ze;let Je="none";if(!T){const g=i.cull;g&&sM(g.enable,m)&&(Je="back",g.face&&(Je=g.face,hx(g.face)&&(Je=g.face(null,m)||this.functionProps.push({func:g.face,v:Je}))))}this.cullMode=Je,this.frontFace=i.frontFace;let Ke=i.colorMask;if(Ke){hx(Ke)&&(Ke=Ke(null,m),this.functionProps.push({func:i.colorMask,v:Ke}));let g=0;Ke[0]&&(g|=GPUColorWrite.RED),Ke[1]&&(g|=GPUColorWrite.GREEN),Ke[2]&&(g|=GPUColorWrite.BLUE),Ke[3]&&(g|=GPUColorWrite.ALPHA),this.writeMask=g}}generateValuesKey(i){return i.map((i=>Array.isArray(i)?i.join():i)).join("-")}getFnValuesKey(){return this.generateValuesKey(this.functionProps.map((i=>i.v)))}getSignatureKey(){return(this.depthBias||0)+"-"+(this.depthBiasSlopeScale||0)+"-"+(this.depthCompare||0)+"-"+(this.depthWriteEnabled||0)+(this.stencilFrontCompare||0)+"-"+(this.stencilFrontPassOp||0)+(this.blendAlphaSrc||0)+"-"+(this.blendAlphaDst||0)+"-"+(this.blendColorSrc||0)+"-"+(this.blendColorDst||0)+(this.cullMode||0)+"-"+(this.frontFace||0)+"-"+(this.topology||0)+"-"+(this.writeMask||0)}}function sM(i,g){return hx(i)?!!(i=i(null,g)):!!i}let aM=new ArrayBuffer(4194304);class GraphicsTexture{constructor(i,g){this._bindGroups=[],this.device=i,this.config=g,this.gpuFormat=oM(g.format,g.type),this._updateTexture()}get width(){return this.texture&&this.texture.width||this.config&&this.config.width}get height(){return this.texture&&this.texture.height||this.config&&this.config.height}updateFilter(){this._clearBindGroups()}_clearBindGroups(){if(this._bindGroups.length){for(let i=0;i<this._bindGroups.length;i++)this._bindGroups[i].outdated=!0;this._bindGroups=[]}}resize(i,g){this.texture&&this.texture.width===i&&this.texture.height===g||(this.config.width=i,this.config.height=g,this._updateTexture())}update(i){cx(this.config,i),this.gpuFormat=oM(this.config.format,this.config.type),this._updateTexture()}_updateTexture(){const i=this.config,g=this.device.wgpu;let m;this.texture&&(this.texture.destroy(),this._clearBindGroups());{let _=i.width,b=i.height;if(void 0===_||void 0===b){const g=i.data;if(px(i.data)){_=Math.sqrt(i.data.length/4),b=_}else _=g.width,b=g.height}const T=this.gpuFormat.format,P={size:[_,b,1],format:T,usage:"depth24plus"===T||"depth24plus-stencil8"===T?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};if(i.sampleCount&&(P.sampleCount=i.sampleCount),m=g.createTexture(P),i.data)if(px(i.data)){const T=i.data,P=!i.type||"uint8"===i.type;let I;I=Array.isArray(T)?P?T.length:4*T.length:T.byteLength;const H=(!i.format||"rgba"===i.format)&&i.premultiplyAlpha;let W;if((H||Array.isArray(T))&&(aM.byteLength<I&&(aM=new ArrayBuffer(I)),W=P?new Uint8Array(aM,0,I):new Float32Array(aM,0,I/4)),H){const i=P?255:1;for(let g=0;g<T.length;g+=4){const m=T[g+3]/i;W[g]=T[g]*m,W[g+1]=T[g+1]*m,W[g+2]=T[g+2]*m,W[g+3]=T[g+3]}}else if(Array.isArray(T))for(let i=0;i<T.length;i++)W[i]=T[i];else W=T;g.queue.writeTexture({texture:m},W.buffer,{bytesPerRow:_*this.gpuFormat.bytesPerTexel},[_,b])}else g.queue.copyExternalImageToTexture({source:i.data,flipY:!!this.config.flipY},{texture:m,premultipliedAlpha:!!this.config.premultiplyAlpha},[_,b])}this.texture=m}getView(){return this.texture.createView()}addBindGroup(i){this._bindGroups.push(i)}destroy(){this.texture&&(this.texture.destroy(),delete this.texture),delete this._bindGroups}}class GraphicsFramebuffer{constructor(i,g){this.device=i,this.options=g,this._update()}get color(){return[this.colorTexture]}resize(i,g){if((!this.colorTexture||i!==this.colorTexture.width||g!==this.colorTexture.height)&&(this.options.width=i,this.options.height=g,this.colorTexture&&this.colorTexture.resize(i,g),this.depthTexture&&this.depthTexture.resize(i,g),this._renderPass)){const i=this._renderPass.colorAttachments[0];i&&i.view&&this.colorTexture&&(i.view=this.colorTexture.getView());const g=this._renderPass.depthStencilAttachment;g&&g.view&&this.depthTexture&&(g.view=this.depthTexture.getView())}}_update(){let i=this.options.colors&&this.options.colors[0]||this.options.color;const g=this.options.colorFormat,m=this.options.colorType;let _,b;i?(_=i.width,b=i.height):(g||m)&&(i=!0),ax(this.options.width)||(_=this.options.width),ax(this.options.height)||(b=this.options.height),this.width=_,this.height=b,!i||i instanceof GraphicsTexture||(!0===i&&(i={width:_,height:b}),i.width||(i.width=_),i.height||(i.height=b),i.format||(i.format=g||"rgba"),i.type||(i.type=m||"uint8"),this._ownColor=!0,i=new GraphicsTexture(this.device,i));let T=this.options.depth;T&&(!0===T?(this._ownDepthTexture=!0,T=new GraphicsTexture(this.device,{width:_,height:b,format:"depth"})):T instanceof GraphicsTexture||(this._ownDepthTexture=!0,T=new GraphicsTexture(this.device,T)));const P=this.options.depthStencil;if(P&&(!0===P?(this._ownDepthTexture=!0,T=new GraphicsTexture(this.device,{width:_,height:b,format:"depth stencil"})):P instanceof GraphicsTexture?T=P:(this._ownDepthTexture=!0,T=new GraphicsTexture(this.device,P))),this.colorTexture=i,this.depthTexture=T,this._renderPass={colorAttachments:[]},null!==i&&(this._renderPass.colorAttachments[0]={view:this.colorTexture&&this.colorTexture.getView(),clearValue:[0,0,0,0],loadOp:"load",storeOp:"store"}),T){const i=this._renderPass.depthStencilAttachment={view:this.depthTexture.getView(),depthClearValue:1,depthLoadOp:"load",depthStoreOp:"store"};T.gpuFormat.isDepthStencil&&(i.stencilReadOnly=!1,i.stencilClearValue=0,i.stencilLoadOp="load",i.stencilStoreOp="store")}}getRenderPassDescriptor(){const i=this._renderPass.colorAttachments[0],g=this._renderPass.depthStencilAttachment;let m,_;if(!this.colorTexture){const g=this.device.context.getCurrentTexture();m=g.width,_=g.height,i.view=g.createView(),i.view.label="default canvas view"}if(i&&(i.loadOp=this.colorLoadOp||"load",i.clearValue=this.colorClearValue||[0,0,0,0]),g){g.depthLoadOp=this.depthLoadOp||"load",g.depthClearValue=this.depthClearValue||1;const i=this.depthTexture;i.gpuFormat.isDepthStencil&&(g.stencilLoadOp=this.stencilLoadOp||"load",g.stencilClearValue=this.stencilClearValue||0),i&&m&&_&&(i.width!==m||i.height!==_)&&(i.resize(m,_),g.view=i.getView())}return this._resetClearOptions(),this._renderPass}setClearOptions(i){i.color&&(this.colorLoadOp="clear",this.colorClearValue=i.color),i.depth&&(this.depthLoadOp="clear",this.depthClearValue=i.depth),i.stencil&&(this.stencilLoadOp="clear",this.stencilClearValue=i.stencil)}_resetClearOptions(){this.colorLoadOp=null,this.colorClearValue=null,this.depthLoadOp=null,this.depthClearValue=null,this.stencilLoadOp=null,this.stencilClearValue=null}destroy(){this._ownColor&&this.colorTexture&&(this.colorTexture.destroy(),delete this.colorTexture),this._ownDepthTexture&&this.depthTexture&&(this.depthTexture.destroy(),delete this.depthTexture,delete this._ownDepthTexture)}}let lM=0;class BindGroupFormat{constructor(i,g,m){this.name=i,this.uuid=lM++,this.groups=g.groups,this.alignment=m,this._parse(g)}getShaderUniforms(){return this._shaderUniforms}getMeshUniforms(){return this._meshUniforms}_parse(i){this._shaderUniforms=[],this._shaderUniforms.index=0,this._shaderUniforms.totalSize=0,this._meshUniforms=[],this._meshUniforms.index=0,this._meshUniforms.totalSize=0;const g=i.groups;if(!g)return;const m=g[0];if(m)for(let i=0;i<m.length;i++){const g=m[i];if(g)if(g.isGlobal){let i=this._shaderUniforms.index;this._shaderUniforms[i++]=g,this._shaderUniforms.index=i,this._shaderUniforms.totalSize+=yb(g.size,this.alignment)}else{let i=this._meshUniforms.index;this._meshUniforms[i++]=g,this._meshUniforms.index=i,this._meshUniforms.totalSize+=yb(g.size,this.alignment)}}}createBindGroup(i,g,m,_,b,T){const P=this.name+"-"+g.uuid;if(!this.groups)return i.wgpu.createBindGroup({layout:_,label:P,entries:[]});const I=this.groups[0],H=[],W=[];for(let _=0;_<I.length;_++){const P=I[_];if(!P)continue;const q=P.name;if(P.resourceType===uw.Sampler){const _=q.substring(0,q.length-7);let b=m&&m[_]||g.getUniform(_)||g.material&&g.material.getUniform(_);if(b instanceof GraphicsFramebuffer&&(b=b.colorTexture),!b)continue;const{min:T,mag:I,wrapS:W,wrapT:$,compare:ye}=b.config,Re=iM(T,I,W,$,ye),Be=i.wgpu.createSampler(Re);H.push({binding:P.binding,resource:Be})}else if(P.resourceType===uw.Texture){const _=m&&m[q]||g.getUniform(q)||g.material&&g.material.getUniform(q);let b=_;if(b instanceof AbstractTexture&&(b=_.getREGLTexture(i)),b instanceof GraphicsFramebuffer&&(b=b.colorTexture),!b)continue;W.push(b),H.push({binding:P.binding,resource:b.getView()})}else{H.push({binding:P.binding,resource:{buffer:(P.isGlobal?b.allocation:T.allocation).gpuBuffer,size:yb(P.size,this.alignment)}})}}const q=i.wgpu.createBindGroup({layout:_,label:P,entries:H});for(let i=0;i<W.length;i++)W[i].addBindGroup(q);return q}dispose(){delete this._shaderUniforms,delete this._meshUniforms,delete this.groups}}const hM=/\s*#define\s+(\w+)\s+([^\n]+)/g,cM=/#([^\s]*)(\s*)/gm,uM=/#[^\s]*\s*\b[0-9A-Z][0-9A-Z_&&\|=! ]+\b/g;function fM(i,g){var m;if(!i)return;const _=i.matchAll(hM),b={};for(const i of _)b[i[1]]=i[2];let T=dM(i=i.replace(/#define.*$/gm,""),b);const P=null===(m=T.match(uM))||void 0===m?void 0:m.filter((i=>!(i=>!isNaN(i))(i)&&""!=i)).map((i=>{const g=i.indexOf(" ");return i.substring(g).trim()})),{normalizeDefines:I,constValues:H}=function(i,g){var m;const _=new Set,b=null===(m=null==i?void 0:i.map)||void 0===m?void 0:m.call(i,(i=>pM(i,g,_))),T={};for(const i in g)_.has(i)||(T[i]=g[i]);return{normalizeDefines:b,constValues:T}}(P,g);T=dM(T,H);const W=function(i,g){let m=i;const _=(null==g?void 0:g.map((i=>{const g=m.indexOf(i),_=m.slice(0,g);return m=m.slice(g+i.length),_})))||[];(null==_?void 0:_.length)&&_.push(m);return _}(T,P);return W.length>0?function(i,g){const m=[];let _=new ConditionalState(!0);_.elseIsValid=!1;const b=(i,g)=>{if(i.index+i[0].length!=g.length)throw new Error(`#${i[1]} must be immediately followed by a template expression (ie: \${value})`)};for(let T=0;T<i.length;++T){const P=i[T],I=P.matchAll(cM);let H=0,W=!1;for(const i of I){switch(_.appendStringToCurrentBranch(P.substring(H,i.index)),i[1]){case"if":case"ifdef":case"ifndef":b(i,P),W=!0,m.push(_);_=new ConditionalState("ifndef"===i[1]?!g[T]:!!g[T]);break;case"elif":b(i,P),W=!0,_.pushBranch(i[1],g[T]);break;case"else":_.pushBranch(i[1],!0),_.appendStringToCurrentBranch(i[2]);break;case"endif":if(!m.length)throw new Error(`#${i[1]} not preceeded by an #if`);const I=_.resolve();_=m.pop(),_.appendStringToCurrentBranch(I,i[2]);break;default:_.appendStringToCurrentBranch(i[0])}H=i.index+i[0].length}H!=P.length&&_.appendStringToCurrentBranch(P.substring(H,P.length)),!W&&g.length>T&&_.appendStringToCurrentBranch(g[T])}if(m.length)throw new Error("Mismatched #if/#endif count");return _.resolve()}(W,I):T}class ConditionalState{constructor(i){this.elseIsValid=!0,this.branches=[],this.pushBranch("if",i)}pushBranch(i,g){if(!this.elseIsValid)throw new Error(`#${i} not preceeded by an #if or #elif`);this.elseIsValid="if"===i||"elif"===i,this.branches.push({expression:!!g,string:""})}appendStringToCurrentBranch(...i){for(const g of i)this.branches[this.branches.length-1].string+=g}resolve(){for(const i of this.branches)if(i.expression)return i.string;return""}}function dM(i,g){var m;if(!g)return i;let _=i;const b=Object.keys(g);return null===(m=null==b?void 0:b.forEach)||void 0===m||m.call(b,(i=>{const m=new RegExp("\\b"+i+"\\b","g");_=_.replace(m,g[i]+"")})),_}function pM(i,g,m){if((null==i?void 0:i.includes("&&"))||(null==i?void 0:i.includes("||"))){if(i.includes("&&")){const _=i.split("&&").map((i=>i.trim()));return function(i,g,m){var _;let b=0;return null===(_=null==i?void 0:i.forEach)||void 0===_||_.call(i,(i=>b+=Number(gM(g,i,m)||0)>1?1:Number(gM(g,i,m)||0))),b===i.length}(_,g,m)}const _=i.split("||").map((i=>i.trim()));return!function(i,g,m){var _;let b=0;return null===(_=null==i?void 0:i.forEach)||void 0===_||_.call(i,(i=>{const _=gM(g,i,m);return b+=_?1:0})),0===b}(_,g,m)}return gM(g,i,m)}function gM(i,g,m){if(g&&g.startsWith&&g.startsWith("!"))return g=g.substring(1),m&&m.add(g),!i[g];if(g&&g.includes&&(g.includes("==")||g.includes("!="))){const _=g.includes("=="),b=g.split(_?"==":"!=").map((i=>i.trim()));return m&&m.add(b[0]),_?i[b[0]]===+b[1]:i[b[0]]!==+b[1]}return m&&m.add(g),i[g]}var mM=Object.freeze({__proto__:null,WGSLParseDefines:fM,getDefineConditionValue:pM});class CommandBuilder{constructor(i,g,m,_,b,T,P,I){this.name=i,this.device=g,this.vert=m,this.frag=_,this.mesh=b,this.contextDesc=T,this.defines=P,this.uniformValues=I}build(i,g){const m=this.mesh,_=this.device,b=this.defines;let T=TM(this.vert),P=TM(this.frag);try{T=fM(T,b)}catch(i){throw i.message=this.name+"(vert):"+i.message,i}try{P=fM(P,b)}catch(i){throw i.message=this.name+"(frag):"+i.message,i}T=bM(T),P&&(P=bM(P));const{source:I,index:H}=wM(T,0);if(T=I,P){const{source:i}=wM(P,H);P=i}const W=new AS(T),q=this._formatBufferInfo(W,m);let $;P&&($=new AS(P));const ye=W.getBindGroups();let Re=[];$&&(Re=$.getBindGroups());const Be=this._createBindGroupLayout(ye,Re,m,this.uniformValues),Ge=this._createPipeline(_,T,q,P,Be,m,i,g),je=this._createBindGroupMapping(ye,Re,m);return{uid:-1,layout:Be,pipeline:Ge,vertexInfo:q,bindGroupFormat:new BindGroupFormat(this.name,je,_.wgpu.limits.minUniformBufferOffsetAlignment),bindGroupMapping:je,activeAttributes:this._getActiveAttributes()}}_getActiveAttributes(){const i=[{name:"position",type:1}];return i.key=i.map((i=>i.name)).join(),i}_createBindGroupLayout(i,g,m,_){const b=[];for(let g=0;g<i.length;g++){const T=i[g];for(let i=0;i<T.length;i++){const g=T[i];if(!g)continue;const P=this._createLayoutEntry(g.binding,GPUShaderStage.VERTEX,g,m,_);b.push(P)}}for(let i=0;i<g.length;i++){const T=g[i];for(let i=0;i<T.length;i++){const g=T[i];if(!g)continue;const P=this._createLayoutEntry(g.binding,GPUShaderStage.FRAGMENT,g,m,_);b.push(P)}}return b.sort(_M),this.device.wgpu.createBindGroupLayout({label:this.name+"-bindgrouplayout",entries:b})}_createLayoutEntry(i,g,m,_,b){if(m.resourceType===uw.Sampler){const _={};return m.type&&"sampler_comparison"===m.type.name&&(_.type="comparison"),{binding:i,visibility:g,sampler:_}}if(m.resourceType===uw.Texture){const T=m.name,P=b[T]||_.material&&_.material.get(T);let I;P&&(P instanceof Texture2D?I=P.config.type:P instanceof GraphicsTexture&&(I=P.gpuFormat.format));let H="float";return I&&I.startsWith("depth")&&(H="depth"),{binding:i,visibility:g,texture:{sampleType:H}}}return{binding:i,visibility:g,buffer:{type:"uniform",hasDynamicOffset:!0}}}_formatBufferInfo(i,g){const m=i.entry.vertex[0].inputs,_={};for(let i=0;i<m.length;i++){_[m[i].name]=m[i]}const b={},T=g.geometry.data,P=g.geometry.semantic;for(const i in T){const g=P[i]||i,m=_[g];m&&(b[g]={geoAttrName:i,location:m.location,itemSize:yM(m.type)})}if(g instanceof InstancedMesh){const i=g.instancedData;for(const g in i)_[g]&&(b[g]={geoAttrName:g,location:_[g].location,itemSize:yM(_[g].type)})}return b}_createBindGroupMapping(i,g,m){const _={};return this._parseGroupMapping(_,i[0],m,"vert"),this._parseGroupMapping(_,g[0],m,"frag"),_}_parseGroupMapping(i,g,m,_){if(g)for(let b=0;b<g.length;b++){const T=g[b];if(!T)continue;const{group:P,binding:I}=T,H=T.members;let W=!1;if(H&&H.length)for(let i=0;i<H.length;i++){const g=H[i].name;if(AM(m,g,this.contextDesc)){if(W)throw new Error("Found a mesh uniform in global struct:"+g+"("+T.name+") in "+this.name+"_"+_)}else{if(!W&&i>0)throw new Error("Found a global uniform in mesh struct:"+g+"("+T.name+") in "+this.name+"_"+_);W=!0}}else{AM(m,T.name,this.contextDesc)||(W=!0)}i.groups=i.groups||[],i.groups[P]=i.groups[P]||[],T.isGlobal=W,T.index=i.groups[P][I]=T}}_createPipeline(i,g,m,_,b,T,P,I){const H=i.wgpu,W=H.createShaderModule({label:this.name+"-vertmodule",code:g});let q;_&&(q=H.createShaderModule({label:this.name+"-fragmodule",code:_})),this._presentationFormat||(this._presentationFormat=navigator.gpu.getPreferredCanvasFormat());const $=T.geometry.getBufferDescriptor(m);if(T instanceof InstancedMesh){const i=T.getBufferDescriptor(m);for(let g=0;g<i.length;g++)i[g]&&($[g]=i[g])}const ye=H.createPipelineLayout({label:this.name+"-pipelinelayout",bindGroupLayouts:[b]}),Re={label:this.name+"-pipeline",layout:ye,vertex:{module:W,buffers:$},primitive:{topology:P.topology,cullMode:P.cullMode}},Be=I&&I.colorTexture&&I.colorTexture.config.sampleCount;Be&&(Re.multisample={count:Be});if(!I||!!I.depthTexture){const i=I&&I.depthTexture;Re.depthStencil={depthBias:P.depthBias,depthBiasSlopeScale:P.depthBiasSlopeScale,depthWriteEnabled:P.depthWriteEnabled,depthCompare:P.depthCompare,format:!i||i.gpuFormat.isDepthStencil?"depth24plus-stencil8":"depth24plus"}}if(q){const i=P.writeMask;Re.fragment={module:q,targets:[{format:I&&I.colorTexture&&I.colorTexture.gpuFormat.format||this._presentationFormat,writeMask:ax(i)?GPUColorWrite.ALL:i}]}}if(Re.depthStencil&&P.stencilFrontCompare&&(Re.depthStencil.stencilBack=Re.depthStencil.stencilFront={compare:P.stencilFrontCompare,passOp:P.stencilFrontPassOp}),q&&P.blendAlphaDst){const i=Re.fragment.targets;for(const g of i)g.blend={color:{srcFactor:P.blendColorSrc,dstFactor:P.blendColorDst,operation:"add"},alpha:{srcFactor:P.blendAlphaSrc,dstFactor:P.blendAlphaDst,operation:"add"}}}return H.createRenderPipeline(Re)}}function AM(i,g,m){return"modelMatrix"===g||"positionMatrix"===g||"projViewModelMatrix"===g||"modelViewMatrix"===g||"modelNormalMatrix"===g||"polygonFill"===g||"polygonOpacity"===g||"lineColor"===g||"lineOpacity"===g||(m[g]&&!m[g].global||i.hasUniform(g)||i.material&&i.material.hasUniform(g))}function yM(i){return i.name.startsWith("vec")?parseInt(i.name[3]):1}function _M(i,g){return i.binding-g.binding}let vM=0;const xM=()=>""+vM++;function bM(i){vM=0;const g=i.replaceAll("$i",xM);vM=0;return g.replaceAll("$o",xM)}function wM(i,g){return vM=g,{source:i.replaceAll("$b",xM),index:vM}}function TM(i){return i?i.replace(/[ \t]*\/\/.*\n/g,"").replace(/[ \t]*\/\*[\s\S]*?\*\//g,""):i}class DynamicOffsets{constructor(){this.items=[],this.offsets=[],this.index=0}reset(){this.index=0}addItem(i,g){const m=this.index++,_=this.items[m];_?(_.binding=i,_.offset=g):this.items[m]={binding:i,offset:g}}addItems(i){for(let g=0;g<i.length;g++)this.addItem(i[g].binding,i[g].offset)}getItems(){return this.items.slice(0,this.index)}getDynamicOffsets(){const i=this.getItems();i.sort(((i,g)=>i.binding-g.binding)),this.offsets.length=i.length;for(let g=0;g<i.length;g++)this.offsets[g]=i[g].offset;return this.offsets}}const SM="function",MM="array";let CM=0;const PM={};class GLShader{constructor({vert:i,frag:g,wgslVert:m,wgslFrag:_,uniforms:b,defines:T,extraCommandProps:P,name:I}){this.name=I,this.vert=i,this.frag=g,this.wgslVert=m,this.wgslFrag=_;const H=CM++;Object.defineProperty(this,"uid",{enumerable:!0,configurable:!1,get:()=>H}),this.shaderDefines=T&&cx({},T)||{},b=this.uniforms=(b||[]).slice(),this.contextDesc={};for(let i=0,g=b.length;i<g;i++){const g=b[i];if(sx(g))if(g.indexOf("[")>0){const{name:i,len:m}=IM(g);this.contextDesc[i]={name:i,type:"array",length:m}}else this.contextDesc[g]=null;else if(g.name.indexOf("[")>0){const{name:i,len:m}=IM(g.name);this.contextDesc[i]={name:i,type:"array",length:m,fn:g.fn}}else this.contextDesc[g.name]=g}this.extraCommandProps=P&&cx({},P)||{},this.commands={},this._compileSource()}set shaderDefines(i){this._shaderDefines=i,this.dkey=Object.keys(this._shaderDefines).join()}get shaderDefines(){return this._shaderDefines||{}}setDefines(i){this.shaderDefines=i}setFramebuffer(i){return this.context.framebuffer=i,this}run(i,g,m){return g(m)}getShaderCommandKey(i,g,m){return this.dkey||"default"}getVersion(i,g){if("#version"===g.substring(0,8))return"";return 0===i.limits.version.indexOf("WebGL 2.0")&&300===this.version?"#version 300 es\n":"#version 100\n"}getActiveVars(i,g,m,_){const b=_;if(PM[b])return PM[b];const T=i._gl,P=T.createProgram(),I=T.createShader(35633);T.shaderSource(I,g),T.compileShader(I);const H=T.createShader(35632);T.shaderSource(H,m),T.compileShader(H),T.attachShader(P,H),T.attachShader(P,I),T.linkProgram(P);const W=T.getProgramParameter(P,35721),q=[];for(let i=0;i<W;++i){const g=T.getActiveAttrib(P,i);g&&q.push({name:g.name,type:g.type})}const $=T.getProgramParameter(P,35718),ye=[];for(let i=0;i<$;++i){const g=T.getActiveUniform(P,i);let m=g.name;g.name.indexOf("[")>0&&(m=m.replace("[0]","")),ye.push(m)}return T.deleteProgram(P),T.deleteShader(I),T.deleteShader(H),PM[b]={activeUniforms:ye,activeAttributes:q},PM[b]}_insertDefines(i,g){const m=[];for(const i in g)_x(g,i)&&!hx(g[i])&&m.push(`#define ${i} ${g[i]}\n`);return m.join("")+i}createMeshCommand(i,g,m={},_){const b=g.getDefines(),T=g.getElements(),P=g instanceof InstancedMesh,I=g.disableVAO,H=yx(i)&&!I,W=cx({},this.shaderDefines||{},b||{}),q=this._insertDefines(this.vert,W),$=this.getVersion(i,q)+q,ye=this._insertDefines(this.frag,W),Re=this.getVersion(i,ye)+ye,Be=Cx($)+"_"+Cx(Re),{activeAttributes:Ge,activeUniforms:je}=this.getActiveVars(i,$,Re,Be),Xe={};Ge.forEach(((g,m)=>{const _=g.name;Xe[_]=H?m:i.prop(_)}));const Ze={};je.forEach((g=>{Ze[g]=i.prop(g)}));const Ye=this.contextDesc;for(const g in Ye)if(Ye[g]&&Ye[g].type===SM)Ze[g]=Ye[g].fn;else if(Ye[g]&&Ye[g].type===MM){const m=Ye[g].name,_=Ye[g].length;for(let g=0;g<_;g++){const _=`${m}[${g}]`;Ze[_]=i.prop(_)}}else Ze[g]=i.prop(g);const Qe={vert:$,frag:Re,uniforms:Ze,attributes:Xe};H&&(Qe.vao=i.prop("vao")),H&&!P||!T||fx(T)||(Qe.elements=i.prop("elements")),Qe.count=i.prop("count"),Qe.offset=i.prop("offset"),Qe.primitive=i.prop("primitive"),Qe.framebuffer=i.prop("framebuffer"),P&&(Qe.instances=i.prop("instances")),cx(Qe,this.extraCommandProps,m);const Je=i(Qe);return Ge.key=Ge.map((i=>i.name)).join(),Je.activeAttributes=Ge,Je}dispose(){for(const i in this.commands){const g=this.commands[i];g&&(g.destroy&&!g[Lx]&&(g[Lx]=!0,g.destroy()))}this.commands={},delete this.vert,delete this.frag}appendDescUniforms(i,g){const m=g,_=this.contextDesc;for(const b in _)if(_[b])if("array"===_[b].type){const T=b,P=_[b].length;let I=g[b];if(_[b].fn&&(I=_[b].fn(null,g)),!I)continue;if(I.length!==P)throw new Error(`${T} uniform's length is not ${P}`);m[T]=m[T]||{};for(let g=0;g<P;g++)m[T][`${g}`]=I[g].getREGLTexture?I[g].getREGLTexture(i):I[g]}else"function"===_[b].type&&(Object.getOwnPropertyDescriptor(m,b)||Object.defineProperty(m,b,{configurable:!1,enumerable:!0,get:function(){return _[b].fn(null,g)}}));return m}setUniforms(i){if(i.modelMatrix||i.positionMatrix)throw new Error("modelMatrix or positionMatrix is reserved uniform name for Mesh, please change to another name");return this.contextKeys=i?Object.keys(i).join():null,this.context=i,this}_compileSource(){this.vert&&(this.vert=VS.compile(this.vert)),this.frag&&(this.frag=VS.compile(this.frag))}}function IM(i){const g=i.indexOf("["),m=i.indexOf("]");return{name:i.substring(0,g),len:+i.substring(g+1,m)}}const kM=new PipelineDescriptor;class GPUShader extends GLShader{getShaderCommandKey(i,g,m){if(i&&i.wgpu){const i=g.getShaderFnValues(this.uid);if(i){const{funcs:g,key:_,commandKey:b}=i;if(!g.length)return b;const T=g.map((i=>i(null,m)));if(kM.generateValuesKey(T)===_)return b}kM.readFromREGLCommand(this.extraCommandProps,g,m,this._gpuFramebuffer);const _=kM.getSignatureKey();return g.setShaderFnValues(this.uid,{funcs:kM.functionProps.map((i=>i.func)),key:kM.getFnValuesKey(),commandKey:_}),_}return super.getShaderCommandKey(i,g,m)}createMeshCommand(i,g,m,_){if(i&&i.wgpu){const b=this.context,T=this._gpuFramebuffer,P=cx({},this.shaderDefines||{},g.getDefines()),{vert:I,frag:H}=this._compileWGSLSource(P),W=new CommandBuilder(this.name,i,I,H,g,this.contextDesc,P,b),q=new PipelineDescriptor,$=cx({},this.extraCommandProps||{},m||{});q.readFromREGLCommand($,g,_,T);const ye=W.build(q,T);return ye.uid=this.uid,ye}return super.createMeshCommand(i,g,m)}_compileWGSLSource(i){const g=ZS.compile(this.wgslVert,i);let m;return this.wgslFrag&&(m=ZS.compile(this.wgslFrag,i)),{vert:g,frag:m}}run(i,g,m){if(!i.wgpu)return super.run(i,g,m);if(!m||!m.length)return;const _=i;this.isGPU=!0;const b=_.dynamicBufferPool,T=this._getCurrentRenderPassEncoder(_);T.setPipeline(g.pipeline);const{uid:P,bindGroupFormat:I,vertexInfo:H,layout:W}=g;this._buffers||(this._buffers={});let q=this._buffers[P];q||(q=this._buffers[P]=new DynamicBuffer(I.getShaderUniforms(),b)),this._dynamicOffsets||(this._dynamicOffsets=new DynamicOffsets),this._shaderDynamicOffsets||(this._shaderDynamicOffsets=new DynamicOffsets),this._shaderDynamicOffsets.reset(),q.writeBuffer(m[0],this._shaderDynamicOffsets);const $=this._shaderDynamicOffsets.getItems();for(let i=0;i<m.length;i++){this._dynamicOffsets.reset();const g=m[i].meshObject,ye=g.writeDynamicBuffer(P,m[i],I.getMeshUniforms(),b,this._dynamicOffsets),Re=I.uuid+"-"+ye.version+"-"+q.version;let Be=g.getBindGroup(Re);Be&&!Be.outdated||(Be=I.createBindGroup(_,g,m[i],W,q,ye),g.setBindGroup(Re,Be)),this._dynamicOffsets.addItems($);const Ge=this._dynamicOffsets.getDynamicOffsets();let je;T.setBindGroup(0,Be,Ge),g instanceof InstancedMesh&&(je=g);for(const i in H){const m=H[i];let _=g.geometry.getBuffer(m.geoAttrName||i);!_&&je&&(_=je.getInstancedBuffer(i)),T.setVertexBuffer(m.location,_,0,_.byteLength)}const Xe=g.getElements(),Ze=g.geometry.getDrawOffset(),Ye=g.geometry.getDrawCount();let Qe=1;je&&(Qe=je.instanceCount),g.geometry.isIndexedElements()?(T.setIndexBuffer(Xe,Xe.itemType),T.drawIndexed(Ye,Qe,Ze)):T.draw(Ye,Qe,Ze)}T.end()}_getCurrentRenderPassEncoder(i){return i.getRenderPassEncoder(this._gpuFramebuffer)}setFramebuffer(i){return i?i.getRenderPassDescriptor?(this._gpuFramebuffer=i,this):super.setFramebuffer(i):this._gpuFramebuffer?(this._gpuFramebuffer=null,this):super.setFramebuffer(i)}dispose(){if(!this.isGPU)return void super.dispose();for(const i in this._buffers)this._buffers[i]&&this._buffers[i].dispose();const i=this.gpuCommands;for(let g=0;g<i.length;g++)i[g]&&i[g].bindGroupFormat&&i[g].bindGroupFormat.dispose()}}class MeshShader extends GPUShader{draw(i,g){if(!g||!g.length)return 0;const m=[];let _,b=0;for(let T=0,P=g.length;T<P;T++){if(!g[T].isValid()){T===P-1&&_&&m.length&&this.run(i,_,m);continue}if(!g[T].geometry.getDrawCount()||!this._runFilter(g[T])){T===P-1&&_&&m.length&&this.run(i,_,m);continue}const I=g[T].getRenderProps(i);this._ensureContextDefines(I),I.shaderContext=this.context,I.meshObject=g[T],this.appendDescUniforms(i,I);const H=this.getMeshCommand(i,g[T],I);g[T].appendGeoAttributes(I,i,H.activeAttributes),m.length&&_!==H&&(this.run(i,_,m),m.length=0),m.push(I),b++,T<P-1?_=H:T===P-1&&this.run(i,H,m)}return b}_ensureContextDefines(i){if(this.context&&(i.contextKeys||(i.contextKeys={}),i.contextKeys[this.uid]!==this.contextKeys)){for(const g in this.context)"framebuffer"===g||Object.getOwnPropertyDescriptor(i,g)||Object.defineProperty(i,g,{configurable:!1,enumerable:!0,get:function(){return this.shaderContext[g]}});Object.getOwnPropertyDescriptor(i,"framebuffer")||Object.defineProperty(i,"framebuffer",{configurable:!1,enumerable:!0,get:function(){return this.targetFramebuffer||this.shaderContext&&this.shaderContext.framebuffer}}),i.contextKeys[this.uid]=this.contextKeys}}_runFilter(i){const g=this.filter;if(!g)return!0;if(Array.isArray(g)){for(let m=0;m<g.length;m++)if(!g[m](i))return!1;return!0}return g(i)}getMeshCommand(i,g,m){this._cmdKeys||(this._cmdKeys={});const _=g.getMaterial();let b=!1;_&&(b=_.doubleSided);const T=this.getShaderCommandKey(i,g,m);let P=this._cmdKeys[T];P||(P=this._cmdKeys[T]={});const I=g.getCommandKey(i);P[I]||(P[I]=T+"_"+g.getCommandKey());const H=P[I];let W=this.commands[H];if(!W){const _={};b&&this.extraCommandProps&&(_.cull={enable:!1}),W=this.commands[H]=this.createMeshCommand(i,g,_,m)}return W}}var OM="#if __VERSION__ == 300\n#define attribute in\n#define varying out\n#endif\nattribute vec2 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_Position = vec4(aPosition, 0., 1.);\n  vTexCoord = aTexCoord;\n}";const EM=new Int8Array([-1,1,-1,-1,1,1,1,1,-1,-1,1,-1]),RM=new Uint8Array([0,1,0,0,1,1,1,1,0,0,1,0]);class QuadShader extends MeshShader{constructor(i){i.vert=i.vert||OM,i.extraCommandProps=i.extraCommandProps||{},i.extraCommandProps.depth||(i.extraCommandProps.depth={enable:!1,mask:!1}),i.extraCommandProps.stencil||(i.extraCommandProps.stencil={enable:!1}),super(i)}draw(i){return this._quadMesh||this._createQuadMesh(i),super.draw(i,this._quadMesh)}getMeshCommand(i){const g=this.dkey||"";return this.commands[g+"_quad"]||(this.commands[g+"_quad"]=this.createMeshCommand(i,this._quadMesh[0])),this.commands[g+"_quad"]}_createQuadMesh(i){const g=new Geometry({aPosition:EM,aTexCoord:RM},null,EM.length/2,{positionSize:2,primitive:"triangles"});g.generateBuffers(i),this._quadMesh=[new Mesh(g)]}dispose(){if(this._quadMesh){const i=this._quadMesh[0];i.geometry.dispose(),i.dispose()}return delete this._quadMesh,super.dispose()}}class FxaaShader extends QuadShader{constructor(){super({vert:OM,frag:"#define SHADER_NAME FXAA\nprecision mediump float;\nvarying vec2 vTexCoord;\nuniform float enableFXAA;\nuniform float enableToneMapping;\nuniform float enableSharpen;\nuniform vec2 resolution;\nuniform sampler2D textureSource;\n#ifdef HAS_NOAA_TEX\nuniform sampler2D noAaTextureSource;\n#endif\n#ifdef HAS_POINT_TEX\nuniform sampler2D pointTextureSource;\n#endif\n#ifdef HAS_TAA_TEX\nuniform sampler2D taaTextureSource;\n#ifdef HAS_FXAA_TEX\nuniform sampler2D fxaaTextureSource;\n#endif\n#endif\nuniform float pixelRatio;\nuniform float sharpFactor;\n#ifdef HAS_OUTLINE_TEX\nuniform sampler2D textureOutline;\nuniform float enableOutline;\nuniform float highlightFactor;\nuniform float outlineFactor;\nuniform float outlineWidth;\nuniform vec3 outlineColor;\n#endif\nvec2 c;\nvec4 d(vec2 e) {\n  \n#ifdef HAS_TAA_TEX\nvec4 f = texture2D(textureSource, e);\n  vec4 taa = texture2D(taaTextureSource, e);\n#ifdef HAS_FXAA_TEX\nvec4 h = texture2D(fxaaTextureSource, e);\n#else\nvec4 h = vec4(.0);\n#endif\nvec4 i = taa + f * (1. - taa.a);\n  return h + i * (1. - h.a);\n#else\nreturn texture2D(textureSource, e);\n#endif\n}\nvec3 j(const in vec3 k, const float l) {\n  vec2 m = pixelRatio / resolution.xy;\n  float n = .0;\n  vec4 o = texture2D(textureSource, c + m * vec2(-1., -1.));\n  o.rgb = mix(vec3(.0), o.rgb, sign(o.a));\n  n += mix(.0, 1., sign(o.a));\n  vec4 u = texture2D(textureSource, c + m * vec2(1.));\n  u.rgb = mix(vec3(.0), u.rgb, sign(u.a));\n  n += mix(.0, 1., sign(u.a));\n  vec4 v = texture2D(textureSource, c + m * vec2(1., -1.));\n  v.rgb = mix(vec3(.0), v.rgb, sign(v.a));\n  n += mix(.0, 1., sign(v.a));\n  vec4 A = texture2D(textureSource, c + m * vec2(-1., 1.));\n  A.rgb = mix(vec3(.0), A.rgb, sign(A.a));\n  n += mix(.0, 1., sign(A.a));\n  return k + l * (n * k - o.rgb - v.rgb - A.rgb - u.rgb);\n}\nvec4 B(const in vec4 k) {\n  return vec4(j(k.rgb, sharpFactor), k.a);\n}\nvec3 C(const vec3 x) {\n  const float a = 2.51;\n  const float b = .03;\n  const float D = 2.43;\n  const float E = .59;\n  const float F = .14;\n  return (x * (a * x + b)) / (x * (D * x + E) + F);\n}\nvec3 G(vec3 k) {\n  k = k / (k + vec3(1.));\n  return k = pow(k, vec3(1. / 2.2));\n}\n#ifdef HAS_OUTLINE_TEX\nvec4 H() {\n  float I = 2.;\n  float J = 1.;\n  float K = pixelRatio / resolution[0] * outlineWidth;\n  float L = pixelRatio / resolution[1] * outlineWidth;\n  vec4 M = (texture2D(textureOutline, c + vec2(K, L)));\n  vec4 N = (texture2D(textureOutline, c + vec2(K, .0)));\n  vec4 O = (texture2D(textureOutline, c + vec2(K, -L)));\n  vec4 P = (texture2D(textureOutline, c + vec2(.0, -L)));\n  vec4 Q = (texture2D(textureOutline, c + vec2(-K, -L)));\n  vec4 R = (texture2D(textureOutline, c + vec2(-K, .0)));\n  vec4 S = (texture2D(textureOutline, c + vec2(-K, L)));\n  vec4 T = (texture2D(textureOutline, c + vec2(.0, L)));\n  vec4 U = -I * R + I * N + -J * S + J * M + -J * Q + J * O;\n  vec4 V = -I * P + I * T + -J * Q + J * S + -J * O + J * M;\n  float W = sqrt(dot(V, V) + dot(U, U));\n  bool X = W < 1. / 65025.;\n  vec3 Y = (texture2D(textureOutline, c)).r * outlineColor;\n  if(Y == vec3(.0) || (highlightFactor == .0 && X)) {\n    return vec4(.0);\n  }\n  float Z = X ? highlightFactor : min(1., sqrt(W) * outlineFactor);\n  return Z * vec4(Y, 1.);\n}\nvec4 ba(const in vec4 k) {\n  vec4 H = H();\n  return H + vec4(k) * (1. - H.a);\n}\n#endif\nvoid main() {\n  c = vTexCoord;\n  vec4 k;\n  if(enableFXAA == 1.) {\n    \n  } else {\n    k = d(vTexCoord);\n  }\n  if(enableSharpen == 1.) {\n    k = B(k);\n  }\n#if defined(HAS_NOAA_TEX) || defined(HAS_POINT_TEX)\nvec4 bb = vec4(.0);\n  vec4 bc = vec4(.0);\n#ifdef HAS_POINT_TEX\nbb = texture2D(pointTextureSource, vTexCoord);\n#endif\n#ifdef HAS_NOAA_TEX\nbc = texture2D(noAaTextureSource, vTexCoord);\n#endif\nvec4 bd = bb + bc * (1. - bb.a);\n  k = bd + k * (1. - bd.a);\n#endif\nif(enableToneMapping == 1.) {\n    k.rgb = G(k.rgb);\n  }\n#ifdef HAS_OUTLINE_TEX\nk = ba(k);\n#endif\ngl_FragColor = k;\n}",extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.resolution[0],height:(i,g)=>g.resolution[1]}}})}getMeshCommand(i,g){const m=this.dkey||"";return this.commands[m+"_fxaa"]||(this.commands[m+"_fxaa"]=this.createMeshCommand(i,g)),this.commands[m+"_fxaa"]}}var LM="#include <gl2_vert>\nattribute vec2 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 projViewModelMatrix;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_Position = projViewModelMatrix * vec4(aPosition, 0., 1.);\n  vTexCoord = aTexCoord;\n}",DM="precision mediump float;\n#include <gl2_frag>\nuniform sampler2D baseColorTexture;\nuniform float opacity;\nuniform vec4 baseColor;\nuniform float alphaTest;\n#ifdef HAS_DEBUG\nuniform sampler2D debugTexture;\n#endif\nvarying vec2 vTexCoord;\nvoid main() {\n  glFragColor = texture2D(baseColorTexture, vTexCoord);\n  glFragColor *= baseColor;\n#ifdef HAS_DEBUG\nvec4 c = texture2D(debugTexture, vTexCoord);\n  glFragColor = vec4(c.rgb + glFragColor.rgb * (1. - c.a), c.a + glFragColor.a * (1. - c.a));\n#endif\nif(glFragColor.a < alphaTest) {\n    discard;\n  }\n  glFragColor *= opacity;\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}";class ImageShader extends MeshShader{constructor(i){const g=[],m=i&&i.extraCommandProps||{};i.vert=LM,i.frag=DM,super({name:"image",vert:LM,frag:DM,wgslVert:"",wgslFrag:"",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,m){return _A(g,m.projViewMatrix,m.modelMatrix)}}],extraCommandProps:m})}getMeshCommand(i,g){const m=g.getCommandKey(i);return this.commands["image_"+m]||(this.commands["image_"+m]=this.createMeshCommand(i,g)),this.commands["image_"+m]}}class PostProcessShader extends QuadShader{constructor(){super({vert:OM,frag:"precision mediump float;\nvarying vec2 vTexCoord;\nuniform vec2 resolution;\nuniform sampler2D textureSource;\nuniform float enableVignette;\nuniform float enableGrain;\nuniform float enableLut;\nuniform float timeGrain;\nuniform float grainFactor;\nuniform vec2 lensRadius;\nuniform float frameMod;\nuniform sampler2D lookupTable;\n#include <srgb_frag>\nfloat c(const in vec2 d) {\n  vec3 e = fract(vec3(d.xyx) * .1031);\n  e += dot(e, e.yzx + 19.19);\n  return fract((e.x + e.y) * e.z);\n}\nfloat f() {\n  float h = c(gl_FragCoord.xy + 1000.0 * fract(timeGrain));\n  float i = h * 2. - 1.;\n  h = i * inversesqrt(abs(i));\n  h = max(-1., h);\n  h = h - sign(i) + .5;\n  return (h + .5) * .5;\n}\nvec4 j(const in vec4 k) {\n  float l = f();\n  return vec4(mix(k.rgb, k.rgb * (k.rgb + (1. - k.rgb) * 2. * l), grainFactor), k.a);\n}\nfloat m(const in vec2 d, const in float n) {\n  vec3 o = vec3(.06711056, .00583715, 52.9829189);\n  return fract(o.z * fract(dot(d.xy + n * vec2(47., 17.) * .695, o.xy)));\n}\nfloat u() {\n  vec2 v = lensRadius;\n  v.y = min(v.y, v.x - 1e-4);\n  float A = m(gl_FragCoord.xy, frameMod);\n  A = (v.x - v.y) * (v.x + v.y) * .07 * (A - .5);\n  return smoothstep(v.x, v.y, A + distance(vTexCoord, vec2(.5)));\n}\nvec4 B(const in vec4 k) {\n  float l = u();\n  return vec4(linearTosRGB(sRGBToLinear(k.rgb) * l), clamp(k.a + (1. - l), .0, 1.));\n}\nvec4 C(in vec4 D, in sampler2D E) {\n  mediump float F = D.b * 63.;\n  mediump vec2 G;\n  G.y = floor(floor(F) / 8.);\n  G.x = floor(F) - G.y * 8.;\n  mediump vec2 H;\n  H.y = floor(ceil(F) / 8.);\n  H.x = ceil(F) - H.y * 8.;\n  highp vec2 I;\n  I.x = G.x * .125 + .5 / 512. + (.125 - 1. / 512.) * D.r;\n  I.y = G.y * .125 + .5 / 512. + (.125 - 1. / 512.) * D.g;\n#ifdef LUT_FLIP_Y\nI.y = 1. - I.y;\n#endif\nhighp vec2 J;\n  J.x = H.x * .125 + .5 / 512. + (.125 - 1. / 512.) * D.r;\n  J.y = H.y * .125 + .5 / 512. + (.125 - 1. / 512.) * D.g;\n#ifdef LUT_FLIP_Y\nJ.y = 1. - J.y;\n#endif\nlowp vec4 K = texture2D(E, I);\n  lowp vec4 L = texture2D(E, J);\n  lowp vec4 M = mix(K, L, fract(F));\n  return M;\n}\nvoid main() {\n  vec4 k = texture2D(textureSource, vTexCoord);\n  if(enableLut == 1.) {\n    k = C(k, lookupTable);\n  }\n  if(enableVignette == 1.) {\n    k = B(k);\n  }\n  if(enableGrain == 1.) {\n    k = j(k);\n  }\n  gl_FragColor = k;\n}",extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.resolution[0],height:(i,g)=>g.resolution[1]}}})}getMeshCommand(i,g){return this.commands.postprocess||(this.commands.postprocess=this.createMeshCommand(i,g)),this.commands.postprocess}}const FM=[[.263385,-.0252475],[-.38545,.054485],[-.139795,-.5379925],[-.2793775,.6875475],[.7139025,.4710925],[.90044,-.16422],[.4481775,-.82799],[-.9253375,-.2910625],[.3468025,1.02292],[-1.13742,.33522],[-.7676225,-.9123175],[-.2005775,-1.1774125],[-.926525,.96876],[1.12909,-.7500325],[.9603,1.14625]],NM=FM.length,HM=[0,0];for(let i=0;i<FM.length;i++)HM[0]+=FM[i][0],HM[1]+=FM[i][1];HM[0]/=NM,HM[1]/=NM;class Jitter{constructor(i){this._frameNum=0,this._ratio=i||.05,this._avg=[HM[0]*this._ratio,HM[1]*this._ratio]}getRatio(){return this._ratio}setRatio(i){this._ratio!==i&&(this._ratio=i,this.reset()),this._avg=[HM[0]*this._ratio,HM[1]*this._ratio]}getAverage(){return this._avg}reset(){this._frameNum=0}getJitter(i){const g=this._frameNum%NM,m=this._ratio;return z_(i,FM[g][0]*m,FM[g][1]*m),i}frame(){this._frameNum++,this._frameNum%NM===0&&(this._frameNum=0)}getSampleCount(){return NM}}class BlurPass{constructor(i,g,m=5){this._regl=i,this._renderer=new Renderer(i),this._inputRGBM=g,this._level=m}render(i,g){this._initShaders(),this._createTextures(i),this._blur(i,g||0);const m={blurTex0:this._blur01Tex,blurTex1:this._blur11Tex,blurTex2:this._blur21Tex,blurTex3:this._blur31Tex,blurTex4:this._blur41Tex};return this._level>5&&(m.blurTex5=this._blur51Tex,m.blurTex6=this._blur61Tex),m}_blur(i,g){let m=this._blurUniforms;m||(m=this._blurUniforms={rgbmRange:7,blurDir:[0,0],outSize:[0,0],pixelRatio:[1,1],outputSize:[0,0]}),z_(m.outSize,i.width,i.height),this._blurOnce(this._blur0Shader,i,this._blur00FBO,this._blur01FBO,.5,g),this._blurOnce(this._blur1Shader,this._blur01FBO.color[0],this._blur10FBO,this._blur11FBO,.5),this._blurOnce(this._blur2Shader,this._blur11FBO.color[0],this._blur20FBO,this._blur21FBO,.5),this._blurOnce(this._blur3Shader,this._blur21FBO.color[0],this._blur30FBO,this._blur31FBO,.5),this._blurOnce(this._blur4Shader,this._blur31FBO.color[0],this._blur40FBO,this._blur41FBO,.5),this._level>5&&(this._blurOnce(this._blur5Shader,this._blur41FBO.color[0],this._blur50FBO,this._blur51FBO,.5),this._blurOnce(this._blur6Shader,this._blur51FBO.color[0],this._blur60FBO,this._blur51FBO,.5))}_blurOnce(i,g,m,_,b,T){const P=Math.ceil(b*g.width),I=Math.ceil(b*g.height);m.width===P&&m.height===I||m.resize(P,I),_.width===P&&_.height===I||_.resize(P,I);const H=this._blurUniforms;H.luminThreshold=T,H.TextureBlurInput=g,H.inputRGBM=+this._inputRGBM,z_(H.blurDir,0,1),z_(H.outputSize,m.width,m.height),this._renderer.render(i,H,null,m),H.luminThreshold=0,H.inputRGBM=1,z_(H.blurDir,1,0),H.TextureBlurInput=m.color[0],this._renderer.render(i,H,null,_)}dispose(){this._blur0Shader&&(this._blur0Shader.dispose(),delete this._blur0Shader,this._blur1Shader.dispose(),this._blur2Shader.dispose(),this._blur3Shader.dispose(),this._blur4Shader.dispose(),this._blur5Shader&&(this._blur5Shader.dispose(),this._blur6Shader.dispose(),delete this._blur5Shader)),this._blur00Tex&&(delete this._blur00Tex,this._blur00FBO.destroy(),this._blur01FBO.destroy(),this._blur10FBO.destroy(),this._blur11FBO.destroy(),this._blur20FBO.destroy(),this._blur21FBO.destroy(),this._blur30FBO.destroy(),this._blur31FBO.destroy(),this._blur40FBO.destroy(),this._blur41FBO.destroy(),this._blur50FBO&&(this._blur50FBO.destroy(),this._blur51FBO.destroy(),this._blur60FBO.destroy(),this._blur61FBO.destroy()))}_createTextures(i){if(this._blur00Tex)return;let g=i.width,m=i.height;this._blur00Tex=this._createColorTex(i,g,m),this._blur00FBO=this._createBlurFBO(this._blur00Tex),this._blur01Tex=this._createColorTex(i),this._blur01FBO=this._createBlurFBO(this._blur01Tex),g=Math.ceil(g/2),m=Math.ceil(m/2),this._blur10Tex=this._createColorTex(i,g,m),this._blur10FBO=this._createBlurFBO(this._blur10Tex),this._blur11Tex=this._createColorTex(i,g,m),this._blur11FBO=this._createBlurFBO(this._blur11Tex),g=Math.ceil(g/2),m=Math.ceil(m/2),this._blur20Tex=this._createColorTex(i,g,m),this._blur20FBO=this._createBlurFBO(this._blur20Tex),this._blur21Tex=this._createColorTex(i,g,m),this._blur21FBO=this._createBlurFBO(this._blur21Tex),g=Math.ceil(g/2),m=Math.ceil(m/2),this._blur30Tex=this._createColorTex(i,g,m),this._blur30FBO=this._createBlurFBO(this._blur30Tex),this._blur31Tex=this._createColorTex(i,g,m),this._blur31FBO=this._createBlurFBO(this._blur31Tex),g=Math.ceil(g/2),m=Math.ceil(m/2),this._blur40Tex=this._createColorTex(i,g,m),this._blur40FBO=this._createBlurFBO(this._blur40Tex),this._blur41Tex=this._createColorTex(i,g,m),this._blur41FBO=this._createBlurFBO(this._blur41Tex),this._level>5&&(g=Math.ceil(g/2),m=Math.ceil(m/2),this._blur50Tex=this._createColorTex(i,g,m),this._blur50FBO=this._createBlurFBO(this._blur50Tex),this._blur51Tex=this._createColorTex(i,g,m),this._blur51FBO=this._createBlurFBO(this._blur51Tex),g=Math.ceil(g/2),m=Math.ceil(m/2),this._blur60Tex=this._createColorTex(i,g,m),this._blur60FBO=this._createBlurFBO(this._blur60Tex),this._blur61Tex=this._createColorTex(i,g,m),this._blur61FBO=this._createBlurFBO(this._blur61Tex))}_createColorTex(i,g,m){return this._regl.texture({min:"linear",mag:"linear",type:"uint8",width:g||i.width,height:m||i.height})}_createBlurFBO(i){return this._regl.framebuffer({width:i.width,height:i.height,colors:[i],depth:!1,stencil:!1})}_initShaders(){if(!this._blur0Shader){const i={vert:OM,extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.outputSize[0],height:(i,g)=>g.outputSize[1]}},frag:"#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\nuniform float inputRGBM;\nuniform float luminThreshold;\n#define SHADER_NAME GAUSSIAN_BLUR0\nconst vec3 c = vec3(.2126, .7152, .0722);\nfloat d(const in vec3 e) {\n  return dot(e, c);\n}\nvec4 f(vec4 e) {\n  float h = max(sign(d(e.rgb) - luminThreshold), .0);\n  return e * h;\n}\nvec2 i;\nvec4 j(const in vec3 e, const in float k) {\n  vec4 l;\n  vec3 m = e / k;\n  l.a = clamp(max(max(m.r, m.g), max(m.b, 1e-6)), .0, 1.);\n  l.a = ceil(l.a * 255.) / 255.;\n  l.rgb = m / l.a;\n  return l;\n}\nvec3 n(const in vec4 e, const in float k) {\n  if(inputRGBM == .0)\n    return e.rgb;\n  return k * e.rgb * e.a;\n}\nvec4 o() {\n  vec3 u = .375 * (f(vec4(n(texture2D(TextureBlurInput, i.xy), rgbmRange), 1.))).rgb;\n  vec2 v;\n  vec2 A = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  v = A * 1.2;\n  u += .3125 * (f(vec4(n(texture2D(TextureBlurInput, i.xy + v.xy), rgbmRange), 1.))).rgb;\n  u += .3125 * (f(vec4(n(texture2D(TextureBlurInput, i.xy - v.xy), rgbmRange), 1.))).rgb;\n  return vec4(u, 1.);\n}\nvoid main(void) {\n  i = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = o();\n  e = j(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}"};this._blur0Shader=new QuadShader(i),i.frag="#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR1\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .3125 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.2857142857142858;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}",this._blur1Shader=new QuadShader(i),i.frag="#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR2\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .2734375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.3333333333333333;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.111111111111111;\n  l += .03515625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .03515625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}",this._blur2Shader=new QuadShader(i),i.frag="#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR3\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .24609375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.3636363636363635;\n  l += .322265625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .322265625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.1818181818181817;\n  l += .0537109375 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .0537109375 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}",this._blur3Shader=new QuadShader(i),i.frag="#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR4\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .2255859375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.3846153846153846;\n  l += .314208984375 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .314208984375 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.230769230769231;\n  l += .06982421875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .06982421875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 5.076923076923077;\n  l += .003173828125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .003173828125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}",this._blur4Shader=new QuadShader(i),this._level>5&&(i.frag="precision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 outSize;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR5\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .20947265625 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  n *= outSize.y * .00075;\n  m = n * 1.4;\n  l += .30548095703125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .30548095703125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.2666666666666666;\n  l += .08331298828125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .08331298828125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 5.133333333333334;\n  l += .00640869140625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .00640869140625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}",this._blur5Shader=new QuadShader(i),i.frag="#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 outSize;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR6\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .196380615234375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  n *= outSize.y * .00075;\n  m = n * 1.411764705882353;\n  l += .2967529296875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .2967529296875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.2941176470588234;\n  l += .09442138671875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .09442138671875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 5.176470588235294;\n  l += .0103759765625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .0103759765625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}",this._blur6Shader=new QuadShader(i))}}}class BloomPass{constructor(i){this._regl=i,this._renderer=new Renderer(i)}render(i,g,m,_,b,T,P,I,H){this._initShaders(),this._createTextures(i);const W=this._blurPass.render(g,m);return this._combine(i,W,g,_,b,T,P,I,H)}_combine(i,g,m,_,b,T,P,I,H){H||this._combineTex.width===i.width&&this._combineTex.height===i.height||this._combineFBO.resize(i.width,i.height);let W=this._combineUniforms;const{blurTex0:q,blurTex1:$,blurTex2:ye,blurTex3:Re,blurTex4:Be}=g;W||(W=this._combineUniforms={bloomFactor:0,bloomRadius:0,rgbmRange:7,TextureBloomBlur1:q,TextureBloomBlur2:$,TextureBloomBlur3:ye,TextureBloomBlur4:Re,TextureBloomBlur5:Be,TextureInput:null,TextureSource:null,outputSize:[0,0]}),W.noAaTextureSource=T,W.pointTextureSource=P,W.enableAA=I,W.bloomFactor=_,W.bloomRadius=b,W.TextureInput=m,W.TextureSource=i,z_(W.outputSize,i.width,i.height);const Ge={};return T?Ge.HAS_NOAA_TEX=1:delete Ge.HAS_NOAA_TEX,P?Ge.HAS_POINT_TEX=1:delete Ge.HAS_POINT_TEX,this._combineShader.setDefines(Ge),this._renderer.render(this._combineShader,W,null,H?null:this._combineFBO),H?null:this._combineTex}dispose(){this._combineFBO&&(this._combineFBO.destroy(),delete this._combineFBO),this._blurPass&&(this._blurPass.dispose(),delete this._blurPass),delete this._uniforms}_createTextures(i){if(this._combineTex)return;this._combineTex=this._createColorTex(i,i.width,i.height,"uint8"),this._combineFBO=this._createBlurFBO(this._combineTex)}_createColorTex(i,g,m,_){return this._renderer.device.texture({min:"linear",mag:"linear",type:_,width:g||i.width,height:m||i.height})}_createBlurFBO(i){return this._renderer.device.framebuffer({width:i.width,height:i.height,colors:[i],depth:!1,stencil:!1})}_initShaders(){if(!this._combineShader){const i={x:0,y:0,width:(i,g)=>g.outputSize[0],height:(i,g)=>g.outputSize[1]};this._blurPass=new BlurPass(this._regl,!1),this._combineShader=new QuadShader({vert:OM,frag:"precision highp float;\nuniform float bloomFactor;\nuniform float bloomRadius;\nuniform float rgbmRange;\nuniform sampler2D TextureBloomBlur1;\nuniform sampler2D TextureBloomBlur2;\nuniform sampler2D TextureBloomBlur3;\nuniform sampler2D TextureBloomBlur4;\nuniform sampler2D TextureBloomBlur5;\nuniform sampler2D TextureInput;\nuniform sampler2D TextureSource;\n#ifdef HAS_NOAA_TEX\nuniform sampler2D noAaTextureSource;\n#endif\n#ifdef HAS_POINT_TEX\nuniform sampler2D pointTextureSource;\n#endif\nuniform float enableAA;\nuniform vec2 outputSize;\n#define SHADER_NAME bloomCombine\nvec2 c;\n#include <srgb_frag>\nvec3 d(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nfloat h(const float i, const float j) {\n  return mix(i, j * 2. - i, bloomRadius);\n}\nvec4 k() {\n  vec3 l = vec3(.0);\n  const float m = .6;\n  const float n = 1.1;\n  const float o = .9;\n  const float u = .6;\n  const float v = .3;\n  const float A = .1;\n  l += (vec4(d(texture2D(TextureBloomBlur1, c), rgbmRange), 1.)).rgb * h(n, m);\n  l += (vec4(d(texture2D(TextureBloomBlur2, c), rgbmRange), 1.)).rgb * h(o, m);\n  l += (vec4(d(texture2D(TextureBloomBlur3, c), rgbmRange), 1.)).rgb * h(u, m);\n  l += (vec4(d(texture2D(TextureBloomBlur4, c), rgbmRange), 1.)).rgb * h(v, m);\n  l += (vec4(d(texture2D(TextureBloomBlur5, c), rgbmRange), 1.)).rgb * h(A, m);\n  vec4 B;\n  if(enableAA == 1.) {\n    \n  } else {\n    B = texture2D(TextureInput, c);\n  }\n  B.rgb = mix(vec3(.0), B.rgb, sign(B.a));\n  vec4 C = texture2D(TextureSource, c);\n#ifdef HAS_NOAA_TEX\nvec4 D = texture2D(noAaTextureSource, c);\n  C = D + C * (1. - D.a);\n#endif\nvec4 E = vec4(.0);\n#ifdef HAS_POINT_TEX\nE = texture2D(pointTextureSource, c);\n#endif\nfloat F = sqrt((l.r + l.g + l.b) / 3.);\n  vec4 G = vec4(linearTosRGB(l * bloomFactor), F);\n  return E + (B + C * (1. - B.a)) * (1. - E.a) + G;\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  gl_FragColor = e;\n}",extraCommandProps:{viewport:i}})}}}class CopyDepthShader extends QuadShader{constructor(){const i=[];super({vert:OM,frag:"precision highp float;\n#include <gl2_frag>\n#define SHADER_NAME COPY_DEPTH\nuniform sampler2D TextureDepth;\nuniform vec2 textureSize;\n#include <common_pack_float>\nvoid main(void) {\n  vec2 c = gl_FragCoord.xy / textureSize.xy;\n  float d = texture2D(TextureDepth, c).r;\n  glFragColor = common_encodeDepth(d);\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",uniforms:[{name:"textureSize",type:"function",fn:(g,m)=>(i[0]=m.TextureDepth.width,i[1]=m.TextureDepth.height,i)}],extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.TextureDepth.width,height:(i,g)=>g.TextureDepth.height}}}),this.version=300}getMeshCommand(i,g){return this.commands.copy_depth||(this.commands.copy_depth=this.createMeshCommand(i,g)),this.commands.copy_depth}}class SsrPass{static getUniformDeclares(){const i=[[0,0,0,0],[0,0,0,0]],g=new Array(16);return[{name:"invProjMatrix",type:"function",fn:(i,m)=>yA(g,m.projMatrix)},{name:"outputFovInfo",type:"array",length:2,fn:function(g,m){const _=Math.tan(.5*m.fov),b=m.outSize[0]/m.outSize[1]*_;return wy(i[0],b,_,b,-_),wy(i[1],-b,_,-b,-_),i}},{name:"reprojViewProjMatrix",type:"function",fn:(i,g)=>_A([],g.prevProjViewMatrix,g.cameraWorldMatrix)}]}static getDefines(){return{HAS_SSR:1}}constructor(i){this._regl=i,this._renderer=new Renderer(i),this._inputRGBM=0}setup(i){this._initShaders(),this._createTextures(i)}getSSRUniforms(i,g,m){if(!this._depthCopy)return null;const _=this._depthCopy;return{TextureDepth:_,TextureReflected:this.getMipmapTexture(),ssrFactor:g||1,ssrQuality:m||2,outSize:[_.width,_.height],fov:i.getFov()*Math.PI/180,prevProjViewMatrix:this._projViewMatrix||i.projViewMatrix,cameraWorldMatrix:i.cameraWorldMatrix}}genMipMap(i,g,m){return this.setup(i),this._mipmap(i),this.copyDepthTex(g),this._projViewMatrix||(this._projViewMatrix=[]),gA(this._projViewMatrix,m),delete this._depthCopied,this._outputTex}getPrevProjViewMatrix(){return this._projViewMatrix}copyDepthTex(i){if(this._depthCopied)return null;if(this.setup(i),this._depthCopy)i.width===this._depthCopy.width&&i.height===this._depthCopy.height||this._depthCopyFBO.resize(i.width,i.height);else{this._depthCopy=this._regl.texture({min:"nearest",mag:"nearest",mipmap:!1,type:"uint8",width:i.width,height:i.height});this._depthCopyFBO=this._regl.framebuffer({width:i.width,height:i.height,colors:[this._depthCopy],colorFormat:"rgba"})}return this._renderer.render(this._copyDepthShader,{TextureDepth:i},null,this._depthCopyFBO),this._depthCopied=!0,this._depthCopy}_mipmap(i){const g=this._targetFBO,m=Math.ceil(.5*i.width),_=Math.ceil(.5*i.height);g.width===m&&g.height===_||g.resize(m,_);let b=this._blurUniforms;b||(b=this._blurUniforms={rgbmRange:7,outputSize:[0,0]}),b.TextureInput=i,b.inputRGBM=+this._inputRGBM,z_(b.outputSize,g.width,g.height),this._renderer.render(this._ssrQuadShader,b,null,g)}getMipmapTexture(){return this._outputTex||(this._outputTex=this._renderer.regl.texture({type:"uint8",width:2,height:2})),this._outputTex}dispose(){this._copyDepthShader&&(this._ssrQuadShader.dispose(),this._copyDepthShader.dispose(),this._targetFBO.destroy(),delete this._copyDepthShader),this._depthCopy&&(this._depthCopyFBO.destroy(),delete this._depthCopy,delete this._depthCopyFBO)}_initShaders(){if(!this._copyDepthShader){this._copyDepthShader=new CopyDepthShader;this._ssrQuadShader=new QuadShader({vert:OM,frag:"#version 100\nprecision mediump float;\nuniform sampler2D TextureInput;\nuniform vec2 outputSize;\n#define SHADER_NAME QUAD\nvec2 c;\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 d = texture2D(TextureInput, c.xy);\n  gl_FragColor = d;\n}",extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.outputSize[0],height:(i,g)=>g.outputSize[1]}}})}}_createTextures(i){if(!this._targetFBO){const g=this._regl;this._outputTex&&this._outputTex.destroy(),this._outputTex=g.texture({min:"linear",mag:"linear",type:"uint8",width:i.width,height:i.height}),this._targetFBO=g.framebuffer({width:i.width,height:i.height,colors:[this._outputTex],depth:!1,stencil:!1})}}}class HeatmapShader extends MeshShader{constructor(i){const g=[];super({vert:"#define SHADER_NAME HEATMAP\nuniform mat4 projViewModelMatrix;\nuniform float extrudeScale;\nuniform float heatmapIntensity;\nattribute vec3 aPosition;\nvarying vec2 vExtrude;\n#ifdef HAS_HEAT_WEIGHT\nattribute highp float aWeight;\nvarying highp float weight;\n#else\nuniform highp float heatmapWeight;\n#endif\nuniform mediump float heatmapRadius;\nconst highp float c = 1. / 255. / 16.;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n  \n#ifdef HAS_HEAT_WEIGHT\nhighp float d = aWeight / 255.;\n  weight = d;\n#else\nhighp float d = heatmapWeight;\n#endif\nmediump float e = heatmapRadius;\n  vec2 f = vec2(mod(aPosition.xy, 2.) * 2. - 1.);\n  float h = sqrt(-2. * log(c / d / heatmapIntensity / GAUSS_COEF)) / 3.;\n  vExtrude = h * f;\n  vec2 i = vExtrude * e * extrudeScale;\n  vec4 j = vec4(floor(aPosition.xy * .5) + i, aPosition.z, 1);\n  gl_Position = projViewModelMatrix * j;\n}",frag:"#define SHADER_NAME HEATMAP\nprecision mediump float;\nuniform highp float heatmapIntensity;\nvarying vec2 vExtrude;\n#ifdef HAS_HEAT_WEIGHT\nvarying highp float weight;\n#else\nuniform highp float heatmapWeight;\n#endif\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n  \n#ifdef HAS_HEAT_WEIGHT\nhighp float c = weight;\n#else\nhighp float c = heatmapWeight;\n#endif\nfloat d = -.5 * 3. * 3. * dot(vExtrude, vExtrude);\n  float e = c * heatmapIntensity * GAUSS_COEF * exp(d);\n  gl_FragColor = vec4(e, 1., 1., 1.);\n}",uniforms:[{name:"extrudeScale",type:"function",fn:function(i,g){return g.resolution/g.dataResolution*g.tileRatio}},{name:"projViewModelMatrix",type:"function",fn:function(i,m){return _A(g,m.projViewMatrix,m.modelMatrix)}}],extraCommandProps:cx({},i&&i.extraCommandProps||{},{blend:{enable:!0,func:{src:"one",dst:"one"},equation:"add"}})})}}var BM=[-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1],zM="#define SHADER_NAME SKYBOX\n#if __VERSION__ == 100\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod(tex, uv, lod) textureCubeLodEXT(tex, uv, lod)\n#else\n#define textureCubeLod(tex, uv, lod) textureCube(tex, uv, lod)\n#endif\n#else\n#define textureCubeLod(tex, uv, lod) textureLod(tex, uv, lod)\n#endif\nprecision highp float;\n#define saturate(x)        clamp(x, 0.0, 1.0)\n#include <gl2_frag>\n#include <hsv_frag>\nuniform vec3 hsv;\nvarying vec3 vWorldPos;\n#ifdef USE_AMBIENT\nuniform vec3 diffuseSPH[9];\n#else\nuniform samplerCube cubeMap;\nuniform float bias;\nuniform float size;\n#endif\nuniform float environmentExposure;\nuniform float backgroundIntensity;\nvec4 c(const in samplerCube d, const in vec3 e, const in float f, const in float h) {\n  vec3 i = e;\n  return textureCubeLod(d, i, h);\n}\nvec3 j(const in vec3 k, const in vec3 l[9]) {\n  float x = k.x;\n  float y = k.y;\n  float z = k.z;\n  vec3 m = (l[0] + l[1] * x + l[2] * y + l[3] * z + l[4] * z * x + l[5] * y * z + l[6] * y * x + l[7] * (3. * z * z - 1.) + l[8] * (x * x - y * y));\n  return max(m, vec3(.0));\n}\nfloat n(const in vec2 o) {\n  vec3 u = fract(vec3(o.xyx) * .1031);\n  u += dot(u, u.yzx + 19.19);\n  return fract((u.x + u.y) * u.z);\n}\n#if defined(TONE_MAPPING)\nconst float v = 1.;\nvec3 A(vec3 B) {\n  vec3 a = B * (B + .0245786) - .000090537;\n  vec3 b = B * (.983729 * B + .4329510) + .238081;\n  return a / b;\n}\nvec3 C(vec3 D) {\n  const mat3 E = mat3(vec3(.59719, .07600, .02840), vec3(.35458, .90834, .13383), vec3(.04823, .01566, .83777));\n  const mat3 F = mat3(vec3(1.60475, -.10208, -.00327), vec3(-.53108, 1.10813, -.07276), vec3(-.07367, -.00605, 1.07602));\n  D *= v / .6;\n  D = E * D;\n  D = A(D);\n  D = F * D;\n  return saturate(D);\n}\nvec3 G(vec3 D) {\n  return C(D);\n}\nvec4 H(in vec4 I) {\n  return vec4(mix(pow(I.rgb, vec3(.41666)) * 1.055 - vec3(.055), I.rgb * 12.92, vec3(lessThanEqual(I.rgb, vec3(.0031308)))), I.a);\n}\nvec4 J(vec4 I) {\n  return (H(I));\n}\n#endif\nvoid main() {\n  vec4 K;\n#ifdef USE_AMBIENT\nvec3 k = normalize(vWorldPos + mix(-.5 / 255., .5 / 255., n(gl_FragCoord.xy)) * 2.);\n  K = vec4(j(k, diffuseSPH), 1.);\n#else\nK = c(cubeMap, vWorldPos, size, bias);\n#endif\nK.rgb *= environmentExposure;\n  K.rgb *= backgroundIntensity;\n  glFragColor = K;\n  if(length(hsv) > .0) {\n    glFragColor.rgb = hsv_apply(clamp(glFragColor.rgb, .0, 1.), hsv);\n  }\n#if defined(TONE_MAPPING)\nglFragColor.rgb = G(glFragColor.rgb);\n  glFragColor = J(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}";class SkyboxShader extends MeshShader{constructor(){super({vert:"#include <gl2_vert>\nattribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 transformMatrix;\nvarying vec3 vWorldPos;\nvoid main() {\n  vWorldPos = aPosition;\n  mat4 c = mat4(mat3(viewMatrix) * transformMatrix);\n  vec4 d = projMatrix * c * vec4(vWorldPos, 1.);\n  gl_Position = d.xyww;\n}",frag:zM,extraCommandProps:{depth:{enable:!0,range:[1,1],func:"lequal"},viewport:{x:0,y:0,width:(i,g)=>g.resolution[0],height:(i,g)=>g.resolution[1]}}}),this.version=300}setMode(i,g){const m={};return i&&(m.TONE_MAPPING=1),0===g&&(m.USE_AMBIENT=1),this._skyboxMesh?this._skyboxMesh[0].setDefines(m):this._meshDefines=m,this}draw(i){return this._skyboxMesh||this._createSkyboxMesh(i),super.draw(i,this._skyboxMesh)}_createSkyboxMesh(i){const g=new Geometry({aPosition:new Int8Array(BM)},null,BM.length/3);g.generateBuffers(i),this._skyboxMesh=[new Mesh(g)],this._meshDefines&&(this._skyboxMesh[0].setDefines(this._meshDefines),delete this._meshDefines)}dispose(){if(this._skyboxMesh){const i=this._skyboxMesh[0];i.geometry.dispose(),i.dispose()}return delete this._skyboxMesh,super.dispose()}}class HeatmapDisplayShader extends MeshShader{constructor(i,g){const m={blend:{enable:!0,func:{src:"one",dst:"one minus src alpha"},equation:"add"},viewport:i};g&&g.extraCommandProps&&cx(m,g.extraCommandProps);const _=[];super({vert:"#define SHADER_NAME HEATMAP_DISPLAY\nuniform mat4 projViewModelMatrix;\nattribute vec3 aPosition;\nvoid main() {\n  gl_Position = projViewModelMatrix * vec4(aPosition, 1.);\n}",frag:"#define SHADER_NAME HEATMAP_DISPLAY\nprecision mediump float;\nuniform sampler2D inputTexture;\nuniform sampler2D colorRamp;\nuniform vec2 textureOutputSize;\nuniform float heatmapOpacity;\nvoid main() {\n  vec2 c = gl_FragCoord.xy / textureOutputSize.xy;\n  float t = texture2D(inputTexture, c).r;\n  vec4 d = texture2D(colorRamp, vec2(t, .5));\n  gl_FragColor = d * heatmapOpacity;\n}",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A(_,g.projViewMatrix,g.modelMatrix)}}],extraCommandProps:m})}}class CopyShader extends QuadShader{constructor(){super({vert:OM,frag:"precision highp float;\nuniform sampler2D texture;\nuniform vec2 size;\nuniform float enableSharpen;\nuniform float sharpFactor;\nuniform float pixelRatio;\nvec2 c;\nvec3 d(const in vec3 e, const float f) {\n  vec2 h = pixelRatio / size.xy;\n  float i = .0;\n  vec4 j = texture2D(texture, c + h * vec2(-1., -1.));\n  j.rgb = mix(vec3(.0), j.rgb, sign(j.a));\n  i += mix(.0, 1., sign(j.a));\n  vec4 k = texture2D(texture, c + h * vec2(1.));\n  k.rgb = mix(vec3(.0), k.rgb, sign(k.a));\n  i += mix(.0, 1., sign(k.a));\n  vec4 l = texture2D(texture, c + h * vec2(1., -1.));\n  l.rgb = mix(vec3(.0), l.rgb, sign(l.a));\n  i += mix(.0, 1., sign(l.a));\n  vec4 m = texture2D(texture, c + h * vec2(-1., 1.));\n  m.rgb = mix(vec3(.0), m.rgb, sign(m.a));\n  i += mix(.0, 1., sign(m.a));\n  return e + f * (i * e - j.rgb - l.rgb - m.rgb - k.rgb);\n}\nvoid main() {\n  c = gl_FragCoord.xy / size;\n  vec4 e = texture2D(texture, c);\n  if(enableSharpen == 1.) {\n    e.rgb = d(e.rgb, sharpFactor);\n  }\n  gl_FragColor = e;\n}",extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.size[0],height:(i,g)=>g.size[1]}}})}getMeshCommand(i,g){return this.commands.copy||(this.commands.copy=this.createMeshCommand(i,g)),this.commands.copy}}const VM=[],UM=[];class EffectShader extends QuadShader{constructor(){super({vert:OM,frag:"#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\nuniform sampler2D sceneMap;\nuniform sampler2D scanEffectMap;\nvoid main() {\n  vec4 c = texture2D(sceneMap, vTexCoord);\n  vec4 d = texture2D(scanEffectMap, vTexCoord);\n  glFragColor = c + d;\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.resolution[0],height:(i,g)=>g.resolution[1]}}})}}const GM=[];class FogPass{constructor(i,g,m){this._regl=i,this._layer=m,this._viewport=g,this._init()}_init(){this._shader=new MeshShader({vert:"attribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nvarying vec4 vWorldPosition;\n#include <get_output>\nvoid main() {\n  vec4 c = getPosition(aPosition);\n  mat4 d = getPositionMatrix();\n  vec4 e = modelMatrix * d * c;\n  gl_Position = projMatrix * modelViewMatrix * d * c;\n  vWorldPosition = e;\n}",frag:"precision mediump float;\nvarying vec4 vWorldPosition;\nuniform vec2 fogDist;\nuniform vec3 cameraPosition;\nuniform float rainDepth;\nvoid main() {\n  vec3 c = vec3(vWorldPosition[0] - cameraPosition[0], vWorldPosition[1] - cameraPosition[1], vWorldPosition[2] - cameraPosition[2]);\n  float d = length(c);\n  float e = clamp(1. - (d - fogDist.x) / (fogDist.y - fogDist.x), .0, 1.);\n  if(vWorldPosition[2] < rainDepth) {\n    gl_FragColor = vec4(e, .0, .0, 1.);\n  } else {\n    gl_FragColor = vec4(e, 1., .0, 1.);\n  }\n}",uniforms:[{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(GM,g.viewMatrix,g.modelMatrix)}}],extraCommandProps:{viewport:this._viewport}});const i=this._layer.getRenderer().createFBOInfo();this._fbo=this._regl.framebuffer(i),this._scene=new Scene,this.renderer=new Renderer(this._regl)}render(i,g){this._resize(),this.renderer.clear({color:[0,0,0,1],depth:1,framebuffer:this._fbo}),this._scene.setMeshes(i);return this.renderer.render(this._shader,{projMatrix:g.projMatrix,viewMatrix:g.viewMatrix,cameraPosition:g.cameraPosition,fogDist:g.fogDist,rainDepth:g.rainDepth},this._scene,this._fbo),this._fbo}dispose(){this._fbo&&this._fbo.destroy(),this._shader&&this._shader.dispose()}_resize(){const i=hx(this._viewport.width.data)?this._viewport.width.data():this._viewport.width,g=hx(this._viewport.height.data)?this._viewport.height.data():this._viewport.height;!this._fbo||this._fbo.width===i&&this._fbo.height===g||this._fbo.resize(i,g)}}class FogShader extends QuadShader{constructor(){super({vert:OM,frag:"#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\n#ifdef HAS_RAIN\nuniform sampler2D ripplesMap;\n#endif\n#ifdef HAS_SNOW\nuniform sampler2D normalMap;\n#endif\n#ifdef HAS_FOG\nuniform vec3 fogColor;\n#endif\nuniform sampler2D sceneMap;\nuniform sampler2D mixFactorMap;\nuniform float time;\nuniform vec2 resolution;\nuniform float snowIntensity;\nfloat c(float a, float b, float w) {\n  return a + w * (b - a);\n}\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec3(.1031, .1030, .0973, .1099)\nfloat d = .5;\nfloat e = .2;\nfloat f = .5;\nfloat h = 20.;\nfloat i(float p) {\n  vec3 j = fract(vec3(p) * HASHSCALE1);\n  j += dot(j, j.yzx + 19.19);\n  return fract((j.x + j.y) * j.z);\n}\nvec2 k(vec2 p) {\n  vec3 j = fract(vec3(p.xyx) * HASHSCALE3);\n  j += dot(j, j.yzx + 19.19);\n  return fract((j.xx + j.yz) * j.zy);\n}\nvec2 l(vec2 m) {\n  float x = fract(sin(dot(m.xy, vec2(122.9898, 783.233))) * 43758.5453);\n  float y = fract(sin(dot(m.xy, vec2(457.6537, 537.2793))) * 37573.5913);\n  return vec2(x, y);\n}\nvec3 n(vec2 o, float u) {\n  vec3 v = vec3(.0);\n  o = o * (2. + u);\n  float A = e * snowIntensity;\n  float B = o.y * (((i(u) * 2. - 1.) * .5 + 1.) * A);\n  float C = (f * time);\n  o += vec2(B, C);\n  vec2 D = k(floor(o) + 31.1759 * u);\n  o = fract(o);\n  o -= (D * 2. - 1.) * .35;\n  o -= .5;\n  float r = length(o);\n  float E = .05 * (1. + .3 * sin(time * d));\n  float F = smoothstep(E, -E, r);\n  vec3 G = vec3(F) * D.x;\n  return G;\n}\nvec3 H() {\n  vec3 v = vec3(0);\n  vec2 o = gl_FragCoord.xy / resolution.xy;\n  o *= vec2(resolution.x / resolution.y, 1.);\n  float I = h * snowIntensity;\n  for(float J = 0.; J < I; J++) {\n    v += n(o, J);\n  }\n  return v;\n}\nvec3 K(vec4 L, vec4 M, float N) {\n  float O = M.b;\n  vec3 P = vec3(1.);\n  if(N < 1.) {\n    float r = c(.5, P.x, O);\n    float g = c(.5, P.y, O);\n    float b = c(.5, P.z, O);\n    return vec3(r, g, b);\n  } else {\n    float r = c(L.r, P.x, O);\n    float g = c(L.g, P.y, O);\n    float b = c(L.b, P.z, O);\n    return vec3(r, g, b);\n  }\n}\nvoid main() {\n  vec4 L = texture2D(sceneMap, vTexCoord);\n  glFragColor = L;\n  vec4 Q = texture2D(mixFactorMap, vTexCoord);\n#ifdef HAS_RAIN\nvec4 R = texture2D(ripplesMap, vTexCoord);\n  if(Q.g < 1.) {\n    L = mix(L, R, .4);\n  }\n  glFragColor = L;\n#endif\n#ifdef HAS_SNOW\nvec3 S = H();\n  glFragColor = vec4(L.rgb + S, L.a);\n#endif\n#ifdef HAS_FOG\nfloat T = Q.r;\n  vec3 U = mix(fogColor, glFragColor.rgb, T);\n  glFragColor = vec4(U, L.a);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.resolution[0],height:(i,g)=>g.resolution[1]}}})}}const jM=[],WM=[.03,.03,.03],qM=[],XM=[],ZM=[],$M=MA([],o_([],90,0,0),[0,0,0]);class RainRipplePass{constructor(i,g){this._regl=i,this._viewport=g,this._init()}_init(){this._shader=new MeshShader({vert:"#include <gl2_vert>\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nvarying vec2 vTexCoord;\n#include <get_output>\nvoid main() {\n  vec4 c = getPosition(aPosition);\n  mat4 d = getPositionMatrix();\n  gl_Position = projMatrix * modelViewMatrix * d * c;\n  vTexCoord = aTexCoord;\n}",frag:"#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\nuniform float rippleRadius;\nuniform float density;\nuniform float time;\nvec3 c(vec2 p) {\n  vec3 q = vec3(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)), dot(p, vec2(419.2, 371.9)));\n  return fract(sin(q) * 43758.5453);\n}\nfloat d(in vec2 x) {\n  vec2 e = x * density / 4000.0;\n  vec2 p = floor(e);\n  vec2 f = fract(e);\n  float h = .0;\n  for(int i = -4; i <= 4; i++)\n    for(int k = -4; k <= 4; k++) {\n      vec2 g = vec2(float(k), float(i));\n      vec3 l = c(p + g);\n      vec2 r = g - f + l.xy;\n      float m = sqrt(dot(r, r));\n      float n = max(mix(smoothstep(.99, .999, max(cos(m - time * 2. + (l.x + l.y) * 5.), 0.)), 0., m), 0.);\n      h += n;\n    }\n  return h;\n}\nvoid main() {\n  vec2 u = vTexCoord;\n  float A = 24. / (rippleRadius * .01);\n  float f = d(A * u) * smoothstep(.0, .4, sin(u.x * 3.151592) * sin(u.y * 3.141592));\n  vec3 B = vec3(-dFdx(f), -dFdy(f), -dFdy(f));\n  glFragColor = vec4(B, 1.);\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",uniforms:[{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(jM,g.viewMatrix,g.modelMatrix)}}],extraCommandProps:{viewport:this._viewport}}),this._shader.version=300,this._fbo=this._regl.framebuffer({color:this._regl.texture({width:this._viewport.width(),height:this._viewport.height(),wrap:"clamp",mag:"linear",min:"linear"}),depth:!0}),this._scene=new Scene,this.renderer=new Renderer(this._regl)}_transformRipples(i){const g=i.coordinateToPointAtRes(i.getCenter(),i.getGLRes()),m=i.getGLScale()/i.getGLScale(this._fixZoom),_=qA(XM,m,m,m),b=$A(_,WM,_),T=mA(ZM);OA(T,o_(qM,0,0,0),[g.x,g.y,0],b),_A(T,T,$M),this._mesh.setLocalTransform(T)}_createRipplesMask(i){this._fixZoom=i.getZoom();const g=800*Math.pow(2,16.685648411389433-this._fixZoom),m={};m.POSITION=[-g,0,-g,g,0,-g,-g,0,g,g,0,g],m.NORMAL=[0,1,0,0,1,0,0,1,0,0,1,0],m.TEXCOORD_0=[0,0,1,0,0,1,1,1];const _=new Geometry(m,[3,1,0,0,2,3],0,{positionAttribute:"POSITION",normalAttribute:"NORMAL",uv0Attribute:"TEXCOORD_0"});_.generateBuffers(this._regl);const b=new Material;return new Mesh(_,b)}render(i,g){this._resize(),this.renderer.clear({color:[0,0,0,1],depth:1,framebuffer:this._fbo}),this._mesh=this._mesh||this._createRipplesMask(i),this._scene.setMeshes(this._mesh),this._transformRipples(i);return this.renderer.render(this._shader,{projMatrix:g.projMatrix,viewMatrix:g.viewMatrix,time:g.time,rippleRadius:g.rippleRadius,density:g.density},this._scene,this._fbo),this._fbo}dispose(){this._fbo&&this._fbo.destroy(),this._shader&&this._shader.dispose()}_resize(){const i=hx(this._viewport.width.data)?this._viewport.width.data():this._viewport.width,g=hx(this._viewport.height.data)?this._viewport.height.data():this._viewport.height;!this._fbo||this._fbo.width===i&&this._fbo.height===g||this._fbo.resize(i,g)}}var YM="attribute vec3 aPosition;\nuniform mat4 positionMatrix;\nuniform mat4 projViewModelMatrix;\n#ifdef HAS_TEXTURE\nattribute vec2 aTexCoord;\nvarying vec2 uv;\nvarying vec4 vPos;\n#endif\n#include <get_output>\nvoid main() {\n  mat4 c = getPositionMatrix();\n  vec4 d = c * getPosition(aPosition);\n  gl_Position = projViewModelMatrix * d;\n#ifdef HAS_TEXTURE\nuv = aTexCoord;\n  vPos = getPosition(aPosition);\n#endif\n}";const QM=[0,0,0,1];class ExtentPass{constructor(i,g){this.regl=i,this._viewport=g,this.renderer=new Renderer(i),this._init()}_init(){this._maskColorFbo=this.renderer.device.framebuffer({color:this.renderer.device.texture({width:1,height:1,wrap:"clamp",mag:"linear",min:"linear"}),depth:!0}),this._maskModeFbo=this.renderer.device.framebuffer({color:this.renderer.device.texture({width:1,height:1,wrap:"clamp",mag:"nearest",min:"nearest"}),depth:!0});const i=[{name:"projViewModelMatrix",type:"function",fn:(i,g)=>_A([],g.projViewMatrix,g.modelMatrix)}];this._maskColorShader=new MeshShader({vert:YM,frag:"#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec4 maskColor;\n#ifdef HAS_TEXTURE\nuniform sampler2D maskTexture;\nvarying vec2 uv;\nuniform vec3 mask_position0;\nuniform vec3 mask_position1;\nuniform vec3 mask_position2;\nuniform vec3 mask_position3;\nvarying vec4 vPos;\nvec2 c(vec2 d, vec2 a, vec2 b, vec2 e, vec2 f) {\n  vec2 h = vec2(.5);\n  for(int i = 0; i < 10; i++) {\n    float j = h.x;\n    float k = h.y;\n    vec2 l = (1. - j) * (1. - k) * a + j * (1. - k) * b + j * k * e + (1. - j) * k * f;\n    vec2 m = d - l;\n    if(length(m) < .001)\n      break;\n    vec2 n = -(1. - k) * a + (1. - k) * b + k * e - k * f;\n    vec2 o = -(1. - j) * a - j * b + j * e + (1. - j) * f;\n    float A = n.x * o.y - n.y * o.x;\n    if(abs(A) > .0001) {\n      vec2 B = vec2((m.x * o.y - m.y * o.x) / A, (m.y * n.x - m.x * n.y) / A);\n      h += B;\n    }\n    h = clamp(h, .0, 1.);\n  }\n  return h;\n}\n#endif\nvoid main() {\n  \n#ifdef HAS_TEXTURE\nvec2 d = vPos.xy;\n  vec2 C = c(d, mask_position0.xy, mask_position1.xy, mask_position2.xy, mask_position3.xy);\n  gl_FragColor = texture2D(maskTexture, C);\n  gl_FragColor.a *= maskColor.a;\n#else\nif(maskColor.a == .0) {\n    discard;\n  }\n  gl_FragColor = maskColor;\n#endif\n}",uniforms:i,extraCommandProps:{viewport:this._viewport,depth:{enable:!0,func:"lequal"}}}),this._maskModeShader=new MeshShader({vert:YM,frag:"#ifdef GL_ES\nprecision highp float;\n#endif\nuniform float maskMode;\n#ifdef HAS_MASK_FLAT\nuniform float flatHeight;\n#endif\n#ifdef HAS_MASK_COLOR\nuniform vec2 heightRange;\n#endif\nvoid main() {\n  \n#if defined(HAS_MASK_FLAT)\ngl_FragColor = vec4(maskMode, flatHeight, .0, 1.);\n#elif defined(HAS_MASK_COLOR)\ngl_FragColor = vec4(maskMode, .0, heightRange.x, heightRange.y);\n#else\ngl_FragColor = vec4(maskMode, .0, .0, .0);\n#endif\n}",uniforms:i,extraCommandProps:{viewport:this._viewport}}),this._scene=new Scene}render(i,g){this._resize(),this.renderer.clear({color:QM,depth:1,framebuffer:this._maskColorFbo}),this.renderer.clear({color:QM,depth:1,framebuffer:this._maskModeFbo}),this._scene.setMeshes(i);const m={projViewMatrix:g};return this.renderer.render(this._maskColorShader,m,this._scene,this._maskColorFbo),this.renderer.render(this._maskModeShader,m,this._scene,this._maskModeFbo),{colorExtent:this._maskColorFbo,modeExtent:this._maskModeFbo}}_resize(){const i=hx(this._viewport.width)?this._viewport.width():this._viewport.width.data(),g=hx(this._viewport.height)?this._viewport.height():this._viewport.height.data();!this._maskColorFbo||this._maskColorFbo.width===i&&this._maskColorFbo.height===g||(this._maskColorFbo.resize(i,g),this._maskModeFbo.resize(i,g))}dispose(){this._maskColorFbo&&(this._maskColorFbo.destroy(),delete this._maskColorFbo),this._maskModeFbo&&(this._maskModeFbo.destroy(),delete this._maskModeFbo),this._maskColorShader&&(this._maskColorShader.dispose(),delete this._maskColorShader),this._maskModeShader&&(this._maskModeShader.dispose(),delete this._maskModeShader)}}const JM="\n#ifdef GL_ES\n  precision highp float;\n#endif\nuniform mat3 ring;\n\nuniform float effectTime;\nvarying vec4 vWorldPosition;\n\nvec3 hsb2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 glowring(vec4 worldPos, vec2 center, float radius, float speed, vec3 effectColor, float direction, float height) {\n  vec2 dir = vec2(worldPos.xy) - center;\n  float len = length(dir);\n  if (len > radius) {\n    return vec4(0.0);\n  } else {\n    vec2 uv = vec2(0.0);\n    if (direction == 0.0) {\n      vec2 lefttop = vec2(center.x - radius, center.y + radius);\n      vec2 rightbottom = vec2(center.x + radius, center.y - radius);\n      uv = vec2(abs(worldPos.x - lefttop.x) / (2.0 * radius), abs(worldPos.y - rightbottom.y) / (2.0 * radius));\n      uv.x -= 0.5;\n      uv.y -= 0.5;\n    } else {\n      if (worldPos.z < 0.1) {\n        return vec4(0.0);\n      }\n      uv = vec2(0.0, worldPos.z / height);\n    }\n    float itime = (effectTime / 2.0) * speed;\n    float r = length(uv) * 3.0;\n    vec3 color = hsb2rgb(effectColor);\n\n    float a = pow(r, 2.0);\n    float b = sin(r * 0.8 - 1.6);\n    float c = sin(r - 0.010);\n    float s = sin(a - itime * 3.0 + b) * c;\n    float t = abs(1.0 / (s * 10.8)) - 0.01;\n    color *= t;\n    vec4 newColor = vec4(color, t);\n    return newColor;\n  }\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    gl_FragColor = color;\n}\n",KM=[];class ScanEffectPass{constructor(i,g,m){this._regl=i,this._layer=m,this._viewport=g,this._init(),this._effectsLength=0}_init(){const i=this._layer.getRenderer().createFBOInfo();this._fbo=this._regl.framebuffer(i),this._scene=new Scene,this.renderer=new Renderer(this._regl)}render(i,g){this._resize(),this.renderer.clear({color:[0,0,0,1],depth:1,framebuffer:this._fbo}),this._scene.setMeshes(i);const m=g.effectInfos;if(!this._shader||m.length!==this._effectsLength){this._shader&&this._shader.dispose();const i=this._createFragSource(m);this._shader=new MeshShader({vert:"#include <gl2_vert>\n#define SHADER_NAME SCANEFFECT\nprecision highp float;\nattribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\n#include <line_extrusion_vert>\n#include <get_output>\nvarying vec4 vWorldPosition;\nvoid main()\n{\n    mat4 localPositionMatrix = getPositionMatrix();\n    #ifdef IS_LINE_EXTRUSION\n        vec3 linePosition = getLineExtrudePosition(aPosition);\n        //linePixelScale = tileRatio * resolution / tileResolution\n        vec4 localVertex = getPosition(linePosition);\n    #else\n        vec4 localVertex = getPosition(aPosition);\n    #endif\n    vec4 worldPosition = modelMatrix * localPositionMatrix * localVertex;\n    vWorldPosition = worldPosition;\n    gl_Position = projMatrix * modelViewMatrix * localPositionMatrix * localVertex;\n}\n",frag:i,uniforms:[{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(KM,g.viewMatrix,g.modelMatrix)}}],extraCommandProps:{viewport:this._viewport}}),this._effectsLength=m.length}const _={projMatrix:g.projMatrix,viewMatrix:g.viewMatrix,effectTime:g.effectTime,minAltitude:0};return this._updateUniforms(_,m),this.renderer.render(this._shader,_,this._scene,this._fbo),this._fbo}_createFragSource(i){let g="";for(let m=0;m<i.length;m++)g+=`uniform mat3 ring${m};\n`;g=JM.replace("uniform mat3 ring;",g);let m="";for(let g=0;g<i.length;g++)m+=`\n                vec2 center${g} = vec2(ring${g}[0][0], ring${g}[0][1]);\n                float radius${g} = ring${g}[0][2];\n                float speed${g} = ring${g}[1][0];\n                vec3 color${g} = vec3(ring${g}[1][1], ring${g}[1][2], ring${g}[2][0]);\n                float direction${g} = ring${g}[2][1];\n                float height${g} = ring${g}[2][2];\n                vec4 ringColor${g} = glowring(vWorldPosition, center${g}, radius${g}, speed${g}, color${g}, direction${g}, height${g});\n                color += ringColor${g};\n            `;return m+="gl_FragColor = color;",g=g.replace("gl_FragColor = color;",m),g}_updateUniforms(i,g){for(let m=0;m<g.length;m++)i[`ring${m}`]=g[m]}dispose(){this._fbo&&this._fbo.destroy(),this._shader&&this._shader.dispose()}_resize(){const i=hx(this._viewport.width.data)?this._viewport.width.data():this._viewport.width,g=hx(this._viewport.height.data)?this._viewport.height.data():this._viewport.height;!this._fbo||this._fbo.width===i&&this._fbo.height===g||this._fbo.resize(i,g)}}const eC=[],tC={width:4,type:"float"};class Skin{constructor(i,g,m){this._regl=i,this.joints=g,this.inverseBindMatrices=[],this.jointMatrices=[],this.jointData=new Float32Array(16*g.length);for(let i=0;i<g.length;++i)this.inverseBindMatrices.push(new Float32Array(m.buffer,m.byteOffset+16*Float32Array.BYTES_PER_ELEMENT*i,16)),this.jointMatrices.push(new Float32Array(this.jointData.buffer,16*Float32Array.BYTES_PER_ELEMENT*i,16));this.jointTextureSize=[4,6]}update(i,g,m){yA(eC,i);for(let i=0;i<this.joints.length;++i){const m=this.jointMatrices[i];_A(m,eC,g[this.joints[i].nodeIndex]),_A(m,m,this.inverseBindMatrices[i])}tC.height=this.joints.length,tC.data=this.jointData;const _=tC;return m?m(_):m=this._regl.texture(_),m}}const nC=[0,0,0],rC=[0,0,0,1],iC=[1,1,1],oC=[];class TRS{constructor(i=[0,0,0],g=[0,0,0,1],m=[1,1,1]){this.translation=i,this.rotation=g,this.scale=m}getMatrix(){return OA(oC,this.rotation,this.translation,this.scale)}decompose(i){CA(this.translation,i),kA(this.rotation,i),PA(this.scale,i)}update(i){i&&(i.translation&&!hy(i.translation,nC)&&WA(this.translation,i.translation),i.rotation&&!C_(i.rotation,rC)&&p_(this.rotation,i.rotation),i.scale&&!hy(i.scale,iC)&&WA(this.scale,i.scale))}}class GeometryResource{constructor(i){this._init(i)}_init(i){this.bbox=i.bbox,this.geometry=i.geometry,this.nodeMatrix=i.nodeMatrix,this.materialInfo=i.materialInfo,this.extraInfo=i.extraInfo,this.animationMatrix=i.animationMatrix,this.morphWeights=i.morphWeights,this.skin=i.skin,this.nodeIndex=i.nodeIndex}copyEdgeGeometry(){this.copyGeometry||(this.copyGeometry=this._copyEdgeGeometry(this.geometry))}createCopyBarycentric(){this.copyGeometry&&!this.copyGeometry.data.aBarycentric&&(this.copyGeometry.buildUniqueVertex(),this.copyGeometry.createBarycentric("aBarycentric"))}_copyEdgeGeometry(i){const g=i.data,m=i.indices||i.elements,_={};for(const m in g)if(m===i.desc.positionAttribute)if(px(g[m]))_[m]=g[m].slice();else if(g[m].buffer&&g[m].buffer.destroy)_[m]={buffer:g[m].buffer},px(g[m].array)&&(_[m].array=g[m].array.slice());else{const g=i._getAttributeData(m);_[m]=m!==i.desc.positionAttribute?g:g.slice()}const b=void 0!==m.length?m.slice():m,T=JSON.parse(JSON.stringify(i.desc)),P=new EdgeGeometry(_,b,0,T);return P.properties=i.properties,P}}let sC=0;const aC=[],lC=[];class GLTFPack{constructor(i,g){this.gltf=i,this.regl=g,this.geometries=[],g&&(this._emptyTexture=g.texture({width:2,height:2}))}getMeshesInfo(){if(!this.gltf)return null;if(this.geometries.length)return this.geometries;this._createTextures(this.gltf.textures),this._createSkins(this.gltf.skins);return this.gltf.scenes[0].nodes.forEach((i=>{this._parserNode(i,this.geometries)})),this._checkBaseColorFactor(),this.geometries}getGLTFBBox(){if(!this.gltf)return null;const i=this.geometries;if(!i||!i.length)return null;const g=[1/0,1/0,1/0],m=[-1/0,-1/0,-1/0];for(let _=0;_<i.length;_++){const b=i[_].bbox,T=b.min,P=b.max;T[0]<g[0]&&(g[0]=T[0]),T[1]<g[1]&&(g[1]=T[1]),T[2]<g[2]&&(g[2]=T[2]),P[0]>m[0]&&(m[0]=P[0]),P[1]>m[1]&&(m[1]=P[1]),P[2]>m[2]&&(m[2]=P[2])}return{min:g,max:m}}_createSkins(i){if(i){this._skinMap={};for(let g=0;g<i.length;g++){const m=i[g];m.joints=m.joints.map((i=>this.gltf.nodes[i])),this._skinMap[g]=new Skin(this.regl,m.joints,m.inverseBindMatrices.array),delete m.inverseBindMatrices}}}_createTextures(i){if(i){this._textureMap={};for(let g=0;g<i.length;g++){const m=i[g];this._textureMap[g]||(this._textureMap[g]=this._toTexture(m),delete m.image)}}}_checkBaseColorFactor(){if(!this._checkBaseColorFactorAlpha())for(let i=0;i<this.geometries.length;i++){const g=this.geometries[i].materialInfo.baseColorFactor;g&&0===g[3]&&(g[3]=1)}}_checkBaseColorFactorAlpha(){for(let i=0;i<this.geometries.length;i++){const g=this.geometries[i].materialInfo.baseColorFactor;if(g&&g[3]>0)return!0}return!1}dispose(){this._emptyTexture&&this._emptyTexture.destroy();const i=this.getMeshesInfo();if(i){i.forEach((i=>{i.geometry.dispose();for(const g in i.materialInfo){const m=i.materialInfo[g];m&&m.destroy&&!m[Lx]&&m.destroy()}}));for(const i in this._textureMap){const g=this._textureMap[i];g&&g.destroy&&!g[Lx]&&g.destroy()}delete this.gltf}}updateAnimation(i,g,m,_,b,T,P,I){const H=this.gltf;if(!H)return;const W=ox();if(sC=H.animations?W.GLTFLoader.getAnimationTimeSpan(H,_):null,!sC)return;i-=b;let q=0;q=g||!g&&this._isFirstLoop(i,m,_,b)?i*m*.001%(sC.max-sC.min)+sC.min:i*m*.001+sC.min,H.scenes[0].nodes.forEach((i=>{this._updateNodeMatrix(_,q,i,null,T,I)}));for(const i in this.gltf.nodes){const g=this.gltf.nodes[i],m=T[g.nodeIndex];if(g.skin&&m){const i=g.skin.update(m,T,P[g.nodeIndex]&&P[g.nodeIndex].jointTexture);P[g.nodeIndex]||(P[g.nodeIndex]={jointTextureSize:g.skin.jointTextureSize,numJoints:g.skin.joints.length}),P[g.nodeIndex].jointTexture=i}}}_isFirstLoop(i,g,m,_){const b=this.gltf;if(!_||!b)return!0;const T=ox();return sC=b.animations?T.GLTFLoader.getAnimationTimeSpan(b,m):null,i*g*.001/(sC.max-sC.min)<1}hasSkinAnimation(){return!!this._isAnimation}_updateNodeMatrix(i,g,m,_,b,T){m.trs&&(T?T.indexOf(Number(m.nodeIndex))>-1&&this._updateNodeTRS(m,g,i):this._updateNodeTRS(m,g,i)),b[m.nodeIndex]=_?_A(b[m.nodeIndex]||[],_,m.matrix||m.trs.getMatrix()):gA(b[m.nodeIndex]||[],m.matrix||m.trs.getMatrix()),m.children&&m.children.forEach((_=>{this._updateNodeMatrix(i,g,_,b[m.nodeIndex],b,T)}))}_updateNodeTRS(i,g,m){const _=ox().GLTFLoader.getAnimationClip(this.gltf,Number(i.nodeIndex),g,m);_.weights&&this._updateMorph(i,_.weights),i.trs.update(_)}_updateMorph(i,g){const m=g.length;if(!i.influencesList){i.influencesList=[];for(let g=0;g<m;g++)i.influencesList[g]=[g,0]}const _=i.influencesList;for(let i=0;i<_.length;i++){const m=_[i];m[0]=i,m[1]=g[i]}_.sort(cC);const b=[];for(let i=0;i<8;i++)b[i]=[i,0];for(let i=0;i<8;i++)i<m&&_[i][1]?(b[i][0]=_[i][0],b[i][1]=_[i][1]):(b[i][0]=Number.MAX_SAFE_INTEGER,b[i][1]=0);b.sort(hC);i.geometries.forEach((i=>{const g=i.properties.morphTargets;for(let m=0;m<8;m++){const _=b[m],T=_[0],P=_[1];T!==Number.MAX_SAFE_INTEGER&&P?(i.updateData("POSITION"+m,g["POSITION_"+T].array),i.properties.morphWeights[m]=P):i.properties.morphWeights[m]=0}}))}_parserNode(i,g,m){if(i.isParsed)return;i.nodeMatrix=i.nodeMatrix||mA([]),i.localMatrix=i.localMatrix||mA([]),i.matrix?(i.trs=new TRS,i.trs.decompose(i.matrix)):i.trs=new TRS(i.translation,i.rotation,i.scale),i.localMatrix=i.trs.getMatrix(),m?_A(i.nodeMatrix,m,i.matrix||i.localMatrix):gA(i.nodeMatrix,i.matrix||i.localMatrix);const _=i.nodeMatrix;if(i.children)for(let m=0;m<i.children.length;m++){this._parserNode(i.children[m],g,_)}if(lx(i.skin)){this._isAnimation=!0;const g=i.skin;i.trs=new TRS,i.skin=this._skinMap[g]}if(lx(i.mesh)){i.mesh=this.gltf.meshes[i.mesh],i.mesh.node=i,i.geometries=i.geometries||[],i.mesh.primitives.forEach((m=>{const b=this._createMaterialInfo(m.material),T=function(i,g,m){const _=i.attributes,b=_.COLOR_0;if(b&&b.array instanceof Float32Array){const i=new Uint8Array(b.array.length);for(let g=0;g<i.length;g++)i[g]=Math.round(255*b.array[g]);b.array=i}else if(b&&(b.array instanceof Uint16Array||b.array instanceof Int16Array||b.array instanceof Uint32Array||b.array instanceof Int32Array)){const i=new Uint8Array(b.array);b.array=i}m&&_.TEXCOORD_0&&!_.TEXCOORD_0&&(_.TEXCOORD_1=_.TEXCOORD_0);const T={};for(const i in _)T[i]=cx({},_[i]),g&&(T[i].buffer=Zb(g,_[i],{dimension:_[i].itemSize}));if(i.morphTargets){const i=Sx(T.POSITION)?T.POSITION.itemSize*T.POSITION.count:T.POSITION.array.length;for(let g=0;g<8;g++)T[`POSITION${g}`]||(T[`POSITION${g}`]=new Float32Array(i).fill(0));for(let i=0;i<4;i++){T[`NORMAL${i}`]||(T[`NORMAL${i}`]=new Float32Array(T.NORMAL.array?T.NORMAL.array.length:T.NORMAL.length).fill(0))}}let P=i.indices;P&&void 0===P.bufferView&&P.array&&(P=P.array);const I=new Geometry(T,P,0,{primitive:fx(i.mode)?Lb(i.mode):i.mode,positionAttribute:"POSITION",normalAttribute:"NORMAL",uv0Attribute:"TEXCOORD_0",uv1Attribute:"TEXCOORD_1",color0Attribute:"COLOR_0"});i.morphTargets&&(I.properties.morphWeights=[]);i.mode>3&&!I.data.NORMAL&&I.createNormal("NORMAL");return I}(m,this.regl,b.occlusionTexture);T.properties.morphTargets=m.morphTargets,i.geometries.push(T);let P=T.boundingBox.copy();P=P.transform(mA(aC),_);const I={geometry:T,bbox:P,nodeMatrix:_,materialInfo:b,extraInfo:this._createExtralInfo(m.material),animationMatrix:i.trs.getMatrix(),morphWeights:i.weights,nodeIndex:i.nodeIndex};i.skin&&(I.skin={jointTextureSize:[4,6],numJoints:i.skin.joints.length,jointTexture:i.skin.jointTexture});const H=new GeometryResource(I);g.push(H)}))}i.isParsed=!0}_createMaterialInfo(i){const g={};if(this.gltf.materials&&this.gltf.materials[i]){const m=this.gltf.materials[i],_=m.pbrMetallicRoughness;if(_){const i=_.metallicRoughnessTexture,m=_.baseColorTexture;m&&(g.baseColorTexture=this._getTexture(m),m.KHR_texture_transform&&(g.khr_offset=m.KHR_texture_transform.offset||[0,0],g.khr_rotation=m.KHR_texture_transform.rotation||0,g.khr_scale=m.KHR_texture_transform.scale||[1,1])),_.baseColorFactor&&(g.baseColorFactor=_.baseColorFactor),i?g.metallicRoughnessTexture=this._getTexture(i):(g.metallicFactor=lx(_.metallicFactor)?_.metallicFactor:1,g.roughnessFactor=lx(_.roughnessFactor)?_.roughnessFactor:1)}const b=m.extensions;if(b&&b.KHR_materials_pbrSpecularGlossiness){const i=b.KHR_materials_pbrSpecularGlossiness;g.name="pbrSpecularGlossiness";for(const m in i)g[m]=lx(i[m].index)?this._getTexture(i[m]):i[m]}m.normalTexture&&(g.normalTexture=this._getTexture(m.normalTexture)),m.occlusionTexture&&(g.occlusionTexture=this._getTexture(m.occlusionTexture)),m.emissiveTexture&&(g.emissiveTexture=this._getTexture(m.emissiveTexture)),m.emissiveFactor&&(g.emissiveFactor=m.emissiveFactor),g.alphaCutoff=m.alphaCutoff||.5,g.doubleSided=m.doubleSided,g.alphaMode=m.alphaMode||"OPAQUE"}return g}_createExtralInfo(i){const g={};if(this.gltf.materials&&this.gltf.materials[i]){const m=this.gltf.materials[i];g.doubleSided=m.doubleSided,g.alphaMode=m.alphaMode||"OPAQUE"}return g}_getTexture(i){const g=i.extensions,m=i.index;if(!lx(m))return null;g&&g.KHR_texture_transform&&(i.KHR_texture_transform=g.KHR_texture_transform);const _=this._textureMap[m];return _.texInfo=i,_}_toTexture(i){if(!i)return this._emptyTexture;const g=i.sampler||{};return new Texture2D({width:i.image.width,height:i.image.height,data:i.image.array,mag:Vb(g.magFilter)||"linear",min:Gb(g.minFilter)||"linear mipmap linear",wrapS:Wb(g.wrapS)||"repeat",wrapT:Wb(g.wrapT)||"repeat"})}arrangeAlongLine(i,g,m,_,b,T){const P=[],I=this._getRotationZ(i,g),H=(i.z||0)-(g.z||0),W=this._getRotationXY(m,H);let q=this._calBoxWidth(_,T);q/=b;const $=Math.sqrt(m*m+H*H),ye=Math.floor($/q);let Re=T.direction||0;if(1===Re?Re=2:2===Re&&(Re=1),ye>=1){for(let m=1;m<=ye;m++){const _=q*(m-.5)/$,b={coordinates:uC(i,g,_),t:_,scale:[1,1,1],rotation:[0,0,I],rotationZ:I,rotationXY:W};P.push(b)}if(T.scaleVertex){const m=(q*ye+($-q*ye)/2)/$,_=[1,1,1];_[Re]=($-q*ye)/q;const b={coordinates:uC(i,g,m),t:m,scale:_,rotation:[0,0,I],rotationZ:I,rotationXY:W};P.push(b)}}else if(T.scaleVertex){const m=[1,1,1];m[Re]=$/q;const _={coordinates:uC(i,g,.5),t:.5,scale:m,rotation:[0,0,I],rotationZ:I,rotationXY:W};P.push(_)}return P}calModelHeightScale(i,g){const m=this.getGLTFBBox(),_=g/Math.abs(m.max[1]-m.min[1]);return qA(i,_,_,_)}_calBoxWidth(i,g){const m=this.getGLTFBBox(),_=g.direction||0,b=cy(lC,m.max,m.min);$A(b,b,i);return b[_]+g.gapLength}_getRotationZ(i,g){return Math.atan2(i.y-g.y,i.x-g.x)/Math.PI*180}_getRotationXY(i,g){return 180*Math.atan(g/i)/Math.PI}}function hC(i,g){return i[0]-g[0]}function cC(i,g){return Math.abs(g[1])-Math.abs(i[1])}function uC(i,g,m){const _=fC(i.x,g.x,m),b=fC(i.y,g.y,m),T=fC(i.z||0,g.z||0,m);return new i.constructor(_,b,T)}function fC(i,g,m){return i+m*(g-i)}function dC(i,g){const{Ajax:m}=ox(),{fetchOptions:_,gltfLoaderOptions:b,urlModifier:T}=g,P=b||{};P.urlModifier=T;const I=i.lastIndexOf("/"),H=i.slice(0,I),W=i.slice(i.lastIndexOf(".")).toLowerCase();return".gltf"===W?m.getJSON(i,_,T).then((i=>gC(H,i,P))):".glb"===W?m.getArrayBuffer(i,_,T).then((i=>gC(H,{buffer:i.data,byteOffset:0},P))):null}function pC(i,g){return new GLTFPack(i,g)}function gC(i,g,m){const{GLTFLoader:_}=ox();return new _(i,g,m).load()}var mC=Object.freeze({__proto__:null,exportGLTFPack:pC,load:dC,loadGLTF:gC});const AC=[-1,0,-1,1,0,-1,-1,0,1,1,0,1],yC=[0,1,0,0,1,0,0,1,0,0,1,0],_C=[3,1,0,0,2,3],vC=[0,0,1,0,0,1,1,1],xC={vertices:[-.8111000061035156,2.0102999210357666,-.8111000061035156,0,.010300000198185444,-0,-.8111000061035156,2.0102999210357666,.8111000061035156,-.8111000061035156,2.0102999210357666,.8111000061035156,0,.010300000198185444,-0,.8111000061035156,2.0102999210357666,.8111000061035156,.8111000061035156,2.0102999210357666,.8111000061035156,0,.010300000198185444,-0,.8111000061035156,2.0102999210357666,-.8111000061035156,.8111000061035156,2.0102999210357666,-.8111000061035156,0,.010300000198185444,-0,-.8111000061035156,2.0102999210357666,-.8111000061035156,.8111000061035156,2.0102999210357666,-.8111000061035156,-.8111000061035156,2.0102999210357666,-.8111000061035156,0,2.9419000148773193,-0,.8111000061035156,2.0102999210357666,.8111000061035156,.8111000061035156,2.0102999210357666,-.8111000061035156,0,2.9419000148773193,-0,-.8111000061035156,2.0102999210357666,-.8111000061035156,-.8111000061035156,2.0102999210357666,.8111000061035156,0,2.9419000148773193,-0,-.8111000061035156,2.0102999210357666,.8111000061035156,.8111000061035156,2.0102999210357666,.8111000061035156,0,2.9419000148773193,-0],normals:[-.9267006516456604,-.3758002817630768,-0,-.9267006516456604,-.3758002817630768,-0,-.9267006516456604,-.3758002817630768,-0,0,-.3758002817630768,.9267006516456604,0,-.3758002817630768,.9267006516456604,0,-.3758002817630768,.9267006516456604,.9267006516456604,-.3758002817630768,-0,.9267006516456604,-.3758002817630768,-0,.9267006516456604,-.3758002817630768,-0,0,-.3758002817630768,-.9267006516456604,0,-.3758002817630768,-.9267006516456604,0,-.3758002817630768,-.9267006516456604,0,.656676173210144,-.7541726231575012,0,.656676173210144,-.7541726231575012,0,.656676173210144,-.7541726231575012,.7541726231575012,.656676173210144,-0,.7541726231575012,.656676173210144,-0,.7541726231575012,.656676173210144,-0,-.7541726231575012,.656676173210144,-0,-.7541726231575012,.656676173210144,-0,-.7541726231575012,.656676173210144,-0,0,.656676173210144,.7541726231575012,0,.656676173210144,.7541726231575012,0,.656676173210144,.7541726231575012],indices:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]},bC=["cube","plane","pyramid"],wC={cube:{meshes:[{primitives:[{attributes:{POSITION:{array:new Int8Array([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1])},NORMAL:{array:new Int8Array([0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1])},TEXCOORD_0:{array:new Int8Array([0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1,1,1])}},indices:new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),mode:4}]}],scenes:[{nodes:[{mesh:0,scale:[60,60,60]}]}]},"plane-cube":{meshes:[{primitives:[{attributes:{POSITION:{array:new Int8Array(AC)},TEXCOORD_0:{array:new Int8Array(vC)}},indices:new Uint16Array(_C),mode:4}]}],scenes:[{nodes:[{mesh:0,scale:[60,60,60],translation:[0,-60,0]},{mesh:0,scale:[60,60,60],translation:[0,60,0]},{mesh:0,scale:[60,60,60],translation:[60,0,0],rotation:[0,0,.7071067811865475,.7071067811865476]},{mesh:0,scale:[60,60,60],translation:[-60,0,0],rotation:[0,0,.7071067811865475,.7071067811865476]},{mesh:0,scale:[60,60,60],translation:[0,0,60],rotation:[.7071067811865475,0,0,.7071067811865476]},{mesh:0,scale:[60,60,60],translation:[0,0,-60],rotation:[.7071067811865475,0,0,.7071067811865476]}]}]},plane:{meshes:[{primitives:[{attributes:{POSITION:{array:new Int8Array(AC)},NORMAL:{array:new Int8Array(yC)},TEXCOORD_0:{array:new Int8Array(vC)}},indices:new Uint16Array(_C),mode:4}]}],scenes:[{nodes:[{mesh:0,scale:[60,60,60]}]}]},pyramid:{meshes:[{primitives:[{attributes:{POSITION:{array:new Float32Array(xC.vertices)},NORMAL:{array:new Float32Array(xC.normals)},TEXCOORD_0:{array:new Float32Array(xC.uv)}},indices:new Uint16Array(xC.indices),mode:4}]}],scenes:[{nodes:[{mesh:0,scale:[60,60,60]}]}]}};const TC=function(){const i=[0,0,0],g=90*Math.PI/180,m=[0,0,0,0],_=new Array(16);return function(b,T,P,I,H,W){const q=[NA([],i,[1,0,0],W&&W[0]||[0,-1,0]),NA([],i,[-1,0,0],W&&W[1]||[0,-1,0]),NA([],i,[0,1,0],W&&W[2]||[0,0,1]),NA([],i,[0,-1,0],W&&W[3]||[0,0,-1]),NA([],i,[0,0,1],W&&W[4]||[0,-1,0]),NA([],i,[0,0,-1],W&&W[5]||[0,-1,0])],$={context:{viewMatrix:function(i,g,m){return q[m]},projMatrix:LA(_,g,1,.5,1.1)}};T&&($.framebuffer=T.faces?function(i,g,m){return T.faces[m]}:T);return b($)(6,((i,g,_)=>{const W={color:m,depth:1};T&&(W.framebuffer=T.faces?T.faces[_]:T),b.clear(W),P(I),H&&H()})),T}}();var SC={vertices:[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1],indices:[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]},MC="#define SHADER_NAME CUBE_MAP\nattribute vec3 aPosition;\nvarying vec3 vWorldPos;\nuniform mat4 projMatrix;\nuniform mat4 viewMatrix;\nvoid main() {\n  vWorldPos = aPosition;\n  gl_Position = projMatrix * viewMatrix * vec4(vWorldPos, 1.);\n}",CC="precision highp float;\n#define PI 3.1415926\nvarying vec3 vWorldPos;\nuniform sampler2D equirectangularMap;\nconst vec2 c = vec2(.1591, .3183);\nvec2 d(vec3 e) {\n  vec2 f = vec2(atan(e.y, e.x), asin(e.z));\n  f *= c;\n  f += .5;\n  return f;\n}\nvoid main() {\n  vec2 f = d(normalize(vWorldPos));\n  vec4 h = texture2D(equirectangularMap, f);\n  gl_FragColor = vec4(h.rgb, 1.);\n}",PC="#define SHADER_NAME PBR_prefilter\nprecision highp float;\nvarying vec3 vWorldPos;\nuniform samplerCube environmentMap;\nuniform sampler2D distributionMap;\nuniform float roughness;\nuniform float resolution;\nconst float c = 3.14159265359;\nfloat d(vec3 e, vec3 f, float h) {\n  float a = h * h;\n  float i = a * a;\n  float j = max(dot(e, f), .0);\n  float k = j * j;\n  float l = i;\n  float m = (k * (i - 1.) + 1.);\n  m = c * m * m;\n  return l / m;\n}\nvec3 n(float o, vec3 e, float h) {\n  vec4 u = texture2D(distributionMap, vec2(h, o));\n  vec3 f = u.xyz;\n  float v = sign(u.w - .5);\n  float A = sign(u.w - 200.0 / 255. * clamp(v, .0, 1.) - .15);\n  f.x *= v;\n  f.y *= A;\n  vec3 B = abs(e.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);\n  vec3 C = normalize(cross(B, e));\n  vec3 D = cross(e, C);\n  vec3 E = C * f.x + D * f.y + e * f.z;\n  return normalize(E);\n}\nvoid main() {\n  vec3 e = normalize(vWorldPos);\n  vec3 F = e;\n  vec3 G = F;\n  const int I = 1024;\n  vec3 J = vec3(.0);\n  float K = .0;\n  for(int L = 0; L < I; ++L) {\n    vec3 f = n(float(L) / float(I), e, roughness);\n    vec3 M = normalize(2. * dot(G, f) * f - G);\n    float O = max(dot(e, M), .0);\n    if(O > .0) {\n      J += textureCube(environmentMap, M).rgb * O;\n      K += O;\n    }\n  }\n  J = J / K;\n  gl_FragColor = vec4(J, 1.);\n}";
/*!
   * from claygl
   * https://github.com/pissang/claygl/
   * License: BSD-2-Clause
   */
function IC(i,g){const m=i[0],_=i[1],b=i[2];return 0===g?1:1===g?m:2===g?_:3===g?b:4===g?m*b:5===g?_*b:6===g?m*_:7===g?3*b*b-1:m*m-_*_}const kC={px:[2,1,0,-1,-1,1],nx:[2,1,0,1,-1,-1],py:[0,2,1,1,-1,-1],ny:[0,2,1,1,1,1],pz:[0,1,2,-1,-1,-1],nz:[0,1,2,1,-1,1]},OC=["px","nx","py","ny","pz","nz"];let EC;const RC=VS.compile(zM);function LC(i,g={},m){i=HC(i);const _=g.envTexture,b=g.envCubeSize||512,T=g.sampleSize||1024,P=g.roughnessLevels||256,I=g.prefilterCubeSize||256;let H,W=!1;if(Array.isArray(_)){const g=i.cube({flipY:!0,faces:_});H=function(i,g,m){const _=i({frag:RC,vert:MC,attributes:{aPosition:SC.vertices},uniforms:{hsv:[0,0,0],projMatrix:i.context("projMatrix"),viewMatrix:i.context("viewMatrix"),cubeMap:g,bias:0,size:g.width,environmentExposure:1,backgroundIntensity:1},elements:SC.indices}),b=i.cube({width:m,height:m,min:"linear",mag:"linear",format:"rgba"}),T=i.framebufferCube({radius:m,color:b});return TC(i,T,_,{size:m},null,[[0,0,-1],[0,0,-1],[0,0,1],[0,0,1],[0,-1,0],[0,-1,0]]),_.destroy(),T}(i,g,b),g.destroy()}else H=function(i,g,m){if(!UC(i))throw new Error("HDR is not supported for lack of support for float 16 texture");m=m||512;const _=i({frag:CC,vert:MC,attributes:{aPosition:SC.vertices},uniforms:{projMatrix:i.context("projMatrix"),viewMatrix:i.context("viewMatrix"),equirectangularMap:g},elements:SC.indices}),b=i.cube({width:m,height:m,min:"linear mipmap linear",mag:"linear",type:"float16",format:"rgba"}),T=i.framebufferCube({radius:m,color:b});return TC(i,T,_),_.destroy(),T}(i,_,b),W=!0;const{prefilterMap:q,prefilterMipmap:$}=function(i,g,m,_,b,T){const P=function(i,g,m,_,b,T){_=_||1024,b=b||256;const P=zC(_,b),I=i.texture({data:P,width:b,height:_,min:"nearest",mag:"nearest"}),H=i({frag:PC,vert:MC,attributes:{aPosition:SC.vertices},uniforms:{projMatrix:i.context("projMatrix"),viewMatrix:i.context("viewMatrix"),environmentMap:g,distributionMap:I,roughness:i.prop("roughness"),resolution:m},elements:SC.indices,viewport:{x:0,y:0,width:i.prop("size"),height:i.prop("size")}});let W=m;const q=i.texture({radius:m,min:"linear",mag:"linear",type:T?"float":"uint8"}),$=i.framebuffer({radius:m,color:q}),ye=Math.log(W)/Math.log(2),Re=[];for(let g=0;g<=ye;g++){let m=0;TC(i,$,H,{roughness:g/(ye-1),size:W},(function(){const g=i.read({framebuffer:$});let _=g;if(T){_=new Uint16Array(g.length);for(let i=0;i<g.length;i++)_[i]=Math.min(DS.toHalfFloat(g[i]),65504)}Re[m]||(Re[m]={mipmap:[]}),Re[m].mipmap.push(_),m++})),W/=2,$.resize(W)}return I.destroy(),$.destroy(),H.destroy(),Re}(i,g,m,_,b,T),I=i.cube({radius:m,min:"linear",mag:"linear",type:T?"float16":"uint8",faces:P,format:"rgba"});return{prefilterMap:I,prefilterMipmap:P}}(i,H,I,T,P,W);let ye;if(!g.ignoreSH){const _=I,b=i=>{const g=[];for(let m=0;m<i.length;m++)g.push(...i[m]);return g},T=DC(i,q,_,!1,g.environmentExposure,!0),{projectEnvironmentMapCPU:P}=g;if(P)return void P({cubePixels:T,width:_,height:_},(i=>{ye=b(i),m(Re())}));ye=function(i,g,m){const _=new Array(9),b=[],T=[],P=[];for(let I=0;I<9;I++){const H=[0,0,0];for(let _=0;_<OC.length;_++){const W=i[_],q=[0,0,0];let $=0,ye=0;const Re=kC[OC[_]];for(let i=0;i<m;i++)for(let _=0;_<g;_++){b[0]=_/(g-1)*2-1,b[1]=i/(m-1)*2-1,b[2]=-1,ny(b,b),P[0]=b[Re[0]]*Re[3],P[1]=b[Re[1]]*Re[4],P[2]=b[Re[2]]*Re[5],T[0]=W[ye++]/255,T[1]=W[ye++]/255,T[2]=W[ye++]/255;const H=W[ye++]/255*7;T[0]*=H,T[1]*=H,T[2]*=H,JA(q,q,T,IC(P,I)*-b[2]),$+=-b[2]}JA(H,H,q,1/$)}_[I]=QA(H,H,1/6)}return _}(T,_,_),ye=b(ye)}function Re(){const m={envMap:H,isHDR:W,prefilterMap:q};return ye&&(m.sh=ye),"array"===g.format&&(m.envMap={width:H.width,height:H.height,faces:DC(i,H,b,W)},m.prefilterMap={width:q.width,height:q.height,faces:$},H.destroy(),q.destroy()),m}if(!m)return Re();m(Re())}function DC(i,g,m,_,b=1,T=!1){const P=i({frag:(T?"#define ENCODE_RGBM\n":"")+"#define SHADER_NAME CUBEMAP\nprecision highp float;\nuniform samplerCube cubeMap;\nuniform float exposure;\nvarying vec3 vWorldPos;\n#ifdef ENCODE_RGBM\nvec4 c(const in vec3 d, const in float e) {\n  if(e <= .0)\n    return vec4(d, 1.);\n  vec4 f;\n  vec3 h = d / e;\n  f.a = clamp(max(max(h.r, h.g), max(h.b, 1e-6)), .0, 1.);\n  f.a = ceil(f.a * 255.) / 255.;\n  f.rgb = h / f.a;\n  return f;\n}\n#endif\nvoid main() {\n  vec4 i = textureCube(cubeMap, vWorldPos);\n  i.rgb *= exposure;\n#ifdef ENCODE_RGBM\ni = c(i.rgb, 7.);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = i;\n#endif\n}",vert:MC,attributes:{aPosition:SC.vertices},uniforms:{projMatrix:i.context("projMatrix"),viewMatrix:i.context("viewMatrix"),cubeMap:g,exposure:b},elements:SC.indices}),I=[],H=i.texture({radius:m,min:"linear",mag:"linear",type:_?"float":"uint8",format:"rgba"}),W=i.framebuffer({radius:m,color:H});return TC(i,W,P,{size:m},(function(){const g=i.read();if(_){const i=new Uint16Array(g.length);for(let m=0;m<g.length;m++)i[m]=Math.min(DS.toHalfFloat(g[m]),65504);I.push(i)}else I.push(g)})),P.destroy(),W.destroy(),I}const FC=new Int8Array([-1,1,0,-1,-1,0,1,1,0,1,-1,0]),NC=new Int8Array([0,1,0,0,1,1,1,0]);function HC(i){return i.vao&&i||function(){if(!EC){const i=document.createElement("canvas").getContext("webgl");EC=Wm({optionalExtensions:["OES_texture_half_float","OES_texture_half_float_linear","OES_texture_float","OES_texture_float_linear"],attributes:{alpha:!0,depth:!0,stencil:!0,preserveDrawingBuffer:!0},gl:i}),EC.on("lost",(()=>{EC.destroy(),EC=null}))}return EC}()}function BC(i,g,m,_){const b=HC(i);g=g||256;const T=zC(m=m||1024,_=_||256),P=b.texture({data:T,width:_,height:m,min:"nearest",mag:"nearest"}),I=b.buffer({data:FC,name:"aPosition"}),H=b.buffer({data:NC,name:"aTexCoord"}),W=b.framebuffer({radius:g,colorType:"uint8",colorFormat:"rgba",min:"linear",mag:"linear"}),q=b({frag:"precision highp float;\nvarying vec2 vTexCoords;\nuniform sampler2D distributionMap;\nconst float c = 3.14159265359;\nvec4 d(float a, float b) {\n  a *= 65535.;\n  b *= 65535.;\n  vec4 rgba;\n  rgba[0] = mod(a, 255.);\n  rgba[1] = (a - rgba[0]) / 65280.0;\n  rgba[2] = mod(b, 255.);\n  rgba[3] = (b - rgba[2]) / 65280.0;\n  return rgba;\n}\nvec3 e(float f, vec3 h, float i) {\n  vec4 j = texture2D(distributionMap, vec2(i, f));\n  vec3 k = j.xyz;\n  float l = sign(j.w - .5);\n  float m = sign(j.w - clamp(l, .0, 1.) * 200.0 / 255. - .15);\n  k.x *= l;\n  k.y *= m;\n  vec3 n = abs(h.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);\n  vec3 o = normalize(cross(n, h));\n  vec3 u = cross(h, o);\n  vec3 v = o * k.x + u * k.y + h * k.z;\n  return normalize(v);\n}\nfloat A(float B, float i) {\n  float a = i;\n  float C = (a * a) / 2.;\n  float D = B;\n  float E = B * (1. - C) + C;\n  return D / E;\n}\nfloat F(float B, float G, float i) {\n  float I = A(B, i);\n  float J = A(G, i);\n  return J * I;\n}\nvec2 K(float B, float i) {\n  vec3 L;\n  L.x = sqrt(1. - B * B);\n  L.y = .0;\n  L.z = B;\n  float M = .0;\n  float O = .0;\n  vec3 h = vec3(.0, .0, 1.);\n  const int P = 1024;\n  for(int Q = 0; Q < P; ++Q) {\n    vec3 k = e(float(Q) / float(P), h, i);\n    vec3 R = normalize(2. * dot(L, k) * k - L);\n    float G = max(R.z, .0);\n    float S = max(k.z, .0);\n    float T = max(dot(L, k), .0);\n    float B = max(dot(h, L), .0);\n    if(G > .0) {\n      float U = F(B, G, i);\n      float W = (U * T) / (S * B);\n      float X = pow(1. - T, 5.);\n      M += (1. - X) * W;\n      O += X * W;\n    }\n  }\n  M /= float(P);\n  O /= float(P);\n  return vec2(M, O);\n}\nvoid main() {\n  vec2 Y = K(vTexCoords.x, vTexCoords.y);\n  gl_FragColor = d(Y.x, Y.y);\n}",vert:"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoords;\nvoid main() {\n  vTexCoords = aTexCoord;\n  gl_Position = vec4(aPosition, 1.);\n}",attributes:{aPosition:{buffer:I},aTexCoord:{buffer:H}},uniforms:{distributionMap:P},framebuffer:W,viewport:{x:0,y:0,width:g,height:g},count:FC.length/3,primitive:"triangle strip"});if(q(),i.wgpu){const g=b.read({framebuffer:W});return new GraphicsTexture(i,{data:g,width:W.width,height:W.height})}return q.destroy(),I.destroy(),H.destroy(),P.destroy(),W}function zC(i,g){const m=new Float32Array(i*g*4);for(let _=0;_<i;_++){const{x:b,y:T}=VC(_,i);for(let i=0;i<g;i++){const P=i/g,I=P*P,H=2*Math.PI*b,W=Math.sqrt((1-T)/(1+(I*I-1)*T)),q=Math.sqrt(1-W*W),$=4*(_*g+i),ye=q*Math.cos(H),Re=q*Math.sin(H);m[$]=Math.abs(255*ye),m[$+1]=Math.abs(255*Re),m[$+2]=255*W,m[$+3]=(ye>0?200:0)+(Re>0?55:0)}}return m}function VC(i,g){let m=(i<<16|i>>>16)>>>0;return m=((1431655765&m)<<1|(2863311530&m)>>>1)>>>0,m=((858993459&m)<<2|(3435973836&m)>>>2)>>>0,m=((252645135&m)<<4|(4042322160&m)>>>4)>>>0,m=(((16711935&m)<<8|(4278255360&m)>>>8)>>>0)/4294967296,{x:i/g,y:m}}function UC(i){return i._gl instanceof WebGL2RenderingContext||i.hasExtension("OES_texture_half_float")}var GC=Object.freeze({__proto__:null,createIBLMaps:function(i,g={}){return LC(i,g)},createIBLMapsAsync:function(i,g={}){return new Promise((m=>{LC(i,g,(i=>{i.updateTime=g.updateTime,m(i)}))}))},generateDFGLUT:BC,supportFloat16:UC});const jC={uvScale:[1,1],uvOffset:[0,0],uvRotation:0,textureOrigin:null,textureWidth:null,baseColorFactor:[1,1,1,1],emissiveFactor:[0,0,0],baseColorIntensity:1,emitColorFactor:1,occlusionFactor:1,roughnessFactor:.4,metallicFactor:0,normalMapFactor:1,specularF0:.5,emitMultiplicative:1,normalMapFlipY:0,outputSRGB:1,baseColorTexture:null,normalTexture:null,occlusionTexture:null,metallicRoughnessTexture:null,emissiveTexture:null,uvOrigin:[0,0],noiseTexture:null,specularAAVariance:20,specularAAThreshold:20,hsv:[0,0,0],contrast:1,bumpTexture:null,bumpScale:.05,bumpMinLayers:5,bumpMaxLayers:20,alphaTest:0};class StandardMaterial extends Material{constructor(i){const g=cx({},jC);(i.metallicRoughnessTexture||i.metallicRoughnessTexture)&&(g.roughnessFactor=1,g.metallicFactor=1),super(i,g)}appendDefines(i,g){super.appendDefines(i,g);const m=this.uniforms,_=g.data[g.desc.positionAttribute];_.buffer&&_.buffer.itemType&&_.buffer.itemType.startsWith("sint")&&(i.POSITION_IS_INT=1);const b=g.data[g.desc.normalAttribute];b&&b.buffer&&b.buffer.itemType&&b.buffer.itemType.startsWith("sint")&&(i.NORMAL_IS_INT=1),m.GAMMA_CORRECT_INPUT&&(i.GAMMA_CORRECT_INPUT=1),g.data[g.desc.colorAttribute]&&(i.HAS_COLOR=1);if(g.data[g.desc.color0Attribute]&&(i.HAS_COLOR0=1,i.COLOR0_SIZE=g.getColor0Size()),g.data[g.desc.tangentAttribute]?i.HAS_TANGENT=1:g.data[g.desc.normalAttribute]&&(i.HAS_NORMAL=1),g.data.aVertexColorType&&(i.HAS_VERTEX_COLOR=1),!g.data[g.desc.uv0Attribute])return i;m.baseColorTexture&&(i.HAS_ALBEDO_MAP=1),m.metallicRoughnessTexture&&(i.HAS_METALLICROUGHNESS_MAP=1),m.occlusionTexture&&g.data[g.desc.uv1Attribute]&&(i.HAS_AO_MAP=1),m.emissiveTexture&&(i.HAS_EMISSIVE_MAP=1),m.normalTexture&&(i.HAS_NORMAL_MAP=1),m.bumpTexture&&(i.HAS_BUMP_MAP=1),m.skinTexture&&(i.HAS_SKIN_MAP=1),(i.HAS_ALBEDO_MAP||i.HAS_METALLICROUGHNESS_MAP||i.HAS_AO_MAP||i.HAS_EMISSIVE_MAP||i.HAS_NORMAL_MAP||i.HAS_BUMP_MAP||i.HAS_SKIN_MAP)&&(i.HAS_MAP=1),m.noiseTexture&&(i.HAS_RANDOM_TEX=1),g.data[g.desc.tangentAttribute]?i.HAS_TANGENT=1:g.data[g.desc.normalAttribute]&&(i.HAS_NORMAL=1);const T=m.alphaMode&&m.alphaMode.toUpperCase();return"MASK"===T?i.ALPHA_MODE=1:"OPAQUE"===T&&(i.ALPHA_MODE=2),i}}class StandardSpecularGlossinessMaterial extends(hw(StandardMaterial)){}function WC(i,g,m){if(m.ambientUpdate){const{iblTexes:_}=i,b=m.target;_?(ZC(_),i.iblTexes=XC(g,b)):i.iblTexes=XC(g,b),b.getRenderer().setToRedraw()}}const qC=[0,0];function XC(i,g){const m=g.getLightManager(),_=m&&m.getAmbientResource();if(!_)return null;const b=_.isHDR;return{prefilterMap:i.cube({width:_.prefilterMap.width,height:_.prefilterMap.height,faces:_.prefilterMap.faces,min:"linear",mag:"linear",format:"rgba",type:b?"float16":"uint8"}),envMap:i.cube({width:_.envMap.width,height:_.envMap.height,faces:_.envMap.faces,min:"linear",mag:"linear",format:"rgba",type:b?"float16":"uint8"}),sh:_.sh}}function ZC(i){for(const g in i)i[g]&&i[g].destroy&&i[g].destroy(),delete i[g]}var $C=Object.freeze({__proto__:null,createIBLTextures:XC,disposeIBLTextures:ZC,getIBLResOnCanvas:function(i){const{dfgLUT:g,iblTexes:m}=i;return{dfgLUT:g,iblTexes:m}},getPBRUniforms:function(i,g,m,_,b){const T=i.viewMatrix,P=i.projMatrix,I=i.cameraPosition,H=i.getRenderer().canvas,W=function(i,g){const m=i.getLightManager(),_=m&&m.getAmbientResource(),b=m&&m.getAmbientLight()||{},T=m&&m.getDirectionalLight()||{};let P;if(_){const i=g.prefilterMap.width,m=Math.log(i)/Math.log(2);P={prefilterMap:g.prefilterMap,diffuseSPH:g.sh,prefilterMiplevel:[m,m],prefilterSize:[i,i],hdrHSV:b.hsv||[0,0,0]}}else P={ambientColor:b.color||[.2,.2,.2]};return P.environmentExposure=fx(b.exposure)?b.exposure:1,P.environmentOrientation=b.orientation||0,P.light0_diffuse=[...T.color||[1,1,1],1],P.light0_viewDirection=T.direction||[1,1,-1],P}(i,g),q=cx({viewMatrix:T,projMatrix:P,projViewMatrix:i.projViewMatrix,cameraPosition:I,outSize:[H.width,H.height],cameraNearFar:[i.cameraNear,i.cameraFar]},W);return q.brdfLUT=m,_&&_.renderUniforms&&cx(q,_.renderUniforms),q.halton=b||qC,q},isSupported:function(i){return!!i.wgpu||i.hasExtension("EXT_shader_texture_lod")},loginIBLResOnCanvas:function(i,g,m){if(!i.dfgLUT&&(i.dfgLUT=BC(g),i.dfgLUT.mtkRefCount=0,m)){const _=(...m)=>WC.call(this,i,g,...m);m.on("updatelights",_),i._iblResListener=_}i.dfgLUT.mtkRefCount++;const _=m.getLightManager();return _&&_.getAmbientResource()?(i.iblTexes||(i.iblTexes=XC(g,m)),{dfgLUT:i.dfgLUT,iblTexes:i.iblTexes}):{dfgLUT:i.dfgLUT,iblTexes:null}},logoutIBLResOnCanvas:function(i,g){let m=!1;if(i.dfgLUT&&(i.dfgLUT.mtkRefCount--,i.dfgLUT.mtkRefCount<=0)){if(m=!0,g){g.off("updatelights",i._iblResListener)}i.dfgLUT.destroy(),delete i.dfgLUT}i.iblTexes&&m&&(ZC(i.iblTexes),delete i.iblTexes)}});class ShadowMapShader extends MeshShader{constructor(i){super({vert:"attribute vec3 aPosition;\nuniform mat4 lightProjViewModelMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\n#include <line_extrusion_vert>\n#include <get_output>\nvarying vec4 vPosition;\nvoid main() {\n  mat4 c = getPositionMatrix();\n#ifdef IS_LINE_EXTRUSION\nvec3 d = getLineExtrudePosition(aPosition);\n  vec4 e = getPosition(d);\n#else\nvec4 e = getPosition(aPosition);\n#endif\ngl_Position = lightProjViewModelMatrix * c * e;\n  vPosition = gl_Position;\n}",frag:"#define SHADER_NAME vsm_mapping\nprecision highp float;\nvarying vec4 vPosition;\n#ifdef PACK_FLOAT\n#include <common_pack_float>\n#endif\nvoid main() {\n  \n#if defined(USE_ESM)\n#ifdef PACK_FLOAT\ngl_FragColor = common_encodeDepth(gl_FragCoord.z);\n#else\ngl_FragColor = vec4(gl_FragCoord.z, .0, .0, 1.);\n#endif\n#endif\n}",uniforms:[{name:"lightProjViewModelMatrix",type:"function",fn:function(i,g){return _A([],g.lightProjViewMatrix,g.modelMatrix)}}],extraCommandProps:{},defines:i})}filter(i){return i.castShadow}}class BoxShadowBlurShader extends QuadShader{constructor({blurOffset:i}){super({vert:OM,frag:"precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D textureSource;\nuniform vec2 resolution;\n#include <common_pack_float>\nvoid main() {\n  float c = .0;\n  float d = .0;\n  for(int x = -BOXBLUR_OFFSET; x <= BOXBLUR_OFFSET; ++x)\n    for(int y = -BOXBLUR_OFFSET; y <= BOXBLUR_OFFSET; ++y) {\n      vec2 e = vTexCoord.st + vec2(float(x) / resolution.x, float(y) / resolution.y);\n      e = clamp(e, .0, 1.);\n      float f = common_decodeDepth(texture2D(textureSource, e));\n      float s = max(.0, sign(1. - f));\n      d += sign(f) * s;\n      c += f;\n    }\n  float h = c / max(1., d);\n  gl_FragColor = common_encodeDepth(h);\n}",defines:{BOXBLUR_OFFSET:i||2}}),this._blurOffset=i||2}getMeshCommand(i,g){const m="box_shadow_blur_"+this._blurOffset;return this.commands[m]||(this.commands[m]=this.createMeshCommand(i,g)),this.commands[m]}}let YC=null,QC=null;class ShadowPass{constructor(i,{width:g,height:m,blurOffset:_,defines:b}){this.renderer=i,this.width=g||512,this.height=m||512,this.blurOffset=ax(_)?2:_,this._init(b)}render(i,{cameraProjViewMatrix:g,lightDir:m,farPlane:_,cameraLookAt:b}){return{lightProjViewMatrix:this._renderShadow(i,g,m,_,b),shadowMap:this.blurTex||this.depthTex,depthFBO:this.depthFBO,blurFBO:this.blurFBO}}resize(i,g){return this.depthTex&&(this.depthTex.resize(i,g),this.depthFBO.resize(i,g)),this.width=i,this.blurFBO&&(this.blurTex.resize(i,g),this.blurFBO.resize(i,g)),this.height=g,this}_renderShadow(i,g,m,_,b){const T=this.renderer,P=YC(g);if(_)for(let i=4;i<8;i++)P[i]=_[i-4];const I=QC(b,P,m);return T.clear({color:[1,0,0,1],depth:1,framebuffer:this.depthFBO}),T.render(this.shadowMapShader,{lightProjViewMatrix:I},i,this.depthFBO),this.blurFBO&&(this.boxBlurShader||(this.boxBlurShader=new BoxShadowBlurShader({blurOffset:this.blurOffset})),T.clear({color:[1,0,0,1],depth:1,framebuffer:this.blurFBO}),T.render(this.boxBlurShader,{resolution:[this.depthTex.width,this.depthTex.height],textureSource:this.depthTex},null,this.blurFBO)),I}_init(i){const g=this.renderer.device,m="uint8",_=this.width,b=this.height;this.depthTex=g.texture({width:_,height:b,format:"rgba",type:m,min:"nearest",mag:"nearest"}),this.shadowMapShader=new ShadowMapShader(i),this.shadowMapShader.filter=i=>i.castShadow,this.depthFBO=g.framebuffer({color:this.depthTex}),this.blurOffset<=0||(this.blurTex=g.texture({width:_,height:b,format:"rgba",type:m,min:"linear",mag:"linear"}),this.blurFBO=g.framebuffer({color:this.blurTex}))}dispose(){this.depthTex&&(this.depthTex.destroy(),this.depthFBO.destroy(),delete this.depthTex,delete this.depthFBO),this.blurTex&&(this.blurTex.destroy(),this.blurFBO.destroy(),delete this.blurTex,delete this.blurFBO),this.shadowMapShader&&(this.shadowMapShader.dispose(),delete this.shadowMapShader),this.boxBlurShader&&(this.boxBlurShader.dispose(),delete this.boxBlurShader)}}YC=function(){const i=[[-1,-1,-1,1],[1,-1,-1,1],[1,1,-1,1],[-1,1,-1,1],[-1,-1,1,1],[1,-1,1,1],[1,1,1,1],[-1,1,1,1]],g=new Array(16);return function(m){yA(g,m);const _=[];for(let m=0;m<i.length;m++){const b=Fy([],i[m],g);Py(b,b,1/b[3]),_.push(b)}return _}}(),QC=function(){let i=new Array(4);const g=new Array(3),m=[0,0,0,0],_=[0,1,0],b=new Array(3);let T=new Array(16),P=new Array(16);const I=new Array(16),H=[1,1,1],W=[0,0,0];return function(q,$,ye){wy(m,...q,1),QA(g,ye,-1),T=NA(T,XA(b,m,ny(b,g)),m,_),Fy(i,$[0],T);let Re=i[2],Be=i[2],Ge=i[0],je=i[0],Xe=i[1],Ze=i[1];for(let g=1;g<8;g++)i=Fy(i,$[g],T),i[2]>Be&&(Be=i[2]),i[2]<Re&&(Re=i[2]),i[0]>je&&(je=i[0]),i[0]<Ge&&(Ge=i[0]),i[1]>Ze&&(Ze=i[1]),i[1]<Xe&&(Xe=i[1]);P=FA(P,-1,1,-1,1,-Be,-Re);const Ye=H[0]=2/(je-Ge),Qe=H[1]=-2/(Ze-Xe);W[0]=-.5*(Ge+je)*Ye,W[1]=-.5*(Xe+Ze)*Qe,mA(I),vA(I,I,W),xA(I,I,H);const Je=_A(P,I,P);return _A(new Array(16),Je,T)}}();class ShadowDisplayShader extends MeshShader{constructor(i){super({vert:"#define SHADER_NAME SHADOW_DISPLAY\nattribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 halton;\nuniform vec2 globalTexSize;\nvarying vec4 vPosition;\n#include <vsm_shadow_vert>\nvoid main() {\n  vec4 c = vec4(aPosition, 1.);\n  vec4 d = modelViewMatrix * c;\n  mat4 e = projMatrix;\n  e[2].xy += halton.xy / globalTexSize.xy;\n  gl_Position = e * d;\n  vPosition = gl_Position;\n  shadow_computeShadowPars(c);\n}",frag:"#define SHADER_NAME SHADOW_DISPLAY\nprecision mediump float;\nuniform vec3 color;\n#include <vsm_shadow_frag>\nvoid main() {\n  float c = shadow_computeShadow();\n  float d = 1. - c;\n  gl_FragColor = vec4(color * d, d);\n}",uniforms:[{name:"modelViewMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.viewMatrix,g.modelMatrix),m}}],defines:i||{USE_ESM:1},extraCommandProps:{depth:{enable:!0,mask:!1},viewport:{x:0,y:0,width:(i,g)=>g.globalTexSize[0],height:(i,g)=>g.globalTexSize[1]}}})}getMeshCommand(i,g){return this.commands.shadow_display||(this.commands.shadow_display=this.createMeshCommand(i,g)),this.commands.shadow_display}}function JC(i){return 256*i[2]*256+256*i[1]+i[0]}const KC=new Uint8Array(4),eP=new Float32Array(KC.buffer);let tP,nP;const rP=[1,1],iP="\n    vec3 unpack(highp float f) {\n        highp vec3 color;\n        color.b = floor(f / 65536.0);\n        color.g = floor((f - color.b * 65536.0) / 256.0);\n        color.r = f - floor(color.b * 65536.0) - floor(color.g * 256.0);\n        // now we have a vec3 with the 3 components in range [0..255]. Let's normalize it!\n        return color / 255.0;\n    }\n",oP="\nfn unpack(f: f32) -> vec3f {\n    var color: vec3f;\n    color.b = floor(f / 65536.0);\n    color.g = floor((f - color.b * 65536.0) / 256.0);\n    color.r = f - floor(color.b * 65536.0) - floor(color.g * 256.0);\n    return color / 255.0;\n}\n",sP=`\n    precision highp float;\n\n    varying float vPickingId;\n    varying float vFbo_picking_visible;\n\n    uniform float fbo_picking_meshId;\n\n    ${iP}\n\n    void main() {\n        if (vFbo_picking_visible == 0.0) {\n            discard;\n            return;\n        }\n        gl_FragColor = vec4(unpack(vPickingId), fbo_picking_meshId / 255.0);\n    }\n`,aP=`\n    ${oP}  // Assuming unpack function is defined in this include\n\n    struct PickingUniforms {\n        fbo_picking_meshId: f32,\n    };\n\n    @group(0) @binding($b) var<uniform> pickingUniforms: PickingUniforms;\n\n    struct VertexOutput {\n        @location($i) vPickingId: f32,\n        @location($i) vFbo_picking_visible: f32,\n    };\n\n    @fragment\n    fn main(vertexOutput: VertexOutput) -> @location(0) vec4f {\n        if (vertexOutput.vFbo_picking_visible == 0.0) {\n            discard;\n        }\n\n        let rgb = unpack(vertexOutput.vPickingId);\n        let alpha = pickingUniforms.fbo_picking_meshId / 255.0;\n        return vec4f(rgb, alpha);\n        // return vec4f(1.0, 0.0, 0.0, 1.0);\n    }\n`,lP=`\n    precision highp float;\n\n    uniform int fbo_picking_meshId;\n    varying float vFbo_picking_visible;\n\n    ${iP}\n\n    void main() {\n        if (vFbo_picking_visible == 0.0) {\n            discard;\n            return;\n        }\n        gl_FragColor = vec4(unpack(float(fbo_picking_meshId)), 1.0);\n        // gl_FragColor = vec4(unpack(float(35)), 1.0);\n    }\n`,hP=`\n    ${oP}\n\n    struct PickingUniforms {\n        fbo_picking_meshId: f32,\n    };\n\n    @group(0) @binding(0) var<uniform> pickingUniforms: PickingUniforms;\n\n    struct VertexOutput {\n        @location($i) vFbo_picking_visible: f32,\n    };\n\n    @fragment\n    fn main(vertexOutput: VertexOutput) -> @location(0) vec4f {\n        if (vertexOutput.vFbo_picking_visible == 0.0) {\n            discard;\n        }\n\n        let meshIdFloat = pickingUniforms.fbo_picking_meshId;\n        let rgb = unpack(meshIdFloat);\n\n        return vec4f(rgb, 1.0);\n    }\n`,cP=`\n    precision highp float;\n\n    varying float vPickingId;\n    varying float vFbo_picking_visible;\n\n    ${iP}\n\n    void main() {\n        if (vFbo_picking_visible == 0.0) {\n            discard;\n            return;\n        }\n        gl_FragColor = vec4(unpack(vPickingId), 1.0);\n    }\n`,uP=`\n    ${oP}\n\n    struct VertexOutput {\n        @location($i) vPickingId: f32,\n        @location($i) vFbo_picking_visible: f32,\n    };\n\n    @fragment\n    fn main(vertexOutput: VertexOutput) -> @location(0) vec4f {\n        if (vertexOutput.vFbo_picking_visible == 0.0) {\n            discard;\n        }\n        let rgb = unpack(vertexOutput.vPickingId);\n        return vec4f(rgb, 1.0);\n    }\n`;function fP(i,g,m){const _=g[0],b=g[1],T=g[2],P=1/(m[3]*_+m[7]*b+m[11]*T+m[15]);return i[0]=(m[0]*_+m[4]*b+m[8]*T+m[12])*P,i[1]=(m[1]*_+m[5]*b+m[9]*T+m[13])*P,i[2]=(m[2]*_+m[6]*b+m[10]*T+m[14])*P,i}function dP(i){return fx(i)&&(rP[0]=rP[1]=i,i=rP),i}const pP=i=>i&&i.geometry&&void 0===i.geometry.properties.shaderHash,gP=[],mP=[],AP=[{name:"modelViewMatrix",type:"function",fn:(i,g)=>_A(gP,g.viewMatrix,g.modelMatrix)},{name:"modelViewProjMatrix",type:"function",fn:(i,g)=>{const m=_A(gP,g.viewMatrix,g.modelMatrix);return _A(gP,g.projMatrix,m)}},{name:"modelMatrixInverse",type:"function",fn:(i,g)=>yA(gP,g.modelMatrix)},{name:"projMatrixInverse",type:"function",fn:(i,g)=>yA(gP,g.projMatrix)},{name:"modelViewMatrixInverse",type:"function",fn:(i,g)=>(_A(gP,g.viewMatrix,g.modelMatrix),yA(gP,gP))},{name:"modelViewProjMatrixInverse",type:"function",fn:(i,g)=>{const m=_A(gP,g.viewMatrix,g.modelMatrix);return _A(gP,g.projMatrix,m),yA(gP,gP)}},{name:"modelInverseTransposeMatrix",type:"function",fn:(i,g)=>{const m=sA(mP,g.modelMatrix),_=lA(m,m);return hA(_,_)}},{name:"modelViewInverseTransposeMatrix",type:"function",fn:(i,g)=>{const m=_A(gP,g.viewMatrix,g.modelMatrix),_=sA(mP,m),b=lA(_,_);return hA(b,b)}}],yP={LOCAL:"positionMatrix",MODEL:"modelMatrix",VIEW:"viewMatrix",PROJECTION:"projMatrix",MODELVIEW:"modelViewMatrix",MODELVIEWPROJECTION:"modelViewProjMatrix",MODELINVERSE:"modelMatrixInverse",VIEWINVERSE:"viewMatrixInverse",PROJECTIONINVERSE:"projMatrixInverse",MODELVIEWINVERSE:"modelViewMatrixInverse",MODELVIEWPROJECTIONINVERSE:"modelViewProjMatrixInverse",MODELINVERSETRANSPOSE:"modelInverseTransposeMatrix",MODELVIEWINVERSETRANSPOSE:"modelViewInverseTransposeMatrix",VIEWPORT:"viewport",JOINTMATRIX:"jointMatrix",ALPHACUTOFF:"alphaCutoff"};class DynamicBufferPool{constructor(i,g,m){this.activeBuffer=null,this.device=i,this.usedBuffers=[],this.poolBuffers=[],this.bufferSize=g,this.bufferAlignment=m}destroy(){this.poolBuffers.forEach((i=>{i.gpuBuffer.destroy()})),this.poolBuffers.length=0,this.usedBuffers.length=0,this.activeBuffer=null}alloc(i,g){if(this.activeBuffer){const i=yb(this.activeBuffer.size,this.bufferAlignment);this.bufferSize-i<g&&this.scheduleSubmit()}this.activeBuffer||(this.activeBuffer=this.poolBuffers.pop(),this.activeBuffer||(this.activeBuffer={gpuBuffer:this.createBuffer(this.device,this.bufferSize),storage:new ArrayBuffer(this.bufferSize),offset:0,size:0}),this.activeBuffer.offset=0,this.activeBuffer.size=0);const m=this.activeBuffer,_=yb(m.size,this.bufferAlignment);i.gpuBuffer=m.gpuBuffer,i.offset=_,i.storage=m.storage,m.size=_+g}createBuffer(i,g){return i.createBuffer({size:g,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}scheduleSubmit(){this.activeBuffer&&(this.usedBuffers.push(this.activeBuffer),this.activeBuffer=null)}submit(){this.scheduleSubmit();const i=this.usedBuffers.length;if(i){const g=this.device,m=this.poolBuffers;for(let _=i-1;_>=0;_--){const i=this.usedBuffers[_],{storage:b,gpuBuffer:T,offset:P,size:I}=i;g.queue.writeBuffer(T,0,b,P,I),m.push(i)}this.usedBuffers.length=0}}}let _P=0;class GraphicsDevice{constructor(i,g,m){this.commandBuffers=[],this._readTargets={},this.wgpu=i,this.adapter=m;const _=navigator.gpu.getPreferredCanvasFormat();g.configure({device:i,format:_,alphaMode:"premultiplied"}),this.context=g;this.dynamicBufferPool=new DynamicBufferPool(i,1048576,i.limits.minUniformBufferOffsetAlignment)}hasExtension(i){return this._supportedFormats||(this._supportedFormats=Mx(this.wgpu)),!0}getCommandEncoder(){let i=this.commandEncoder;return i||(i=this.wgpu.createCommandEncoder(),this.commandEncoder=i),i}endCommandEncoder(){const{commandEncoder:i}=this;if(i){const g=i.finish();this.addCommandBuffer(g,!1),this.commandEncoder=null}}getDefaultFramebuffer(){let i=this._defaultFramebuffer;if(!i){const g=this.context.canvas;i=this._defaultFramebuffer=new GraphicsFramebuffer(this,{width:g.width,height:g.height,depthStencil:!0}),i.uid=_P++}return i}getRenderPassEncoder(i){const g=(i=i||this.getDefaultFramebuffer()).getRenderPassDescriptor();return this.getCommandEncoder().beginRenderPass(g)}addCommandBuffer(i,g){g?this.commandBuffers.unshift(i):this.commandBuffers.push(i)}submit(){this.endCommandEncoder(),this.dynamicBufferPool.submit(),this.commandBuffers.length>0&&(this.wgpu.queue.submit(this.commandBuffers),this.commandBuffers.length=0)}buffer(i){return Geometry.createBuffer(this,i,i.name)}framebuffer(i,g){let m;return fx(i)?(void 0===g&&(g=i),m={color:!0,depthStencil:!0,width:i,height:g}):m=i,new GraphicsFramebuffer(this,m)}texture(i){return fx(i)&&(i={width:i,height:i}),new GraphicsTexture(this,i)}clear(i){(i.framebuffer||this.getDefaultFramebuffer()).setClearOptions(i)}read(i){const g=i.framebuffer||this._defaultFramebuffer,m=g.width,_=g.height;let{width:b,height:T}=i;b||(b=m),T||(T=_);const P=this.wgpu;this.submit();const I={x:i.x,y:_-i.y,z:0};I.x+b>m&&(I.x=m-b),I.y+T>_&&(I.y=_-T);const H=i.pixels||new Uint8Array(b*T*4);if(g===this._defaultFramebuffer){const i=new OffscreenCanvas(b,T).getContext("2d",{willReadFrequently:!0});i.drawImage(this.context.canvas,I.x,I.y,b,T,0,0,b,T);const g=i.getImageData(0,0,b,T).data;for(let i=0;i<H.length;i+=4)H[i]=g[i],H[i+1]=g[i+1],H[i+2]=g[i+2],H[i+3]=g[i+3];return H}const W=["opaque","premultiplied"],q=W.map((()=>new OffscreenCanvas(b,T)));return q.map(((i,g)=>{const m=i.getContext("webgpu");return m.configure({device:P,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:W[g]}),m.getCurrentTexture()})).map(((i,m)=>{const _=P.createCommandEncoder();_.copyTextureToTexture({texture:g.colorTexture.texture,origin:I},{texture:i},{width:b,height:T}),this.wgpu.queue.submit([_.finish()]);const $=new OffscreenCanvas(b,T).getContext("2d",{willReadFrequently:!0});$.drawImage(q[m],0,0);const ye=$.getImageData(0,0,b,T).data,Re=W[m];for(let i=0;i<H.length;i+=4)"premultiplied"===Re?H[i+3]=ye[i+3]:(H[i]=ye[i],H[i+1]=ye[i+1],H[i+2]=ye[i+2])})),H}destroy(){this._defaultFramebuffer&&(this._defaultFramebuffer.destroy(),delete this._defaultFramebuffer);for(const i in this._readTargets){const g=this._readTargets[i];g&&g.destroy()}this._readTargets={}}}const vP={parseHDR:ES},xP={PBRHelper:GC,StandardMaterial,StandardSpecularGlossinessMaterial,StandardShader:class StandardShader extends MeshShader{constructor(i={}){let g=i.extraCommandProps||{};const m=i.uniforms;g=cx({},g);const _=i.defines||{},b=[],T=[],P=[],I=[],H=[],W=[{name:"modelNormalMatrix",type:"function",fn:(i,g)=>sA(b,g.modelMatrix)},{name:"modelViewNormalMatrix",type:"function",fn:(i,g)=>{const m=_A(T,g.viewMatrix,g.modelMatrix),_=yA(m,m),b=AA(_,_);return sA(P,b)}},{name:"modelViewMatrix",type:"function",fn:(i,g)=>_A(I,g.viewMatrix,g.modelMatrix)},{name:"environmentTransform",type:"function",global:!0,fn:(i,g)=>uA(H,Math.PI*(g.environmentOrientation||0)/180)}];m&&W.push(...m);super({name:"standard",vert:i.vert||"#include <gl2_vert>\n#define SHADER_NAME PBR\nattribute vec3 aPosition;\n#if defined(HAS_MAP) || defined(HAS_TERRAIN_FLAT_MASK)\nattribute vec2 aTexCoord;\n#include <common_pack_float>\n#endif\n#if defined(HAS_MAP)\nuniform vec2 uvOrigin;\nuniform vec2 uvScale;\nuniform vec2 uvOffset;\nuniform float uvRotation;\n#ifdef HAS_I3S_UVREGION\nattribute vec4 uvRegion;\nvarying vec4 vUvRegion;\n#endif\n#if defined(HAS_AO_MAP)\nattribute vec2 aTexCoord1;\nvarying vec2 vTexCoord1;\n#endif\n#endif\nvec3 c;\nvec3 d;\nvec4 e;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 projMatrix;\nuniform mediump vec3 cameraPosition;\nuniform mat3 modelNormalMatrix;\n#ifdef HAS_SSR\nuniform mat3 modelViewNormalMatrix;\nvarying vec3 vViewNormal;\n#ifdef HAS_TANGENT\nvarying vec4 vViewTangent;\n#endif\n#endif\nvarying vec3 vModelNormal;\nvarying vec4 vViewVertex;\n#if defined(HAS_TANGENT)\nvarying vec4 vModelTangent;\nvarying vec3 vModelBiTangent;\n#endif\nvarying vec3 vModelVertex;\n#if defined(HAS_MAP)\nvarying vec2 vTexCoord;\n#endif\n#if defined(HAS_COLOR)\nattribute vec4 aColor;\nvarying vec4 vColor;\n#endif\n#ifdef HAS_OPACITY\nattribute float aOpacity;\n#endif\nvarying float vOpacity;\n#include <highlight_vert>\n#if defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nattribute vec3 aColor0;\nvarying vec3 vColor0;\n#else\nattribute vec4 aColor0;\nvarying vec4 vColor0;\n#endif\n#endif\n#include <line_extrusion_vert>\n#include <get_output>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_vert>\n#endif\n#include <heatmap_render_vert>\n#include <vertex_color_vert>\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nvarying vec3 vTangentViewPos;\nvarying vec3 vTangentFragPos;\n#if __VERSION__ == 100\nmat3 f(in mat3 h) {\n  vec3 i = h[0];\n  vec3 j = h[1];\n  vec3 k = h[2];\n  return mat3(vec3(i.x, j.x, k.x), vec3(i.y, j.y, k.y), vec3(i.z, j.z, k.z));\n}\n#else\nmat3 f(in mat3 h) {\n  return transpose(h);\n}\n#endif\n#endif\nvoid l(const highp vec4 q, out highp vec3 m) {\n  m = vec3(.0, .0, 1.) + vec3(2., -2., -2.) * q.x * q.zwx + vec3(2., 2., -2.) * q.y * q.wzy;\n}\nvoid l(const highp vec4 q, out highp vec3 m, out highp vec3 t) {\n  l(q, m);\n  t = vec3(1., .0, .0) + vec3(-2., 2., -2.) * q.y * q.yxw + vec3(-2., 2., 2.) * q.z * q.zwx;\n}\nconst float o = .5;\nvec2 u(vec2 v, float A) {\n  return vec2(cos(A) * (v.x - o) + sin(A) * (v.y - o) + o, cos(A) * (v.y - o) - sin(A) * (v.x - o) + o);\n}\n#if defined(HAS_MAP)\nvec2 B(vec2 v) {\n  vec2 C = decode_getTexcoord(v);\n#ifdef HAS_RANDOM_TEX\nvec2 D = uvOrigin;\n  vec2 E = C * uvScale + uvOffset;\n  return mod(D, 1.) + E;\n#else\nvec2 D = uvOrigin;\n  vec2 E = C * uvScale;\n  if(uvRotation != .0) {\n    D = u(D, uvRotation);\n    E = u(E, uvRotation);\n  }\n  return mod(D, 1.) + E + uvOffset;\n#endif\n}\n#endif\n#ifdef PICKING_MODE\n#include <fbo_picking_vert>\n#endif\n#include <excavate_vert>\nvoid main() {\n  mat4 F = getPositionMatrix();\n#ifdef IS_LINE_EXTRUSION\nvec3 G = getLineExtrudePosition(aPosition);\n  vec4 H = getPosition(G);\n#else\nvec4 H = getPosition(aPosition);\n#endif\nvModelVertex = (modelMatrix * H).xyz;\n  vec4 I = F * H;\n  vec4 J = modelViewMatrix * I;\n  vViewVertex = J;\n#ifdef HAS_MASK_EXTENT\ngl_Position = projMatrix * getMaskPosition(I, modelMatrix);\n#else\ngl_Position = projMatrix * J;\n#endif\n#ifdef PICKING_MODE\nfloat K = 1.;\n#if defined(HAS_COLOR)\nK *= aColor.a;\n#endif\n#if defined(HAS_COLOR0) && COLOR0_SIZE == 4\nK *= aColor0.a;\n#endif\nfbo_picking_setData(gl_Position.w, K != .0);\n#else\n#if defined(HAS_MAP)\nvTexCoord = B(aTexCoord);\n#ifdef HAS_AO_MAP\nvTexCoord1 = B(aTexCoord1);\n#endif\n#ifdef HAS_I3S_UVREGION\nvUvRegion = uvRegion / 65535.;\n#endif\n#endif\n#if defined(HAS_TANGENT) || defined(HAS_NORMAL)\nmat3 L = mat3(F);\n  mat3 M = modelNormalMatrix * L;\n#if defined(HAS_TANGENT)\nvec3 t;\n  l(aTangent, d, t);\n  vModelTangent = vec4(M * t, aTangent.w);\n#else\nd = decode_getNormal(aNormal);\n#endif\nvec3 N = d;\n  vModelNormal = M * N;\n#else\nd = vec3(.0);\n  vModelNormal = vec3(.0);\n#endif\n#if defined(HAS_TANGENT)\nvModelBiTangent = cross(vModelNormal, vModelTangent.xyz) * sign(aTangent.w);\n#endif\n#ifdef HAS_SSR\nmat3 O = modelViewNormalMatrix * L;\n  vViewNormal = O * d;\n#if defined(HAS_TANGENT)\nvec4 P = vec4(t, aTangent.w);\n  vViewTangent = vec4(O * P.xyz, P.w);\n#endif\n#endif\n#if defined(HAS_COLOR)\nvColor = aColor / 255.;\n#endif\n#ifdef HAS_OPACITY\nvOpacity = aOpacity / 255.;\n#else\nvOpacity = 1.;\n#endif\nhighlight_setVarying();\n#if defined(HAS_COLOR0)\nvColor0 = aColor0 / 255.;\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nshadow_computeShadowPars(I);\n#endif\n#ifdef HAS_HEATMAP\nheatmap_compute(projMatrix * modelViewMatrix * F, H);\n#endif\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nmat3 Q = f(mat3(vModelTangent.xyz, vModelBiTangent, vModelNormal));\n  vTangentViewPos = Q * cameraPosition;\n  vTangentFragPos = Q * vModelVertex;\n#endif\n#ifdef HAS_VERTEX_COLOR\nvertexColor_update();\n#endif\n#ifdef HAS_EXCAVATE_ANALYSIS\nvCoordinateTexcoord = getCoordinateTexcoord(I);\n  vExcavateHeight = getWorldHeight(I);\n#endif\n#endif\n}",frag:i.frag||"#define PI 3.141593\n#define RECIPROCAL_PI 1.0\n#if __VERSION__ == 100\n#if defined(GL_EXT_shader_texture_lod)\n#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod(tex, uv, lod) textureCubeLodEXT(tex, uv, lod)\n#else\n#define textureCubeLod(tex, uv, lod) textureCube(tex, uv, lod)\n#endif\n#if defined(GL_OES_standard_derivatives)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#else\n#define textureCubeLod(tex, uv, lod) textureLod(tex, uv, lod)\n#endif\n#define saturate(x)        clamp(x, 0.0, 1.0)\nprecision mediump float;\n#include <gl2_frag>\n#include <hsv_frag>\n#include <srgb_frag>\nuniform vec3 hsv;\nuniform float contrast;\nstruct MaterialUniforms {\n  vec2 roughnessMetalness;\n  vec3 albedo;\n  float alpha;\n  vec3 normal;\n  vec3 emit;\n  float ao;\n  vec3 specularColor;\n  float glossiness;\n  vec4 skinColor;\n} c;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_frag>\n#endif\nuniform vec3 cameraPosition;\nuniform float alphaTest;\n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nuniform vec4 diffuseFactor;\nuniform vec3 specularFactor;\nuniform float glossinessFactor;\n#if defined(HAS_DIFFUSE_MAP)\nuniform sampler2D diffuseTexture;\n#endif\n#if defined(HAS_SPECULARGLOSSINESS_MAP)\nuniform sampler2D specularGlossinessTexture;\n#endif\n#endif\nuniform vec3 emissiveFactor;\nuniform vec4 baseColorFactor;\nuniform float baseColorIntensity;\nuniform float emitColorFactor;\nuniform float occlusionFactor;\nuniform float environmentExposure;\nuniform float roughnessFactor;\nuniform float metallicFactor;\nuniform float normalMapFactor;\nuniform float specularF0;\nuniform int emitMultiplicative;\nuniform int normalMapFlipY;\nuniform int outputSRGB;\nuniform mat3 environmentTransform;\n#if defined(HAS_ALBEDO_MAP)\nuniform sampler2D baseColorTexture;\n#endif\n#if defined(HAS_METALLICROUGHNESS_MAP)\nuniform sampler2D metallicRoughnessTexture;\n#endif\n#if defined(HAS_EMISSIVE_MAP)\nuniform sampler2D emissiveTexture;\n#endif\n#if defined(HAS_AO_MAP)\nuniform sampler2D occlusionTexture;\nvarying vec2 vTexCoord1;\n#endif\n#if defined(HAS_NORMAL_MAP) && defined(HAS_TANGENT)\nuniform sampler2D normalTexture;\n#endif\n#if defined(HAS_SKIN_MAP)\nuniform sampler2D skinTexture;\n#endif\n#if defined(ALPHA_MODE) && ALPHA_MODE == 1\nuniform float alphaCutoff;\n#endif\n#ifdef HAS_RANDOM_TEX\nuniform highp vec2 uvOrigin;\nuniform sampler2D noiseTexture;\n#endif\nuniform sampler2D brdfLUT;\n#if defined(HAS_IBL_LIGHTING)\nuniform vec3 hdrHSV;\nuniform samplerCube prefilterMap;\nuniform vec3 diffuseSPH[9];\nuniform vec2 prefilterMiplevel;\nuniform vec2 prefilterSize;\n#else\nuniform vec3 ambientColor;\n#endif\nuniform vec2 cameraNearFar;\nuniform vec3 light0_viewDirection;\nuniform vec4 light0_diffuse;\n#ifdef HAS_SSR\nvarying vec3 vViewNormal;\n#if defined(HAS_TANGENT)\nvarying vec4 vViewTangent;\n#endif\n#endif\nvarying vec3 vModelVertex;\nvarying vec4 vViewVertex;\n#if defined(HAS_MAP)\n#include <compute_texcoord_frag>\n#endif\nvarying vec3 vModelNormal;\n#if defined(HAS_TANGENT)\nvarying vec4 vModelTangent;\nvarying vec3 vModelBiTangent;\n#endif\n#if defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nvarying vec3 vColor0;\n#else\nvarying vec4 vColor0;\n#endif\n#endif\n#if defined(HAS_COLOR)\nvarying vec4 vColor;\n#elif defined(IS_LINE_EXTRUSION)\nuniform vec4 lineColor;\n#else\nuniform vec4 polygonFill;\n#endif\n#ifdef HAS_LAYER_OPACITY\nuniform float layerOpacity;\n#endif\nvarying float vOpacity;\n#ifdef HAS_INSTANCE_COLOR\nvarying vec4 vInstanceColor;\n#endif\n#ifdef IS_LINE_EXTRUSION\nuniform float lineOpacity;\n#else\nuniform float polygonOpacity;\n#endif\n#ifdef HAS_PATTERN\nuniform sampler2D linePatternFile;\nuniform vec2 atlasSize;\nuniform float flipY;\nuniform float currentTime;\nuniform float animSpeedScale;\n#ifdef HAS_PATTERN_ANIM\nvarying float vLinePatternAnimSpeed;\n#else\nuniform float linePatternAnimSpeed;\n#endif\n#ifdef HAS_PATTERN_GAP\nvarying float vLinePatternGap;\n#else\nuniform float linePatternGap;\n#endif\nuniform vec4 linePatternGapColor;\nuniform vec2 uvScale;\nvarying float vPatternHeight;\nvarying float vLinesofar;\nvarying vec4 vTexInfo;\nvarying float vNormalY;\nvec2 d(vec2 e) {\n  vec2 f = mod(e, 1.);\n  vec2 h = vTexInfo.xy;\n  vec2 i = vTexInfo.zw;\n  return (h + f * i) / atlasSize;\n}\n#endif\n#include <heatmap_render_frag>\n#include <snow_frag>\n#include <mask_frag>\n#include <terrain_normal_frag>\n#include <vertex_color_frag>\n#include <excavate_frag>\n#ifdef HAS_RANDOM_TEX\nconst float j = .5;\nvec2 k(vec2 f, float l) {\n  return vec2(cos(l) * (f.x - j) + sin(l) * (f.y - j) + j, cos(l) * (f.y - j) - sin(l) * (f.x - j) + j);\n}\nfloat m(vec3 n) {\n  return n.x + n.y + n.z;\n}\n#endif\nvec4 o(sampler2D u, in vec2 f) {\n  \n#ifdef HAS_RANDOM_TEX\nhighp vec2 A = uvOrigin;\n  highp vec2 B = f + A - mod(A, 1.);\n  float C = texture2D(noiseTexture, .005 * B).x;\n  vec2 D = dFdx(B);\n  vec2 E = dFdx(B);\n  float F = C * 8.;\n  float G = fract(F);\n#if 1\nfloat H = floor(F);\n  float I = H + 1.;\n#else\nfloat H = floor(F + .5);\n  float I = floor(F);\n  G = min(G, 1. - G) * 2.;\n#endif\nvec2 J = sin(vec2(3., 7.) * H);\n  vec2 K = sin(vec2(3., 7.) * I);\n  float L = .5;\n  vec4 M = texture2DGradEXT(u, f + L * J, D, E);\n  vec4 N = texture2DGradEXT(u, f + L * K, D, E);\n  return mix(M, N, smoothstep(.2, .8, G - .1 * m(M.xyz - N.xyz)));\n#else\nreturn texture2D(u, f);\n#endif\n}\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nuniform sampler2D bumpTexture;\nuniform float bumpScale;\nuniform float bumpMaxLayers;\nuniform float bumpMinLayers;\nvec2 O(vec2 f, vec3 P) {\n  float Q = mix(bumpMaxLayers, bumpMinLayers, abs(dot(vec3(.0, .0, 1.), P)));\n  float R = 1. / Q;\n  float S = .0;\n  vec2 T = P.xy * bumpScale / (P.z * Q);\n  vec2 U = f;\n  float V = o(bumpTexture, U).r;\n  for(int W = 0; W < 30; W++) {\n    S += R;\n    U -= T;\n    V = o(bumpTexture, U).r;\n    if(V < S) {\n      break;\n    }\n  }\n  vec2 X = U + T;\n  float Y = V - S;\n  float Z = o(bumpTexture, X).r - S + R;\n  return mix(U, X, Y / (Y - Z));\n}\nvarying vec3 vTangentViewPos;\nvarying vec3 vTangentFragPos;\n#endif\n#define SHADER_NAME PBR\nvec3 ba() {\n  return c.albedo;\n}\nfloat bb() {\n  return c.alpha;\n}\nfloat bc() {\n  return c.roughnessMetalness.y;\n}\nfloat bd() {\n  \n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nreturn 1. - c.glossiness;\n#else\nreturn c.roughnessMetalness.x;\n#endif\n}\nvec3 be() {\n  return c.emit;\n}\nvec4 bf() {\n  return c.skinColor;\n}\nvec3 bg() {\n  return c.normal;\n}\nfloat bh() {\n  return c.ao;\n}\nfloat bi(const in vec4 bj) {\n  return bj.r + bj.g / 255.;\n}\nvec3 bk(const in float bl, in vec3 bm, const in vec3 t, const in vec3 b, in vec3 bn) {\n  bm.xy = bl * bm.xy;\n  mat3 bo = mat3(t, b, bn);\n  return normalize(bo * bm);\n}\nfloat bp(const float bq, const vec3 bm, const vec3 br) {\n  float bs = clamp(dot(bm, br), 0., 1.);\n  float a = bq * bq;\n  float bt = a * a;\n  float bu = (bs * bt - bs) * bs + 1.;\n  return bt / (PI * bu * bu);\n}\nvec3 bv(const vec3 bw, const float bx, const in vec3 by, const in vec3 br) {\n  float bz = clamp(dot(by, br), 0., 1.);\n  bz = pow(1. - bz, 5.);\n  return bx * bz + (1. - bz) * bw;\n}\nfloat bA(const in vec3 bm, const in vec3 bB, const in float bq, const float bC) {\n  float bD = clamp(dot(bm, bB), 0., 1.);\n  float a = bq * bq;\n  float bE = bD * (bC * (1. - a) + a);\n  float bF = bC * (bD * (1. - a) + a);\n  return .5 / (bF + bE);\n}\nvec3 bG(const float bq, const vec3 bm, const vec3 bB, const vec3 by, const vec3 bH, const float bC, const float bx) {\n  vec3 br = normalize(bB + by);\n  float bI = bp(bq, bm, br);\n  float bJ = bA(bm, bB, bq, bC);\n  vec3 bK = bv(bH, bx, by, br);\n  return (bI * bJ * PI) * bK;\n}\nvec3 bL(const in vec3 bM) {\n  return RECIPROCAL_PI * bM;\n}\nvoid bN(const in vec3 bm, const in vec3 bB, const in float bC, const in float bq, const in vec3 bO, const in vec3 bH, const in vec3 bP, const in vec3 by, const in float bx, out vec3 bQ, out vec3 bR) {\n  if(bC <= .0) {\n    bR = bQ = vec3(.0);\n    return;\n  }\n  vec3 a = bC * bP;\n  vec3 bS = bG(bq, bm, bB, by, bH, bC, bx);\n  bR = a * bS;\n  bQ = a * bL(bO);\n}\n#if defined(HAS_IBL_LIGHTING)\nvec3 bT(const in vec3 bm) {\n  vec3 bn = environmentTransform * bm;\n  float x = bn.x;\n  float y = bn.y;\n  float z = bn.z;\n  vec3 bU = (diffuseSPH[0] + diffuseSPH[1] * x + diffuseSPH[2] * y + diffuseSPH[3] * z + diffuseSPH[4] * z * x + diffuseSPH[5] * y * z + diffuseSPH[6] * y * x + diffuseSPH[7] * (3. * z * z - 1.) + diffuseSPH[8] * (x * x - y * y));\n  if(length(hdrHSV) > .0) {\n    bU = hsv_apply(bU, hdrHSV);\n  }\n  return max(bU, vec3(.0));\n}\nvec3 bV(const in float bq, const in vec3 bW) {\n  vec3 bX = bW;\n  float bY = prefilterMiplevel.x;\n  float bZ = min(bY, bq * prefilterMiplevel.y);\n  vec3 ca = textureCubeLod(prefilterMap, bX, bZ).rgb;\n  if(length(hdrHSV) > .0) {\n    return hsv_apply(ca, hdrHSV);\n  } else {\n    return ca;\n  }\n}\nvec3 cb(const in vec3 cc, const in vec3 bB, const in float bq, const in vec3 cd, const in vec3 bO) {\n  float ce = 1. - bq;\n  vec3 bW = mix(cc, reflect(-bB, cc), ce * (sqrt(ce) + bq));\n  float bl = clamp(1. + dot(bW, cd), .0, 1.);\n  vec3 cf = bV(bq, environmentTransform * bW) * bl * bl;\n  return cf;\n}\n#else\nvec3 cb(const in vec3 bm, const in vec3 cg, const in float bq, const in vec3 cd, const in vec3 bO) {\n  return ambientColor * bL(bO);\n}\n#endif\nvec3 ch(const in vec3 ci, const in float bq, const in float bD, const in float bx) {\n  vec4 rgba = texture2D(brdfLUT, vec2(bD, bq)) * vec4(255., 65280.0, 255., 65280.0);\n  float b = (rgba[3] + rgba[2]);\n  float a = (rgba[1] + rgba[0]);\n  return (ci * a + b * bx) / 65535.;\n}\nvec3 cj(const in vec3 bm, const in vec3 cg, const in float bD, const in float bq, const in vec3 bH, const in vec3 cd, const in float bx, const in vec3 bO) {\n  return cb(bm, cg, bq, cd, bO) * ch(bH, bq, bD, bx);\n}\nfloat ck(const in float cl, const in float bD) {\n  float bu = bD + cl;\n  return clamp(bu * bu - 1. + cl, .0, 1.);\n}\nvoid cm() {\n  \n#ifdef HAS_MAP\nvec2 f = computeTexCoord(vTexCoord);\n#endif\n#ifdef HAS_UV_FLIP\nf.y = 1. - f.y;\n#endif\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nf = O(f, normalize(vTangentViewPos - vTangentFragPos));\n#endif\nc.albedo = baseColorIntensity * baseColorFactor.rgb;\n  c.alpha = baseColorFactor.a * vOpacity;\n#if defined(HAS_PATTERN)\nfloat cn = vLinesofar;\n  vec2 i = vTexInfo.zw;\n#ifdef HAS_PATTERN_GAP\nfloat co = vLinePatternGap;\n#else\nfloat co = linePatternGap;\n#endif\n#ifdef HAS_PATTERN_ANIM\nfloat cp = vLinePatternAnimSpeed;\n#else\nfloat cp = linePatternAnimSpeed;\n#endif\nfloat cq = ceil(i.x * vPatternHeight / i.y);\n  float cr = cq * (1. + co);\n  cp /= animSpeedScale;\n  cn += mod(currentTime * -cp * .2, cr);\n  float cs = mod(cn / cr, 1.);\n  float ct = mod(flipY * vNormalY, 1.);\n  vec2 f = d(vec2(cs * (1. + co) * uvScale[0], ct * uvScale[1]));\n  vec4 cu = texture2D(linePatternFile, f);\n  float cv = clamp(sign(1. / (1. + co) - cs) + .000001, .0, 1.);\n  cu = mix(linePatternGapColor, cu, cv);\n#ifdef IS_SQUARE_TUBE\nfloat n = clamp(sign(abs(vNormalY) - .999999), .0, 1.);\n  cu = mix(cu, vec4(1.), n);\n#endif\nc.albedo *= cu.rgb;\n  c.alpha *= cu.a;\n#endif\n#if defined(HAS_ALBEDO_MAP)\nvec4 cw = o(baseColorTexture, f);\n  c.albedo *= sRGBToLinear(cw.rgb);\n  c.alpha *= cw.a;\n#endif\n#if defined(HAS_SKIN_MAP)\nvec4 cx = o(skinTexture, f);\n  c.skinColor = cx;\n#endif\n#if defined(HAS_COLOR0)\nc.albedo *= vColor0.rgb;\n#if COLOR0_SIZE == 4\nc.alpha *= vColor0.a;\n#endif\n#endif\n#if defined(HAS_COLOR)\nc.albedo *= vColor.rgb;\n  c.alpha *= vColor.a;\n#elif defined(IS_LINE_EXTRUSION)\nc.albedo *= lineColor.rgb;\n  c.alpha *= lineColor.a;\n#else\nc.albedo *= polygonFill.rgb;\n  c.alpha *= polygonFill.a;\n#endif\n#if defined(HAS_INSTANCE_COLOR)\nc.albedo *= vInstanceColor.rgb;\n  c.alpha *= vInstanceColor.a;\n#endif\n#if defined(HAS_METALLICROUGHNESS_MAP)\nc.roughnessMetalness = o(metallicRoughnessTexture, f).gb * vec2(roughnessFactor, metallicFactor);\n#else\nc.roughnessMetalness = vec2(roughnessFactor, metallicFactor);\n#endif\nc.emit = emissiveFactor;\n#if defined(HAS_EMISSIVE_MAP)\nif(emitMultiplicative == 1) {\n    c.emit *= sRGBToLinear(o(emissiveTexture, f).rgb);\n  } else {\n    c.emit += sRGBToLinear(o(emissiveTexture, f).rgb);\n  }\n#endif\nc.emit *= emitColorFactor;\n#if defined(HAS_AO_MAP)\nvec2 cy = computeTexCoord(vTexCoord1);\n  c.ao = o(occlusionTexture, cy).r;\n#else\nc.ao = 1.;\n#endif\nc.ao *= occlusionFactor;\n#if defined(HAS_NORMAL_MAP) && defined(HAS_TANGENT)\nvec3 cz = o(normalTexture, f).xyz * 2. - 1.;\n  cz.y = normalMapFlipY == 1 ? -cz.y : cz.y;\n  c.normal = cz;\n#else\nc.normal = normalize(vModelNormal);\n#endif\n#if defined(HAS_TERRAIN_NORMAL) && defined(HAS_TANGENT)\nvec3 cz = convertTerrainHeightToNormalMap(f);\n  cz.y = normalMapFlipY == 1 ? -cz.y : cz.y;\n  c.normal = cz;\n#endif\n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nc.albedo *= diffuseFactor.rgb;\n  c.alpha *= diffuseFactor.a;\n#if defined(HAS_DIFFUSE_MAP)\nvec4 cA = o(diffuseTexture, f);\n  c.albedo *= sRGBToLinear(cA.rgb);\n  c.alpha *= cA.a;\n#endif\nc.specularColor = specularFactor;\n  c.glossiness = glossinessFactor;\n#if defined(HAS_SPECULARGLOSSINESS_MAP)\nvec4 cB = o(specularGlossinessTexture, f);\n  c.specularColor *= sRGBToLinear(cB.rgb);\n  c.glossiness *= cB.a;\n#endif\n#endif\n}\nvec3 cC(const vec3 x) {\n  const float a = 2.51;\n  const float b = .03;\n  const float cD = 2.43;\n  const float bu = .59;\n  const float cE = .14;\n  return (x * (a * x + b)) / (x * (cD * x + bu) + cE);\n}\nvec3 cF(vec3 cG) {\n  cG = cC(cG);\n  return cG = pow(cG, vec3(1. / 2.2));\n}\nuniform float specularAAVariance;\nuniform float specularAAThreshold;\nfloat cH(float bq, const vec3 cI) {\n  \n#if defined(GL_OES_standard_derivatives) || __VERSION__ == 300\nvec3 cJ = dFdx(cI);\n  vec3 cK = dFdy(cI);\n  float cL = specularAAVariance * (dot(cJ, cJ) + dot(cK, cK));\n  float cM = min(2. * cL, specularAAThreshold);\n  float cN = saturate(bq * bq + cM);\n  return sqrt(cN);\n#else\nreturn bq;\n#endif\n}\n#ifdef HAS_SSR\nuniform sampler2D TextureDepth;\nuniform highp vec2 outSize;\nuniform float ssrFactor;\nuniform float ssrQuality;\nuniform sampler2D TextureReflected;\nuniform highp mat4 projMatrix;\nuniform mat4 invProjMatrix;\nuniform vec4 outputFovInfo[2];\nuniform mat4 reprojViewProjMatrix;\nvec3 cO(const in mat4 cP, const in vec3 cQ) {\n  vec4 cR = cP * vec4(cQ, 1.);\n  return vec3(.5 + .5 * cR.xy / cR.w, cR.w);\n}\nvec3 cS(const in float cT, const in vec2 f) {\n  return texture2D(TextureReflected, f).rgb;\n}\nfloat cU(float cV) {\n  highp mat4 cP = projMatrix;\n  highp float z = cV * 2. - 1.;\n  return -cP[3].z / (z + cP[2].z);\n}\nfloat cW(const vec2 f) {\n  float cV = bi(texture2D(TextureDepth, f));\n  return cV;\n}\nfloat cX(const in vec2 cY, const in float cZ) {\n  vec3 da = vec3(.06711056, .00583715, 52.9829189);\n  return fract(da.z * fract(dot(cY.xy + cZ * vec2(47., 17.) * .695, da.xy))) * .5;\n}\nvec3 db(const in float cZ, const in vec3 dc, const in vec3 dd, const in vec3 de, const in vec3 cg, const in float df) {\n  vec2 dg;\n  dg.x = cX(gl_FragCoord.yx, cZ);\n  dg.y = fract(dg.x * 52.9829189);\n  dg.y = mix(dg.y, 1., .7);\n  float dh = 2. * 3.14159 * dg.x;\n  float di = pow(max(dg.y, .000001), df / (2. - df));\n  float dj = sqrt(1. - di * di);\n  vec3 dk = vec3(dj * cos(dh), dj * sin(dh), di);\n  dk = dk.x * dc + dk.y * dd + dk.z * de;\n  return normalize((2. * dot(cg, dk)) * dk - cg);\n}\nfloat dl(const in float cZ) {\n  return (cX(gl_FragCoord.xy, cZ) - .5);\n}\nvec3 dm(const in vec3 dn, const in float dp, const in vec3 dq) {\n  vec3 dr = cO(projMatrix, vViewVertex.xyz + dq * dp);\n  dr.z = 1. / dr.z;\n  dr -= dn;\n  float ds = min(1., .99 * (1. - dn.x) / max(1e-5, dr.x));\n  float dt = min(1., .99 * (1. - dn.y) / max(1e-5, dr.y));\n  float dw = min(1., .99 * dn.x / max(1e-5, -dr.x));\n  float dx = min(1., .99 * dn.y / max(1e-5, -dr.y));\n  return dr * min(ds, dt) * min(dw, dx);\n}\nfloat dy(const in vec3 dn, const in vec3 dr, inout float dz, inout float dA) {\n  float dB = (dA + dz) * .5;\n  vec3 dC = dn + dr * dB;\n  float z = cW(dC.xy);\n  float cV = cU(z);\n  float dD = -1. / dC.z;\n  dz = cV > dD ? dz : dB;\n  dA = cV > dD ? dB : dA;\n  return dB;\n}\nvec4 dE(const in vec3 dn, const in float dp, in float dF, const in vec3 dq, const in float bq, const in float cZ) {\n  int dG = 20;\n  float dH = 1. / float(dG);\n  dF *= dH;\n  vec3 dr = dm(dn, dp, dq);\n  float dI = dH;\n  vec3 dJ = vec3(.0, dI, 1.);\n  vec3 dC;\n  float z, cV, dD, dK, dL, dM;\n  bool dN;\n  float dO = 1.;\n  float dB;\n  for(int W = 0; W < dG; W++) {\n    dC = dn + dr * dJ.y;\n    z = cW(dC.xy);\n    cV = cU(z);\n    dD = -1. / dC.z;\n    float dP = clamp(sign(.999 - z), .0, 1.);\n    dK = dP * (dD - cV);\n    dK *= clamp(sign(abs(dK) - dp * dH * dH), .0, 1.);\n    dN = abs(dK + dF) < dF;\n    dL = clamp(dJ.x / (dJ.x - dK), .0, 1.);\n    dM = dN ? dJ.y + dL * dH - dH : 1.;\n    dJ.z = min(dJ.z, dM);\n    dJ.x = dK;\n    if(dN) {\n      float dz = dJ.y - dH;\n      float dA = dJ.y;\n      dB = dy(dn, dr, dz, dA);\n      dB = dy(dn, dr, dz, dA);\n      dB = dy(dn, dr, dz, dA);\n      dO = dB;\n      break;\n    }\n    dJ.y += dH;\n  }\n  return vec4(dn + dr * dO, 1. - dO);\n}\nvec4 dQ(in vec4 dR, const in float dS, const in vec3 dT, const in vec3 dU, const in float bq) {\n  vec4 dV = mix(outputFovInfo[0], outputFovInfo[1], dR.x);\n  dR.xyz = vec3(mix(dV.xy, dV.zw, dR.y), 1.) * -1. / dR.z;\n  dR.xyz = (reprojViewProjMatrix * vec4(dR.xyz, 1.)).xyw;\n  dR.xy /= dR.z;\n  float dW = clamp(6. - 6. * max(abs(dR.x), abs(dR.y)), .0, 1.);\n  dR.xy = .5 + .5 * dR.xy;\n  vec3 dX = dU * cS(bq * (1. - dR.w), dR.xy);\n  return vec4(mix(dT, dX, dS * dW), 1.);\n}\nvec3 ssr(const in vec3 dT, const in vec3 dU, const in float bq, const in vec3 bm, const in vec3 cg) {\n  float dY = .0;\n  vec4 bU = vec4(.0);\n  float df = bq * bq;\n  df = df * df;\n  vec3 dZ = abs(bm.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);\n  vec3 dc = normalize(cross(dZ, bm));\n  vec3 dd = cross(bm, dc);\n  float dS = ssrFactor * clamp(-4. * dot(cg, bm) + 3.8, .0, 1.);\n  dS *= clamp(4.7 - bq * 5., .0, 1.);\n  vec3 dn = cO(projMatrix, vViewVertex.xyz);\n  dn.z = 1. / dn.z;\n  vec3 dq = db(dY, dc, dd, bm, cg, df);\n  float dp = mix(cameraNearFar.y + vViewVertex.z, -vViewVertex.z - cameraNearFar.x, dq.z * .5 + .5);\n  float dF = .5 * dp;\n  vec4 dR;\n  if(dot(dq, bm) > .001 && dS > .0) {\n    dR = dE(dn, dp, dF, dq, bq, dY);\n    if(dR.w > .0)\n      bU += dQ(dR, dS, dT, dU, bq);\n    \n  }\n  return bU.w > .0 ? bU.rgb / bU.w : dT;\n}\n#endif\n#include <highlight_frag>\nvec4 ea(in vec4 eb) {\n  return vec4(mix(pow(eb.rgb, vec3(.41666)) * 1.055 - vec3(.055), eb.rgb * 12.92, vec3(lessThanEqual(eb.rgb, vec3(.0031308)))), eb.a);\n}\nvec4 ec(vec4 eb) {\n  return (ea(eb));\n}\nvoid main() {\n  cm();\n  vec3 cg = normalize(cameraPosition - vModelVertex.xyz);\n#if defined(HAS_DOUBLE_SIDE)\nvec3 cd = gl_FrontFacing ? normalize(vModelNormal) : -normalize(vModelNormal);\n#else\nvec3 cd = normalize(vModelNormal);\n#endif\n#if defined(HAS_TANGENT)\nvec4 ed;\n  ed = vModelTangent;\n#if defined(HAS_DOUBLE_SIDE)\ned.xyz = gl_FrontFacing ? normalize(ed.xyz) : -normalize(ed.xyz);\n#else\ned.xyz = normalize(ed.xyz);\n#endif\nvec3 ee = normalize(vModelBiTangent);\n#endif\nfloat bw = .08 * specularF0;\n  float ef = bc();\n  vec3 bO = ba();\n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nvec3 eg = c.specularColor;\n#else\nvec3 eg = mix(vec3(bw), bO, ef);\n#endif\nbO *= 1. - ef;\n  float eh = clamp(50.0 * eg.g, .0, 1.);\n  float ei = bd();\n  if(specularAAVariance > .0) {\n    ei = cH(ei, cd);\n  }\n  vec3 ej = be();\n  vec3 ek = bg();\n  vec3 el = vec3(ek);\n#if defined(HAS_TANGENT) && (defined(HAS_NORMAL_MAP) || defined(HAS_TERRAIN_NORMAL))\nel = bk(normalMapFactor, el, ed.xyz, ee, cd);\n#endif\nvec3 cA = vec3(.0);\n  vec3 bH = vec3(.0);\n#if defined(HAS_IBL_LIGHTING)\ncA = bO * bT(el) * .5;\n#else\ncA = bO * ambientColor;\n#endif\nfloat bD = dot(el, cg);\n  bH = cj(el, cg, bD, ei, eg, cd, eh, bO);\n  float em;\n  float en = 1.;\n  float eo = bh();\n  cA *= environmentExposure * eo;\n#ifdef HAS_IBL_LIGHTING\nen = ck(eo, bD);\n#endif\n#ifdef HAS_SSR\nvec3 ep = normalize(gl_FrontFacing ? vViewNormal : -vViewNormal);\n  vec3 eq = ep;\n#if defined(HAS_TANGENT) && (defined(HAS_NORMAL_MAP) || defined(HAS_TERRAIN_NORMAL))\nvec4 er;\n  er = vViewTangent;\n  er = gl_FrontFacing ? er : -er;\n  er.xyz = normalize(er.xyz);\n  vec3 es = normalize(cross(ep, er.xyz)) * er.w;\n  eq = bk(normalMapFactor, ek, er.xyz, es, ep);\n#endif\nbH = ssr(bH, eg * en, ei, eq, -normalize(vViewVertex.xyz));\n#endif\nbH *= environmentExposure * en;\n  vec3 et, eu;\n  vec3 ev = vModelNormal;\n  vec3 ew = -light0_viewDirection;\n  float ex = saturate(dot(ew, el));\n  bN(el, cg, ex, max(.045, ei), bO, eg, light0_diffuse.rgb, ew, eh, eu, et);\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nfloat ey = shadow_computeShadow();\n  eu = shadow_blend(eu, ey).rgb;\n  et = shadow_blend(et, ey).rgb;\n#endif\ncA += eu;\n  bH += et;\n  cA += ej;\n  vec3 ez = bH + cA;\n  if(outputSRGB == 1)\n    ez = linearTosRGB(ez);\n  \n#ifdef HAS_SKIN_MAP\nvec4 eA = bf();\n  ez.rgb = ez.rgb * (1. - eA.a) + eA.rgb * eA.a;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nez.rgb = shadow_blend(ez.rgb, ey).rgb;\n#endif\n#endif\nfloat eB = bb();\n  if(eB < alphaTest) {\n    discard;\n  }\n#if defined(ALPHA_MODE)\n#if ALPHA_MODE == 1\nif(eB < alphaCutoff) {\n    discard;\n  } else {\n    eB = 1.;\n  }\n#else\neB = 1.;\n#endif\n#endif\n#if defined(IS_LINE_EXTRUSION)\neB *= lineOpacity;\n#else\neB *= polygonOpacity;\n#endif\nglFragColor = vec4(ez * eB, eB);\n#ifdef HAS_VERTEX_COLOR\nglFragColor *= vertexColor_get();\n#endif\n#ifdef HAS_EXCAVATE_ANALYSIS\nglFragColor = excavateColor(glFragColor);\n#endif\n#ifdef HAS_HEATMAP\nglFragColor = heatmap_getColor(glFragColor);\n#endif\n#ifdef HAS_SNOW\nglFragColor.rgb = snow(glFragColor, bg(), 1.);\n#endif\nif(contrast != 1.) {\n    glFragColor = contrastMatrix(contrast) * glFragColor;\n  }\n  if(length(hsv) > .0) {\n    glFragColor = hsv_apply(glFragColor, hsv);\n  }\n#ifdef OUTPUT_NORMAL\nglFragColor = vec4(cd, 1.);\n#endif\nglFragColor = highlight_blendColor(glFragColor);\n#ifdef HAS_LAYER_OPACITY\nglFragColor *= layerOpacity;\n#endif\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",wgslVert:i.wgslVert||"",wgslFrag:i.wgslFrag||"",uniforms:W,extraCommandProps:g,defines:_}),this.version=300}getGeometryDefines(i){const g={};return i.data[i.desc.tangentAttribute]?g.HAS_TANGENT=1:i.data[i.desc.normalAttribute]&&(g.HAS_NORMAL=1),i.data[i.desc.colorAttribute]&&(g.HAS_COLOR=1),i.data[i.desc.color0Attribute]&&(g.HAS_COLOR0=1,g.COLOR0_SIZE=i.getColor0Size()),g}},StandardDepthShader:class StandardDepthShader extends MeshShader{constructor(i={}){const g=[];super({vert:"#define SHADER_NAME depth_vert\nattribute vec3 aPosition;\n#include <line_extrusion_vert>\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 projMatrix;\nuniform vec2 outSize;\nuniform vec2 halton;\n#include <get_output>\nvoid main() {\n  mat4 c = getPositionMatrix();\n#ifdef IS_LINE_EXTRUSION\nvec4 d = getPosition(getLineExtrudePosition(aPosition));\n#else\nvec4 d = getPosition(aPosition);\n#endif\nvec4 e = modelViewMatrix * c * d;\n  mat4 f = projMatrix;\n  f[2].xy += halton.xy / outSize.xy;\n  gl_Position = f * e;\n}",frag:"#define SHADER_NAME depth_frag\nprecision highp float;\nvoid main() {\n  gl_FragColor = vec4(1., .0, .0, 1.);\n}",uniforms:[{name:"modelViewMatrix",type:"function",fn:(i,m)=>_A(g,m.viewMatrix,m.modelMatrix)}],extraCommandProps:i.extraCommandProps,defines:i.defines})}},PBRUtils:$C},bP=Vx;bP.flatten=db;var wP=Object.freeze({__proto__:null,AbstractTexture,BloomPass,BoundingBox,BoxBlurShader:class BoxBlurShader extends QuadShader{constructor({blurOffset:i}){super({vert:OM,frag:"precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D textureSource;\nuniform vec2 resolution;\nuniform float ignoreTransparent;\nvoid main() {\n  vec4 c = vec4(.0);\n  float d = .0;\n  for(int x = -BOXBLUR_OFFSET; x <= BOXBLUR_OFFSET; ++x)\n    for(int y = -BOXBLUR_OFFSET; y <= BOXBLUR_OFFSET; ++y) {\n      vec2 e = vTexCoord.st + vec2(float(x) / resolution.x, float(y) / resolution.y);\n      e = clamp(e, .0, 1.);\n      vec4 f = texture2D(textureSource, e);\n      float h;\n      if(ignoreTransparent == 1.) {\n        h = sign(f.a);\n      } else {\n        h = 1.;\n      }\n      d += h;\n      c += h * f;\n    }\n  gl_FragColor = c / max(d, 1.) * clamp(sign(d - 1.), .0, 1.);\n}",defines:{BOXBLUR_OFFSET:i||2},extraCommandProps:{viewport:{x:0,y:0,width:(i,g)=>g.resolution[0],height:(i,g)=>g.resolution[1]}}}),this._blurOffset=i||2}getMeshCommand(i,g){const m="box_blur_"+this._blurOffset;return this.commands[m]||(this.commands[m]=this.createMeshCommand(i,g)),this.commands[m]}},Constants:Fx,CopyShader,EdgeGeometry,EdgeShader:class EdgeShader extends MeshShader{constructor(i={}){const g=[],m=i.uniforms,_=[{name:"modelViewMatrix",type:"function",fn:function(i,m){return _A(g,m.viewMatrix,m.modelMatrix)}}];m&&_.push(...m),super({vert:"attribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 modelViewMatrix;\n#include <get_output>\nvoid main() {\n  vec4 c = getPosition(aPosition);\n  mat4 d = getPositionMatrix();\n  gl_Position = projMatrix * modelViewMatrix * d * c;\n}",frag:"precision mediump float;\nuniform vec4 lineColor;\nuniform float lineOpacity;\nvoid main() {\n  gl_FragColor = lineColor;\n  gl_FragColor.a *= lineOpacity;\n}",uniforms:_,defines:i.defines||{},extraCommandProps:i.extraCommandProps||{}})}},ExtentPass,FBORayPicking:class FBORayPicking{constructor(i,{name:g,vert:m,wgslVert:_,uniforms:b,defines:T,extraCommandProps:P,enableStencil:I},H,W){this._renderer=i,this._fbo=H,this._map=W,this._clearFbo(H),this._name=g||"fboraypicking",this._vert=m,this._wgslVert=_,this._uniforms=b,this._defines=T,this._extraCommandProps=cx({},P),delete this._extraCommandProps.blend,I?this._extraCommandProps.stencil={enable:I,mask:255,func:{cmp:"<",ref:1,mask:255},op:{fail:"keep",zfail:"keep",zpass:"replace"}}:delete this._extraCommandProps.stencil,this._currentMeshes=[],this._init()}_init(){const i=[];this._uniforms&&i.push(...this._uniforms);const g={ENABLE_PICKING:1,HAS_PICKING_ID:1};if(this._defines)for(const i in this._defines)g[i]=this._defines[i];const m=this._vert,_=this._wgslVert,b=this._extraCommandProps;this._shader0=new MeshShader({name:this._name+"-0",vert:m,frag:sP,wgslVert:_,wgslFrag:aP,uniforms:i,defines:g,extraCommandProps:b}),this._shader2=new MeshShader({name:this._name+"-2",vert:m,frag:cP,wgslVert:_,wgslFrag:uP,uniforms:i,defines:g,extraCommandProps:b});const T={ENABLE_PICKING:1,HAS_PICKING_ID:1};if(this._defines)for(const i in this._defines)T[i]=this._defines[i];this._shader1=new MeshShader({name:this._name+"-1",vert:m,frag:lP,wgslVert:_,wgslFrag:hP,uniforms:i,defines:T,extraCommandProps:b}),this._depthShader=new MeshShader({name:this._name+"-depth",vert:m,frag:"\n    #ifdef GL_ES\n        precision highp float;\n    #endif\n    #if __VERSION__ == 100 && defined(GL_EXT_frag_depth)\n        #extension GL_EXT_frag_depth : enable\n    #endif\n    #include <gl2_frag>\n    #include <common_pack_float>\n    varying float vFbo_picking_viewZ;\n    uniform float logDepthBufFC;\n    varying float vFbo_picking_fragDepth;\n\n    const float PackUpscale = 256. / 255.;\n    const float UnpackDownscale = 255. / 256.;\n    const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\n    const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n    const float ShiftRight8 = 1. / 256.;\n    vec4 packDepthToRGBA(const in float v ) {\n        vec4 r = vec4(fract(v * PackFactors), v);\n        r.yzw -= r.xyz * ShiftRight8;\n        return r * PackUpscale;\n    }\n\n    void main() {\n        float fragDepth = vFbo_picking_fragDepth > 1.0 ? vFbo_picking_fragDepth : vFbo_picking_viewZ + 1.0;\n        #if __VERSION__ == 300 || __VERSION__ == 100 && defined(GL_EXT_frag_depth)\n            gl_FragDepthEXT = log2(fragDepth) * logDepthBufFC * 0.5;\n        #endif\n        vec4 depthColor = packDepthToRGBA(fragDepth - 1.0);\n        glFragColor = common_unpackFloat(dot(depthColor, UnpackFactors));\n        #if __VERSION__ == 100\n            gl_FragColor = glFragColor;\n        #endif\n    }\n",wgslVert:_,wgslFrag:"\n    #include <common_pack_float>\n\n    struct DepthPackingUniforms {\n        logDepthBufFC: f32,\n    };\n\n    @group(0) @binding($b) var<uniform> depthPackingUniforms: DepthPackingUniforms;\n\n    struct VertexOutput {\n        @location($i) vFbo_picking_viewZ: f32,\n        @location($i) vFbo_picking_fragDepth: f32,\n    };\n\n    const PackUpscale = 256.0 / 255.0;\n    const UnpackDownscale = 255.0 / 256.0;\n    const PackFactors = vec3f(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0);\n    const UnpackFactors = UnpackDownscale / vec4f(PackFactors, 1.0);\n    const ShiftRight8 = 1.0 / 256.0;\n\n    fn packDepthToRGBA(v: f32) -> vec4f {\n        var r = vec4f(fract(v * PackFactors), v);\n        // r.yzw -= r.xyz * ShiftRight8;\n        r = vec4f(r.x, r.yzw - r.xyz * ShiftRight8);\n        return r * PackUpscale;\n    }\n\n    @fragment\n    fn main(vertexOutput: VertexOutput) -> @location(0) vec4f {\n        let fragDepth = select(\n            vertexOutput.vFbo_picking_viewZ + 1.0,\n            vertexOutput.vFbo_picking_fragDepth,\n            vertexOutput.vFbo_picking_fragDepth > 1.0\n        );\n\n        let depthColor = packDepthToRGBA(fragDepth - 1.0);\n        var glFragColor = common_unpackFloat(dot(depthColor, UnpackFactors));\n\n        return glFragColor;\n    }\n",uniforms:i,defines:T,extraCommandProps:b}),this._scene=new Scene,this._scene1=new Scene}filter(){return!0}render(i,g,m=!1){if(!i||!i.length)return this;const _=this._fbo;m&&this.clear(),i=i.filter((i=>i&&i.isValid&&i.isValid())),this._scene.setMeshes(i);const b=this._getShader(i,m);b.filter=this.filter,this._currentShader&&b!==this._currentShader&&this.clear(),this._currentShader=b,i.forEach(((i,g)=>{i.setUniform("fbo_picking_meshId",g+this._currentMeshes.length)}));for(let g=0;g<i.length;g++)this._currentMeshes.push(i[g]);return this._renderer.render(b,g,this._scene,_),this}pickAll(i,g,m,_,b){m=dP(m);const{meshIds:T,pickingIds:P,coords:I,points:H}=this._pick(i,g,m,_,b),W=[];if(P&&T){const i={};for(let g=0;g<T.length;g++){const m=`${P[g]}_${T[g]}`;null==T[g]||null==P[g]||i[m]||(i[m]=!0,W.push({meshId:T[g],pickingId:P[g],point:H[g]||null,coordinate:I[g]||null}))}}return W}pick(i,g,m,_,b={}){m=dP(m);const{meshIds:T,pickingIds:P,width:I,coords:H,points:W}=this._pick(i,g,m,_,b);if(P&&T){const i=[];for(let g=0;g<=m[0];g++)i.push(g),g>0&&i.push(-g);for(let g=0;g<i.length;g++)for(let _=0;_<i.length;_++){const b=(i[_]+m[1])*I+(i[g]+m[0]);if(null!=T[b])return{meshId:T[b],pickingId:P[b],point:W[b]||null,coordinate:H[b]||null}}}return{pickingId:null,meshId:null,point:null}}_pick(i,g,m,_,b={}){const T=this._currentShader,P=this._currentMeshes;if(!T||!P||!P.length)return{pickingId:null,meshId:null,point:null};i=Math.round(i),g=Math.round(g);const I=this._fbo;if(i<=2||i>=I.width-2||g<=2||g>=I.height-2)return{pickingId:null,meshId:null,point:null};const{px:H,py:W,width:q,height:$}=this._getParams(i,g,m,I),ye=new Uint8Array(4*q*$),Re=this._renderer.device.read({data:ye,x:H,y:W,framebuffer:I,width:q,height:$}),Be=[];let Ge=[];for(let i=0;i<Re.length;i+=4){const{pickingId:g,meshId:m}=this._packData(Re.subarray(i,i+4),T);Be.push(m),Ge.push(g)}const je={},Xe=Be.filter((i=>null!=i&&!je[i]&&(je[i]=1,!0))).map((i=>P[i]));let Ze;for(let i=0;i<Xe.length;i++)if(Xe[i]&&Xe[i].geometry){Ze=Xe[i];break}if(!Ze)return{pickingId:null,meshId:null,point:null};const Ye=Ze.geometry.desc.pickingIdAttribute;Be.length&&T===this._shader1&&(void 0!==Ze.getUniform("uPickingId")||Ze.geometry.data[Ye])&&(Ge=this._getPickingId(H,W,q,$,ye,Xe,_));const Qe=[],Je=[];if(Be.length&&b.returnPoint){const{viewMatrix:m,projMatrix:T}=b,P=this._pickDepth(H,W,q,$,ye,Xe,_);for(let _=0;_<P.length;_++)if(P[_]&&null!=Be[_]){const b=this._getWorldPos(i,g,P[_],m,T),I=this._convertPickPoint(b);Qe.push(b),Je.push(I)}else Qe.push(null),Je.push(null)}return{meshIds:Be,pickingIds:Ge,coords:Je,points:Qe,width:q,height:$}}_convertPickPoint(i){const g=this._map;if(!g)return null;const m=g.getGLRes();if(!tP){const i=g.getCenter();nP=new i.constructor(0,0,0);const m=g.coordToPoint(i);tP=new m.constructor(0,0)}tP.set(i[0],i[1]);const _=g.pointAtResToCoord(tP,m,nP),b=g.pointAtResToAltitude(i[2],m);return[_.x,_.y,b]}clear(){return this._fbo&&this._clearFbo(this._fbo),this._currentMeshes=[],delete this._currentShader,this}getMeshAt(i){return this._currentMeshes?this._currentMeshes[i]:null}getRenderedMeshes(){return this._currentMeshes}dispose(){this.clear(),this._shader0&&this._shader0.dispose(),this._shader1&&this._shader1.dispose(),this._shader2&&this._shader2.dispose(),this._scene&&this._scene.clear(),this._scene1&&this._scene1.clear()}_getWorldPos(i,g,m,_,b){const T=this._fbo,P=[],I=T.width/2||1,H=T.height/2||1,W=[(i-I)/I,(H-g)/H,0,1],q=[(i-I)/I,(H-g)/H,1,1],$=yA(P,b),ye=[],Re=[];fP(ye,W,$),fP(Re,q,$);const Be=-ye[2],Ge=(m-Be)/(-Re[2]-Be),je=yA(P,_A(P,b,_)),Xe=fP(W,W,je),Ze=fP(q,q,je);return[dx(Xe[0],Ze[0],Ge),dx(Xe[1],Ze[1],Ge),dx(Xe[2],Ze[2],Ge)]}_getPickingId(i,g,m,_,b,T,P){const I=this._renderer.device,H=this._getFBO1();this._clearFbo(H),this._scene1.setMeshes(T),this._renderer.render(this._shader2,P,this._scene1,H);const W=I.read({data:b,x:i,y:g,framebuffer:H,width:m,height:_}),q=[];for(let i=0;i<W.length;i+=4)q.push(JC(W.subarray(i,i+4)));return q}_pickDepth(i,g,m,_,b,T,P){const I=this._renderer.device,H=this._getFBO1();this._scene1.setMeshes(T),this._clearFbo(H),P.logDepthBufFC=2/(Math.log(this._map.cameraFar+1)/Math.LN2),this._renderer.render(this._depthShader,P,this._scene1,H);const W=I.read({data:b,x:i,y:g,framebuffer:H,width:m,height:_}),q=[];for(let i=0;i<W.length;i+=4)q.push(($=W.subarray(i,i+4),KC[0]=$[3],KC[1]=$[2],KC[2]=$[1],KC[3]=$[0],eP[0]));var $;return q}_packData(i,g){if(255===i[0]&&255===i[1]&&255===i[2]&&255===i[3])return{meshId:null,pickingId:null};let m=null,_=null;return g===this._shader1?_=JC(i):g===this._shader0?(_=i[3],m=JC(i)):(_=null,m=JC(i)),{meshId:_,pickingId:m}}_clearFbo(i){this._renderer.device.clear({color:[1,1,1,1],depth:1,stencil:255,framebuffer:i})}_getShader(i,g){return g&&i.length<256?this._shader0:this._shader1}_getFBO1(){const i=this._renderer.device,g=this._fbo;return this._fbo1?this._fbo1.width===g.width&&this._fbo1.height===g.height||this._fbo1.resize(g.width,g.height):this._fbo1=i.framebuffer(g.width,g.height),this._fbo1}_getParams(i,g,m,_){const b=m[0],T=m[1];g=_.height-g;let P=2*b+1,I=2*T+1;const H=(i-=b)+P,W=(g-=T)+I;return H>_.width&&(P-=H-_.width),W>_.height&&(I-=W-_.height),{px:i=i<0?0:i,py:g=g<0?0:g,width:P,height:I}}getPickingVert(){return this._vert}getPickingWGSLVert(){return this._wgslVert}getUniformDeclares(){return this._uniforms}},FogPass,FogShader,FxaaShader,GLTFHelper:mC,GLTFManager:class GLTFManager{constructor(i,g){this.regl=i,this.resourceMap={},this.options=g||{}}getGLTF(i){return this.resourceMap[i]}loginGLTF(i,g){if(this.resourceMap[i])this.resourceMap[i].refCount+=1;else{if(wC[i]){const g=function(i){let g=null;return wC[i]&&(g={meshes:wC[i].meshes},g.scenes=JSON.parse(JSON.stringify(wC[i].scenes))),g}(i);this.resourceMap[i]=this._exportGLTFResource(g,i,!1)}else this.resourceMap[i]=g?g(i).then((g=>(this.resourceMap[i]=this._exportGLTFResource(g,i),this.resourceMap[i]))):this._loadGLTFModel(i);this.resourceMap[i].refCount=1}}logoutGLTF(i){if(this.resourceMap[i]&&(this.resourceMap[i].refCount-=1,this.resourceMap[i].refCount<1)){const g=this.resourceMap[i].resources;if(g)for(let i=0;i<g.length;i++)g[i].geometry.dispose(),g[i].copyGeometry&&g[i].copyGeometry.dispose(),g[i].material&&g[i].material.dispose();this.resourceMap[i].gltfPack&&this.resourceMap[i].gltfPack.dispose(),delete this.resourceMap[i]}}isSimpleModel(i){return wC[i]}addSimpleModel(i,g){!function(i,g){"string"==typeof i&&bC.indexOf(i)<0&&(wC[i]=g)}(i,g)}removeSimpleModel(i){delete wC[i]}_exportGLTFResource(i,g,m=!0){if(!i)return null;const _=pC(i,m?this.regl:null),b=_.getMeshesInfo();return{bbox:_.getGLTFBBox(),gltfPack:_,resources:b,json:i.json,refCount:this.resourceMap[g]?this.resourceMap[g].refCount:0}}fetchGLTF(i){return dC(i,this.options).then((i=>i))}_loadGLTFModel(i){return this.fetchGLTF(i).then((g=>(this.resourceMap[i]=this._exportGLTFResource(g,i),this.resourceMap[i])))}},Geometry,GraphicsDevice,GraphicsFramebuffer,GraphicsTexture,HDR:vP,HeatmapDisplayShader,HeatmapShader,ImageShader,InstancedMesh,Jitter,KHRTechniquesWebglManager:class KHRTechniquesWebglManager{constructor(i,g,m){this._regl=i,this._khrShaders={},this._commandProps=g,this._resLoader=m}getExcludeFilter(){return pP}forEachShader(i){for(const g in this._khrShaders){const m=this._khrShaders[g];i(m.shader,m.filter,m.uniformSemantics)}}createMesh(i,g,m,_){const b=g.extensions.KHR_techniques_webgl,T=g.materials[i.material].extensions.KHR_techniques_webgl,{technique:P,values:I}=T,H=b.techniques[P],W=b.programs[H.program],q=b.shaders[W.vertexShader],$=b.shaders[W.fragmentShader];$.content=function(i){if(i&&i.indexOf("precision")<0)return"precision mediump float;\n"+i;return i}($.content);const ye=Cx(q.content)+"-"+Cx($.content);this._khrShaders[ye]||(this._khrShaders[ye]=this._createTechniqueShader(ye,b,P,this._commandProps,_));const{attributeSemantics:Re}=this._khrShaders[ye],Be=this._createGeometry(i,Re,m,ye),Ge=cx({},I);for(const i in I)if(H.uniforms[i]&&35678===H.uniforms[i].type){Ge[i]=this._getTexture(g.textures[I[i].index])}return{geometry:Be,material:new Material(Ge)}}_createGeometry(i,g,m,_){const b=i.attributes,T="COLOR_0";if(b[T]){const i=b[T].array||b[T];if(i instanceof Float32Array){const g=new Uint8Array(i.length);for(let m=0;m<g.length;m++)g[m]=Math.round(255*i[m]);b[T].array?(b[T].array=g,b[T].componentType=5121):b[T]=g}}const P={};for(const i in b){const m=Zb(this._regl,b[i],{dimension:b[i].itemSize,name:i}),_=g[i]||i;P[_]={buffer:m},b[i].quantization&&(P[_].quantization=b[i].quantization),_===g.POSITION&&(P[_].array=b[i].array)}const I=new Geometry(P,i.indices.array?i.indices.array:i.indices,0,{positionAttribute:g.POSITION,normalAttribute:g.NORMAL,uv0Attribute:g.TEXCOORD_0,uv1Attribute:g.TEXCOORD_1,color0Attribute:g.COLOR_0,tangentAttribute:g.TANGENT,textureCoordMatrixAttribute:g.TextureCoordMatrix,primitive:void 0===i.mode?"triangles":Lb(i.mode)});I.generateBuffers(this._regl,{excludeElementsInVAO:m}),I.properties.shaderHash=_;const H=I.data[I.desc.positionAttribute];return H&&H.array&&delete H.array,I}_getTexture(i){const g={type:i.type?Fb(i.type):"uint8",format:i.format?Bb(i.format):"rgba",flipY:!!i.flipY},m=i.image;m.array?g.data=m.array:m.mipmap&&(g.mipmap=m.mipmap),g.width=m.width,g.height=m.height;const _=i.sampler||i.texture.sampler;return _&&(_.magFilter&&(g.mag=Vb(_.magFilter)),_.minFilter&&(g.min=Gb(_.minFilter)),_.wrapS&&(g.wrapS=Wb(_.wrapS)),_.wrapT&&(g.wrapT=Wb(_.wrapT))),new Texture2D(g,this._resLoader)}_createTechniqueShader(i,g,m,_,b){const{techniques:T,programs:P,shaders:I}=g,H=T[m],W=P[H.program],q=I[W.vertexShader].content,$=I[W.fragmentShader].content,ye={};for(const i in H.uniforms){const g=H.uniforms[i];g.semantic&&(ye[g.semantic]=i)}const Re=AP.slice();for(const i in ye){Re.push({name:ye[i],type:"function",fn:(g,m)=>m[yP[i]]})}const Be=new MeshShader({vert:q,frag:$,uniforms:Re,extraCommandProps:_});b&&(Be.version=300);const Ge={};for(const i in H.attributes){Ge[H.attributes[i].semantic]=i}return{shader:Be,filter:g=>g&&g.geometry&&g.geometry.properties.shaderHash===i,uniformSemantics:ye,attributeSemantics:Ge}}dispose(){for(const i in this._khrShaders){const{shader:g}=this._khrShaders[i];g.dispose()}this._khrShaders={}}},Material,Mesh,MeshShader,PhongMaterial,PhongShader:class PhongShader extends MeshShader{constructor(i={}){const g=[],m=[],_=i.uniforms,b=[{name:"modelNormalMatrix",type:"function",fn:function(i,m){return sA(g,m.modelMatrix)}},{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(m,g.viewMatrix,g.modelMatrix)}}];_&&b.push(..._),super({name:"phong",vert:i.vert||"#include <gl2_vert>\nattribute vec3 aPosition;\n#include <line_extrusion_vert>\n#ifdef HAS_MAP\nuniform vec2 uvScale;\nuniform vec2 uvOffset;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n#ifdef HAS_I3S_UVREGION\nattribute vec4 uvRegion;\nvarying vec4 vUvRegion;\n#endif\n#if defined(HAS_AO_MAP)\nattribute vec2 aTexCoord1;\nvarying vec2 vTexCoord1;\n#endif\n#endif\n#if defined(HAS_COLOR)\nattribute vec4 aColor;\nvarying vec4 vColor;\n#elif defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nattribute vec3 aColor0;\n#else\nattribute vec4 aColor0;\n#endif\nvarying vec4 vColor;\n#endif\nvarying vec3 vFragPos;\nvarying vec3 vNormal;\nuniform mat4 projMatrix;\nuniform mat3 modelNormalMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 positionMatrix;\nuniform vec2 halton;\nuniform vec2 outSize;\nuniform mat4 projViewMatrix;\n#include <highlight_vert>\n#include <get_output>\n#include <heatmap_render_vert>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_vert>\n#endif\n#ifdef HAS_EXTRUSION_OPACITY\nattribute float aExtrusionOpacity;\nvarying float vExtrusionOpacity;\n#endif\n#if defined(HAS_TANGENT)\nvarying vec4 vTangent;\n#endif\nvoid c(const highp vec4 q, out highp vec3 d) {\n  d = vec3(.0, .0, 1.) + vec3(2., -2., -2.) * q.x * q.zwx + vec3(2., 2., -2.) * q.y * q.wzy;\n}\nvoid c(const highp vec4 q, out highp vec3 d, out highp vec3 t) {\n  c(q, d);\n  t = vec3(1., .0, .0) + vec3(-2., 2., -2.) * q.y * q.yxw + vec3(-2., 2., 2.) * q.z * q.zwx;\n}\n#include <vertex_color_vert>\nvoid main() {\n  \n#ifdef IS_LINE_EXTRUSION\nvec4 e = getPosition(getLineExtrudePosition(aPosition));\n#else\nvec4 e = getPosition(aPosition);\n#endif\nmat4 f = getPositionMatrix();\n  vFragPos = vec3(modelMatrix * f * e);\n#if defined(HAS_NORMAL) || defined(HAS_TANGENT)\nmat3 h = modelNormalMatrix * mat3(f);\n  vec3 i;\n#if defined(HAS_TANGENT)\nvec3 t;\n  c(aTangent, i, t);\n  vTangent = vec4(h * t, aTangent.w);\n#else\ni = decode_getNormal(aNormal);\n#endif\nvec3 j = appendMorphNormal(i);\n  vNormal = normalize(h * j);\n#else\nvNormal = vec3(.0);\n#endif\nmat4 k = projMatrix;\n  k[2].xy += halton.xy / outSize.xy;\n#ifdef HAS_MASK_EXTENT\ngl_Position = k * getMaskPosition(f * e, modelMatrix);\n#else\ngl_Position = k * modelViewMatrix * f * e;\n#endif\n#ifdef HAS_MAP\nvec2 l = decode_getTexcoord(aTexCoord);\n  vTexCoord = l * uvScale + uvOffset;\n#endif\n#ifdef HAS_AO_MAP\nvec2 m = decode_getTexcoord(aTexCoord1);\n  vTexCoord1 = m * uvScale + uvOffset;\n#endif\n#ifdef HAS_EXTRUSION_OPACITY\nvExtrusionOpacity = aExtrusionOpacity;\n#endif\n#if defined(HAS_COLOR)\nvColor = aColor / 255.;\n#elif defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nvColor = vec4(aColor0 / 255., 1.);\n#else\nvColor = aColor0 / 255.;\n#endif\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nshadow_computeShadowPars(f * e);\n#endif\n#ifdef HAS_HEATMAP\nheatmap_compute(projMatrix * modelViewMatrix * f, e);\n#endif\n#ifdef HAS_I3S_UVREGION\nvUvRegion = uvRegion / 65535.;\n#endif\nhighlight_setVarying();\n#ifdef HAS_VERTEX_COLOR\nvertexColor_update();\n#endif\n}",frag:i.frag||"precision mediump float;\n#include <gl2_frag>\nuniform vec4 baseColorFactor;\nuniform float materialShininess;\nuniform float environmentExposure;\nuniform float specularStrength;\nuniform vec3 light0_viewDirection;\nuniform vec3 ambientColor;\nuniform vec4 light0_diffuse;\nuniform vec3 lightSpecular;\nuniform vec3 cameraPosition;\nuniform float alphaTest;\n#ifdef HAS_TOON\nuniform float toons;\nuniform float specularToons;\n#endif\n#ifdef HAS_TANGENT\nvarying vec4 vTangent;\n#endif\n#ifdef HAS_MAP\n#include <compute_texcoord_frag>\n#endif\nvarying vec3 vNormal;\nvarying vec3 vFragPos;\n#ifdef HAS_INSTANCE_COLOR\nvarying vec4 vInstanceColor;\n#endif\n#ifdef HAS_BASECOLOR_MAP\nuniform sampler2D baseColorTexture;\n#endif\n#ifdef HAS_EXTRUSION_OPACITY\nuniform vec2 extrusionOpacityRange;\nvarying float vExtrusionOpacity;\n#endif\n#if defined(HAS_COLOR) || defined(HAS_COLOR0)\nvarying vec4 vColor;\n#elif defined(IS_LINE_EXTRUSION)\nuniform vec4 lineColor;\n#else\nuniform vec4 polygonFill;\n#endif\n#ifdef HAS_LAYER_OPACITY\nuniform float layerOpacity;\n#endif\n#ifdef IS_LINE_EXTRUSION\nuniform float lineOpacity;\n#else\nuniform float polygonOpacity;\n#endif\n#ifdef HAS_AO_MAP\nuniform sampler2D occlusionTexture;\nvarying vec2 vTexCoord1;\n#endif\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D normalTexture;\n#endif\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D emissiveTexture;\n#endif\n#ifdef SHADING_MODEL_SPECULAR_GLOSSINESS\nuniform vec4 diffuseFactor;\nuniform vec3 specularFactor;\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D diffuseTexture;\n#endif\n#ifdef HAS_SPECULARGLOSSINESS_MAP\nuniform sampler2D specularGlossinessTexture;\n#endif\n#endif\n#include <heatmap_render_frag>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_frag>\n#endif\n#include <highlight_frag>\n#include <mask_frag>\n#include <vertex_color_frag>\nvec3 c() {\n  \n#if defined(HAS_NORMAL_MAP)\nvec3 d = normalize(vNormal);\n  vec3 e = texture2D(normalTexture, computeTexCoord(vTexCoord)).xyz * 2. - 1.;\n#if defined(HAS_TANGENT)\nvec3 t = normalize(vTangent.xyz);\n  vec3 b = normalize(cross(d, t) * sign(vTangent.w));\n  mat3 f = mat3(t, b, d);\n  return normalize(f * e);\n#else\nreturn normalize(e);\n#endif\n#else\nreturn normalize(vNormal);\n#endif\n}\nvec4 h() {\n  \n#if defined(HAS_BASECOLOR_MAP)\nreturn texture2D(baseColorTexture, computeTexCoord(vTexCoord));\n#elif defined(HAS_DIFFUSE_MAP)\nreturn texture2D(diffuseTexture, computeTexCoord(vTexCoord));\n#elif defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nreturn diffuseFactor;\n#else\nreturn baseColorFactor;\n#endif\n}\nvec3 i() {\n  \n#if defined(HAS_SPECULARGLOSSINESS_MAP)\nreturn texture2D(specularGlossinessTexture, computeTexCoord(vTexCoord)).rgb;\n#elif defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nreturn specularFactor;\n#else\nreturn vec3(1.);\n#endif\n}\nvoid main() {\n  vec4 j = h();\n#ifdef SHADING_MODEL_UNLIT\nvec3 k = vec3(1.);\n#else\nvec3 k = ambientColor;\n#endif\nvec3 l = environmentExposure * k * j.rgb;\n#ifdef HAS_INSTANCE_COLOR\nl *= vInstanceColor.rgb;\n#endif\nvec3 m = c();\n  vec3 o = normalize(-light0_viewDirection);\n  float u = max(dot(m, o), .0);\n#ifdef HAS_TOON\nfloat v = floor(u * toons);\n  u = v / toons;\n#endif\n#ifdef SHADING_MODEL_UNLIT\nvec3 A = vec3(.0);\n#else\nvec3 A = light0_diffuse.rgb;\n#endif\nvec3 B = A * u * j.rgb;\n#if defined(HAS_COLOR) || defined(HAS_COLOR0)\nvec3 C = vColor.rgb;\n#elif defined(IS_LINE_EXTRUSION)\nvec3 C = lineColor.rgb;\n#else\nvec3 C = polygonFill.rgb;\n#endif\n#ifdef HAS_INSTANCE_COLOR\nC *= vInstanceColor.rgb;\n#endif\nl *= C.rgb;\n  B *= C.rgb;\n  vec3 D = normalize(cameraPosition - vFragPos);\n  vec3 E = normalize(o + D);\n  float F = pow(max(dot(m, E), .0), materialShininess);\n#ifdef HAS_TOON\nfloat G = floor(F * specularToons);\n  F = G / specularToons;\n#endif\n#ifdef SHADING_MODEL_UNLIT\nvec3 H = vec3(.0);\n#else\nvec3 H = lightSpecular;\n#endif\nvec3 I = specularStrength * H * F * i();\n#ifdef HAS_OCCLUSION_MAP\nfloat J = texture2D(occlusionTexture, computeTexCoord(vTexCoord1)).r;\n  l *= J;\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nfloat K = shadow_computeShadow();\n  B = shadow_blend(B, K).rgb;\n  I = shadow_blend(I, K).rgb;\n  l = shadow_blend(l, K).rgb;\n#endif\nvec3 L = l + B + I;\n#ifdef HAS_EMISSIVE_MAP\nvec3 M = texture2D(emissiveTexture, computeTexCoord(vTexCoord)).rgb;\n  L += M;\n#endif\n#ifdef IS_LINE_EXTRUSION\nglFragColor = vec4(L, lineOpacity * j.a);\n#else\nglFragColor = vec4(L, polygonOpacity * j.a);\n#endif\n#if defined(HAS_COLOR) || defined(HAS_COLOR0)\nfloat N = vColor.a;\n#elif defined(IS_LINE_EXTRUSION)\nfloat N = lineColor.a;\n#else\nfloat N = polygonFill.a;\n#endif\nglFragColor *= N;\n#ifdef HAS_EXTRUSION_OPACITY\nfloat O = extrusionOpacityRange.x;\n  float P = extrusionOpacityRange.y;\n  float Q = O + vExtrusionOpacity * (P - O);\n  Q = clamp(Q, .0, 1.);\n  glFragColor *= Q;\n#endif\nif(glFragColor.a < alphaTest) {\n    discard;\n  }\n#ifdef HAS_VERTEX_COLOR\nglFragColor *= vertexColor_get();\n#endif\n#ifdef HAS_HEATMAP\nglFragColor = heatmap_getColor(glFragColor);\n#endif\nglFragColor = highlight_blendColor(glFragColor);\n#ifdef HAS_LAYER_OPACITY\nglFragColor *= layerOpacity;\n#endif\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",wgslVert:"",wgslFrag:"",uniforms:b,defines:i.defines||{},extraCommandProps:i.extraCommandProps||{}}),this.version=300}getGeometryDefines(i){const g={};return i.data[i.desc.tangentAttribute]?g.HAS_TANGENT=1:i.data[i.desc.normalAttribute]&&(g.HAS_NORMAL=1),g}},PhongSpecularGlossinessMaterial,Plane,PointLineShader:class PointLineShader extends MeshShader{constructor(i={}){const g=[];super({vert:"attribute vec3 aPosition;\n#ifdef HAS_COLOR0\nattribute vec4 aColor0;\nvarying vec4 vColor;\n#endif\nuniform mat4 modelMatrix;\nuniform mat4 projMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 projViewModelMatrix;\nuniform float pointSize;\n#if defined(HAS_MAP)\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n#endif\n#include <get_output>\n#include <heatmap_render_vert>\n#ifdef HAS_FLOODANALYSE\nvarying float vHeight;\n#endif\nvoid main() {\n  vec4 c = getPosition(aPosition);\n  mat4 d = getPositionMatrix();\n  gl_PointSize = pointSize;\n#ifdef HAS_MASK_EXTENT\ngl_Position = projMatrix * getMaskPosition(d * c, modelMatrix);\n#else\ngl_Position = projViewModelMatrix * d * c;\n#endif\n#ifdef HAS_COLOR0\nvColor = aColor0 / 255.;\n#endif\n#ifdef HAS_MAP\nvTexCoord = aTexCoord;\n#endif\n#ifdef HAS_HEATMAP\nheatmap_compute(projMatrix * modelViewMatrix * d, c);\n#endif\n}",frag:"precision mediump float;\n#include <gl2_frag>\n#if defined(HAS_COLOR0)\nvarying vec4 vColor;\n#endif\n#include <heatmap_render_frag>\nuniform vec4 baseColorFactor;\n#if defined(HAS_MAP)\n#if defined(HAS_ALBEDO_MAP)\nuniform sampler2D baseColorTexture;\n#endif\n#if defined(HAS_DIFFUSE_MAP)\nuniform sampler2D diffuseTexture;\n#endif\nvarying vec2 vTexCoord;\n#endif\n#include <mask_frag>\nvoid main() {\n  \n#ifdef HAS_COLOR0\nglFragColor = vColor * baseColorFactor;\n#else\nglFragColor = vec4(1.) * baseColorFactor;\n#endif\n#ifdef HAS_MAP\n#ifdef HAS_ALBEDO_MAP\nglFragColor *= texture2D(baseColorTexture, vTexCoord);\n#endif\n#ifdef HAS_DIFFUSE_MAP\nglFragColor *= texture2D(diffuseTexture, vTexCoord);\n#endif\n#endif\n#ifdef HAS_HEATMAP\nglFragColor = heatmap_getColor(glFragColor);\n#endif\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",uniforms:[{name:"projViewModelMatrix",type:"function",fn:(i,m)=>_A(g,m.projViewMatrix,m.modelMatrix)}],defines:i.defines||{},extraCommandProps:i.extraCommandProps||{}})}},PostProcessShader,QuadShader,REGLHelper:Yb,RainRipplesPass:RainRipplePass,Renderer,ResourceLoader,ScanEffectPass,ScanEffectShader:EffectShader,Scene,Shader:GPUShader,ShaderLib:VS,ShadowDisplayShader,ShadowMapShader,ShadowPass,SkyboxShader,SsrPass,StandardLiteMaterial:class StandardLiteMaterial extends Material{constructor(i){super(i,aw)}appendDefines(i,g){super.appendDefines(i,g);const m=this.uniforms;m.extrusionOpacity&&(i.HAS_EXTRUSION_OPACITY=1),g.data[g.desc.colorAttribute]&&(i.HAS_COLOR=1);return g.data[g.desc.color0Attribute]&&(i.HAS_COLOR0=1,i.COLOR0_SIZE=g.getColor0Size()),g.data[g.desc.uv0Attribute]?(m.baseColorTexture&&(i.HAS_BASECOLOR_MAP=1),m.occlusionTexture&&g.data[g.desc.uv1Attribute]&&(i.HAS_AO_MAP=1),m.emissiveTexture&&(i.HAS_EMISSIVE_MAP=1),m.normalTexture&&(i.HAS_NORMAL_MAP=1),(i.HAS_BASECOLOR_MAP||i.HAS_AO_MAP||i.HAS_EMISSIVE_MAP||i.HAS_NORMAL_MAP)&&(i.HAS_MAP=1),i.ALPHATEST=.01,i.GAMMA_INPUT=1,i.GAMMA_FACTOR=1,i.TONEMAP_OUTPUT=1,i.ENVMAP_MODE_REFLECTION=1,i.ENV_RGBM=1,i.IRR_RGBM=1,i):i}},StandardLiteShader:class StandardLiteShader extends MeshShader{constructor(i={}){const g=[],m=i.uniforms,_=[{name:"viewMatrixInverse",type:"function",fn:(i,g)=>yA(VM,g.viewMatrix)},{name:"modelViewMatrix",type:"function",fn:function(i,m){return _A(g,m.viewMatrix,m.modelMatrix)}},{name:"environmentTransform",type:"function",fn:(i,g)=>uA(UM,Math.PI*(g.environmentOrientation||0)/180)}];m&&_.push(...m),super({vert:"precision mediump float;\n#include <gl2_vert>\nattribute vec3 aPosition;\n#include <line_extrusion_vert>\n#ifdef HAS_MAP\nuniform vec2 uvScale;\nuniform vec2 uvOffset;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n#ifdef HAS_I3S_UVREGION\nattribute vec4 uvRegion;\nvarying vec4 vUvRegion;\n#endif\n#endif\n#if defined(HAS_COLOR)\nattribute vec4 aColor;\n#elif defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nattribute vec3 aColor0;\n#else\nattribute vec4 aColor0;\n#endif\nvarying vec4 vColor;\n#endif\nuniform mat4 projMatrix;\nuniform mat3 modelNormalMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 positionMatrix;\nuniform vec2 halton;\nuniform vec2 outSize;\nuniform mat4 projViewMatrix;\n#include <get_output>\n#include <heatmap_render_vert>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_vert>\n#endif\nvarying vec3 vViewPosition;\nvoid main() {\n  \n#ifdef IS_LINE_EXTRUSION\nvec4 c = getPosition(getLineExtrudePosition(aPosition));\n#else\nvec4 c = getPosition(aPosition);\n#endif\nmat4 d = getPositionMatrix();\n  mat4 e = projMatrix;\n  e[2].xy += halton.xy / outSize.xy;\n#ifdef HAS_MASK_EXTENT\ngl_Position = e * getMaskPosition(d * c, modelMatrix);\n#else\ngl_Position = e * modelViewMatrix * d * c;\n#endif\nvec4 f = modelViewMatrix * d * c;\n  vViewPosition = -f.xyz;\n#ifdef HAS_MAP\nvec2 h = decode_getTexcoord(aTexCoord);\n  vTexCoord = h * uvScale + uvOffset;\n#endif\n#if defined(HAS_COLOR)\nvColor = aColor / 255.;\n#elif defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nvColor = vec4(aColor0 / 255., 1.);\n#else\nvColor = aColor0 / 255.;\n#endif\n#endif\n}",frag:"#if __VERSION__ == 100\n#if defined(GL_EXT_shader_texture_lod)\n#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod(tex, uv, lod) textureCubeLodEXT(tex, uv, lod)\n#else\n#define textureCubeLod(tex, uv, lod) textureCube(tex, uv, lod)\n#endif\n#if defined(GL_OES_standard_derivatives)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#else\n#define textureCubeLod(tex, uv, lod) textureLod(tex, uv, lod)\n#endif\n#define saturate(x)        clamp(x, 0.0, 1.0)\nprecision mediump float;\n#include <gl2_frag>\n#include <hsv_frag>\nuniform vec3 hsv;\n#define GET_BASEMAP(UV) (texture2D(baseColorTexture, (UV)))\nuniform mat4 viewMatrix;\nuniform mat4 projMatrix;\nuniform vec3 cameraPosition;\n#if defined(HAS_IBL_LIGHTING)\nuniform mat4 viewMatrixInverse;\n#endif\nuniform vec4 baseColorFactor;\nuniform vec3 emissiveFactor;\nuniform vec3 specularFactor;\nuniform float opacity;\nuniform float envRotationSin;\nuniform float envRotationCos;\nuniform float rgbmRange;\n#if defined(HAS_MAP)\n#include <compute_texcoord_frag>\n#endif\n#ifdef HAS_BASECOLOR_MAP\nuniform sampler2D baseColorTexture;\n#endif\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D normalTexture;\nvec3 c(vec3 d, vec3 e) {\n  vec3 f = dFdx(d.xyz);\n  vec3 h = dFdy(d.xyz);\n  vec3 i = normalize(f - h);\n  vec3 j = normalize(-f + h);\n  vec3 k = normalize(e);\n  vec3 l = texture2D(normalTexture, computeTexCoord(vTexCoord)).rgb * 2. - 1.;\n  mat3 m = mat3(i, j, k);\n  return normalize(m * l);\n}\n#endif\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D emissiveTexture;\n#endif\n#ifdef SHADING_MODEL_SPECULAR_GLOSSINESS\nuniform vec4 diffuseFactor;\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D diffuseTexture;\n#endif\n#ifdef HAS_SPECULARGLOSSINESS_MAP\nuniform sampler2D specularGlossinessTexture;\n#endif\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_frag>\n#endif\n#if defined(HAS_COLOR) || defined(HAS_COLOR0)\nvarying vec4 vColor;\n#endif\n#ifdef GAMMA_INPUT\nvec3 n(vec3 o) {\n  return o * o;\n}\nfloat n(float o) {\n  return o * o;\n}\n#else\nvec3 n(vec3 o) {\n  return o;\n}\nfloat n(float o) {\n  return o;\n}\n#endif\nvec3 u() {\n  \n#ifdef SHADING_MODEL_SPECULAR_GLOSSINESS\n#ifdef HAS_SPECULARGLOSSINESS_MAP\nreturn texture2D(specularGlossinessTexture, computeTexCoord(vTexCoord)).rgb;\n#else\nreturn specularFactor;\n#endif\n#else\nreturn specularFactor;\n#endif\n}\nvec3 v() {\n  \n#ifdef HAS_EMISSIVE_MAP\nreturn texture2D(emissiveTexture, computeTexCoord(vTexCoord)).rgb;\n#else\nreturn emissiveFactor;\n#endif\n}\n#if defined(TONEMAP_OUTPUT)\n#if TONEMAP_OUTPUT > 0\nuniform float exposureBias;\nfloat A(vec3 rgb) {\n  return dot(rgb, vec3(.299, .587, .114));\n}\nfloat B(vec3 rgb) {\n  return dot(rgb, vec3(.212671, .715160, .072169));\n}\nvec3 C(vec3 xyz) {\n  vec3 D = vec3(3.240479, -1.53715, -.498535);\n  vec3 E = vec3(-.969256, 1.875992, .041556);\n  vec3 F = vec3(.055648, -.204043, 1.057311);\n  vec3 rgb;\n  rgb.b = dot(xyz, F);\n  rgb.g = dot(xyz, E);\n  rgb.r = dot(xyz, D);\n  return rgb;\n}\nvec3 H(vec3 rgb) {\n  vec3 I = vec3(.412453, .35758, .180423);\n  vec3 J = vec3(.212671, .71516, .0721688);\n  vec3 K = vec3(.0193338, .119194, .950227);\n  vec3 xyz;\n  xyz.x = dot(rgb, I);\n  xyz.y = dot(rgb, J);\n  xyz.z = dot(rgb, K);\n  return xyz;\n}\nvec3 L(vec3 xyz) {\n  float M = xyz.x + xyz.y + xyz.z;\n  M = 1. / M;\n  vec3 O;\n  O.z = xyz.y;\n  O.x = xyz.x * M;\n  O.y = xyz.y * M;\n  return O;\n}\nvec3 P(vec3 O) {\n  float x = O.x;\n  float y = O.y;\n  float J = O.z;\n  vec3 xyz;\n  xyz.y = J;\n  xyz.x = x * (J / y);\n  xyz.z = (1. - x - y) * (J / y);\n  return xyz;\n}\nfloat Q(float x) {\n  float U = pow(x, 1.60525727);\n  float V = ((1.05542877 * 4.68037409) * U) / (4.68037409 * U + 1.);\n  return clamp(V, .0, 1.);\n}\nconst float W = 1. / .18;\nfloat ba(float x) {\n  x *= W;\n  const float bb = .2;\n  const float F = .34;\n  const float bc = .002;\n  const float bd = 1.68;\n  const float be = .0005;\n  const float bf = .252;\n  const float bg = 1. / .833837;\n  return ((x * (bb * x + bc * F) + bd * be) / (x * (bb * x + F) + bd * bf) - be / bf) * bg;\n}\nvec3 bh(vec3 x) {\n  x *= W;\n  const float bb = .27;\n  const float F = .29;\n  const float bc = .052;\n  const float bd = .2;\n  const float bf = .18;\n  const float bg = 1. / .897105;\n  return ((x * (bb * x + bc * F)) / (x * (bb * x + F) + bd * bf)) * bg;\n}\nvec3 bi(vec3 x) {\n  vec3 bj = x.rgb;\n  bj = min(bj, vec3(3.));\n  float bk = B(bj);\n  if(bk > .0) {\n    float bl = Q(bk);\n    bj = bj * (bl / bk);\n    bj = clamp(bj, vec3(.0), vec3(1.));\n  }\n  float bm = 1. / 2.2;\n  bj = pow(bj, vec3(bm));\n  return bj;\n}\n#endif\n#endif\n#if defined(IRR_RGBM) || defined(ENV_RGBM) || defined(ENV_GAMMA) || defined(IRR_GAMMA)\nuniform float envMapExposure;\n#endif\nuniform vec4 themingColor;\nuniform mat3 environmentTransform;\nvec3 bn(vec3 bo, vec3 bp) {\n  \n#if defined(HAS_SHADOWMAP)\nfloat bq = dot(shadowLightDir, bp);\n  float br = (bq + 1.) / 2.;\n  br = min(1., br * 1.5);\n  float bs = 1.;\n  vec3 bt = bo * min(bs, br);\n  return bt;\n#else\nreturn bo;\n#endif\n}\n#ifdef HAS_IBL_LIGHTING\nuniform float reflectivity;\nuniform vec3 hdrHSV;\nuniform samplerCube prefilterMap;\nuniform vec3 diffuseSPH[9];\nuniform vec2 prefilterMiplevel;\nuniform vec2 prefilterSize;\n#else\nuniform vec3 ambientColor;\n#endif\n#if defined(HAS_IBL_LIGHTING)\nvec3 bu(const in vec3 bv) {\n  vec3 bw = environmentTransform * bv;\n  float x = bw.x;\n  float y = bw.y;\n  float z = bw.z;\n  vec3 bt = (diffuseSPH[0] + diffuseSPH[1] * x + diffuseSPH[2] * y + diffuseSPH[3] * z + diffuseSPH[4] * z * x + diffuseSPH[5] * y * z + diffuseSPH[6] * y * x + diffuseSPH[7] * (3. * z * z - 1.) + diffuseSPH[8] * (x * x - y * y));\n  if(length(hdrHSV) > .0) {\n    bt = hsv_apply(bt, hdrHSV);\n  }\n  return max(bt, vec3(.0));\n}\nvec3 bx(const in vec4 by, const in float bz) {\n  if(bz <= .0)\n    return by.rgb;\n  return bz * by.rgb * by.a;\n}\nfloat bA(const in float bB) {\n  return bB;\n}\nvec3 bC(const in float bD, const in vec3 D) {\n  vec3 bE = D;\n  float bF = prefilterMiplevel.x;\n  float bG = min(bF, bA(bD) * prefilterMiplevel.y);\n  vec3 bH = bx(textureCubeLod(prefilterMap, bE, bG), rgbmRange);\n  if(length(hdrHSV) > .0) {\n    return hsv_apply(bH, hdrHSV);\n  } else {\n    return bH;\n  }\n}\nvec3 bI(const in vec3 k, const in vec3 D, const in float bJ) {\n  float bK = 1. - bJ;\n  float bL = bK * (sqrt(bK) + bJ);\n  return mix(k, D, bL);\n}\nvec3 bM(const in vec3 bv, const in vec3 bN, const in float bO, const in vec3 bP) {\n  vec3 D = reflect(-bN, bv);\n  D = bI(bv, D, bO);\n  vec3 bQ = bC(bO, environmentTransform * D);\n  float bR = clamp(1. + dot(D, bP), .0, 1.);\n  bQ *= bR * bR;\n  return bQ;\n}\n#else\nvec3 bM(const in vec3 bv, const in vec3 bN, const in float bO, const in vec3 bP) {\n  return ambientColor;\n}\n#endif\nvarying highp vec3 vViewPosition;\nvec3 bS(vec3 bT, float bU) {\n  float bV = max(1. - bU, .0);\n  return bT + (1. - bT) * pow(bV, 5.);\n}\nfloat bW(float bT, float bU) {\n  float bV = max(1. - bU, .0);\n  return bT + (1. - bT) * pow(bV, 5.);\n}\n#include <srgb_frag>\nvoid main() {\n  glFragColor = vec4(vec3(1.), opacity);\n#ifdef HAS_BASECOLOR_MAP\nvec4 bX = GET_BASEMAP(computeTexCoord(vTexCoord));\n#ifdef GAMMA_INPUT\nbX.xyz *= bX.xyz;\n#endif\nglFragColor = glFragColor * bX;\n#endif\n#ifdef ALPHATEST\nif(glFragColor.a < ALPHATEST)\n    discard;\n  \n#endif\nfloat bY = 1.;\n  vec3 bZ = dFdx(vViewPosition);\n  vec3 ca = dFdy(vViewPosition);\n  vec3 bv = normalize(cross(bZ, ca));\n  vec3 cb;\n  if(projMatrix[3][3] == .0) {\n    cb = normalize(vViewPosition);\n  } else {\n    cb = vec3(.0, .0, 1.);\n  }\n  bv = faceforward(bv, -cb, bv);\n  vec3 cc = bv;\n#ifdef HAS_NORMAL_MAP\nbv = c(-vViewPosition, bv);\n#endif\nvec3 cd = vec3(.0);\n  vec3 ce = vec3(.0);\n#ifdef HAS_IBL_LIGHTING\nvec3 bp = mat3(viewMatrixInverse) * bv;\n  vec3 cf = glFragColor.rgb * bu(bp) * .5;\n  cf = bn(cf, bp);\n  cd += n(baseColorFactor.rgb) * cf;\n#endif\nvec3 cg = v();\n#ifdef METAL\nglFragColor.xyz = glFragColor.xyz * (n(cg) + cd + n(baseColorFactor.rgb) + ce);\n#else\nglFragColor.xyz = glFragColor.xyz * (n(cg) + cd + n(baseColorFactor.rgb)) + ce;\n#endif\nvec3 ch;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nfloat ci = shadow_computeShadow();\n  ch = shadow_blend(ch, ci).rgb;\n#endif\n#ifdef HAS_COLOR\nglFragColor = glFragColor * vColor;\n#endif\nglFragColor.rgb += ch;\n  glFragColor.rgb = linearTosRGB(glFragColor.rgb);\n#if defined(HAS_IBL_LIGHTING)\nvec3 cj;\n#if defined(HAS_NORMAL_MAP)\n#ifdef ENVMAP_MODE_REFLECTION\ncj = reflect(-cb, bv);\n#else\ncj = refract(-cb, bv, 1.);\n#endif\n#else\ncj = reflect(-cb, bv);\n#endif\ncj = mat3(viewMatrixInverse) * cj;\n  float ck = 1.;\n  vec3 cl;\n#ifdef HAS_IBL_LIGHTING\ncl = vec3(.0);\n#elif\ncl = ambientColor;\n#endif\ncl *= ck;\n  float bV = dot(cb, bv);\n  if(bV < -1e-2 || reflectivity == .0)\n    bV = 1.;\n  else\n    bV = max(1e-6, bV);\n  vec3 cm;\n  vec3 cn = u();\n#ifdef METAL\ncm = n(cn);\n#else\ncm = bS(n(cn), bV) * (1. - envRotationSin);\n  glFragColor.a = mix(glFragColor.a, bW(glFragColor.a, bV), reflectivity) * envRotationCos;\n  float co = pow(1. - bV * .5, 5.);\n  float cp = (28. / 23.) * (1. - co) * (1. - co);\n  glFragColor.rgb *= cp * (1. - n(cn));\n#endif\nglFragColor.rgb += cl.rgb * bY * cm.rgb;\n#endif\n#if defined(TONEMAP_OUTPUT)\n#if TONEMAP_OUTPUT == 1\nglFragColor.rgb = bi(exposureBias * glFragColor.rgb);\n#elif TONEMAP_OUTPUT == 2\nglFragColor.rgb = bh(exposureBias * glFragColor.rgb);\n#endif\n#endif\nglFragColor.rgb = mix(glFragColor.rgb, themingColor.rgb, themingColor.a);\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",uniforms:_,defines:i.defines||{},extraCommandProps:i.extraCommandProps||{}}),this.version=300}},Texture2D,Util:Ex,WGSLParseDefines:mM,WaterShader:class WaterShader extends MeshShader{constructor(i={}){super({vert:"const float c = 3.141592653589793;\nuniform mat4 projMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nattribute vec3 aNormal;\nvarying vec2 vuv;\nvarying vec3 vpos;\nvarying vec3 vnormal;\nvarying mat3 vtbnMatrix;\nvec4 d(mat4 e, mat4 f, vec3 h) {\n  return e * modelMatrix * f * vec4(h, 1.);\n}\nvec3 i(in vec3 h, in vec3 j) {\n  return normalize(h + j);\n}\nmat3 k(in vec3 l) {\n  vec3 t = normalize(cross(vec3(.0, .0, 1.), l));\n  vec3 b = normalize(cross(l, t));\n  return mat3(t, b, l);\n}\nvoid m() {\n  \n}\nvoid main(void) {\n  vuv = aTexCoord;\n  vpos = (modelMatrix * vec4(aPosition, 1.)).xyz;\n  vnormal = aNormal;\n  vtbnMatrix = k(vnormal);\n  gl_Position = d(projMatrix, viewMatrix, vpos);\n  m();\n}",frag:"precision highp float;\nprecision highp sampler2D;\nuniform sampler2D texWaveNormal;\nuniform sampler2D texWavePerturbation;\nuniform vec3 octaveTextureRepeat;\nuniform vec4 waveParams;\nuniform vec2 waveDirection;\nuniform vec4 waterColor;\nuniform vec3 lightingDirection;\nuniform vec3 lightingIntensity;\nuniform vec3 camPos;\nuniform float timeElapsed;\nvarying vec2 vuv;\nvarying vec3 vpos;\nvarying vec3 vnormal;\nvarying mat3 vtbnMatrix;\nconst vec2 c = vec2(6. / 25., 5. / 24.);\nvec2 d(sampler2D e, vec2 f) {\n  return 2. * texture2D(e, f).rg - 1.;\n}\nfloat h(vec2 f) {\n  return texture2D(texWavePerturbation, f).b;\n}\nvec3 i(sampler2D e, vec2 f) {\n  return 2. * texture2D(e, f).rgb - 1.;\n}\nfloat j(vec2 f, float k) {\n  return fract(k);\n}\nfloat l(vec2 f, float k) {\n  float m = j(f, k);\n  return 1. - abs(1. - 2. * m);\n}\nvec3 n(sampler2D o, vec2 f, float k, float u) {\n  float v = waveParams[2];\n  float A = waveParams[3];\n  vec2 B = d(o, f) * v;\n  float m = j(f, k + u);\n  float C = l(f, k + u);\n  vec2 D = f;\n  D -= B * (m + A);\n  D += u;\n  D += (k - m) * c;\n  return vec3(D, C);\n}\nconst float E = .3737;\nconst float F = 7.77;\nvec3 G(sampler2D H, sampler2D I, vec2 f, vec2 J, float k) {\n  float K = waveParams[0];\n  vec2 L = k * -J;\n  float M = h(f * E) * F;\n  vec3 N = n(I, f + L, k + M, .0);\n  vec3 O = n(I, f + L, k + M, .5);\n  vec3 P = i(H, N.xy) * N.z;\n  vec3 Q = i(H, O.xy) * O.z;\n  vec3 R = normalize(P + Q);\n  R.xy *= K;\n  R.z = sqrt(1. - dot(R.xy, R.xy));\n  return R;\n}\nvec3 S(vec2 f, float k) {\n  float T = waveParams[1];\n  return G(texWaveNormal, texWavePerturbation, f * T, waveDirection, k);\n}\nconst float U = 3.141592653589793;\nconst float V = 1. / U;\nconst float W = .3183098861837907;\nconst float X = 1.570796326794897;\nstruct PBRShadingWater {\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float VdotH;\n  float LdotH;\n  float VdotN;\n};\nfloat Y = 2.2;\nvec3 Z(float ba, vec3 bb, float bc) {\n  return bb + (bc - bb) * pow(1. - ba, 5.);\n}\nfloat bd(float be, float bf) {\n  float bg = bf * bf;\n  float bh = be * be;\n  float bi = pow((bh * (bg - 1.) + 1.), Y) * U;\n  return bg / bi;\n}\nfloat bj(float bk) {\n  return .25 / (bk * bk);\n}\nvec3 bl(in PBRShadingWater bm, float bf, vec3 bn, float bo) {\n  vec3 bp = Z(bm.VdotH, bn, bo);\n  float bq = bd(bm.NdotH, bf);\n  float br = bj(bm.LdotH);\n  return (bq * br) * bp;\n}\nvec3 bs(const vec3 x) {\n  return (x * (2.51 * x + .03)) / (x * (2.43 * x + .59) + .14);\n}\nconst float bt = 2.2;\nconst float bu = .4545454545;\nvec4 bv(vec4 bw) {\n  return vec4(pow(bw.rgb, vec3(bu)), bw.w);\n}\nvec3 bx(vec3 bw) {\n  return pow(bw, vec3(bt));\n}\nconst vec3 by = vec3(.02, 1., 5.);\nconst vec2 bz = vec2(.02, .1);\nconst float bf = .06;\nconst vec3 bA = vec3(0, .6, .9);\nconst vec3 bB = vec3(.72, .92, 1.);\nPBRShadingWater bC;\nvec3 bD(in float bE, in vec3 bF, in vec3 bG) {\n  float bH = pow((1. - bE), by[2]);\n  return mix(bG, bF, bH);\n}\nvec3 bI(in vec3 bJ, in vec3 bK, in vec3 bL, vec3 bw, in vec3 bM, in vec3 bN, in float bO) {\n  vec3 bP = bx(bw);\n  vec3 bQ = normalize(bL + bK);\n  bC.NdotL = clamp(dot(bJ, bL), .0, 1.);\n  bC.NdotV = clamp(dot(bJ, bK), .001, 1.);\n  bC.VdotN = clamp(dot(bK, bJ), .001, 1.);\n  bC.NdotH = clamp(dot(bJ, bQ), .0, 1.);\n  bC.VdotH = clamp(dot(bK, bQ), .0, 1.);\n  bC.LdotH = clamp(dot(bL, bQ), .0, 1.);\n  float bR = max(dot(bN, bK), .0);\n  vec3 bS = bx(bB);\n  vec3 bT = bx(bA);\n  vec3 bB = bD(bR, bS, bT);\n  float bU = max(dot(bN, bL), .0);\n  bB *= .1 + bU * .9;\n  float bV = clamp(bO, .8, 1.);\n  vec3 bW = Z(bC.VdotN, vec3(by[0]), by[1]) * bB * bV;\n  vec3 bX = bP * mix(bB, bU * bM * V, 2. / 3.) * bV;\n  vec3 bY = vec3(.0);\n  if(bR > .0 && bU > .0) {\n    vec3 bZ = bl(bC, bf, vec3(bz[0]), bz[1]);\n    vec3 ca = bM * V * bO;\n    bY = bC.NdotL * ca * bZ;\n  }\n  return bs(bW + bX + bY);\n}\nvoid main() {\n  vec3 bN = vnormal;\n  vec3 cb = S(vuv, timeElapsed);\n  vec3 bJ = normalize(vtbnMatrix * cb);\n  vec3 bK = -normalize(vpos - camPos);\n  vec3 bL = normalize(-lightingDirection);\n  float bO = 1.;\n  vec4 cc = vec4(bI(bJ, bK, bL, waterColor.rgb, lightingIntensity, bN, bO), waterColor.w);\n  gl_FragColor = bv(cc);\n}",defines:i.defines||{},extraCommandProps:i.extraCommandProps||{}})}},WebGLConstants:BS,WgslShaderLib:ZS,WireFrameMaterial:class WireFrameMaterial extends Material{constructor(i){super(i,ow)}},WireframeShader:class WireframeShader extends MeshShader{constructor(i={}){let g=i.extraCommandProps||{};const m=[];g=cx({},g,{blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"},sample:{alpha:!0}}),super({vert:"#include <gl2_vert>\nattribute vec3 aPosition;\nattribute vec3 aBarycentric;\nvarying vec3 vBarycentric;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projMatrix;\nuniform mat4 positionMatrix;\nvarying vec3 vPosition;\n#include <get_output>\nvoid main() {\n  mat4 c = getPositionMatrix();\n  vec4 d = getPosition(aPosition);\n#ifdef HAS_MASK_EXTENT\ngl_Position = projMatrix * getMaskPosition(c * d, modelMatrix);\n#else\ngl_Position = projMatrix * modelViewMatrix * c * d;\n#endif\nvBarycentric = aBarycentric;\n  vPosition = aPosition;\n}",frag:"#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec3 vBarycentric;\nuniform float time;\nuniform float thickness;\nuniform float secondThickness;\nuniform float dashRepeats;\nuniform float dashLength;\nuniform bool dashOverlap;\nuniform bool dashEnabled;\nuniform bool dashAnimate;\nuniform bool seeThrough;\nuniform bool insideAltColor;\nuniform bool dualStroke;\nuniform bool squeeze;\nuniform float squeezeMin;\nuniform float squeezeMax;\nuniform vec4 stroke;\nuniform vec4 fill;\nuniform float opacity;\nuniform bool noiseEnable;\nvarying vec3 vPosition;\n#ifdef HAS_INSTANCE\nvarying vec4 vInstanceColor;\n#endif\n#include <mask_frag>\n#define F4 0.309016994374947451\n#define halfDist 0.5\nvec4 c(vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\nfloat c(float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\nvec4 d(vec4 x) {\n  return c((x * 34. + 1.) * x);\n}\nfloat d(float x) {\n  return c((x * 34. + 1.) * x);\n}\nvec4 e(vec4 r) {\n  return 1.79284291400159 - .85373472095314 * r;\n}\nfloat e(float r) {\n  return 1.79284291400159 - .85373472095314 * r;\n}\nvec4 f(float h, vec4 i) {\n  const vec4 k = vec4(1., 1., 1., -1.);\n  vec4 p, s;\n  p.xyz = floor(fract(vec3(h) * i.xyz) * 7.) * i.z - 1.;\n  p.w = 1.5 - dot(abs(p.xyz), k.xyz);\n  s = vec4(lessThan(p, vec4(.0)));\n  p.xyz = p.xyz + (s.xyz * 2. - 1.) * s.www;\n  return p;\n}\nfloat l(vec4 m) {\n  const vec4 n = vec4(.138196601125011, .276393202250021, .414589803375032, -.447213595499958);\n  vec4 o = floor(m + dot(m, vec4(F4)));\n  vec4 u = m - o + dot(o, n.xxxx);\n  vec4 A;\n  vec3 B = step(u.yzw, u.xxx);\n  vec3 D = step(u.zww, u.yyz);\n  A.x = B.x + B.y + B.z;\n  A.yzw = 1. - B;\n  A.y += D.x + D.y;\n  A.zw += 1. - D.xy;\n  A.z += D.z;\n  A.w += 1. - D.z;\n  vec4 E = clamp(A, .0, 1.);\n  vec4 F = clamp(A - 1., .0, 1.);\n  vec4 G = clamp(A - 2., .0, 1.);\n  vec4 H = u - G + n.xxxx;\n  vec4 I = u - F + n.yyyy;\n  vec4 J = u - E + n.zzzz;\n  vec4 K = u + n.wwww;\n  o = c(o);\n  float L = d(d(d(d(o.w) + o.z) + o.y) + o.x);\n  vec4 M = d(d(d(d(o.w + vec4(G.w, F.w, E.w, 1.)) + o.z + vec4(G.z, F.z, E.z, 1.)) + o.y + vec4(G.y, F.y, E.y, 1.)) + o.x + vec4(G.x, F.x, E.x, 1.));\n  vec4 i = vec4(1. / 294., 1. / 49., 1. / 7., .0);\n  vec4 N = f(L, i);\n  vec4 O = f(M.x, i);\n  vec4 P = f(M.y, i);\n  vec4 Q = f(M.z, i);\n  vec4 R = f(M.w, i);\n  vec4 S = e(vec4(dot(N, N), dot(O, O), dot(P, P), dot(Q, Q)));\n  N *= S.x;\n  O *= S.y;\n  P *= S.z;\n  Q *= S.w;\n  R *= e(dot(R, R));\n  vec3 T = max(.6 - vec3(dot(u, u), dot(H, H), dot(I, I)), .0);\n  vec2 U = max(.6 - vec2(dot(J, J), dot(K, K)), .0);\n  T = T * T;\n  U = U * U;\n  return 49. * (dot(T * T, vec3(dot(N, u), dot(O, H), dot(P, I))) + dot(U * U, vec2(dot(Q, J), dot(R, K))));\n}\nconst float V = 3.14159265359;\nfloat W(float X, float Y) {\n  float Z = fwidth(Y) * halfDist;\n  return smoothstep(X - Z, X + Z, Y);\n}\nvec4 ba(vec3 bb) {\n  float bc = min(min(bb.x, bb.y), bb.z);\n  float bd = .0;\n  if(noiseEnable)\n    bd += l(vec4(vPosition.xyz * 80.0, time * halfDist)) * .12;\n  bc += bd;\n  float be = max(bb.x, bb.y);\n  if(bb.y < bb.x && bb.y < bb.z) {\n    be = 1. - be;\n  }\n  float bf = thickness;\n  if(squeeze) {\n    bf *= mix(squeezeMin, squeezeMax, (1. - sin(be * V)));\n  }\n  if(dashEnabled) {\n    float bg = 1. / dashRepeats * dashLength / 2.;\n    if(!dashOverlap) {\n      bg += 1. / dashRepeats / 2.;\n    }\n    if(dashAnimate) {\n      bg += time * .22;\n    }\n    float bh = fract((be + bg) * dashRepeats);\n    bf *= 1. - W(dashLength, bh);\n  }\n  float bi = 1. - W(bf, bc);\n#ifdef HAS_INSTANCE\nvec4 bj = vInstanceColor;\n#else\nvec4 bj = stroke;\n#endif\nvec4 bk = vec4(.0);\n  if(seeThrough) {\n    bk = vec4(bj.xyz, bi);\n    if(insideAltColor && !gl_FrontFacing) {\n      bk.rgb = fill.xyz;\n    }\n  } else {\n    vec3 bl = mix(fill.xyz, bj.xyz, bi);\n    bk.a = fill.a;\n    if(dualStroke) {\n      float bm = 1. - W(secondThickness, bc);\n      vec3 bn = mix(fill.xyz, stroke.xyz, abs(bm - bi));\n      bk.rgb = bn;\n    } else {\n      bk.rgb = bl;\n    }\n  }\n  return bk;\n}\nvoid main() {\n  glFragColor = ba(vBarycentric);\n  glFragColor *= halfDist + opacity;\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",uniforms:[{name:"modelViewMatrix",type:"function",fn:(i,g)=>_A(m,g.viewMatrix,g.modelMatrix)}],extraCommandProps:g}),this.version=300}},earcut:bP,glMatrix:Ym,mat2:tA,mat2d:iA,mat3:pA,mat4:VA,pbr:xP,quat:O_,quat2:N_,vec2:av,vec3:yy,vec4:Xy});function TP(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var SP={exports:{}},MP={exports:{}},CP=function(i){return!(!i||"string"==typeof i)&&(i instanceof Array||Array.isArray(i)||i.length>=0&&(i.splice instanceof Function||Object.getOwnPropertyDescriptor(i,i.length-1)&&"String"!==i.constructor.name))},PP=Array.prototype.concat,IP=Array.prototype.slice,kP=MP.exports=function(i){for(var g=[],m=0,_=i.length;m<_;m++){var b=i[m];CP(b)?g=PP.call(g,IP.call(b)):g.push(b)}return g};kP.wrap=function(i){return function(){return i(kP(arguments))}};var OP={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},EP=MP.exports,RP=Object.hasOwnProperty,LP=Object.create(null);for(var DP in OP)RP.call(OP,DP)&&(LP[OP[DP]]=DP);var FP=SP.exports={to:{},get:{}};function NP(i,g,m){return Math.min(Math.max(g,i),m)}function HP(i){var g=Math.round(i).toString(16).toUpperCase();return g.length<2?"0"+g:g}FP.get=function(i){var g,m;switch(i.substring(0,3).toLowerCase()){case"hsl":g=FP.get.hsl(i),m="hsl";break;case"hwb":g=FP.get.hwb(i),m="hwb";break;default:g=FP.get.rgb(i),m="rgb"}return g?{model:m,value:g}:null},FP.get.rgb=function(i){if(!i)return null;var g,m,_,b=[0,0,0,1];if(g=i.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(_=g[2],g=g[1],m=0;m<3;m++){var T=2*m;b[m]=parseInt(g.slice(T,T+2),16)}_&&(b[3]=parseInt(_,16)/255)}else if(g=i.match(/^#([a-f0-9]{3,4})$/i)){for(_=(g=g[1])[3],m=0;m<3;m++)b[m]=parseInt(g[m]+g[m],16);_&&(b[3]=parseInt(_+_,16)/255)}else if(g=i.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)){for(m=0;m<3;m++)b[m]=parseInt(g[m+1],0);g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}else{if(!(g=i.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)))return(g=i.match(/^(\w+)$/))?"transparent"===g[1]?[0,0,0,0]:RP.call(OP,g[1])?((b=OP[g[1]])[3]=1,b):null:null;for(m=0;m<3;m++)b[m]=Math.round(2.55*parseFloat(g[m+1]));g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}for(m=0;m<3;m++)b[m]=NP(b[m],0,255);return b[3]=NP(b[3],0,1),b},FP.get.hsl=function(i){if(!i)return null;var g=i.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,NP(parseFloat(g[2]),0,100),NP(parseFloat(g[3]),0,100),NP(isNaN(m)?1:m,0,1)]}return null},FP.get.hwb=function(i){if(!i)return null;var g=i.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,NP(parseFloat(g[2]),0,100),NP(parseFloat(g[3]),0,100),NP(isNaN(m)?1:m,0,1)]}return null},FP.to.hex=function(){var i=EP(arguments);return"#"+HP(i[0])+HP(i[1])+HP(i[2])+(i[3]<1?HP(Math.round(255*i[3])):"")},FP.to.rgb=function(){var i=EP(arguments);return i.length<4||1===i[3]?"rgb("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+")":"rgba("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+", "+i[3]+")"},FP.to.rgb.percent=function(){var i=EP(arguments),g=Math.round(i[0]/255*100),m=Math.round(i[1]/255*100),_=Math.round(i[2]/255*100);return i.length<4||1===i[3]?"rgb("+g+"%, "+m+"%, "+_+"%)":"rgba("+g+"%, "+m+"%, "+_+"%, "+i[3]+")"},FP.to.hsl=function(){var i=EP(arguments);return i.length<4||1===i[3]?"hsl("+i[0]+", "+i[1]+"%, "+i[2]+"%)":"hsla("+i[0]+", "+i[1]+"%, "+i[2]+"%, "+i[3]+")"},FP.to.hwb=function(){var i=EP(arguments),g="";return i.length>=4&&1!==i[3]&&(g=", "+i[3]),"hwb("+i[0]+", "+i[1]+"%, "+i[2]+"%"+g+")"},FP.to.keyword=function(i){return LP[i.slice(0,3)]};var BP=SP.exports,zP={exports:{}},VP={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},UP={};for(var GP in VP)VP.hasOwnProperty(GP)&&(UP[VP[GP]]=GP);var jP=zP.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var WP in jP)if(jP.hasOwnProperty(WP)){if(!("channels"in jP[WP]))throw new Error("missing channels property: "+WP);if(!("labels"in jP[WP]))throw new Error("missing channel labels property: "+WP);if(jP[WP].labels.length!==jP[WP].channels)throw new Error("channel and label counts mismatch: "+WP);var qP=jP[WP].channels,XP=jP[WP].labels;delete jP[WP].channels,delete jP[WP].labels,Object.defineProperty(jP[WP],"channels",{value:qP}),Object.defineProperty(jP[WP],"labels",{value:XP})}function ZP(i,g){return Math.pow(i[0]-g[0],2)+Math.pow(i[1]-g[1],2)+Math.pow(i[2]-g[2],2)}jP.rgb.hsl=function(i){var g,m,_=i[0]/255,b=i[1]/255,T=i[2]/255,P=Math.min(_,b,T),I=Math.max(_,b,T),H=I-P;return I===P?g=0:_===I?g=(b-T)/H:b===I?g=2+(T-_)/H:T===I&&(g=4+(_-b)/H),(g=Math.min(60*g,360))<0&&(g+=360),m=(P+I)/2,[g,100*(I===P?0:m<=.5?H/(I+P):H/(2-I-P)),100*m]},jP.rgb.hsv=function(i){var g,m,_,b,T,P=i[0]/255,I=i[1]/255,H=i[2]/255,W=Math.max(P,I,H),q=W-Math.min(P,I,H),$=function(i){return(W-i)/6/q+.5};return 0===q?b=T=0:(T=q/W,g=$(P),m=$(I),_=$(H),P===W?b=_-m:I===W?b=1/3+g-_:H===W&&(b=2/3+m-g),b<0?b+=1:b>1&&(b-=1)),[360*b,100*T,100*W]},jP.rgb.hwb=function(i){var g=i[0],m=i[1],_=i[2];return[jP.rgb.hsl(i)[0],100*(1/255*Math.min(g,Math.min(m,_))),100*(_=1-1/255*Math.max(g,Math.max(m,_)))]},jP.rgb.cmyk=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255;return[100*((1-m-(g=Math.min(1-m,1-_,1-b)))/(1-g)||0),100*((1-_-g)/(1-g)||0),100*((1-b-g)/(1-g)||0),100*g]},jP.rgb.keyword=function(i){var g=UP[i];if(g)return g;var m,_=1/0;for(var b in VP)if(VP.hasOwnProperty(b)){var T=ZP(i,VP[b]);T<_&&(_=T,m=b)}return m},jP.keyword.rgb=function(i){return VP[i]},jP.rgb.xyz=function(i){var g=i[0]/255,m=i[1]/255,_=i[2]/255;return[100*(.4124*(g=g>.04045?Math.pow((g+.055)/1.055,2.4):g/12.92)+.3576*(m=m>.04045?Math.pow((m+.055)/1.055,2.4):m/12.92)+.1805*(_=_>.04045?Math.pow((_+.055)/1.055,2.4):_/12.92)),100*(.2126*g+.7152*m+.0722*_),100*(.0193*g+.1192*m+.9505*_)]},jP.rgb.lab=function(i){var g=jP.rgb.xyz(i),m=g[0],_=g[1],b=g[2];return _/=100,b/=108.883,m=(m/=95.047)>.008856?Math.pow(m,1/3):7.787*m+16/116,[116*(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116)-16,500*(m-_),200*(_-(b=b>.008856?Math.pow(b,1/3):7.787*b+16/116))]},jP.hsl.rgb=function(i){var g,m,_,b,T,P=i[0]/360,I=i[1]/100,H=i[2]/100;if(0===I)return[T=255*H,T,T];g=2*H-(m=H<.5?H*(1+I):H+I-H*I),b=[0,0,0];for(var W=0;W<3;W++)(_=P+1/3*-(W-1))<0&&_++,_>1&&_--,b[W]=255*(T=6*_<1?g+6*(m-g)*_:2*_<1?m:3*_<2?g+(m-g)*(2/3-_)*6:g);return b},jP.hsl.hsv=function(i){var g=i[0],m=i[1]/100,_=i[2]/100,b=m,T=Math.max(_,.01);return m*=(_*=2)<=1?_:2-_,b*=T<=1?T:2-T,[g,100*(0===_?2*b/(T+b):2*m/(_+m)),100*((_+m)/2)]},jP.hsv.rgb=function(i){var g=i[0]/60,m=i[1]/100,_=i[2]/100,b=Math.floor(g)%6,T=g-Math.floor(g),P=255*_*(1-m),I=255*_*(1-m*T),H=255*_*(1-m*(1-T));switch(_*=255,b){case 0:return[_,H,P];case 1:return[I,_,P];case 2:return[P,_,H];case 3:return[P,I,_];case 4:return[H,P,_];case 5:return[_,P,I]}},jP.hsv.hsl=function(i){var g,m,_,b=i[0],T=i[1]/100,P=i[2]/100,I=Math.max(P,.01);return _=(2-T)*P,m=T*I,[b,100*(m=(m/=(g=(2-T)*I)<=1?g:2-g)||0),100*(_/=2)]},jP.hwb.rgb=function(i){var g,m,_,b,T,P,I,H=i[0]/360,W=i[1]/100,q=i[2]/100,$=W+q;switch($>1&&(W/=$,q/=$),_=6*H-(g=Math.floor(6*H)),1&g&&(_=1-_),b=W+_*((m=1-q)-W),g){default:case 6:case 0:T=m,P=b,I=W;break;case 1:T=b,P=m,I=W;break;case 2:T=W,P=m,I=b;break;case 3:T=W,P=b,I=m;break;case 4:T=b,P=W,I=m;break;case 5:T=m,P=W,I=b}return[255*T,255*P,255*I]},jP.cmyk.rgb=function(i){var g=i[1]/100,m=i[2]/100,_=i[3]/100;return[255*(1-Math.min(1,i[0]/100*(1-_)+_)),255*(1-Math.min(1,g*(1-_)+_)),255*(1-Math.min(1,m*(1-_)+_))]},jP.xyz.rgb=function(i){var g,m,_,b=i[0]/100,T=i[1]/100,P=i[2]/100;return m=-.9689*b+1.8758*T+.0415*P,_=.0557*b+-.204*T+1.057*P,g=(g=3.2406*b+-1.5372*T+-.4986*P)>.0031308?1.055*Math.pow(g,1/2.4)-.055:12.92*g,m=m>.0031308?1.055*Math.pow(m,1/2.4)-.055:12.92*m,_=_>.0031308?1.055*Math.pow(_,1/2.4)-.055:12.92*_,[255*(g=Math.min(Math.max(0,g),1)),255*(m=Math.min(Math.max(0,m),1)),255*(_=Math.min(Math.max(0,_),1))]},jP.xyz.lab=function(i){var g=i[0],m=i[1],_=i[2];return m/=100,_/=108.883,g=(g/=95.047)>.008856?Math.pow(g,1/3):7.787*g+16/116,[116*(m=m>.008856?Math.pow(m,1/3):7.787*m+16/116)-16,500*(g-m),200*(m-(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116))]},jP.lab.xyz=function(i){var g,m,_;g=i[1]/500+(m=(i[0]+16)/116),_=m-i[2]/200;var b=Math.pow(m,3),T=Math.pow(g,3),P=Math.pow(_,3);return m=b>.008856?b:(m-16/116)/7.787,g=T>.008856?T:(g-16/116)/7.787,_=P>.008856?P:(_-16/116)/7.787,[g*=95.047,m*=100,_*=108.883]},jP.lab.lch=function(i){var g,m=i[0],_=i[1],b=i[2];return(g=360*Math.atan2(b,_)/2/Math.PI)<0&&(g+=360),[m,Math.sqrt(_*_+b*b),g]},jP.lch.lab=function(i){var g,m=i[1];return g=i[2]/360*2*Math.PI,[i[0],m*Math.cos(g),m*Math.sin(g)]},jP.rgb.ansi16=function(i){var g=i[0],m=i[1],_=i[2],b=1 in arguments?arguments[1]:jP.rgb.hsv(i)[2];if(0===(b=Math.round(b/50)))return 30;var T=30+(Math.round(_/255)<<2|Math.round(m/255)<<1|Math.round(g/255));return 2===b&&(T+=60),T},jP.hsv.ansi16=function(i){return jP.rgb.ansi16(jP.hsv.rgb(i),i[2])},jP.rgb.ansi256=function(i){var g=i[0],m=i[1],_=i[2];return g===m&&m===_?g<8?16:g>248?231:Math.round((g-8)/247*24)+232:16+36*Math.round(g/255*5)+6*Math.round(m/255*5)+Math.round(_/255*5)},jP.ansi16.rgb=function(i){var g=i%10;if(0===g||7===g)return i>50&&(g+=3.5),[g=g/10.5*255,g,g];var m=.5*(1+~~(i>50));return[(1&g)*m*255,(g>>1&1)*m*255,(g>>2&1)*m*255]},jP.ansi256.rgb=function(i){if(i>=232){var g=10*(i-232)+8;return[g,g,g]}var m;return i-=16,[Math.floor(i/36)/5*255,Math.floor((m=i%36)/6)/5*255,m%6/5*255]},jP.rgb.hex=function(i){var g=(((255&Math.round(i[0]))<<16)+((255&Math.round(i[1]))<<8)+(255&Math.round(i[2]))).toString(16).toUpperCase();return"000000".substring(g.length)+g},jP.hex.rgb=function(i){var g=i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!g)return[0,0,0];var m=g[0];3===g[0].length&&(m=m.split("").map((function(i){return i+i})).join(""));var _=parseInt(m,16);return[_>>16&255,_>>8&255,255&_]},jP.rgb.hcg=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255,T=Math.max(Math.max(m,_),b),P=Math.min(Math.min(m,_),b),I=T-P;return g=I<=0?0:T===m?(_-b)/I%6:T===_?2+(b-m)/I:4+(m-_)/I+4,g/=6,[360*(g%=1),100*I,100*(I<1?P/(1-I):0)]},jP.hsl.hcg=function(i){var g=i[1]/100,m=i[2]/100,_=1,b=0;return(_=m<.5?2*g*m:2*g*(1-m))<1&&(b=(m-.5*_)/(1-_)),[i[0],100*_,100*b]},jP.hsv.hcg=function(i){var g=i[2]/100,m=i[1]/100*g,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},jP.hcg.rgb=function(i){var g=i[1]/100,m=i[2]/100;if(0===g)return[255*m,255*m,255*m];var _,b=[0,0,0],T=i[0]/360%1*6,P=T%1,I=1-P;switch(Math.floor(T)){case 0:b[0]=1,b[1]=P,b[2]=0;break;case 1:b[0]=I,b[1]=1,b[2]=0;break;case 2:b[0]=0,b[1]=1,b[2]=P;break;case 3:b[0]=0,b[1]=I,b[2]=1;break;case 4:b[0]=P,b[1]=0,b[2]=1;break;default:b[0]=1,b[1]=0,b[2]=I}return[255*(g*b[0]+(_=(1-g)*m)),255*(g*b[1]+_),255*(g*b[2]+_)]},jP.hcg.hsv=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g),_=0;return m>0&&(_=g/m),[i[0],100*_,100*m]},jP.hcg.hsl=function(i){var g=i[1]/100,m=i[2]/100*(1-g)+.5*g,_=0;return m>0&&m<.5?_=g/(2*m):m>=.5&&m<1&&(_=g/(2*(1-m))),[i[0],100*_,100*m]},jP.hcg.hwb=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g);return[i[0],100*(m-g),100*(1-m)]},jP.hwb.hcg=function(i){var g=1-i[2]/100,m=g-i[1]/100,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},jP.apple.rgb=function(i){return[i[0]/65535*255,i[1]/65535*255,i[2]/65535*255]},jP.rgb.apple=function(i){return[i[0]/255*65535,i[1]/255*65535,i[2]/255*65535]},jP.gray.rgb=function(i){return[i[0]/100*255,i[0]/100*255,i[0]/100*255]},jP.gray.hsl=jP.gray.hsv=function(i){return[0,0,i[0]]},jP.gray.hwb=function(i){return[0,100,i[0]]},jP.gray.cmyk=function(i){return[0,0,0,i[0]]},jP.gray.lab=function(i){return[i[0],0,0]},jP.gray.hex=function(i){var g=255&Math.round(i[0]/100*255),m=((g<<16)+(g<<8)+g).toString(16).toUpperCase();return"000000".substring(m.length)+m},jP.rgb.gray=function(i){return[(i[0]+i[1]+i[2])/3/255*100]};var $P=zP.exports,YP=$P;function QP(i){var g=function(){for(var i={},g=Object.keys(YP),m=g.length,_=0;_<m;_++)i[g[_]]={distance:-1,parent:null};return i}(),m=[i];for(g[i].distance=0;m.length;)for(var _=m.pop(),b=Object.keys(YP[_]),T=b.length,P=0;P<T;P++){var I=b[P],H=g[I];-1===H.distance&&(H.distance=g[_].distance+1,H.parent=_,m.unshift(I))}return g}function JP(i,g){return function(m){return g(i(m))}}function KP(i,g){for(var m=[g[i].parent,i],_=YP[g[i].parent][i],b=g[i].parent;g[b].parent;)m.unshift(g[b].parent),_=JP(YP[g[b].parent][b],_),b=g[b].parent;return _.conversion=m,_}var eI=$P,tI=function(i){for(var g=QP(i),m={},_=Object.keys(g),b=_.length,T=0;T<b;T++){var P=_[T];null!==g[P].parent&&(m[P]=KP(P,g))}return m},nI={};Object.keys(eI).forEach((function(i){nI[i]={},Object.defineProperty(nI[i],"channels",{value:eI[i].channels}),Object.defineProperty(nI[i],"labels",{value:eI[i].labels});var g=tI(i);Object.keys(g).forEach((function(m){var _=g[m];nI[i][m]=function(i){var g=function(g){if(null==g)return g;arguments.length>1&&(g=Array.prototype.slice.call(arguments));var m=i(g);if("object"==typeof m)for(var _=m.length,b=0;b<_;b++)m[b]=Math.round(m[b]);return m};return"conversion"in i&&(g.conversion=i.conversion),g}(_),nI[i][m].raw=function(i){var g=function(g){return null==g?g:(arguments.length>1&&(g=Array.prototype.slice.call(arguments)),i(g))};return"conversion"in i&&(g.conversion=i.conversion),g}(_)}))}));var rI=BP,iI=nI,oI=[].slice,sI=["keyword","gray","hex"],aI={};Object.keys(iI).forEach((function(i){aI[oI.call(iI[i].labels).sort().join("")]=i}));var lI={};function hI(i,g){if(!(this instanceof hI))return new hI(i,g);if(g&&g in sI&&(g=null),g&&!(g in iI))throw new Error("Unknown model: "+g);var m,_;if(null==i)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(i instanceof hI)this.model=i.model,this.color=i.color.slice(),this.valpha=i.valpha;else if("string"==typeof i){var b=rI.get(i);if(null===b)throw new Error("Unable to parse color from string: "+i);this.model=b.model,this.color=b.value.slice(0,_=iI[this.model].channels),this.valpha="number"==typeof b.value[_]?b.value[_]:1}else if(i.length){this.model=g||"rgb";var T=oI.call(i,0,_=iI[this.model].channels);this.color=fI(T,_),this.valpha="number"==typeof i[_]?i[_]:1}else if("number"==typeof i)i&=16777215,this.model="rgb",this.color=[i>>16&255,i>>8&255,255&i],this.valpha=1;else{this.valpha=1;var P=Object.keys(i);"alpha"in i&&(P.splice(P.indexOf("alpha"),1),this.valpha="number"==typeof i.alpha?i.alpha:0);var I=P.sort().join("");if(!(I in aI))throw new Error("Unable to parse color from object: "+JSON.stringify(i));this.model=aI[I];var H=iI[this.model].labels,W=[];for(m=0;m<H.length;m++)W.push(i[H[m]]);this.color=fI(W)}if(lI[this.model])for(_=iI[this.model].channels,m=0;m<_;m++){var q=lI[this.model][m];q&&(this.color[m]=q(this.color[m]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}function cI(i,g,m){return(i=Array.isArray(i)?i:[i]).forEach((function(i){(lI[i]||(lI[i]=[]))[g]=m})),i=i[0],function(_){var b;return arguments.length?(m&&(_=m(_)),(b=this[i]()).color[g]=_,b):(b=this[i]().color[g],m&&(b=m(b)),b)}}function uI(i){return function(g){return Math.max(0,Math.min(i,g))}}function fI(i,g){for(var m=0;m<g;m++)"number"!=typeof i[m]&&(i[m]=0);return i}hI.prototype={toString:function(){return this.string()},toJSON:function(){return this[this.model]()},string:function(i){var g=this.model in rI.to?this:this.rgb(),m=1===(g=g.round("number"==typeof i?i:1)).valpha?g.color:g.color.concat(this.valpha);return rI.to[g.model](m)},percentString:function(i){var g=this.rgb().round("number"==typeof i?i:1),m=1===g.valpha?g.color:g.color.concat(this.valpha);return rI.to.rgb.percent(m)},array:function(){return 1===this.valpha?this.color.slice():this.color.concat(this.valpha)},object:function(){for(var i={},g=iI[this.model].channels,m=iI[this.model].labels,_=0;_<g;_++)i[m[_]]=this.color[_];return 1!==this.valpha&&(i.alpha=this.valpha),i},unitArray:function(){var i=this.rgb().color;return i[0]/=255,i[1]/=255,i[2]/=255,1!==this.valpha&&i.push(this.valpha),i},unitObject:function(){var i=this.rgb().object();return i.r/=255,i.g/=255,i.b/=255,1!==this.valpha&&(i.alpha=this.valpha),i},round:function(i){return i=Math.max(i||0,0),new hI(this.color.map(function(i){return function(g){return function(i,g){return Number(i.toFixed(g))}(g,i)}}(i)).concat(this.valpha),this.model)},alpha:function(i){return arguments.length?new hI(this.color.concat(Math.max(0,Math.min(1,i))),this.model):this.valpha},red:cI("rgb",0,uI(255)),green:cI("rgb",1,uI(255)),blue:cI("rgb",2,uI(255)),hue:cI(["hsl","hsv","hsl","hwb","hcg"],0,(function(i){return(i%360+360)%360})),saturationl:cI("hsl",1,uI(100)),lightness:cI("hsl",2,uI(100)),saturationv:cI("hsv",1,uI(100)),value:cI("hsv",2,uI(100)),chroma:cI("hcg",1,uI(100)),gray:cI("hcg",2,uI(100)),white:cI("hwb",1,uI(100)),wblack:cI("hwb",2,uI(100)),cyan:cI("cmyk",0,uI(100)),magenta:cI("cmyk",1,uI(100)),yellow:cI("cmyk",2,uI(100)),black:cI("cmyk",3,uI(100)),x:cI("xyz",0,uI(100)),y:cI("xyz",1,uI(100)),z:cI("xyz",2,uI(100)),l:cI("lab",0,uI(100)),a:cI("lab",1),b:cI("lab",2),keyword:function(i){return arguments.length?new hI(i):iI[this.model].keyword(this.color)},hex:function(i){return arguments.length?new hI(i):rI.to.hex(this.rgb().round().color)},rgbNumber:function(){var i=this.rgb().color;return(255&i[0])<<16|(255&i[1])<<8|255&i[2]},luminosity:function(){for(var i=this.rgb().color,g=[],m=0;m<i.length;m++){var _=i[m]/255;g[m]=_<=.03928?_/12.92:Math.pow((_+.055)/1.055,2.4)}return.2126*g[0]+.7152*g[1]+.0722*g[2]},contrast:function(i){var g=this.luminosity(),m=i.luminosity();return g>m?(g+.05)/(m+.05):(m+.05)/(g+.05)},level:function(i){var g=this.contrast(i);return g>=7.1?"AAA":g>=4.5?"AA":""},isDark:function(){var i=this.rgb().color;return(299*i[0]+587*i[1]+114*i[2])/1e3<128},isLight:function(){return!this.isDark()},negate:function(){for(var i=this.rgb(),g=0;g<3;g++)i.color[g]=255-i.color[g];return i},lighten:function(i){var g=this.hsl();return g.color[2]+=g.color[2]*i,g},darken:function(i){var g=this.hsl();return g.color[2]-=g.color[2]*i,g},saturate:function(i){var g=this.hsl();return g.color[1]+=g.color[1]*i,g},desaturate:function(i){var g=this.hsl();return g.color[1]-=g.color[1]*i,g},whiten:function(i){var g=this.hwb();return g.color[1]+=g.color[1]*i,g},blacken:function(i){var g=this.hwb();return g.color[2]+=g.color[2]*i,g},grayscale:function(){var i=this.rgb().color,g=.3*i[0]+.59*i[1]+.11*i[2];return hI.rgb(g,g,g)},fade:function(i){return this.alpha(this.valpha-this.valpha*i)},opaquer:function(i){return this.alpha(this.valpha+this.valpha*i)},rotate:function(i){var g=this.hsl(),m=g.color[0];return g.color[0]=m=(m=(m+i)%360)<0?360+m:m,g},mix:function(i,g){if(!i||!i.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof i);var m=i.rgb(),_=this.rgb(),b=void 0===g?.5:g,T=2*b-1,P=m.alpha()-_.alpha(),I=((T*P===-1?T:(T+P)/(1+T*P))+1)/2,H=1-I;return hI.rgb(I*m.red()+H*_.red(),I*m.green()+H*_.green(),I*m.blue()+H*_.blue(),m.alpha()*b+_.alpha()*(1-b))}},Object.keys(iI).forEach((function(i){if(-1===sI.indexOf(i)){var g=iI[i].channels;hI.prototype[i]=function(){if(this.model===i)return new hI(this);if(arguments.length)return new hI(arguments,i);var m,_="number"==typeof arguments[g]?g:this.valpha;return new hI((m=iI[this.model][i].raw(this.color),Array.isArray(m)?m:[m]).concat(_),i)},hI[i]=function(m){return"number"==typeof m&&(m=fI(oI.call(arguments),g)),new hI(m,i)}}}));var dI=TP(hI);const pI="function"==typeof Object.assign,gI=[];function mI(i){if(pI)Object.assign.apply(Object,arguments);else for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}function AI(i){return null==i}function yI(i){return"number"==typeof i&&!isNaN(i)}function _I(i){return!AI(i)&&("function"==typeof i||null!==i.constructor&&i.constructor===Function)}const vI=[];function xI(i,g){const m=g._get2DExtentAtRes(g.getGLRes()),_=m.getWidth(),b=m.getHeight(),T=i;mA(T);const P=WA(gI,g.cameraLookAt);return P[2]=0,vA(T,T,P),xA(T,T,qA(vI,_,b,1)),T}function bI(i,g){return Object.prototype.hasOwnProperty.call(i,g)}function wI(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];if(m)for(let g=0,_=m.length;g<_;g++)i.push(m[g])}return i.length}const TI={};function SI(i,g){if(!Array.isArray(g)){g=TI[g]=TI[g]||dI(g).unitArray()}for(let m=0;m<g.length;m++)i[m]=g[m];return 3===g.length&&(i[3]=1),i}function MI(i,g){if(!Array.isArray(g)){g=TI[g]=TI[g]||dI(g).unitArray()}for(let m=0;m<g.length;m++)i[m]=255*g[m];return 3===i.length&&i.push(255),i}function CI(i,g,m=0){if(!(i&&g instanceof pl))return null;const _=i.coordinateToPointAtRes(g,i.getGLRes());return[_.x,_.y,m]}const PI=[0,0],II=[0,0,0];let kI;class ShadowProcess{static getUniformDeclares(){const i=[],g=[];return g.push({name:"shadow_lightProjViewModelMatrix",type:"function",fn:function(g,m){return _A(i,m.shadow_lightProjViewMatrix,m.modelMatrix)}}),g}constructor(i,g){this.renderer=new Renderer(i),this._esmShadowThreshold=.3,this._layer=g,this._init()}resize(){const i=this.canvas;i.width=this._layer.getRenderer().canvas.width,i.height=this._layer.getRenderer().canvas.height}_init(){const i=(this._layer._getSceneConfig()||{}).shadow||{},g=this._getShadowRes(),m=this.getDefines();this._shadowPass=new ShadowPass(this.renderer,{width:g,height:g,blurOffset:i.blurOffset,defines:m}),this._shadowDisplayShader=new ShadowDisplayShader(m),this._createGround()}_getShadowRes(){let i=2048;const g=((this._layer._getSceneConfig()||{}).shadow||{}).quality;return"medium"===g?i=1024:"low"===g&&(i=512),i}getDefines(){return{HAS_SHADOWING:1,PACK_FLOAT:1,USE_ESM:1}}render(i,g,m,_,b,T,P,I,H,W){this._transformGround();const q=this._layer.getMap(),$=this._getShadowRes();let ye,Re;if(W||$!==this._shadowPass.width||this._shadowChanged(q,P,!!i)){$!==this._shadowPass.width&&this._shadowPass.resize($,$),this._tempMat0=this._tempMat0||[],this._tempMat1=this._tempMat1||[];const _=_A(this._tempMat0,g,m),b=ny(this._tempMat1,T);kI||(kI=q.getContainerExtent());let I=q.height;q.getPitch()>62&&(I=q._getVisualHeight(62));const H=kI.set(0,q.height-I,q.width,q.height).convertTo((i=>q._containerPointToPointAtRes(i,q.getGLRes()))),W=H.toArray();i&&P.addMesh(this._ground);const Be=W.map((i=>[i.x,i.y,0,1])),{lightProjViewMatrix:Ge,shadowMap:je,blurFBO:Xe}=this._shadowPass.render(P,{cameraProjViewMatrix:_,lightDir:b,farPlane:Be,cameraLookAt:q.cameraLookAt});ye=this._lightProjViewMatrix=Ge,Re=this._shadowMap=je,this._blurFBO=Xe,this._renderedShadows=P.getMeshes().reduce(((i,g)=>(g.castShadow&&g.geometry&&(i[g.uuid]={v0:g.version,v1:g.geometry.version}),i)),{}),this._renderedView={count:P.getMeshes().length-+!!i,displayShadow:!!i},this._updated=!0}else ye=this._lightProjViewMatrix,Re=this._shadowMap,this._updated=!1;this._projMatrix=g,this._viewMatrix=m,AI(b)&&(b=1),i&&P.getMeshes().length&&this.displayShadow(_,b,I,H);return{shadow_lightProjViewMatrix:ye,shadow_shadowMap:Re,shadow_opacity:b,shadow_color:_||II,esm_shadow_threshold:this._esmShadowThreshold}}displayShadow(i,g,m,_){const b=this._lightProjViewMatrix,T=this._ground,P=this._groundLightProjViewModelMatrix||[],I=this._layer.getRenderer().canvas,H=this._texSize=this._texSize||[];H[0]=I.width,H[1]=I.height,this.renderer.render(this._shadowDisplayShader,{halton:m||PI,globalTexSize:H,projMatrix:this._projMatrix,viewMatrix:this._viewMatrix,shadow_lightProjViewModelMatrix:_A(P,b,T.localTransform),shadow_shadowMap:this._shadowMap,esm_shadow_threshold:this._esmShadowThreshold,shadow_opacity:g,color:i||II},this._groundScene,_)}dispose(){this._shadowPass.dispose(),this._shadowDisplayShader.dispose(),this._ground&&(this._ground.geometry.dispose(),this._ground.dispose()),delete this.renderer}isUpdated(){return!1!==this._updated}_shadowChanged(i,g,m){if(!this._renderedShadows)return!0;const _=this._renderedView;if(g.getMeshes().length!==_.count||m!==_.displayShadow)return!0;const b=g.getMeshes();for(let i=0;i<b.length;i++){const g=this._renderedShadows[b[i].uuid];if(b[i].castShadow&&(b[i].hasSkinAnimation()||!g||g.v0!==b[i].version||g.v1!==b[i].geometry.version))return!0}return!1}_createGround(){const i=new Plane;i.generateBuffers(this.renderer.device),this._ground=new Mesh(i),this._groundScene=new Scene([this._ground])}_transformGround(){const i=this._layer.getMap(),g=xI(this._ground.localTransform,i);this._ground.setLocalTransform(g)}}const OI=[0,0],EI=new pl(0,0),RI=new pl(0,0),LI=[],DI=[],FI=[];function NI(i,g,m,_){const b=i.getGLRes(),T=i.distanceToPointAtRes(g,g,b,m?EI:null,RI);return _?T.y:T.x}const{getIBLResOnCanvas:HI,logoutIBLResOnCanvas:BI,getPBRUniforms:zI,loginIBLResOnCanvas:VI}=xP.PBRUtils,UI=[0,0],GI=[1,1],jI=[],WI=[],qI=[],XI=[],ZI=[];class GroundPainter{static getGroundTransform(i,g){return xI(i,g)}constructor(i,g){this._regl=i,this.renderer=new Renderer(i),this._layer=g,this._loader=new ResourceLoader(null),this._bindOnMaterialComplete=(...i)=>this._onMaterialComplete.call(this,...i),this._init();const m=this.getMap().getRenderer().canvas;VI(m,i,this.getMap())}needToRedraw(){const i=this._getUVOffsetAnim();return i&&(i[0]||i[1])}getMap(){return this._layer&&this._layer.getMap()}getSymbol(){const i=this._layer.getGroundConfig();return i&&i.symbol}isEnable(){const i=this._layer.getGroundConfig();return i&&i.enable}paint(i){if(!this.isEnable())return!1;const g=this._getShader();if(this._isInSSRPhase(i)&&g===this._fillShader)return!1;const m=this._getGroundDefines(i);m&&this._ground.setDefines(m),this._ground.material!==this.material&&this._ground.setMaterial(this.material);const _=this._layer.getGroundConfig();this._ground.ssr=(_&&_.symbol).ssr?1:0,this._transformGround();const b=this._getUniformValues(i);b.offsetFactor=i.offsetFactor,b.offsetUnits=i.offsetUnits;const T=i&&i.renderTarget&&i.renderTarget.fbo,P=this._layer.getRenderer();return g===this._fillShader?(this.renderer.render(g,b,this._groundScene,T),P.setCanvasUpdated&&P.setCanvasUpdated(),!0):(g.filter=i.sceneFilter,this.renderer.render(g,b,this._groundScene,T),P.setCanvasUpdated&&P.setCanvasUpdated(),!0)}_isInSSRPhase(i){return!(!this._layer.getRenderer().isEnableSSR||!this._layer.getRenderer().isEnableSSR())&&!(!i||!i.ssr)}update(){const i=this._layer.getGroundConfig();if(!i)return;const g=i&&i.symbol,m=i.urlModifier;if(g){this._polygonFill=this._parseColor(g.polygonFill||[1,1,1,1]),this._polygonOpacity=void 0===g.polygonOpacity?1:g.polygonOpacity;const i=g.polygonPatternFile;if(i){if(!this._polygonPatternFile||this._polygonPatternFile._pattern_src!==i){const g=new Image;g.onload=()=>{this._polygonPatternFile&&this._polygonPatternFile.destroy(),this._polygonPatternFile=this._createPatternTexture(g),this._polygonPatternFile._pattern_src=i,this.setToRedraw()},g.src=m&&m(i)||i}}else this._polygonPatternFile&&(this._polygonPatternFile.destroy(),delete this._polygonPatternFile)}else this._polygonFill=[1,1,1,1],this._polygonOpacity=1,this._polygonPatternFile&&(this._polygonPatternFile.destroy(),delete this._polygonPatternFile);this._updateMaterial()}setToRedraw(){const i=this._layer.getRenderer();i&&i.setToRedraw()}dispose(){this.material&&(this.material.dispose(),delete this.material),this._ground&&(this._ground.geometry.dispose(),this._ground.material&&this._ground.material.dispose(),this._ground.dispose(),delete this._ground),this._polygonPatternFile&&(this._polygonPatternFile.destroy(),delete this._polygonPatternFile),this._fillShader&&(this._fillShader.dispose(),delete this._fillShader),this._standardShader&&(this._standardShader.dispose(),delete this._standardShader),this._disposeIblTextures()}_getShader(){const i=this._layer.getGroundConfig();if(!i||!i.renderPlugin)return this._fillShader;const g=i.renderPlugin.type;if("lit"===g)return this._standardShader;if("fill"===g)return this._fillShader;throw new Error("unsupported render plugin of "+g+" for layer ground")}_getUniformValues(i){const g=this._getCommonUniforms(i);g.polygonFill=this._polygonFill,g.polygonOpacity=this._polygonOpacity;return this._getShader()===this._fillShader&&this._polygonPatternFile&&(g.polygonPatternFile=this._polygonPatternFile),g}_getCommonUniforms(i){let g;if("lit"===this._layer.getGroundConfig().renderPlugin.type){const m=this.getMap().getRenderer().canvas,{iblTexes:_,dfgLUT:b}=HI(m);g=zI(this.getMap(),_,b,i&&i.ssr,i&&i.jitter)}else{g={projViewMatrix:this.getMap().projViewMatrix}}return this._setIncludeUniformValues(g,i),g}_setIncludeUniformValues(i,g){const m=g&&g.includes;if(m)for(const _ in m)m[_]&&g[_].renderUniforms&&mI(i,g[_].renderUniforms)}_disposeIblTextures(){const i=this.getMap().getRenderer().canvas;BI(i,this.getMap())}_init(){const i=this._getExtraCommandProps(),g=ShadowProcess.getUniformDeclares(),m=[];g.push({name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A(m,g.projViewMatrix,g.modelMatrix)}}),this._fillShader=new MeshShader({name:"ground-fill",vert:"attribute vec3 aPosition;\nuniform mat4 projViewModelMatrix;\nuniform mat4 modelMatrix;\n#ifdef HAS_PATTERN\nattribute vec2 aTexCoord;\nuniform vec2 uvScale;\nuniform vec2 uvOffset;\nvarying vec2 vTexCoord;\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_vert>\n#endif\nvoid main() {\n  \n#ifdef HAS_PATTERN\nvTexCoord = aTexCoord * uvScale + uvOffset;\n#endif\nvec3 c = vec3(aPosition);\n  gl_Position = projViewModelMatrix * vec4(c, 1.);\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nshadow_computeShadowPars(vec4(c, 1.));\n#endif\n}",frag:"precision mediump float;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_frag>\n#endif\n#ifdef HAS_PATTERN\nuniform sampler2D polygonPatternFile;\nvarying vec2 vTexCoord;\n#endif\nuniform vec4 polygonFill;\nuniform float polygonOpacity;\nvoid main() {\n  \n#ifdef HAS_PATTERN\nvec4 c = texture2D(polygonPatternFile, vTexCoord);\n#else\nvec4 c = polygonFill;\n#endif\ngl_FragColor = c * polygonOpacity;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nfloat d = shadow_computeShadow();\n  gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, d);\n#endif\n}",wgslFrag:null,wgslVert:null,uniforms:g,extraCommandProps:i,defines:{}});const _=ShadowProcess.getUniformDeclares();_.push(...SsrPass.getUniformDeclares()),this._standardShader=new xP.StandardShader({uniforms:_,extraCommandProps:i}),this._createGround(),this.update()}_getExtraCommandProps(){const i=[0,1],g=this._layer.getRenderer().canvas;return{viewport:{x:0,y:0,width:()=>g.width,height:()=>g.height},cull:{enable:!0},depth:{enable:!0,mask:()=>{const i=this._layer.getGroundConfig();return i.depth||void 0===i.depth},range:()=>{const g=this._layer.getGroundConfig(),m=g&&g.renderPlugin.sceneConfig;return m&&m.depthRange||i},func:"<="},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"},polygonOffset:{enable:!0,offset:{factor:(i,g)=>g.offsetFactor,units:(i,g)=>g.offsetUnits}}}}_hasIBL(){const i=this.getMap().getLightManager();return!!(i&&i.getAmbientResource())}_createGround(){const i=new Plane;i.data.aTexCoord=new Uint8Array([0,0,1,0,0,1,1,1]),i.createTangent(),i.generateBuffers(this.renderer.device),this._ground=new Mesh(i,null,{castShadow:!1});const g=this._standardShader.getGeometryDefines(i);this._ground.setDefines(g),this._groundScene=new Scene([this._ground])}_transformGround(){const i=this.getMap(),g=GroundPainter.getGroundTransform(this._ground.localTransform,i);this._ground.setLocalTransform(g);const m=i.getGLRes(),_=i._get2DExtentAtRes(m),b=_.getWidth(),T=_.getHeight(),P=i.cameraLookAt,I=P[0]-b,H=P[1]-T,W=this._polygonPatternFile?this._polygonPatternFile.width/this._polygonPatternFile.height:1,q=this.getSymbol(),$=this.material?this.material.get("textureOrigin"):q.polygonPatternFileOrigin,ye=!!(this.material?this.material.get("uvOffsetInMeter"):q.uvOffsetInMeter),Re=(this.material?this.material.get("uvOffset"):q.uvOffset)||UI,Be=this.material&&this.material.get("uvScale")||GI,Ge=this.material?this.material.get("textureWidth"):q.polygonPatternFileWidth,je=this.material?Ge*(Be[1]/Be[0]):q.polygonPatternFileHeight,Xe=this._getUVOffsetAnim(),[Ze,Ye,Qe,Je,Ke]=function(i,g,m,_,b,T,P,I,H,W,q){const $=i.getGLRes();_&&(EI.set(_[0],_[1]),i.coordToPointAtRes(EI,$,RI),g-=RI.x,m-=RI.y);const ye=_?EI:null;W=B_(DI,W);const Re=!H&&W||OI;let Be=H&&W||OI;Be=B_(LI,Be),Be[0]&&(Be[0]=NI(i,Be[0],ye)),Be[1]&&(Be[1]=NI(i,Be[1],ye,1));let Ge=.5;b&&(Ge=NI(i,b,ye));let je=Ge/P;if(T&&(je=NI(i,T,ye,1)),q&&(q[0]||q[1])){const g=performance.now()/1e3;let m=q[0],_=q[1];H&&(m=-NI(i,q[0],ye),_=-NI(i,q[1],ye,1)),q[0]&&(H?Be[0]=g*m:Re[0]=g*m),q[1]&&(H?Be[1]=g*_:Re[1]=g*_)}const Xe=(g+Be[0])/(Ge/I[0]),Ze=(m-Be[1])/(je/I[1]);return FI[0]=Ge/I[0],FI[1]=je/I[1],FI[2]=Xe,FI[3]=Ze,FI[4]=Re,FI}(i,I,H,$,Ge,je,W,Be,ye,Re,Xe),et=2*_.getWidth()/Ze,tt=2*_.getHeight()/Ye;if(!this.material)return this._ground.setUniform("uvScale",z_(jI,et,tt)),void this._ground.setUniform("uvOffset",z_(WI,Qe%1+Ke[0],Je%1+Ke[1]));this._ground.setUniform("uvScale",z_(ZI,et,tt)),this._ground.setUniform("uvOffset",z_(qI,Qe%1+Ke[0],Je%1+Ke[1])),this._ground.setUniform("uvOrigin",z_(XI,Qe-Qe%1,Je-Je%1)),this._ground.setUniform("uvRotation",0)}_getGroundDefines(i){let g=!1;const m=this._ground.defines,_=this._layer._getSceneConfig&&this._layer._getSceneConfig(),b=this._layer.getGroundConfig();function T(i,_){i?m[_]||(m[_]=1,g=!0):m[_]&&(delete m[_],g=!0)}T(this._hasIBL(),"HAS_IBL_LIGHTING");T(i&&i.ssr&&b&&b.symbol&&b.symbol.ssr,"HAS_SSR");const P=i&&_&&_.shadow&&_.shadow.enable;T(P,"HAS_SHADOWING"),T(P,"USE_ESM");return T(!!this._polygonPatternFile,"HAS_PATTERN"),g?m:null}_updateMaterial(){const i=this.getSymbol()&&this.getSymbol().material||{},g={};let m=!1;const _=this._layer.getGroundConfig();this._loader.setURLModifier(_.urlModifier);for(const _ in i)if(bI(i,_))if(_.indexOf("Texture")>0){let b=i[_];if(!b)continue;b="string"==typeof b?{url:b,wrap:"repeat"}:b,b.flipY=!0,b.min="linear mipmap linear",b.mag="linear",b.flipY=!0,g[_]=new Texture2D(b,this._loader),m=!0}else g[_]=i[_];this.material?(this._loadingMaterial=new xP.StandardMaterial(g),this._loadingMaterial.isReady()?this._onMaterialComplete():this._loadingMaterial.once("complete",this._bindOnMaterialComplete)):(this.material=new xP.StandardMaterial(g),this.material.once("complete",this._bindOnMaterialComplete,this)),m||this._onMaterialComplete()}_onMaterialComplete(){this._loadingMaterial&&(this.material.dispose(),this.material=this._loadingMaterial,delete this._loadingMaterial),this.setToRedraw()}_createPatternTexture(i){i=kx(i);return this._regl.texture({width:i.width,height:i.height,data:i,mag:"linear",min:"linear mipmap linear",flipY:!0,wrap:"repeat"})}_parseColor(i){return SI([],i)}_getUVOffsetAnim(){return this.material&&this.material.get("uvOffsetAnim")}getRenderMeshes(){return this._groundScene.getMeshes()}}const{createIBLTextures:$I,disposeIBLTextures:YI}=xP.PBRUtils,QI=[0,0,0],JI=[],KI=[];class EnvironmentPainter{constructor(i,g){this._maxLevel=4,this._regl=i,this.renderer=new Renderer(i),this._layer=g,this._init(),this._updateMode()}paint(i){if(!this.isEnable()||!this._resource)return;const g=this._getUniformValues(i);this.renderer.render(this._shader,g,null,i&&i.renderTarget&&i.renderTarget.fbo)}update(){const i=this.getMap();if(!i||!this.isEnable())return;const g=i.getLightManager(),m=g&&g.getAmbientResource();m!==this._resource&&this._iblTexes&&(YI(this._iblTexes),delete this._iblTexes),this._resource=m,this._updateMode()}dispose(){this._shader.dispose(),YI(this._iblTexes),delete this._shader,delete this._iblTexes,delete this._resource}getMap(){return this._layer.getMap()}_updateMode(){if(!this._resource)return;const i=this._layer._getSceneConfig().environment||{};this._shader.setMode(i.toneMapping,i.mode?1:0)}isEnable(){const i=this._layer._getSceneConfig();return this._hasIBL()&&i&&i.environment&&i.environment.enable}_hasIBL(){const i=this.getMap().getLightManager();return!!(i&&i.getAmbientResource())}_getUniformValues(){const i=this.getMap(),g=this.getMap().getLightManager(),m=g&&g.getAmbientLight();let _=this._iblTexes;_||(_=this._iblTexes=$I(this._regl,i));const b=this._layer.getRenderer().canvas,T=this._layer._getSceneConfig().environment||{},P=T.level||0,I=_.prefilterMap.width,H=this._transform=this._transform||[],W=T.brightness||0,q=T.intensity||1;return WA(JI,m&&m.hsv||QI),W&&(JI[2]+=W),KI[0]=b.width,KI[1]=b.height,{cubeMap:_.prefilterMap,bias:P,size:I/Math.pow(2,Math.max(0,P-1)),environmentExposure:yI(m&&m.exposure)?m.exposure:1,backgroundIntensity:q,diffuseSPH:_.sh,viewMatrix:i.viewMatrix,projMatrix:i.projMatrix,resolution:KI,hsv:JI,transformMatrix:uA(H,m&&Math.PI/180*-m.orientation||0)}}_init(){const i=this.getMap();if(i.on("updatelights",this.update,this),this._shader=new SkyboxShader,i.options.lights){const i=this.getMap().getLightManager().getAmbientResource();this._resource=i}}}const ek=[],tk=[.03,.03,.03],nk=[],rk=[],ik=[],ok=[1,1,1],sk=[-1200,-1200,0],ak=[1200,1200,1e3],lk={min:[],max:[]},hk=MA([],o_([],90,0,0),[0,0,0]);class RainPainer{constructor(i,g){this._regl=i,this.renderer=new Renderer(i),this._layer=g,this._timer=new Clock,this._init()}getMap(){return this._layer&&this._layer.getMap()}_init(){const i=this._layer.getRenderer().canvas;this._shader=new MeshShader({vert:"attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nuniform vec3 cameraPosition;\nuniform float top;\nuniform float bottom;\nuniform float time;\nvarying vec2 vTexCoord;\n#include <get_output>\nfloat c(float x, float y) {\n  return atan(y, x);\n}\nvec2 d(vec2 e, vec2 f, vec2 h) {\n  vec2 i = vec2(.0);\n  float j = distance(h, f);\n  float a = c(e.x - f.x, e.y - f.y);\n  h.x > f.x ? a -= .785 : a += .785;\n  i.x = cos(a) * j;\n  i.y = sin(a) * j;\n  return i + f;\n  return i;\n}\nvoid main() {\n  vec4 k = getPosition(aPosition);\n  mat4 l = getPositionMatrix();\n  vec2 m = d(vec2(cameraPosition.x, cameraPosition.z), vec2(aNormal.x, aNormal.z), vec2(k.x, k.z));\n  float n = top - bottom;\n  float y = aNormal.y - bottom - n * time;\n  y = y + (y < .0 ? n : .0);\n  float o = (1. - y / n) * (1. - y / n);\n  y = n * (1. - o);\n  y += bottom;\n  y += aPosition.y - aNormal.y;\n  k = vec4(m.x, y, m.y, 1.);\n  gl_Position = projMatrix * modelViewMatrix * l * k;\n  vTexCoord = aTexCoord;\n}",frag:"precision mediump float;\nvarying vec2 vTexCoord;\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D rainMap;\nvoid main() {\n  vec4 c = texture2D(rainMap, vTexCoord);\n  vec4 d = vec4(diffuse, opacity);\n  d *= c;\n  gl_FragColor = d;\n}",uniforms:[{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(ek,g.viewMatrix,g.modelMatrix)}}],extraCommandProps:{viewport:{x:0,y:0,width:()=>i.width,height:()=>i.height},depth:{enable:!0,mask:!1,func:"less",range:[0,1]},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}}),this._createScene()}_createScene(){const i=this._regl.texture({width:2,height:2});if(this._mesh=this._createRain(),!this._mesh)return;this._scene=new Scene(this._mesh);const g=this._getRainConfig();g.rainTexture?this._creatRainTexture(g.rainTexture).then((i=>{this._mesh.material.set("rainMap",i)})):(this._mesh.material.set("rainMap",i),console.warn("should set rain texture."))}_createRain(){const i=this.getMap(),g=this._getRainConfig();if(!g)return null;this._fixZoom=i.getZoom();const m=this._getFixExtent(),_=this._rainDensity=g.density,b=this._rainWidth=g.rainWidth||1,T=this._rainHeight=g.rainHeight||1,P=[],I=[],H=[],W=[];for(let i=0;i<_;i++){const g={};g.x=Math.random()*(m.max[0]-m.min[0])+m.min[0],g.y=Math.random()*(m.max[2]-m.min[2])+m.min[2],g.z=Math.random()*(m.max[1]-m.min[1])+m.min[1];const _=(m.max[2]-m.min[2])/37.5*T,q=_/3*b;P.push(g.x+q,g.y+_,g.z,g.x-q,g.y+_,g.z,g.x-q,g.y,g.z,g.x+q,g.y,g.z),I.push(g.x,g.y-_/2,g.z,g.x,g.y-_/2,g.z,g.x,g.y-_/2,g.z,g.x,g.y-_/2,g.z),H.push(1,1,0,1,0,0,1,0),W.push(4*i+0,4*i+1,4*i+2,4*i+0,4*i+2,4*i+3)}const q={};q.POSITION=P,q.NORMAL=I,q.TEXCOORD_0=H;const $=new Geometry(q,W,0,{primitive:"triangles",positionAttribute:"POSITION",normalAttribute:"NORMAL",uv0Attribute:"TEXCOORD_0"});$.generateBuffers(this.renderer.device);const ye=new Material({rainMap:this._regl.texture({width:2,height:2}),diffuse:g.color||[1,1,1],opacity:g.opacity||1}),Re=new Mesh($,ye);return Re.setUniform("top",m.max[2]),Re.setUniform("bottom",m.min[2]),this._transformRain(Re),Re.transparent=!0,Re}_creatRainTexture(i){const g=new Image;return g.src=this._rainTexture=i,new Promise(((i,m)=>{g.onload=()=>{const m=this._regl.texture({mag:"linear",min:"linear mipmap nearest",wrapS:"clamp",wrapT:"clamp",data:g});i(m)},g.onerror=i=>{m(i)}}))}paint(i){if(!this._scene)return;const g=this._getRainConfig(),m={},_=this.getMap();m.projMatrix=_.projMatrix,m.viewMatrix=_.viewMatrix,m.cameraPosition=_.cameraPosition;const b=g.speed||1,T=this._timer.getElapsedTime()/(2/b)%1;m.time=T,this._mesh.material.set("diffuse",g.color||ok),this._mesh.material.set("opacity",g.opacity||1),this._transformRain(this._mesh);this.renderer.render(this._shader,m,this._scene,i&&i.renderTarget&&i.renderTarget.fbo),this._layer.getRenderer().setCanvasUpdated()}_transformRain(i){const g=this.getMap(),m=g.coordinateToPointAtRes(g.getCenter(),g.getGLRes()),_=g.getGLScale()/g.getGLScale(this._fixZoom),b=qA(rk,_,_,_),T=$A(b,tk,b),P=mA(ik),I=this._getRainConfig(),H=g.getBearing();OA(P,o_(nk,I.windDirectionX||0,I.windDirectionY||0,90-H),[m.x,m.y,0],T),_A(P,P,hk),i.setLocalTransform(P)}setToRedraw(){const i=this._layer.getRenderer();i&&i.setToRedraw()}update(){const i=this._getRainConfig();if(i){if(this._mesh||this._createScene(),i.density!==this._rainDensity||i.rainWidth!==this._rainWidth||i.rainHeight!==this._rainHeight){const i=this._mesh.material.get("rainMap");this._mesh.geometry.dispose(),this._mesh.dispose(),this._scene.clear(),this._mesh=this._createRain(),this._mesh.material.set("rainMap",i),this._scene.setMeshes(this._mesh)}i.rainTexture!==this._rainTexture&&this._creatRainTexture(i.rainTexture).then((i=>{this._mesh.material.set("rainMap",i)}))}}dispose(){this._mesh&&(this._mesh.geometry.dispose(),this._mesh.material&&this._mesh.material.dispose(),this._mesh.dispose(),delete this._mesh),this._shader&&(this._shader.dispose(),delete this._shader)}isEnable(){const i=this._getRainConfig();return i&&i.enable}_getRainConfig(){const i=this._layer.getWeatherConfig();return i&&i.rain}_getFixExtent(){const i=16.685648411389433-this.getMap().getZoom();return QA(lk.min,sk,Math.pow(2,i)),QA(lk.max,ak,Math.pow(2,i)),lk}}class Clock{constructor(i){this.autoStart=void 0===i||i,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let i=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const g=("undefined"==typeof performance?Date:performance).now();i=(g-this.oldTime)/1e3,this.oldTime=g,this.elapsedTime+=i}return 0}}const ck=[],uk=[.03,.03,.03],fk=[],dk=[],pk=[],gk=MA([],o_([],90,0,0),[0,0,0]);class SnowPainter{constructor(i,g){this._regl=i,this._layer=g,this._init()}_init(){const i=this._layer.getRenderer().canvas;this._shader=new MeshShader({vert:"#include <gl2_vert>\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\n#include <get_output>\nvoid main() {\n  mat4 c = getPositionMatrix();\n  vec4 d = getPosition(aPosition);\n  gl_Position = projMatrix * modelViewMatrix * c * d;\n  vTexCoord = aTexCoord;\n}",frag:"#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nprecision mediump float;\nuniform sampler2D perlinTexture;\nvarying vec2 vTexCoord;\nfloat c(float a, float b, float w) {\n  return a + w * (b - a);\n}\nvoid main() {\n  float d = texture2D(perlinTexture, vTexCoord).r;\n  vec3 e = vec3(1.);\n  float r = c(.5, e.x, d);\n  float g = c(.5, e.y, d);\n  float b = c(.5, e.z, d);\n  glFragColor = vec4(r, g, b, 1.);\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",uniforms:[{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(ck,g.viewMatrix,g.modelMatrix)}}],extraCommandProps:{viewport:{x:0,y:0,width:()=>i.width,height:()=>i.height}}}),this._shader.version=300,this._scene=new Scene,this._groundMask=this._createGroundMask(),this._scene.setMeshes(this._groundMask),this.renderer=new Renderer(this._regl);const g=this._getSnowConfig();g&&(g.snowGroundTexture?this._createSnowTexture(g.snowGroundTexture):(this._groundNormal=this._regl.texture({width:2,height:2}),console.warn("should set snow ground texture.")))}render(i){this._groundNormal&&this._groundMask.material.set("perlinTexture",this._groundNormal);const g=this._layer.getMap();this._transformMask(g);this.renderer.render(this._shader,{projMatrix:g.projMatrix,viewMatrix:g.viewMatrix,cameraPosition:g.cameraPosition},this._scene,i&&i.renderTarget&&i.renderTarget.fbo),this._layer.getRenderer().setCanvasUpdated()}_transformMask(i){const g=i.coordinateToPointAtRes(i.getCenter(),i.getGLRes()),m=i.getGLScale()/i.getGLScale(this._fixZoom),_=qA(dk,m,m,m),b=$A(_,uk,_),T=mA(pk);OA(T,o_(fk,0,0,0),[g.x,g.y,.005],b),_A(T,T,gk),this._groundMask.setLocalTransform(T)}_createSnowTexture(i){const g=new Image;g.onload=()=>{this._groundNormal=this._regl.texture({mag:"linear",min:"linear mipmap nearest",wrapS:"repeat",wrapT:"repeat",data:g})},g.onerror=i=>{console.log(i)},g.src=this._snowGroundTexture=i}_createGroundMask(){const i=this._layer.getMap();this._fixZoom=i.getZoom();const g=16e3*Math.pow(2,16.685648411389433-this._fixZoom),m={};m.POSITION=[-g,0,-g,g,0,-g,-g,0,g,g,0,g],m.NORMAL=[0,1,0,0,1,0,0,1,0,0,1,0],m.TEXCOORD_0=[0,0,1,0,0,1,1,1];const _=new Geometry(m,[3,1,0,0,2,3],0,{positionAttribute:"POSITION",normalAttribute:"NORMAL",uv0Attribute:"TEXCOORD_0"});_.generateBuffers(this._regl);const b=new Material({perlinTexture:this._regl.texture({width:2,height:2})});return new Mesh(_,b)}getMeshes(){return this._groundMask}dispose(){this._groundMask&&(this._groundMask.geometry.dispose(),this._groundMask.material&&this._groundMask.material.dispose(),this._groundMask.dispose(),delete this._groundMask),this._shader&&(this._shader.dispose(),delete this._shader)}update(){const i=this._getSnowConfig();i&&i.snowGroundTexture===!this._snowGroundTexture&&this._createSnowTexture(i.snowGroundTexture)}isEnable(){const i=this._getSnowConfig();return i&&i.enable}_getSnowConfig(){const i=this._layer.getWeatherConfig();return i&&i.snow}}const mk=[];class WeatherPainter{constructor(i,g,m){this._regl=i,this._layer=g,this._config=m,this._init()}_init(){this.renderer=new Renderer(this._regl);const i=this._layer.getRenderer(),g=this._viewport={x:0,y:0,width:()=>i.canvas?i.canvas.width:1,height:()=>i.canvas?i.canvas.height:1};this._width=g.width,this._height=g.height,this._fbo=this._regl.framebuffer({color:this._regl.texture({width:i.canvas?i.canvas.width:1,height:i.canvas?i.canvas.height:1,wrap:"clamp",mag:"linear",min:"linear"}),depth:!0}),this.EMPTY_TEXTURE=this._regl.texture({width:2,height:2}),this._rainPainter=new RainPainer(this._regl,this._layer),this._rainRipplesPass=new RainRipplePass(this._regl,g),this._snowPainter=new SnowPainter(this._regl,this._layer),this._fogPass=new FogPass(this._regl,g,this._layer),this._weatherShader=new FogShader,this._weatherShader.version=300}getMap(){return this._layer&&this._layer.getMap()}renderScene(i){this.renderSnowMask(i),this.renderRain(i)}renderRain(i){this.isEnableRain()&&this._rainPainter.paint(i)}renderSnowMask(i){if(!this.isEnableSnow()||!this._showSnowGround())return;const g=this.getMap();this._snowPainter.render(i,g)}paint(i,g){if(!g||!g.length)return i;this._resize();const m=this._layer.getWeatherConfig(),_={};if(this.isEnableRain()?(_.ripplesMap=this._renderRainRipples(),this._weatherShader.shaderDefines.HAS_RAIN=1):delete this._weatherShader.shaderDefines.HAS_RAIN,this.isEnableSnow()?(this._weatherShader.shaderDefines.HAS_SNOW=1,_.snowIntensity=fx(m.snow.snowIntensity)?m.snow.snowIntensity:.5,g.forEach((i=>{i.defines.HAS_SNOW=1}))):(delete this._weatherShader.shaderDefines.HAS_SNOW,g.forEach((i=>{delete i.defines.HAS_SNOW}))),this.isEnableFog()){_.fogColor=m.fog.color||[.9,.9,.9],this._weatherShader.shaderDefines.HAS_FOG=1}else delete this._weatherShader.shaderDefines.HAS_FOG;return this._weatherShader.setDefines(this._weatherShader.shaderDefines),_.mixFactorMap=this._renderMixFactor(g)||this.EMPTY_TEXTURE,_.sceneMap=i,_.time=this._getTimeSpan()/1e3,_.resolution=z_(mk,this._fbo.width,this._fbo.height),this.renderer.render(this._weatherShader,_,null,this._fbo),this._renderMeshes=g,this._fbo}_renderMixFactor(i){const g={},m=this.getMap(),_=m.getZoom(),b=Math.pow(2,16.685648411389433-_),T=this._layer.getWeatherConfig(),P=T.fog;if(!P||!P.enable)return null;const I=P.start||.1,H=P.end||100;g.projMatrix=m.projMatrix,g.viewMatrix=m.viewMatrix,g.cameraPosition=m.cameraPosition,g.fogDist=[I*b,H*b],g.rainDepth=m.altitudeToPoint(T.rain&&T.rain.rainDepth||.1,m.getGLRes());const W=this._fogPass.render(i,g);return this._layer.getRenderer()._getFBOColor(W)}_renderRainRipples(){const i=this.getMap(),g=this._layer.getWeatherConfig(),m=g.rain.rippleRadius||24,_={};_.projMatrix=i.projMatrix,_.viewMatrix=i.viewMatrix,_.time=this._getTimeSpan()/1e3,_.rippleRadius=m,_.density=g.rain.density||2e3;return this._rainRipplesPass.render(i,_)}_getTimeSpan(){if(!this._layer)return 0;if(void 0===this._currentFrameTime&&(this._currentFrameTime=0),this.isPlaying()){const i=this._layer.getRenderer();this._currentFrameTime=i.getFrameTime()}return this._currentFrameTime}isEnable(){const i=this._layer.getWeatherConfig();return i&&i.enable}isEnableRain(){const i=this._layer.getWeatherConfig();return i&&i.enable&&i.rain&&i.rain.enable}isEnableFog(){const i=this._layer.getWeatherConfig();return i&&i.enable&&i.fog&&i.fog.enable}isEnableSnow(){const i=this._layer.getWeatherConfig();return i&&i.enable&&i.snow&&i.snow.enable}_showSnowGround(){const i=this._layer.getWeatherConfig();return this.isEnableSnow()&&!1===i.snow.showGround}isPlaying(){const i=this._layer.getWeatherConfig();return!!i&&!1!==i.playing}_hasWeather(){return this.isEnableRain()||this.isEnableFog()||this.isEnableSnow()}update(){!this.isEnable()&&this._renderMeshes&&this._renderMeshes.forEach((i=>{delete i.defines.HAS_SNOW,delete i.defines.HAS_RAIN,delete i.defines.HAS_FOG})),this.isEnableRain()&&(this._rainPainter=this._rainPainter||new RainPainer(this._regl,this._layer),this._rainPainter.update()),this.isEnableSnow()&&(this._snowPainter=this._snowPainter||new SnowPainter(this._regl,this._layer),this._snowPainter.update())}getShadowMeshes(){return this._snowPainter.getMeshes()}_resize(){const i=this._width(),g=this._height();!this._fbo||this._fbo.width===i&&this._fbo.height===g||this._fbo.resize(i,g)}dispose(){this._fbo&&this._fbo.destroy(),this._weatherShader&&(this._weatherShader.dispose(),delete this._weatherShader),this._rainPainter&&(this._rainPainter.dispose(),delete this._rainPainter),this._snowPainter&&(this._snowPainter.dispose(),delete this._snowPainter)}}const Ak=[],yk=i=>!!i.bloom,_k=i=>!!i.ssr;class PostProcess{constructor(i,g){this._regl=i,this._layer=g,this._renderer=new Renderer(i),this._fxaaShader=new FxaaShader,this._copyShader=new CopyShader,this._ssrPass=new SsrPass(this._regl)}setContextIncludes(){}bloom(i,g,m,_,b,T,P){this._bloomPass||(this._bloomPass=new BloomPass(this._regl));const I=this._layer.getRenderer()._getFBOColor(this._bloomFBO);return this._bloomPass.render(i,I,_,b,T,g,m,P)}drawBloom(i){const g=this._layer.getRenderer(),m=this._regl,_=this._bloomFBO;if(_){const{width:g,height:b}=i;_.width===g&&_.height===b||_.resize(g,b),m.clear({color:[0,0,0,0],framebuffer:_})}else{const g=this._createFBOInfo(i);this._bloomFBO=m.framebuffer(g)}const b=g.getFrameTime(),T=g.getFrameEvent(),P=g.getFrameContext(),I=P.renderMode,H=P.sceneFilter,W=P.renderTarget;P.isPostProcess=!0,P.renderMode="default",P.sceneFilter=yk,P.renderTarget={fbo:this._bloomFBO,getFramebuffer:vk,getDepthTexture:xk};const q=g.reglGL;return q.resetDrawCalls(),g.forEachRenderer(T?i=>{g.clearStencil(i,_),i.drawOnInteracting(T,b,P)}:i=>{g.clearStencil(i,_),i.draw(b,P)}),delete P.isPostProcess,P.renderMode=I,P.sceneFilter=H,P.renderTarget=W,q.getDrawCalls()}genSsrMipmap(i,g){const m=this._layer.getMap().projViewMatrix;this._ssrPass.genMipMap(i,g,m)}getPrevSsrProjViewMatrix(){return this._ssrPass&&this._ssrPass.getPrevProjViewMatrix()}drawSSR(i,g,m){m&&this._ssrPass.copyDepthTex(i);const _=this._layer.getRenderer(),b=_.getFrameTime(),T=_.getFrameEvent(),P=_.getFrameContext();P.isPostProcess=!0,P.ssr=this.getSSRContext();const I=P.renderMode,H=P.sceneFilter;P.renderMode="default",P.sceneFilter=_k,P.renderTarget.fbo=g;const W=_.reglGL;let q=!1;_.forEachRenderer(T?i=>{_.clearStencil(i,g),q||(W.resetDrawCalls(),q=!0),i.drawOnInteracting(T,b,P)}:i=>{_.clearStencil(i,g),q||(W.resetDrawCalls(),q=!0),i.draw(b,P)});const $=_.drawGround();return delete P.ssr,delete P.isPostProcess,P.renderMode=I,P.sceneFilter=H,this._ssrPainted=W.getDrawCalls()>0,$}getSSRUniforms(){const i=this._layer._getSceneConfig(),g=i&&i.postProcess,m=this._layer.getMap();return this._ssrPass.getSSRUniforms(m,g.ssr.factor,g.ssr.quality)}getSSRContext(){const i=this._layer._getSceneConfig(),g=i&&i.postProcess,m=this._layer.getMap(),_=this._ssrPass.getSSRUniforms(m,g.ssr.factor,g.ssr.quality);if(!_)return null;return{renderUniforms:_,defines:{HAS_SSR:1}}}fxaa(i,g,m,_,b,T,P,I,H,W,q,$){!i||i.width===g.fbo&&i.height===g.height||i.resize(g.width,g.height);const ye={};I?ye.HAS_OUTLINE_TEX=1:delete ye.HAS_OUTLINE_TEX,this._fxaaShader.setDefines(ye),this._renderer.render(this._fxaaShader,{textureSource:g,resolution:z_(Ak,g.width,g.height),enableFXAA:m,enableToneMapping:_,enableSharpen:b,pixelRatio:T,sharpFactor:P,textureOutline:I,highlightFactor:H,outlineFactor:W,outlineWidth:q,outlineColor:$},null,i)}renderFBOToScreen(i,g,m,_){this._copyFBOSize||(this._copyFBOSize=[]),this._copyFBOSize[0]=i.width,this._copyFBOSize[1]=i.height;const b=this._layer.getRenderer();this._renderer.render(this._copyShader,{texture:i.color&&b._getFBOColor(i)||i,size:this._copyFBOSize,enableSharpen:+!!g,sharpFactor:m,pixelRatio:_})}postprocess(i,g,m){this._postProcessShader||(this._postProcessShader=new PostProcessShader);const _=this._layer&&this._layer.getRenderer(),b=m||_._getFBOColor(i);return g.resolution=z_(Ak,b.width,b.height),g.textureSource=b,g.timeGrain=performance.now(),this._renderer.render(this._postProcessShader,g),this._target}dispose(){this._bloomFBO&&(this._bloomFBO.destroy(),delete this._bloomFBO),this._bloomPass&&(this._bloomPass.dispose(),delete this._bloomPass),this._postProcessShader&&(this._postProcessShader.dispose(),delete this._postProcessShader),this._fxaaShader&&(this._fxaaShader.dispose(),delete this._fxaaShader),this._copyShader&&(this._copyShader.dispose(),delete this._copyShader)}_createFBOInfo(i,g){const{width:m,height:_}=this._layer.getRenderer().canvas,b=this._regl;let T;T=this._layer.getRenderer()._isUseMultiSample()?b.renderbuffer({width:m,height:_,samples:this._layer.options.multiSamples,format:"rgba8"}):b.texture({min:"nearest",mag:"nearest",format:g||"rgba",width:m,height:_});const P={width:m,height:_,colors:[T]};return i&&(P.depthStencil=i),P}}function vk(i){return i._framebuffer.framebuffer}function xk(i){return i.depthStencil._texture.texture}class AnalysisShader extends QuadShader{constructor(i){super({vert:"#if __VERSION__ == 300\n#define attribute in\n#define varying out\n#endif\nattribute vec2 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_Position = vec4(aPosition, 0., 1.);\n  vTexCoord = aTexCoord;\n}",frag:"#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\n#ifdef HAS_FLOODANALYSE\nuniform vec3 flood_waterColor;\nuniform float flood_waterOpacity;\nuniform sampler2D floodMap;\n#endif\n#ifdef HAS_SKYLINE\nuniform sampler2D skylineMap;\n#endif\n#ifdef HAS_VIEWSHED\nuniform vec4 viewshed_visibleColor;\nuniform vec4 viewshed_invisibleColor;\nuniform sampler2D viewshedMap;\n#endif\n#ifdef HAS_INSIGHT\nuniform vec4 insight_visibleColor;\nuniform vec4 insight_invisibleColor;\nuniform sampler2D insightMap;\n#endif\n#ifdef HAS_CUT\nuniform sampler2D meshesMap;\nuniform sampler2D invisibleMap;\n#endif\n#ifdef HAS_EXCAVATE\nuniform sampler2D excavateMap;\n#endif\n#ifdef HAS_CROSSCUT\nuniform sampler2D crosscutMap;\nuniform vec4 cutLineColor;\n#endif\n#ifdef HAS_HEIGHTLIMIT\nuniform vec3 limitColor;\nuniform sampler2D heightLimitMap;\n#endif\nuniform sampler2D sceneMap;\nvoid main() {\n  vec4 c = texture2D(sceneMap, vTexCoord);\n  glFragColor = c;\n#ifdef HAS_VIEWSHED\nvec4 d = texture2D(viewshedMap, vTexCoord);\n  if(d.r > .99) {\n    glFragColor = vec4(mix(viewshed_invisibleColor.rgb, c.rgb, viewshed_invisibleColor.a), c.a);\n  } else if(d.g > .99) {\n    glFragColor = vec4(mix(viewshed_visibleColor.rgb, c.rgb, viewshed_visibleColor.a), c.a);\n  } else if(d.a < .01) {\n    glFragColor = vec4(d.rgb, 1.);\n  }\n  \n  \n#endif\n#ifdef HAS_FLOODANALYSE\nvec4 e = texture2D(floodMap, vTexCoord);\n  if(e.r > .0) {\n    glFragColor = vec4(mix(glFragColor.rgb, flood_waterColor, flood_waterOpacity), glFragColor.a);\n  }\n#endif\n#ifdef HAS_SKYLINE\nvec4 f = texture2D(skylineMap, vTexCoord);\n  if(f.r > .0 || f.g > .0 || f.b > .0) {\n    glFragColor = f;\n  }\n#endif\n#ifdef HAS_INSIGHT\nvec4 h = texture2D(insightMap, vTexCoord);\n  if(h.g > .0) {\n    glFragColor = insight_visibleColor;\n  } else if(h.r > .0) {\n    glFragColor = insight_invisibleColor;\n  }\n  \n#endif\n#ifdef HAS_CUT\nvec4 i = texture2D(invisibleMap, vTexCoord);\n  vec4 j = texture2D(meshesMap, vTexCoord);\n  if(i.r == 1. && i.g == .0 && i.b == .0) {\n    glFragColor = j;\n  } else if(i.r == .0 && i.g == 1. && i.b == .0) {\n    glFragColor = j;\n  } else if(i.r == .0 && i.g == .0 && i.b == 1.) {\n    glFragColor = c;\n  }\n  \n  \n#endif\n#ifdef HAS_EXCAVATE\nvec4 k = texture2D(excavateMap, vTexCoord);\n  if(k.r == 1. && k.g == .0 && k.b == .0) {\n    glFragColor = c;\n  } else {\n    glFragColor = k;\n  }\n#endif\n#ifdef HAS_CROSSCUT\nvec4 l = texture2D(crosscutMap, vTexCoord);\n  if(l.r > .0) {\n    glFragColor = vec4(mix(cutLineColor.rgb, glFragColor.rgb, .99), glFragColor.a);\n  }\n#endif\n#ifdef HAS_HEIGHTLIMIT\nvec4 m = texture2D(heightLimitMap, vTexCoord);\n  if(m.r > .0) {\n    glFragColor = vec4(mix(limitColor, glFragColor.rgb, .6), glFragColor.a);\n  }\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",extraCommandProps:{viewport:i,cull:{enable:!0},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"},equation:"add"}}})}}class AnalysisPainter{constructor(i,g,m){this._regl=i,this._layer=g,this._config=m,this._init()}_init(){this.renderer=new Renderer(this._regl);const i=this._layer.getRenderer(),g=this._viewport={x:0,y:0,width:()=>i.canvas?i.canvas.width:1,height:()=>i.canvas?i.canvas.height:1};this._fbo=this._regl.framebuffer({color:this._regl.texture({width:i.canvas?i.canvas.width:1,height:i.canvas?i.canvas.height:1,wrap:"clamp",mag:"linear",min:"linear"}),depth:!0}),this._shader=new AnalysisShader(g)}getMap(){return this._layer&&this._layer.getMap()}paint(i,g){if(!g&&g.length)return i;this._resize();const m={},_=this._layer._analysisTaskList;if(!this._hasAnalysis())return i;this._regl.clear({color:[0,0,0,0],depth:1,stencil:0,framebuffer:this._fbo}),delete this._shader.shaderDefines.HAS_FLOODANALYSE,delete this._shader.shaderDefines.HAS_VIEWSHED,delete this._shader.shaderDefines.HAS_SKYLINE,delete this._shader.shaderDefines.HAS_INSIGHT,delete this._shader.shaderDefines.HAS_CUT,delete this._shader.shaderDefines.HAS_CROSSCUT,delete this._shader.shaderDefines.HAS_HEIGHTLIMIT;for(let i=0;i<_.length;i++){const b=_[i];if(!b.isEnable())continue;const T=b.getDefines();mI(this._shader.shaderDefines,T);const P=this.getMap(),I=P.width,H=P.height,W=this._getToAnalysisMeshes(g,b.getExcludeLayers()),q=b.renderAnalysis(W,I,H);q&&mI(m,q)}return m.sceneMap=i,this._shader.setDefines(this._shader.shaderDefines),this.renderer.render(this._shader,m,null,this._fbo),this._fbo}_getToAnalysisMeshes(i,g){let m=[];for(let _=0;_<i.length;_++){if(g.indexOf(i[_].getId())>-1)continue;const b=i[_].getRenderer();if(b&&b.getAnalysisMeshes){const i=b.getAnalysisMeshes();i.forEach((i=>{i.setUniform("useAnalysis",1)})),m=m.concat(i)}}return m}_resize(){const i=Po.isFunction(this._viewport.width.data)?this._viewport.width.data():this._viewport.width,g=Po.isFunction(this._viewport.height.data)?this._viewport.height.data():this._viewport.height;!this._fbo||this._fbo.width===i&&this._fbo.height===g||this._fbo.resize(i,g)}_hasAnalysis(){const i=this._layer&&this._layer._analysisTaskList;if(!i)return!1;for(let g=0;g<i.length;g++)if(i[g].isEnable())return!0;return!1}}const bk=[],wk=new pl(0,0);let Tk={};class ScanEffectPainter{constructor(i,g){this._regl=i,this._layer=g,this._init()}_init(){this.renderer=new Renderer(this._regl);const i=this._layer.getRenderer(),g=this._viewport={x:0,y:0,width:()=>i.canvas?i.canvas.width:1,height:()=>i.canvas?i.canvas.height:1};this._width=g.width,this._height=g.height,this._fbo=this._regl.framebuffer({color:this._regl.texture({width:i.canvas?i.canvas.width:1,height:i.canvas?i.canvas.height:1,wrap:"clamp",mag:"linear",min:"linear"}),depth:!0}),this.EMPTY_TEXTURE=this._regl.texture({width:2,height:2}),this._shader=new EffectShader,this._pass=new ScanEffectPass(this._regl,g,this._layer),this._shader.version=300}getMap(){return this._layer&&this._layer.getMap()}paint(i,g){if(!g||!g.length)return i;const m=this._layer.getMap();this._resize();const _=this._layer.getScanEffectConfig(),b={},{effects:T}=_,P=m.getGLRes(),I=[];this._effectLength!==T.length&&(Tk={});for(let i=0;i<T.length;i++){const{center:g,radius:_,speed:b,color:H,direction:W,height:q}=T[i],$=Sk(g),ye=m.coordinateToPointAtRes($,P,wk).toArray(),Re=m.distanceToPointAtRes(_,0,P).x,Be="vertical"===W?1:0,Ge=m.altitudeToPoint(q||0,P);Tk[i]=Tk[i]||[];const je=aA(Tk[i],ye[0],ye[1],Re,b,H[0],H[1],H[2],Be,Ge);I.push(je)}const H={projMatrix:m.projMatrix,viewMatrix:m.viewMatrix,effectInfos:I,effectTime:this._getTimeSpan()/1e3},W=this._layer.getRenderer(),q=this._pass.render(g,H)||this.EMPTY_TEXTURE;return b.scanEffectMap=W._getFBOColor(q),b.sceneMap=i,b.resolution=z_(bk,this._fbo.width,this._fbo.height),this.renderer.render(this._shader,b,null,this._fbo),this._fbo}_getTimeSpan(){if(!this._layer)return 0;if(void 0===this._currentFrameTime&&(this._currentFrameTime=0),this.isPlaying()){const i=this._layer.getRenderer();this._currentFrameTime=i.getFrameTime()}return this._currentFrameTime}isPlaying(){const i=this._layer.getScanEffectConfig();return!!i&&!1!==i.playing}_resize(){const i=this._width(),g=this._height();!this._fbo||this._fbo.width===i&&this._fbo.height===g||this._fbo.resize(i,g)}dispose(){this._fbo&&this._fbo.destroy(),this._shader&&(this._shader.dispose(),delete this._shader),this._pass&&this._pass.dispose()}}function Sk(i){return Array.isArray(i)?(wk.x=i[0],wk.y=i[1],wk):i}function Mk(i,g,m,_,b){const T={alpha:!0,depth:!0,stencil:!0,preserveDrawingBuffer:g},P=function(i,g,m){const _=m?["webgl","experimental-webgl"]:["webgl2","webgl","experimental-webgl"];let b=null;for(let m=0;m<_.length;++m){try{b=i.getContext(_[m],g)}catch(i){}if(b)break}b||console.error("Browser doesn't support WebGL.");return b}(i,T,m);!function(i,g,m){g&&g.forEach((g=>{i.getExtension(g)}));m&&m.forEach((g=>{i.getExtension(g)}))}(P,_,b),P.wrap=()=>new Qv(P);const I=P.wrap(),H=Wm({gl:I,attributes:T,extensions:_,optionalExtensions:b}),W={gl:P,reglGL:I,regl:H,device:H,getImageData:(g,m,_,b)=>{const T=new Uint8Array(_*b*4);return H.read({x:g,y:i.height-m,width:_,height:b,data:T}),new ImageData(new Uint8ClampedArray(T.buffer),_,b)}};return{gl:P,reglGL:I,regl:H,context:W}}const Ck=function(i){return class extends i{createContext(){this.createCanvas();const i=this.getMap(),{preserveDrawingBuffer:g,onlyWebGL1:m,extensions:_,optionalExtensions:b}=i.options,{gl:T,regl:P,reglGL:I,context:H}=Mk(this.canvas,g,m,_,b);this.gl=T,this.regl=P,this.reglGL=I,this.context=H,this.context.device=P,this.device=this.regl}}},{LayerAbstractRenderer:Pk}=Om,Ik=[0,0,0,0],kk=[1,1,-1],Ok=[0,0],Ek=i=>!i.bloom&&!i.ssr,Rk=i=>!i.bloom,Lk=i=>!i.ssr;class GroupGLLayerRenderer extends(Ck(Pk)){setToRedraw(){this.setRetireFrames(),super.setToRedraw()}onAdd(){super.onAdd(),this.prepareCanvas()}updateSceneConfig(){this._groundPainter&&this._groundPainter.update(),this._envPainter&&this._envPainter.update(),this._weatherPainter&&this._weatherPainter.update(),this.setToRedraw()}render(...i){this.getMap()&&this.layer.isVisible()&&(this.forEachRenderer((i=>{i._replacedDrawFn||(i.draw=this._buildDrawFn(i.draw),i.drawOnInteracting=this._buildDrawOnInteractingFn(i.drawOnInteracting),i.setToRedraw=this._buildSetToRedrawFn(i.setToRedraw),i._replacedDrawFn=!0)})),this.prepareRender(),this.prepareCanvas(),this.layer._updatePolygonOffset(),this._toRedraw=!1,this._renderChildLayers("render",i),this._renderOutlines(),this._postProcess())}prepareCanvas(){super.prepareCanvas(),this.forEachRenderer((i=>{i.prepareCanvas()}))}drawOnInteracting(...i){this.getMap()&&this.layer.isVisible()&&(this.layer._updatePolygonOffset(),this._toRedraw=!1,this._renderChildLayers("drawOnInteracting",i),this._renderOutlines(),this._postProcess())}_renderChildLayers(i,g){this._renderMode="default";const m=this.hasRenderTarget(),_=this._getDrawContext(g);if(m&&(this._drawContext.renderTarget=this._getFramebufferTarget()),this._envPainter.paint(_),this.drawGround(!0),!m)return void this._renderInMode("default",null,i,g,!0);const b=this.reglGL,T=this.layer._getSceneConfig(),P=T&&T.postProcess,I=this.isSSROn();_.jitter=Ok;const H=this.layer.getGroundConfig();_.hasSSRGround=!!(I&&H&&H.enable&&H.symbol&&H.symbol.ssr),b.resetDrawCalls(),this._renderInMode("default",this._targetFBO,i,g,!0),I&&this._postProcessor.drawSSR(this._blitDepthTex(),this._targetFBO);P.bloom&&P.bloom.enable&&(this._bloomPainted=this._postProcessor.drawBloom(this._depthTex)),2===I&&this._postProcessor.drawSSR(this._blitDepthTex(),this._targetFBO,!0),b.resetDrawCalls(),this._weatherPainter.renderScene(_),this._pointDrawCount=b.getDrawCalls()}_renderInMode(i,g,m,_,b){this._renderMode=i;const T=this._getDrawContext(_);T.renderMode=this._renderMode,T.renderTarget&&(T.renderTarget.fbo=g),b&&(T.isFinalRender=!0),this.forEachRenderer(((i,b)=>{b.isVisible()&&(this.clearStencil(i,g),i[m].apply(i,_))}))}_getDrawContext(i){let g=i[0];return Dk(g)||(g=i[1]),g!==this._contextFrameTime&&(this.forEachRenderer(((i,g)=>{g.isVisible()&&i.needRetireFrames&&i.needRetireFrames()&&this.setRetireFrames()})),this._drawContext=this._prepareDrawContext(g),this._contextFrameTime=g,this._frameEvent=Dk(i[0])?null:i[0]),this._drawContext}_renderOutlines(){if(!this.isEnableOutline())return;const i=this._getOutlineFBO(),g=this.reglGL;g.resetDrawCalls(),this.forEachRenderer(((g,m)=>{m.isVisible()&&g.drawOutline&&g.drawOutline(i)})),this._outlineCounts=g.getDrawCalls()}_getOutlineFBO(){const{width:i,height:g}=this.canvas;let m=this._outlineFBO;if(m)i===m.width&&g===m.height||m.resize(i,g);else{const _=this.regl.texture({width:i,height:g,format:"rgba4",sampleCount:4});m=this._outlineFBO=this.regl.framebuffer({width:i,height:g,colors:[_],depth:!1,stencil:!1})}return m}_getFBOColor(i){if(this._isUseMultiSample()){const g=this._getBlitFBO(i);return g.width!==i.width||g.height!==i.height?g.resize(i.width,i.height):this.regl.clear({color:[0,0,0,0],framebuffer:g}),g.blit(i),g.color[0]}return i.color[0]}_blitDepthTex(){if(this._depthTex.subimage)return this._depthTex;const{width:i,height:g}=this._depthTex;if(!this._blitDepthFBO){const m=this.regl,_=m.texture({min:"nearest",mag:"nearest",mipmap:!1,type:"depth stencil",width:i,height:g,format:"depth stencil"}),b=m.renderbuffer({width:i,height:g,format:"rgba4"});this._blitDepthFBO=m.framebuffer({depthStencil:_,colors:[b],colorFormat:"rgba4",width:i,height:g})}return this._blitDepthFBO.width===i&&this._blitDepthFBO.height===g||this._blitDepthFBO.resize(i,g),this.regl.clear({color:[0,0,0,0],depth:1,framebuffer:this._blitDepthFBO}),this._blitDepthFBO.blit(this._targetFBO,256,"nearest"),this._blitDepthFBO.depthStencil}_getBlitFBO(i){if(this._blitFBOs||(this._blitFBOs=[]),!i._blitFBO){const g=this._createSimpleFBOInfo(!0,i.width,i.height),m=this.regl.framebuffer(g);this._blitFBOs.push(m),i._blitFBO=m}return i._blitFBO}_isUseMultiSample(){if(this.device&&this.device.wgpu)return!1;return 0===this.regl.limits.version.indexOf("WebGL 2.0")&&this.layer.options.antialias}hasRenderTarget(){const i=this.layer._getSceneConfig(),g=i&&i.postProcess;return!(!g||!g.enable)}testIfNeedRedraw(){if(this.layer.options.forceRedrawPerFrame)return!0;if(this._toRedraw)return this._toRedraw=!1,!0;if(this.getMap().isInteracting()&&(this._groundPainter&&this._groundPainter.isEnable()||this._envPainter&&this._envPainter.isEnable()))return!0;if(this._weatherPainter&&this._weatherPainter.isEnable())return!0;if(this.isEnableScanEffect())return!0;const i=this.layer.getTerrainLayer();if(i){const g=i.getRenderer();if(g&&g.testIfNeedRedraw())return this._needUpdateSSR=!0,!0}const g=this._getLayers();for(const i of g){if(!i)continue;const g=i.getRenderer();if(g&&g.testIfNeedRedraw())return this._needUpdateSSR=!0,!0}return!1}isRenderComplete(){const i=this._getLayers();for(const g of i){const i=g.getRenderer();if(i&&!i.isRenderComplete())return!1}return!0}mustRenderOnInteracting(){const i=this._getLayers();for(const g of i){const i=g.getRenderer();if(i&&i.mustRenderOnInteracting())return!0}return!1}isCanvasUpdated(){if(super.isCanvasUpdated())return!0;const i=this._getLayers();for(const g of i){const i=g.getRenderer();if(i&&i.isCanvasUpdated())return!0}return!1}isBlank(){if(this._groundPainter&&this._groundPainter.isEnable())return!1;if(this._envPainter&&this._envPainter.isEnable())return!1;const i=this.layer.getTerrainLayer();if(i){const g=i.getRenderer();if(g&&!g.isBlank())return!1}const g=this._getLayers();for(const i of g){const g=i.getRenderer();if(g&&!g.isBlank())return!1}return!0}initContext(){if(super.initContext(),!this.context)return;this.forEachRenderer((i=>{i.canvas&&i.initContext()}));const i=this.layer,{regl:g,gl:m,reglGL:_,device:b}=this.context;this.device=b||g,this.regl=g,this.reglGL=_,this.gl=m,this.canvas.gl=this.gl,this._jitter=[0,0];const T=g||b;this._groundPainter=new GroundPainter(T,this.layer),this._envPainter=new EnvironmentPainter(T,this.layer);const P=this.layer.getWeatherConfig();this._weatherPainter=new WeatherPainter(T,i,P),this._analysisPainter=new AnalysisPainter(T,i),this._scanEffectPainter=new ScanEffectPainter(T,i);const I=this.layer._getSceneConfig()||{},H=I&&I.postProcess;this._jitGetter=new Jitter(H&&H.antialias&&H.antialias.jitterRatio||.2),this._postProcessor=new PostProcess(T,this.layer,this._jitGetter),this._shadowProcess=new ShadowProcess(T,this.layer)}clearContext(){super.clearContext(),this._clearFramebuffers()}_clearFramebuffers(){const i=this.regl;this._targetFBO&&i.clear({color:Ik,depth:1,stencil:0,framebuffer:this._targetFBO}),this._outlineFBO&&i.clear({color:Ik,depth:1,stencil:0,framebuffer:this._outlineFBO})}resizeCanvas(){const i=this.canvas.width,g=this.canvas.height;!this._targetFBO||this._targetFBO.width===i&&this._targetFBO.height===g||(super.resizeCanvas(),this._targetFBO.resize(i,g),this._clearFramebuffers(),this.forEachRenderer((i=>{i.canvas&&i.resizeCanvas()})))}_getLayers(){return this.layer._getLayers()}forEachRenderer(i){const g=this._getLayers();for(const m of g){if(!m.isVisible()||!m.options.beneathTerrain)continue;const g=m.getRenderer();g&&i(g,m)}const m=this.layer.getTerrainLayer();if(m){const g=m.getRenderer();g&&i(g,m)}for(const m of g){if(!m.isVisible()||m.options.beneathTerrain)continue;const g=m.getRenderer();g&&i(g,m)}}clearStencil(i,g){const m={stencil:i.getStencilValue?i.getStencilValue():255};g&&(m.framebuffer=g),this.device.clear(m)}onRemove(){const i=this.canvas.pickingFBO;i&&i.destroy&&!i.___disposed&&(i.___disposed=!0,i.destroy()),this._destroyFramebuffers(),this._groundPainter&&(this._groundPainter.dispose(),delete this._groundPainter),this._envPainter&&(this._envPainter.dispose(),delete this._envPainter),this._shadowProcess&&(this._shadowProcess.dispose(),delete this._shadowProcess),this._postProcessor&&(this._postProcessor.dispose(),delete this._postProcessor),this._outlineFBO&&(this._outlineFBO.destroy(),delete this._outlineFBO),this._weatherPainter&&(this._weatherPainter.dispose(),delete this._weatherPainter),delete this.gl,delete this.regl,super.onRemove()}hitDetect(){return!1}_destroyFramebuffers(){if(this._targetFBO&&(this._targetFBO.destroy(),delete this._targetFBO,this._postFBO&&(this._postFBO.destroy(),delete this._postFBO),this._blitDepthFBO&&(this._blitDepthFBO.destroy(),delete this._blitDepthFBO),this._blitFBOs)){for(let i=0;i<this._blitFBOs.length;i++)this._blitFBOs[i]&&this._blitFBOs[i].destroy();delete this._blitFBOs}}setRetireFrames(){this._needRetireFrames=!0}getFrameTime(){return this._contextFrameTime}getFrameEvent(){return this._frameEvent}getFrameContext(){return this._drawContext}drawGround(i){const g=this.layer.getGroundConfig();if(!g||!g.enable)return!1;if(!this._groundPainter)return!1;const m=this.getFrameContext(),_=m.jitter;m.jitter=Ok;const b=this.layer.getPolygonOffsetCount();let T;m.offsetFactor=b+1,m.offsetUnits=b+1,i&&(T=m.sceneFilter,delete m.sceneFilter);const P=this._groundPainter.paint(m);return this._groundPainter.needToRedraw()&&this.setToRedraw(),T&&(m.sceneFilter=T),m.jitter=_,P}_buildDrawFn(i){const g=this;return function(m,_){return(_=_||g._drawContext)&&_.renderTarget&&(_.renderTarget.getFramebuffer=Fk,_.renderTarget.getDepthTexture=Nk),i.call(this,m,_)}}_buildDrawOnInteractingFn(i){const g=this;return function(m,_,b){return(b=b||g._drawContext)&&b.renderTarget&&(b.renderTarget.getFramebuffer=Fk,b.renderTarget.getDepthTexture=Nk),i.call(this,m,_,b)}}_buildSetToRedrawFn(i){return function(...g){return i.apply(this,g)}}isEnableSSR(){const i=this.layer._getSceneConfig(),g=i&&i.postProcess;return g&&g.enable&&g.ssr&&g.ssr.enable}isSSROn(){const i=this.isEnableSSR(),g=this.getMap();if(!i||g.getPitch()<=-.001)return 0;const m=g.projViewMatrix,_=this._postProcessor.getPrevSsrProjViewMatrix();return _&&BA(_,m)?1:2}isEnableTAA(){return!1}isEnableSSAO(){return!1}isEnableOutline(){const i=this.layer._getSceneConfig(),g=i&&i.postProcess;return g&&g.enable&&g.outline&&g.outline.enable}isEnableWeather(){const i=this.layer._getSceneConfig(),g=i&&i.weather;return g&&g.enable}_getViewStates(){const i=this.layer.getMap();if(!this._renderedView){this._renderedView={center:i.getCenter(),bearing:i.getBearing(),pitch:i.getPitch(),res:i.getResolution()};let g=!1;if(i.options.lights){const m=i.getLightManager().getDirectionalLight().direction||kk;this._renderedView.lightDirection=WA([],m),g=!0}return{viewChanged:!0,lightDirectionChanged:g}}const g=i.getResolution()/this._renderedView.res,m=i.coordToContainerPoint(this._renderedView.center),_=this.layer.options.viewMoveThreshold,b=m._sub(i.width/2,i.height/2).mag()>_||g<.95||g>1.05;let T=!1;if(i.options.lights){const g=i.getLightManager().getDirectionalLight().direction||kk;T=!hy(this._renderedView.lightDirection,g),T&&(this._renderedView.lightDirection=WA([],g))}return b&&(this._renderedView.center=i.getCenter(),this._renderedView.bearing=i.getBearing(),this._renderedView.pitch=i.getPitch(),this._renderedView.res=i.getResolution()),{viewChanged:b,lightDirectionChanged:T}}_prepareDrawContext(i){const g=this.layer._getSceneConfig(),m=g&&g.postProcess,_=g&&g.weather,b={timestamp:i,renderMode:this._renderMode||"default",includes:{},states:this._getViewStates(),testSceneFilter:i=>!b.sceneFilter||b.sceneFilter(i),isFinalRender:!1,weather:{fog:_&&_.fog}},T=this._jitGetter;T&&T.setRatio(m&&m.antialias&&m.antialias.jitterRatio||.2);const P=this.isSSROn();let I;if(m&&m.enable){if(this.isEnableTAA()){(this.getMap().isInteracting()||this._needRetireFrames)&&T.reset(),T.getJitter(this._jitter),T.frame()}else z_(this._jitter,0,0);b.jitter=this._jitter;const i=m.bloom&&m.bloom.enable;i&&P?(b.bloom=1,b.sceneFilter=Ek):i?(b.bloom=1,b.sceneFilter=Rk):P&&(b.sceneFilter=Lk),I=this._getFramebufferTarget(),I&&(b.renderTarget=I)}else this._destroyFramebuffers();return"noAa"!==this._renderMode&&(this._shadowContext=this._prepareShadowContext(b),this._shadowContext&&(b.includes.shadow=1),this._includesState=this._updateIncludesState(b)),this._shadowContext&&(b.shadow=this._shadowContext,b.includes.shadow=1),b.states.includesChanged=this._includesState,m&&m.enable&&this._postProcessor&&this._postProcessor.setContextIncludes(b),b}_renderAnalysis(i){const g=this._getLayers().filter((i=>i.isVisible()));return this.layer.getTerrainLayer()&&g.push(this.layer.getTerrainLayer()),this._analysisPainter.paint(i,g)}_updateIncludesState(i){let g=!1;const m=Object.keys(i.includes),_=this._prevIncludeKeys;if(_){const i=m.filter((i=>-1===_.indexOf(i))).concat(_.filter((i=>-1===m.indexOf(i))));i.length&&(g=i.reduce(((i,g)=>(i[g]=1,i)),{}))}return this._prevIncludeKeys=m,g}_prepareShadowContext(i){const g=this.layer._getSceneConfig();if(!g||!g.shadow||!g.shadow.enable)return this._shadowProcess&&(this._shadowProcess.dispose(),delete this._shadowProcess),null;this._shadowProcess||(this._shadowProcess=new ShadowProcess(this.regl,this.layer));const m={config:g.shadow,defines:this._shadowProcess.getDefines(),uniformDeclares:ShadowProcess.getUniformDeclares()};return m.renderUniforms=this._renderShadow(i),m}_renderShadow(i){const g=i.renderTarget&&i.renderTarget.fbo,m=this.layer._getSceneConfig(),_=[];let b=i.states.lightDirectionChanged||i.states.viewChanged;this.forEachRenderer(((i,g)=>{if(!i.getShadowMeshes||!g.isVisible())return;const m=i.getShadowMeshes();if(Array.isArray(m))for(let i=0;i<m.length;i++)m[i]&&(m[i].needUpdateShadow&&(b=!0,m[i].needUpdateShadow=!1),m[i].hasFunctionUniform&&(m[i].hasFunctionUniform("minAltitude")||m[i].setFunctionUniform("minAltitude",(()=>g&&g.options.altitude||0)),_.push(m[i])))})),this._shadowScene||(this._shadowScene=new Scene),this._shadowScene.setMeshes(_);const T=this.getMap(),P=m.shadow,I=T.getLightManager(),H=I&&I.getDirectionalLight().direction||kk;return this._shadowProcess.render(!m.ground||!m.ground.enable,T.projMatrix,T.viewMatrix,P.color,P.opacity,H,this._shadowScene,this._jitter,g,b)}_renderWeather(i){let g=[];if(this.forEachRenderer(((i,m)=>{if(!i.getAnalysisMeshes||!m.isVisible())return;const _=i.getAnalysisMeshes();g=g.concat(_)})),this._groundPainter){const i=this._groundPainter.getRenderMeshes();g=g.concat(i)}const m=this.layer.getWeatherConfig();return this._weatherPainter.paint(i,g,m)}_renderScanEffect(i){let g=[];if(this.forEachRenderer(((i,m)=>{if(!i.getAnalysisMeshes||!m.isVisible())return;const _=i.getAnalysisMeshes();g=g.concat(_)})),this._groundPainter){const i=this._groundPainter.getRenderMeshes();g=g.concat(i)}return this._scanEffectPainter.paint(i,g)}getGroundMesh(){if(this._groundPainter){return this._groundPainter.getRenderMeshes()}return[]}_getFramebufferTarget(){const i=this.layer._getSceneConfig();if(!this._targetFBO){const g=this.regl;let m=this._depthTex;(!m||!m._texture||m._texture.refCount<=0)&&(m=null);const _=this.createFBOInfo(i&&i.postProcess,m);this._depthTex=_.depth||_.depthStencil,this._targetFBO=g.framebuffer(_),this._clearFramebuffers()}return{fbo:this._targetFBO}}_createSimpleFBOInfo(i,g,m){g=g||this.canvas.width,m=m||this.canvas.height;const _=this.device,b=this._isUseMultiSample();let T;if(!i&&b)T=_.renderbuffer({width:g,height:m,samples:this.layer.options.multiSamples,format:"rgba8"});else{T=_.texture({min:"nearest",mag:"nearest",type:"uint8",width:g,height:m,sampleCount:4})}return{width:g,height:m,colors:[T],colorFormat:b?"rgba8":"rgba"}}createFBOInfo(i,g){let{width:m,height:_}=this.canvas;m=m||1,_=_||1;const b=this.device,T=this._createSimpleFBOInfo(),P=this._isUseMultiSample(),I=!this.regl||b.hasExtension("WEBGL_depth_texture");if(P){const i=g||b.renderbuffer({width:m,height:_,format:"depth24 stencil8",samples:this.layer.options.multiSamples});T.depthStencil=i}else if(I){const i=g||b.texture({min:"nearest",mag:"nearest",mipmap:!1,type:"depth stencil",width:m,height:_,format:"depth stencil"});T.depthStencil=i}else{const i=g||b.renderbuffer({width:m,height:_,format:"depth stencil"});T.depthStencil=i}return T}_postProcess(){if(!this._targetFBO)return void(this._needRetireFrames=!1);const i=this.layer._getSceneConfig(),g=i&&i.postProcess;if(!g||!g.enable){if(this.isEnableWeather())throw new Error("you must enable the post process to turn on weather");return}this.layer.fire("postprocessstart");const m=this.layer.getMap();let _=g.sharpen&&g.sharpen.factor;_||0===_||(_=.2);let b=0,T=.2,P=.3,I=1,H=[1,1,0];g.outline&&(b=+!!g.outline.enable,T=Hk(g.outline,"highlightFactor",T),P=Hk(g.outline,"outlineFactor",P),I=Hk(g.outline,"outlineWidth",I),H=Hk(g.outline,"outlineColor",H));const W=g.ssr&&g.ssr.enable,q=g.bloom&&g.bloom.enable,$=this._analysisPainter._hasAnalysis(),ye=this._weatherPainter._hasWeather(),Re=this.isEnableScanEffect(),Be=q||W||$||ye||Re;let Ge=this._postFBO;if(Be){if(!Ge){const i=this._createSimpleFBOInfo();this._isUseMultiSample()&&(i.depthStencil=this.regl.renderbuffer({width:this.canvas.width,height:this.canvas.height,samples:this.layer.options.multiSamples,format:"depth24 stencil8"})),Ge=this._postFBO=this.regl.framebuffer(i)}const{width:i,height:g}=this.canvas;Ge.width===i&&Ge.height===g||Ge.resize(i,g)}else Ge=null,this._postFBO&&(this._postFBO.destroy(),delete this._postFBO);let je=this._getFBOColor(this._targetFBO);if(this._postProcessor.fxaa(Ge,je,0,+!(!g.toneMapping||!g.toneMapping.enable),+!(Be||!g.sharpen||!g.sharpen.enable),m.getDevicePixelRatio(),_,b&&this._outlineCounts>0&&this._getOutlineFBO(),T,P,I,H),Ge&&(je=this._getFBOColor(Ge)),q&&this._bloomPainted){const i=g.bloom,m=+i.threshold||0,_=Hk(i,"factor",1),b=Hk(i,"radius",1);je=this._postProcessor.bloom(je,null,null,m,_,b,0)}if(W&&(this._postProcessor.genSsrMipmap(je,this._blitDepthTex()),this._needUpdateSSR)){const i=this._needRetireFrames;this.setToRedraw(),this._needRetireFrames=i,this._needUpdateSSR=!1}this._scanEffectPainter&&this.isEnableScanEffect()&&(je=this._renderScanEffect(je)),this._analysisPainter&&(je=this._renderAnalysis(je)),this.isEnableWeather()&&(je=this._renderWeather(je)),Be&&this._postProcessor.renderFBOToScreen(je,+!(!g.sharpen||!g.sharpen.enable),_,m.getDevicePixelRatio()),this.layer.fire("postprocessend")}isEnableScanEffect(){const i=this.layer._getSceneConfig(),g=i&&i.postProcess&&i.postProcess.scanEffect;return g&&g.enable&&g.effects.length}}function Dk(i){return"number"==typeof i&&!isNaN(i)}function Fk(i){return i._framebuffer.framebuffer}function Nk(i){return i.depthStencil._texture.texture}function Hk(i,g,m){return null==i[g]?m:i[g]}class TerrainWorkerConnection extends Um.Actor{constructor(i){super("@maptalks/terrain"),this.mapId=i}checkUrl(i){return i&&Po.isString(i)?Po.getAbsoluteURL(i):i}fetchTerrain(i,g,m){i=this.checkUrl(i);const _=g.tileImage,b={actorId:this.actorId,mapId:this.mapId,command:"fetchTerrain",params:{url:i,origin:location.origin,terrainWidth:g.terrainWidth,type:g.type,accessToken:g.accessToken,cesiumIonTokenURL:g.cesiumIonTokenURL,error:g.error,colors:g.colors,tileSize:g.tileSize,tileImage:_}},T=[];_&&T.push(_),this.send(b,T,((i,g)=>{i?m(i):m(i,g)}))}abortTerrain(i,g){this.broadcast({actorId:this.actorId,mapId:this.mapId,command:"abortTerrain",params:{url:i}},null,g)}addLayer(i,g,m){this.broadcast({actorId:this.actorId,mapId:this.mapId,layerId:i,command:"addLayer",params:{}},null,m)}createTerrainMesh(i,g){this.send({actorId:this.actorId,command:"createTerrainMesh",params:i},[i.terrainHeights.data.buffer],((i,m)=>{i?g(i):g(i,m)}))}removeLayer(i,g,m){this.broadcast({mapId:this.mapId,layerId:i,command:"removeLayer"},null,m)}}class Martini{constructor(i=257){this.gridSize=i;const g=i-1;if(g&g-1)throw new Error(`Expected grid size to be 2^n+1, got ${i}.`);this.numTriangles=g*g*2-2,this.numParentTriangles=this.numTriangles-g*g,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let i=0;i<this.numTriangles;i++){let m=i+2,_=0,b=0,T=0,P=0,I=0,H=0;for(1&m?T=P=I=g:_=b=H=g;(m>>=1)>1;){const i=_+T>>1,g=b+P>>1;1&m?(T=_,P=b,_=I,b=H):(_=T,b=P,T=I,P=H),I=i,H=g}const W=4*i;this.coords[W+0]=_,this.coords[W+1]=b,this.coords[W+2]=T,this.coords[W+3]=P}}createTile(i){return new Tile(i,this)}}class Tile{constructor(i,g){const m=g.gridSize;if(i.length!==m*m)throw new Error(`Expected terrain data of length ${m*m} (${m} x ${m}), got ${i.length}.`);this.terrain=i,this.martini=g,this.errors=new Float32Array(i.length),this.update()}update(){const{numTriangles:i,numParentTriangles:g,coords:m,gridSize:_}=this.martini,{terrain:b,errors:T}=this;for(let P=i-1;P>=0;P--){const i=4*P,I=m[i+0],H=m[i+1],W=m[i+2],q=m[i+3],$=I+W>>1,ye=H+q>>1,Re=$+ye-H,Be=ye+I-$,Ge=ye*_+$,je=Math.abs((b[H*_+I]+b[q*_+W])/2-b[Ge]);if(T[Ge]=Math.max(T[Ge],je),P<g){T[Ge]=Math.max(T[Ge],T[(H+Be>>1)*_+(I+Re>>1)],T[(q+Be>>1)*_+(W+Re>>1)])}}}getMesh(i=0){const{gridSize:g,indices:m}=this.martini,{errors:_}=this;let b=0,T=0;const P=g-1;function I(P,H,W,q,$,ye){const Re=P+W>>1,Be=H+q>>1;Math.abs(P-$)+Math.abs(H-ye)>1&&_[Be*g+Re]>i?(I($,ye,P,H,Re,Be),I(W,q,$,ye,Re,Be)):(m[H*g+P]=m[H*g+P]||++b,m[q*g+W]=m[q*g+W]||++b,m[ye*g+$]=m[ye*g+$]||++b,T++)}m.fill(0),I(0,0,P,P,P,0),I(P,P,0,0,0,P);const H=new Uint16Array(2*b),W=new Uint32Array(3*T);let q=0;function $(b,T,P,I,ye,Re){const Be=b+P>>1,Ge=T+I>>1;if(Math.abs(b-ye)+Math.abs(T-Re)>1&&_[Ge*g+Be]>i)$(ye,Re,b,T,Be,Ge),$(P,I,ye,Re,Be,Ge);else{const i=m[T*g+b]-1,_=m[I*g+P]-1,$=m[Re*g+ye]-1;H[2*i]=b,H[2*i+1]=T,H[2*_]=P,H[2*_+1]=I,H[2*$]=ye,H[2*$+1]=Re,W[q++]=i,W[q++]=_,W[q++]=$}}return $(0,0,P,P,P,0),$(P,P,0,0,0,P),{vertices:H,triangles:W}}getMeshWithSkirts(i=0,g){const{gridSize:m,indices:_}=this.martini,{errors:b}=this;let T=0,P=0;const I=m-1;let H,W,q=0;const $=[],ye=[],Re=[],Be=[];function Ge(g,je,Xe,Ze,Ye,Qe){const Je=g+Xe>>1,Ke=je+Ze>>1;Math.abs(g-Ye)+Math.abs(je-Qe)>1&&b[Ke*m+Je]>i?(Ge(Ye,Qe,g,je,Je,Ke),Ge(Xe,Ze,Ye,Qe,Je,Ke)):(H=je*m+g,W=Ze*m+Xe,q=Qe*m+Ye,0===_[H]&&(0===g?$.push(T):g===I&&ye.push(T),0===je?Re.push(T):je===I&&Be.push(T),_[H]=++T),0===_[W]&&(0===Xe?$.push(T):Xe===I&&ye.push(T),0===Ze?Re.push(T):Ze===I&&Be.push(T),_[W]=++T),0===_[q]&&(0===Ye?$.push(T):Ye===I&&ye.push(T),0===Qe?Re.push(T):Qe===I&&Be.push(T),_[q]=++T),P++)}let je;_.fill(0),Ge(0,0,I,I,I,0),Ge(I,I,0,0,0,I),je=g?2*(T+3*$.length-2+3*ye.length-2+3*Re.length-2+3*Be.length-2):2*(T+$.length+ye.length+Re.length+Be.length);const Xe=3*(P+2*($.length-1)+2*(ye.length-1)+2*(Re.length-1)+2*(Be.length-1)),Ze=new Uint16Array(je),Ye=new Uint32Array(Xe);let Qe=0;function Je(g,T,P,I,H,W){const q=g+P>>1,$=T+I>>1;if(Math.abs(g-H)+Math.abs(T-W)>1&&b[$*m+q]>i)Je(H,W,g,T,q,$),Je(P,I,H,W,q,$);else{const i=_[T*m+g]-1,b=_[I*m+P]-1,q=_[W*m+H]-1;Ze[2*i]=g,Ze[2*i+1]=T,Ze[2*b]=P,Ze[2*b+1]=I,Ze[2*q]=H,Ze[2*q+1]=W,Ye[Qe++]=i,Ye[Qe++]=b,Ye[Qe++]=q}}Je(0,0,I,I,I,0),Je(I,I,0,0,0,I),$.sort(((i,g)=>Ze[2*i+1]-Ze[2*g+1])),ye.sort(((i,g)=>Ze[2*g+1]-Ze[2*i+1])),Re.sort(((i,g)=>Ze[2*g]-Ze[2*i])),Be.sort(((i,g)=>Ze[2*i]-Ze[2*g]));let Ke,et,tt,at,ht=2*T,gt=0;function yt(i){gt=i.length;for(let m=0;m<gt-1;m++)Ke=i[m],et=i[m+1],tt=ht/2,at=(ht+(g?6:2))/2,Ze[ht++]=2*Ke,Ze[ht++]=2*Ke+1,g&&(Ze[ht++]=2*Ke,Ze[ht++]=2*Ke+1,Ze[ht++]=2*et,Ze[ht++]=2*et+1),g?(Ye[Qe++]=tt+1,Ye[Qe++]=tt,Ye[Qe++]=tt+2,Ye[Qe++]=tt,Ye[Qe++]=at,Ye[Qe++]=tt+2):(Ye[Qe++]=Ke,Ye[Qe++]=tt,Ye[Qe++]=et,Ye[Qe++]=tt,Ye[Qe++]=at,Ye[Qe++]=et);Ze[ht++]=2*i[gt-1],Ze[ht++]=2*i[gt-1]+1}yt($);const vt=ht;yt(ye);const xt=ht;yt(Re);const bt=ht;yt(Be);return{vertices:Ze,triangles:Ye,numVerticesWithoutSkirts:T,numTrianglesWithoutSkirts:P,leftSkirtIndex:vt,rightSkirtIndex:xt,bottomSkirtIndex:bt,topSkirtIndex:ht}}}const Bk={};function zk(i,g,m){let _=Bk[m];_||(_=Bk[m]=new Martini(m));const b=_.createTile(g).getMeshWithSkirts(i,!0),{triangles:T,vertices:P,leftSkirtIndex:I,rightSkirtIndex:H,bottomSkirtIndex:W,topSkirtIndex:q}=b;let{numVerticesWithoutSkirts:$,numTrianglesWithoutSkirts:ye}=b;$||($=P.length/2,ye=T.length/3);const Re=P.length/2,Be=new Float32Array(3*Re),Ge=new Float32Array(2*Re);let je=1/0,Xe=-1/0;const Ze=m-1;for(let i=0;i<Re;i++){const _=P[2*i],b=P[2*i+1];if(i>=$){const g=_/2*3;let m,b=.001;(i-(i<I/2?$:i<H/2?I/2:i<W/2?H/2:W/2))%3==0?(m=Math.min(0,je),b=0):m=Be[g+2];Be[3*i]=Be[g],Be[3*i+1]=Be[g+1],Be[3*i+2]=m,Ge[2*i]=Be[g]/Ze+b,Ge[2*i+1]=-Be[g+1]/Ze+b}else{const T=g[b*m+_];Be[3*i]=1*_,Be[3*i+1]=1*-b,Be[3*i+2]=T,Ge[2*i]=_/Ze,Ge[2*i+1]=b/Ze,T<je&&(je=T),T>Xe&&(Xe=T)}}return{positions:Be,texcoords:Ge,triangles:T,leftSkirtIndex:I,rightSkirtIndex:H,bottomSkirtIndex:W,topSkirtIndex:q,numTrianglesWithoutSkirts:ye,numVerticesWithoutSkirts:$,minHeight:Math.min(0,je),maxHeight:Xe,terrainWidth:m}}function Vk(i,g,m,_,b,T,P,I,H){const W={};for(let q=0;q<H;q++)W[q+""]=Gk(i,g,m,_,b,T,P,I,q);return W}const Uk=[];function Gk(i,g,m,_,b,T,P,I,H){if((_-=H)<=0)return Uk;const W=i.getTileSize().width,q=i._getTileOffset(_,b),$=T[0]-q[0],ye=q[1]-T[1],Re=i._getTileConfig(),Be=i.getSpatialReference().getResolution(_),Ge=Re.tileSystem.scale.y,je=1e-7;let Xe=0,Ze=0,Ye=I/=Math.pow(2,H),Qe=I;if($<0?Ye+=Math.ceil(-$/W-je):$>0&&(Xe-=Math.ceil($/W-je)),ye>0?Ze-=Math.ceil(ye/W-je):ye<0&&(Qe+=Math.ceil(-ye/W-je)),0===Xe&&0===Ze&&Ye<=1&&Qe<=1){const b=Math.floor(g*I);let T=Math.floor(m*I);const H=T;return Ge!==P&&(T=qk(Re,T,Be)),[{x:b,y:T,skinY:H,z:_,offset:q,tileSize:W,id:i._getTileId(b,T,_)}]}const Je=[];for(let b=Xe;b<Ye;b++)for(let T=Ze;T<Qe;T++){const H=g*I+b;let $=m*I+T;const ye=$;Ge!==P&&($=qk(Re,$,Be)),Je.push({x:H,y:$,skinY:ye,z:_,offset:q,tileSize:W,id:i._getTileId(H,$,_)})}return Je}function jk(i,g,m,_){let b=i/m*_/g;return b<1?(b=1/b,b=1/Math.round(b)):b=Math.round(b),b}function Wk(i,g,m){const _=i.getResolution(g),b=g-Math.log(m/_)*Math.LOG2E;return{zoom:b,res:i.getResolution(b)}}function qk(i,g,m){const _=i.fullExtent,b=i.tileSize.width,T=Math.max(_.top,_.bottom),P=Math.min(_.top,_.bottom);return Math.ceil(T/b/m)-1-Math.floor(P/b/m)-g}function Xk(i,g){const m=g*g,_=0!==i?new Float32Array(m):new Uint8Array(m);return _.fill(i),{data:_,width:g,height:g,max:i,min:i}}new un(0,0);const Zk=Xk(0,5),$k=zk(1,Zk.data,Zk.width);function Yk(i,g,m){const _=m&&m.includes;if(_)for(const b in _)_[b]&&(m[b].uniformDeclares&&g.push(...m[b].uniformDeclares),m[b].defines&&mI(i,m[b].defines))}function Qk(i,g){const m=g&&g.includes;if(m)for(const _ in m)m[_]&&g[_].renderUniforms&&mI(i,g[_].renderUniforms)}$k.empty=!0;var Jk=Object.freeze({__proto__:null,fillIncludes:Yk,setIncludeUniformValues:Qk});const Kk=[],eO=[];class TerrainPainter{constructor(i){this.layer=i;const g=i.getRenderer();this.graphics=g.regl||g.device,this.renderer=new Renderer(this.graphics),this._leafScene=new Scene;const m=new Uint8Array(16);m.fill(255),this._emptyTileTexture=this.graphics.texture({width:2,height:2,data:m}),this._resLoader=new ResourceLoader(this._emptyTileTexture),this._createEmptyTerrainGeo()}setToRedraw(){this.layer.getRenderer().setToRedraw()}getMap(){return this.layer.getMap()}startFrame(i){i&&i.states&&i.states.includesChanged&&(this.shader.dispose(),delete this.shader),this.shader||this.initShader(i),this._leafScene.clear()}createTerrainMesh(i,g){const{mesh:m,image:_}=g;let b=g.terrainMesh;const{positions:T,texcoords:P,triangles:I,empty:H}=m;if(b&&b.geometry!==this._emptyTerrainGeometry)b.geometry.updateData("aPosition",T),b.geometry.updateData("aTexCoord",P),b.geometry.setElements(I),b.geometry.generateBuffers(this.graphics);else{const i=H?this._emptyTerrainGeometry:new Geometry({aPosition:T,aTexCoord:P},I,0);i!==this._emptyTerrainGeometry&&i.generateBuffers(this.graphics),b?b.geometry=i:b=new Mesh(i,null,{disableVAO:!0})}if(!b.uniforms.skin){const i=this.getEmptyTexture();b.setUniform("skin",i)}if(!b.uniforms.flatMask){const i=this.getEmptyTexture();b.setUniform("flatMask",i)}return b.setUniform("heightTexture",_),this.prepareMesh(b,i,g),b}_updateMaskDefines(i){const g=this.layer.getRenderer();g&&g.updateMaskDefines(i)}_getPositionMatrix(i){const g=this._getHeightScale(),m=mA(i);return xA(m,m,[1,1,g]),m}_getHeightScale(){let i=this.layer.options.exaggeration;return AI(i)&&(i=1),this._getPointZ(100)/100*i}_getLocalTransform(i,g,m){const _=this.getMap(),b=this.layer.getTileSize().width,T=g.res/_.getGLRes(),P=b/(m-1),{extent2d:I,offset:H}=g;qA(Kk,(I.xmin-H[0])*T,(g.extent2d.ymax-H[1])*T,0);const W=mA(i);return vA(W,W,Kk),qA(eO,T*P,T*P,1),xA(W,W,eO),W}prepareMesh(i,g,m){if(!i.isValid())return;const{mesh:_}=m;this._updateMaskDefines(i);const{triangles:b,numTrianglesWithoutSkirts:T,terrainWidth:P}=_;i.localTransform=this._getLocalTransform(i.localTransform||[],g,P),i.positionMatrix=this._getPositionMatrix(i.positionMatrix||[]),i.properties.skirtOffset=3*T,i.properties.skirtCount=b.length-3*T,i.properties.z=g.z,i.properties.minHeight=_.minHeight,i.properties.maxHeight=_.maxHeight,i.properties.terrainWidth=P,i.castShadow=!1,bI(i.uniforms,"minAltitude")||Object.defineProperty(i.uniforms,"minAltitude",{enumerable:!0,get:()=>m.minAltitude||0})}addTerrainImage(i,g){const m=g.terrainMesh;m&&m.geometry&&g.skin&&(m.setUniform("skin",g.skin.color[0]),m.setUniform("flatMask",g.mask.color[0]),m.setUniform("polygonOpacity",1),this._leafScene.addMesh(m))}endFrame(i){this.updateIBLDefines(this.shader);let g=0;const m=this.getUniformValues(),_=this._getRenderFBO(i);return this.shader.filter=i&&i.sceneFilter,Qk(m,i),this._leafScene.getMeshes().forEach((i=>{this._updateMaskDefines(i)})),g+=this.renderer.render(this.shader,m,this._leafScene,_),g}delete(){this.shader&&(this.shader.dispose(),delete this.shader),this._emptyTileTexture&&(this._emptyTileTexture.destroy(),delete this._emptyTileTexture),this._emptyTerrainGeometry&&(this._emptyTerrainGeometry.dispose(),delete this._emptyTerrainGeometry)}deleteMesh(i){if(!i)return;const g=i.geometry;i.dispose(),g!==this._emptyTerrainGeometry&&g.dispose()}initShader(i){const g=[],m=[],_={},b=[];Yk(_,b,i),this.shader=new MeshShader({name:"terrain-mesh",vert:"#define SHADER_NAME TERRAIN_MESH\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nuniform float minAltitude;\nuniform mat4 projViewModelMatrix;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nuniform float heightScale;\nvarying vec2 vUv;\nuniform sampler2D flatMask;\n#include <common_pack_float>\n#include <mask_vert>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_vert>\n#endif\nvoid main() {\n  vec2 c = aTexCoord;\n  c.y = 1. - c.y;\n  vec4 d = texture2D(flatMask, c);\n  float e = aPosition.z;\n  if(length(d) < 2.) {\n    float f = decodeFloat32(d);\n    e = min(aPosition.z, f);\n  }\n  vec4 h = vec4(aPosition.xy, (e + minAltitude) * heightScale, 1.);\n  h = positionMatrix * h;\n#ifdef HAS_MASK_EXTENT\ngl_Position = projMatrix * getMaskPosition(h, modelMatrix);\n#else\ngl_Position = projViewModelMatrix * h;\n#endif\nvUv = aTexCoord;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nshadow_computeShadowPars(h);\n#endif\n}",frag:"#define SHADER_NAME TERRAIN_MESH\nprecision mediump float;\nuniform sampler2D skin;\nuniform float polygonOpacity;\nuniform float layerOpacity;\nvarying vec2 vUv;\n#include <mask_frag>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_frag>\n#endif\nvoid main() {\n  vec2 c = vec2(vUv);\n  c.y = 1. - c.y;\n  vec4 d = texture2D(skin, c);\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nfloat e = shadow_computeShadow();\n  d.rgb = shadow_blend(d.rgb, e).rgb;\n#endif\ngl_FragColor = d * polygonOpacity * layerOpacity;\n#ifdef HAS_MASK_EXTENT\ngl_FragColor = setMask(gl_FragColor);\n#endif\n}",wgslVert:"",wgslFrag:"",uniforms:b.concat([{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(m,g.viewMatrix,g.modelMatrix)}},{name:"projViewModelMatrix",type:"function",fn:function(i,m){return _A(g,m.projViewMatrix,m.modelMatrix)}}]),defines:_,extraCommandProps:this.getExtraCommandProps()})}getExtraCommandProps(){const i=this.layer.getRenderer().canvas;return{viewport:{x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1},cull:{enable:!0,face:"back"},depth:{enable:!0,mask:()=>!!this.layer.options.depthMask,func:this.layer.options.depthFunc||"<="},blend:{enable:!0,func:{src:this.layer.options.blendSrc,dst:this.layer.options.blendDst},equation:"add"}}}_getRenderFBO(i){return i&&i.renderTarget&&i.renderTarget.fbo}getUniformValues(){const i=this.getMap(),g=i.projViewMatrix,m=this.layer.getRenderer().getMaskUniforms();let _=this.layer.options.opacity;AI(_)&&(_=1);const b={viewMatrix:i.viewMatrix,projMatrix:i.projMatrix,projViewMatrix:g,heightScale:1,layerOpacity:_};return mI(b,m),b}_getPointZ(i){const g=this.layer.getMap();if(!g)return null;return g.altitudeToPoint(i,g.getGLRes())}getEmptyTexture(){return this._emptyTileTexture}hasIBL(){const i=this.getMap().getLightManager();return!!(i&&i.getAmbientResource())}updateIBLDefines(i){const g=i.shaderDefines;let m=!1;this.hasIBL()?g[["HAS_IBL_LIGHTING"]]||(g.HAS_IBL_LIGHTING=1,m=!0):g[["HAS_IBL_LIGHTING"]]&&(delete g.HAS_IBL_LIGHTING,m=!0),m&&(i.shaderDefines=g)}_createEmptyTerrainGeo(){const i=$k,{positions:g,texcoords:m,triangles:_}=i;this._emptyTerrainGeometry=new Geometry({aPosition:g,aTexCoord:m},_,0),this._emptyTerrainGeometry.generateBuffers(this.graphics)}}const{getIBLResOnCanvas:tO,getPBRUniforms:nO,loginIBLResOnCanvas:rO,logoutIBLResOnCanvas:iO}=xP.PBRUtils,oO={baseColorFactor:[1,1,1,1],emissiveFactor:[0,0,0],baseColorIntensity:1,emitColorFactor:1,roughnessFactor:1,metallicFactor:0,emitMultiplicative:1,outputSRGB:1,hsv:[0,0,0],contrast:1,alphaTest:0};class TerrainLitPainter extends TerrainPainter{constructor(...i){super(...i),this.createIBLTextures(),this._matVer=0}updateMaterial(i,g){this._matVer=g,this._material=this._material||{},mI(this._material,i),this.setToRedraw()}setMaterial(i,g){this._matVer=g,this._material=mI({},oO,i),this.setToRedraw()}createIBLTextures(){const i=this.getMap().getRenderer().canvas;rO(i,this.graphics,this.getMap()),this.layer.fire("iblupdated")}disposeIBLTextures(){const i=this.getMap().getRenderer().canvas;iO(i,this.getMap())}createTerrainMesh(i,g){const{mesh:m,image:_}=g,{positions:b,texcoords:T,triangles:P,leftSkirtIndex:I,rightSkirtIndex:H,bottomSkirtIndex:W,numVerticesWithoutSkirts:q}=m,$=new Int8Array(b.length);for(let i=2;i<$.length;i+=3)i<3*q?$[i]=1:i<I/2*3?$[i-2]=-1:i<H/2*3?$[i-2]=1:$[i-1]=i<W/2*3?-1:1;const ye=new Geometry({aPosition:b,aTexCoord:T,aNormal:$},P,0);let Re;ye.createTangent(),delete ye.data.aNormal,ye.generateBuffers(this.graphics),Re=_?this.graphics.texture({width:_.width,height:_.height,data:_,min:"linear",mag:"linear"}):this.getEmptyTexture();const Be=this.getEmptyTexture(),Ge=mI({},oO,this.layer.options.material||{});Ge.skinTexture=Be,Ge.terrainHeightTexture=Re;const je=new xP.StandardMaterial(Ge),Xe=new Mesh(ye,je);if(Xe.properties.matVer=this._matVer,!Xe.uniforms.flatMask){const i=this.getEmptyTexture();Xe.setUniform("flatMask",i)}const Ze=Xe.defines;return Ze.HAS_UV_FLIP=1,Ze.HAS_TERRAIN_NORMAL=1,Ze.HAS_MAP=1,Ze.HAS_LAYER_OPACITY=1,Ze.HAS_TERRAIN_FLAT_MASK=1,Xe.defines=Ze,this.prepareMesh(Xe,i,g),Xe}addTerrainImage(i,g){const m=g.terrainMesh;if(m){if(this._material&&m.properties.matVer!==this._matVer){for(const i in this._material)m.material.set(i,this._material[i]);m.properties.matVer=this._matVer}g.skin&&m.material.set("skinTexture",g.skin.color[0]),g.mask&&m.setUniform("flatMask",g.mask.color[0]),m.setUniform("polygonOpacity",1),this._leafScene.addMesh(m)}}getUniformValues(){const i=this.getMap(),g=i.getRenderer().canvas,{iblTexes:m,dfgLUT:_}=tO(g),b=nO(i,m,_),T=this.layer.getTileSize().width,P=this.layer.getRenderer().getMaskUniforms();let I=this.layer.options.opacity;return AI(I)&&(I=1),mI(b,{viewMatrix:i.viewMatrix,projMatrix:i.projMatrix,projViewMatrix:i.projViewMatrix,outSize:[g.width,g.height],polygonFill:[1,1,1,1],terrainHeightMapResolution:[T,T],terrainResolution:[g.width,g.height],terrainUnpackFactors:[6553.6,25.6,.1,1e4],layerOpacity:I}),mI(b,P),b}initShader(i){const g={},m=[];Yk(g,m,i),this.shader=new xP.StandardShader({uniforms:m,defines:g,extraCommandProps:this.getExtraCommandProps()})}delete(){return this.disposeIBLTextures(),super.delete()}}function sO(i,g,m,_){const b=aO.call(this,m,_);this._projViewMatrix=g;const{colorExtent:T,modeExtent:P}=this._extentPass.render(b,g);this._maskUniforms=this._maskUniforms||{},this._maskUniforms.mask_colorExtent=T,this._maskUniforms.mask_extent=i,this._maskUniforms.mask_modeExtent=P,this._maskUniforms.mask_hasFlatOut=hO.call(this,"flat-outside"),this._maskUniforms.mask_hasClipOut=hO.call(this,"clip-outside"),this._maskUniforms.mask_hasVideo=hO.call(this,"video"),this._maskUniforms.mask_heightRatio=m,this._maskUniforms.mask_heightOffset=_,this.setToRedraw()}function aO(i,g){const m=[],_=this.layer.getMasks();for(let b=0;b<_.length;b++){const T=_[b].getMesh(this.regl,i,g);T&&m.push(T)}return m}function lO(){if(!this._extentPass||!this._maskUniforms)return;const i=aO.call(this,this._maskUniforms.mask_heightRatio,this._maskUniforms.mask_heightOffset);this._extentPass.render(i,this._projViewMatrix);const g=this.layer.getMasks();for(let i=0;i<g.length;i++)g[i]._update&&g[i]._update()}function hO(i){const g=this.layer.getMasks();for(let m=0;m<g.length;m++)if(g[m].getMode()===i)return 1;return 0}function cO(){const i=this.layer.getMasks();if(!i)return!1;for(let g=0;g<i.length;g++)if(i[g]._needUpdate)return i[g]._needUpdate();return!1}function uO(i){return class extends i{setMask(i,g,m,_){this.viewport||(this.viewport={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1}),this._extentPass?sO.call(this,i,g,m,_):this.regl?(this._extentPass=new ExtentPass(this.regl,this.viewport),sO.call(this,i,g,m,_)):this.layer.once("contextcreate",(()=>{this._extentPass=new ExtentPass(this.regl,this.viewport),sO.call(this,i,g,m,_)}),this)}needToRedraw(){return!!super.needToRedraw()||!!cO.call(this)}getMaskUniforms(){return cO.call(this)&&lO.call(this),this.layer.updateMaskExtent(),this._maskUniforms}getMaskDefines(){return this._maskDefines||(this._maskDefines={}),this._maskUniforms&&this._maskUniforms.mask_colorExtent?this._maskDefines.HAS_MASK_EXTENT=1:delete this._maskDefines.HAS_MASK_EXTENT,this._maskDefines}updateMaskDefines(i){const g=i.getDefines();delete g.HAS_MASK_EXTENT;mI(g,this.getMaskDefines()),i.setDefines(g)}_clearMask(){this._deleteMaskUniforms(),this._extentPass&&(this._extentPass.dispose(),delete this._extentPass),this.setToRedraw()}_deleteMaskUniforms(){delete this._maskUniforms}}}class LRUPool{constructor(i,g){this.max=i,this.onRemove=g,this.reset()}reset(){if(this.data){const i=this.data.values();for(const g of i)this.onRemove(g)}return this.data=new Map,this}clear(){this.reset(),delete this.onRemove}add(i,g){return g?(this.has(i)?(this.data.delete(i),this.data.set(i,g)):this.data.set(i,g),this):this}keys(){const i=new Array(this.data.size);let g=0;const m=this.data.keys();for(const _ of m)i[g++]=_;return i}has(i){return this.data.has(i)}getAndRemove(i){if(!this.has(i))return null;const g=this.data.get(i);return this.data.delete(i),g}get(i){if(!this.has(i))return null;return this.data.get(i)}pop(){if(this.data.size<this.max)return null;const i=this.data.keys().next();return this.data.get(i.value).current?(this.max+=Math.ceil(this.max/2),null):this.getAndRemove(i.value)}remove(i){if(!this.has(i))return this;const g=this.data.get(i);return this.data.delete(i),this.onRemove(g),this}resetCurrent(i){this.data&&this.data.forEach((g=>{g.current=i}))}}const{TileLayerRendererable:fO,LayerAbstractRenderer:dO}=Om,pO=new un(0,0),gO=new un(0,0),mO=new kl(0,0,0,0),AO=new un(0,0),yO={color:[0,0,0,0],depth:1,stencil:0},_O={color:[1,1,1,1],depth:0,stencil:0};class TerrainLayerRenderer extends(uO(fO(dO))){constructor(...i){super(...i),this.init()}isDrawable(){return!0}getTempTileOnLoading(i,g){if(g.image&&!g.image.reset)return g;this._debugTile(i,"getTempTileOnLoading");const m=this._createTerrainFromParent(i);return m.temp=!0,g.image||(g.image=m),delete g.image.reset,g.current=!0,g.info=i,mI(g.image,m),this._createMesh(g.image,i),g}_resetTerrainImage(i,g,m){g.reset=!0,delete g.data,delete g.loadTime,delete g.rendered,delete g.minAltitude;const _=i.id+"-temp",b=g.skinImages;if(b)for(let i=0;i<b.length;i++){const g=b[i];if(g){for(let i=0;i<g.length;i++){const b=g[i];b&&(b.refs.delete(_),b.refs.size||m.push(b))}delete g.currentSkins,delete g.tileIds}}delete g.sourceZoom,delete g.skinImages,delete g.skinStatus,delete g.skinTileIds,g.debugTexture&&(g.debugTexture.destroy(),delete g.debugTexture)}_createTerrainFromParent(i,g){for(g=g||this.findParentTile(i);g&&g.image&&(-1===g.image.sourceZoom||g.image.originalError);)g=this.findParentTile(g.info);const m=i.res,_=this.getMap().pointAtResToDistance(1,1,m),b=g&&g.image&&g.image.data&&this._clipParentTerrain(g,i),T=b&&-1!==g.image.sourceZoom?g.info.z:-1;if(!b||b.width<=1){const m=this._findTileMinAltitude(i,g);return{data:Xk(m||0,5),minAltitude:m,mesh:$k,sourceZoom:T}}return{data:b,mesh:zk(_/2,b.data,b.width),sourceZoom:T}}_findTileMinAltitude(i,g){if(g&&g.minAltitude)return g.minAltitude;const{idx:m,idy:_,z:b}=i;for(let i=-1;i<=1;i++)for(let g=-1;g<=1;g++){if(0===i&&0===g)continue;const T=this.layer.getTileId(m+i,_+g,b),P=this.layer.tileInfoCache,I=P&&P.get(T);if(I&&I.minAltitude)return I.minAltitude}return 0}consumeTile(i,g){if(this._debugTile(g,"consumeTile"),i.empty&&!i.mesh){const m=this.findParentTile(g);if(!m||m.image&&m.image.empty){i.mesh=$k;const m=this._findTileMinAltitude(g);i.data=Xk(m||0,5),i.minAltitude=m,i.sourceZoom=-1}else i=this._createTerrainFromParent(g,m)}this._createMesh(i,g),super.consumeTile(i,g),this._recenterMapOnTerrain(g)}_createMesh(i,g){if(i&&i.mesh){i.terrainMesh=this._painter.createTerrainMesh(g,i),g.minAltitude=i.data.min,g.maxAltitude=i.data.max,delete i.mesh;const m=this.layer.tileInfoCache;if(m&&g.parent&&!i.empty&&!i.temp){const i=m.get(g.parent);if(i){const{minAltitude:m,maxAltitude:_}=g;(void 0===i.minAltitude||i.minAltitude>m)&&(i.minAltitude=m),(void 0===i.maxAltitude||i.maxAltitude<_)&&(i.maxAltitude=_)}}}}_recenterMapOnTerrain(i){const g=this.getMap();if(g.updateCenterAltitude&&void 0===g.centerAltitude&&i.z===this.getCurrentTileZoom()){const m=g._getPrjCenter(),_=g._prjToPointAtRes(m,i.res,AO);i.extent2d.contains(_)&&g.updateCenterAltitude()}}draw(i,g){this._createPainter(),this._painter.startFrame(g),super.draw(i,g),this._endFrame(g)}drawTile(i,g){const m=this.getMap();if(!i||!m||!g)return;if(!this.drawingCurrentTiles&&!this.drawingChildTiles)return;this._debugTile(i,"drawTile");let _=this.drawingCurrentTiles?this.getTileOpacity(g):1;_*=this.layer.options.opacity||1,this._painter.addTerrainImage(i,g,_)}_drawTiles(i,g,m,_,b,T,P){const I=[];this._newTerrainTileCounter=0;const H=this.layer.getSkinCount(),W=new Set;if(P&&P.length){wI(T,P.map((i=>i.info)));for(let i=0;i<H;i++)this._renderChildTerrainSkin(i,P,W,I)}wI(i,this._getTempTilesForMissed(T,I)),this._debugTile(i,"drawTiles");for(let g=0;g<H;g++)this._renderChildTerrainSkin(g,i,W,I);for(let g=0;g<i.length;g++)this._renderTerrainMeshSkin(i[g].info,i[g].image);for(let i=0;i<I.length;i++)I[i]&&I[i].texture&&!I[i].refs.size&&(this._skinImageCache.delete(I[i].tile.id),this._deleteSkinImage(I[i]));return this._clearCachdeSkinImages(),super._drawTiles(...arguments)}_getTempTilesForMissed(i,g){const m=[];let _=this._tempTilesPool;_||(_=this._tempTilesPool=new LRUPool(this.layer.options.tempTileCacheSize,(i=>{const{info:g,image:m}=i;this._deleteTerrainImage(g,m)}))),_.resetCurrent(!1);for(let b=0;b<i.length;b++){const T=i[b];let P;this._debugTile(T,"getTempTilesForMissed"),_.has(T.id)?P=_.getAndRemove(T.id):(P=_.pop(),P?P.image&&(this._resetTerrainImage(P.info,P.image,g),P.image.temp=!0):P={info:T}),P.current=!0,_.add(T.id,P),m.push(P)}for(let g=0;g<i.length;g++)this.getTempTileOnLoading(i[g],m[g]);return m}_clearCachdeSkinImages(){if(!this._skinImageCache)return;const i=this.getCurrentTimestamp();if(this._clearSkinImageTimestamp&&i-this._clearSkinImageTimestamp<1e3)return;const g=new Set;for(const i of this.tileCache.data.values())this._collectSkinImages(i,g);for(const i in this.tilesInView){this._collectSkinImages(this.tilesInView[i],g)}if(this._tempTilesPool)for(const i of this._tempTilesPool.data.values())this._collectSkinImages(i,g);g.size&&(this._skinImageCache.forEach(((i,m)=>{g.has(m)||(console.log("deleted:",m),this._deleteSkinImage(this._skinImageCache.get(m)),this._skinImageCache.delete(m))})),this._clearSkinImageTimestamp=i)}_collectSkinImages(i,g){const m=i.image&&i.image.skinImages;if(m&&m.length)for(let i=0;i<m.length;i++){const _=m[i]&&m.currentSkins;if(_)for(const i of _)g.add(i)}}_renderChildTerrainSkin(i,g,m,_){const b=this.layer.getSkinLayer(i).getRenderer();if(!b)return;const T=[];for(let b=0;b<g.length;b++){const{info:P,image:I}=g[b];this._prepareMask(P,I),this._debugTile(P,"renderChildTerrainSkin");let H=!1;if(this._prepareChildTerrainSkin(i,P,I,_)){const g=I.skinImages[i];for(let i=0;i<g.length;i++){const _=g[i].tile.info.id;m.has(_)||(!H&&g[i].layer.hasTerrainMask&&(this._clearMask(I.mask),H=!0),g[i].terrainMaskFBO=I.mask,T.push(g[i]),m.add(_))}}}b.renderTerrainSkin(this.device,this.layer,T)}_prepareMask(i,g){g.mask||(g.mask=this._createTerrainMaskTexture(i,g),g.mask.id=i.id)}_clearMask(i){_O.framebuffer=i,this.device.clear(_O)}_prepareChildTerrainSkin(i,g,m,_){const b=this.getMap();if(delete m.path,!g||!b||!m)return!1;if(!m.terrainMesh)return!1;const T=this.layer.getSkinLayer(i),P=T.getRenderer();if(!P)return!1;m.skinImages||(m.skinImages=[]),m.skinStatus||(m.skinStatus=[]),m.skinTileIds||(m.skinTileIds=[]);const I=P.isAnimating&&P.isAnimating(),H=m.skinStatus[i],W=P.needToRefreshTerrainTileOnZooming&&P.needToRefreshTerrainTileOnZooming(),q=I||W&&m.renderedZoom!==b.getZoom();if(H&&!q)return!1;const $=T.getSpatialReference(),{x:ye,y:Re,z:Be,res:Ge,offset:je}=g;let Xe=g.nw;Xe||(Xe=g.nw=this.getMap().pointAtResToCoord(g.extent2d.getMin(pO),g.res));const Ze=this.layer.getTileSize().width;let{res:Ye,zoom:Qe}=Wk($,Be,Ge);let Je=jk(Ye,T.getTileSize().width,Ge,Ze),Ke=m.skinTileIds[i];if(!Ke){const g=this.layer._getTileConfig().tileSystem.scale.y,_=T.options.maxAvailableZoom;!AI(_)&&_>=0&&Qe>_&&(Je*=Math.pow(2,_-Qe),Qe=_),Ke=m.skinTileIds[i]=Vk(T,ye,Re,Qe,Xe,je,g,Je,1)}const et=Ke[0];let tt=!0;const at=[];for(let i=0;i<et.length;i++){const g=P.getCachedTile(et[i],!1);if(g)at.push(g);else{tt=!1;const g=P.findParentTile(et[i]);g&&at.push(g)}}const ht=m.skinImages[i]||[];ht.currentSkins=ht.currentSkins||new Set;const gt=new Set;let yt=!1;for(let i=0;i<ht.length;i++){if(!ht[i].tile){yt=!0;continue}gt.add(ht[i].tile.info.id)}if(!at.length)return ht.currentSkins.clear(),m.skinImages[i]=[],!1;const vt=at.map((i=>i.info.id)).join();if(!q&&!yt&&ht.tileIds===vt)return!1;ht.tileIds=vt;let xt=!1;ht.currentSkins.clear(),ht.length=0;const bt=ht.currentSkins;let Tt=g.id;m.temp&&(Tt+="-temp");for(let i=0;i<at.length;i++){const g=at[i].info.id;bt.add(g);let m=this._getCachedSkinImage(g);m&&((Mt=m)&&Mt.texture)||(m={tile:mI({},at[i]),layer:T,refs:new Set,texture:P.createTerrainTexture(this.device)},this._saveCachedSkinImage(g,m)),m.refs.add(Tt),ht.push(m),xt=!0}var Mt;return this._clearPrevSkinImages(g,m,gt,bt,_),xt&&this._newTerrainTileCounter++,m.skinImages[i]=ht,T.fire("renderterrainskin",{tile:g,skinTiles:at}),tt&&(m.skinStatus[i]=1),!0}_clearPrevSkinImages(i,g,m,_,b){if(!m.size)return;let T=i.id;g.temp&&(T+="-temp");for(const i of m)if(!_||!_.has(i)){const g=this._getCachedSkinImage(i);this._deleteCachedSkinImage(g,T,b)}}_getCachedSkinImage(i){return this._skinImageCache||(this._skinImageCache=new Map),this._skinImageCache.get(i)}_saveCachedSkinImage(i,g){this._skinImageCache.set(i,g)}_renderTerrainMeshSkin(i,g){const m=this.getMap();if(!i||!m||!g)return;this._debugTile(i,"_renderTerrainMeshSkin");const _=this._needRefreshTerrainSkins(g.renderedZoom);if(g.rendered&&!_)return;g.skin?(yO.framebuffer=g.skin,this.device.clear(yO)):(g.skin=this._createTerrainTexture(i,g),this._prepareMask(i,g)),this._initSkinShader();const b=this.layer.options.debug,T=[],P=b&&[],I=this.layer.getTileSize().width,H=g.skinImages;if(H)for(let g=0;g<H.length;g++){const m=H[g];for(let g=0;g<m.length;g++){const{tile:_,texture:b,layer:P}=m[g];if((_.info.offset[0]||_.info.offset[1])&&i.skinTileIds){const g=i.skinTileIds[P.getId()];for(let i=0;i<g.length;i++)if(_.info.x===g[i].x&&_.info.y===g[i].y){_.info.offset=g[i].offset;break}}const H=vO(i,_,I),W=m[g].skinMesh||new Mesh(this._skinGeometry);W.setUniform("skinTexture",b);const q=P.getOpacity();W.setUniform("opacity",AI(q)?1:q),W.setUniform("skinDim",H),W.setUniform("tileSize",I),W.setUniform("x",i.x),W.setUniform("y",i.y),m[g].skinMesh=W,T.push(W)}}if(b){const m=g.skinDebugMesh||new Mesh(this._skinGeometry);m.setUniform("tileSize",I);const _=g.debugTexture||this._createDebugTexture(i,I,g.temp);g.debugTexture=_,g.skinDebugMesh=m,m.setUniform("opacity",1),m.setUniform("skinTexture",_),m.setUniform("skinDim",[0,0,1]),m.setUniform("tileSize",I),P.push(m)}if(T.length){this._skinScene.setMeshes(T);try{this.renderer.render(this._skinShader,null,this._skinScene,g.skin)}catch(i){throw console.error(g),i}}P&&P.length&&this.layer.options.debug&&(this._skinScene.setMeshes(P),this.renderer.render(this._skinShader,null,this._skinScene,g.skin)),g.rendered=this._isSkinReady(g),g.renderedZoom=m.getZoom()}_createDebugTexture(i,g,m){g*=2;const{x:_,y:b,z:T}=i,P=`terrain:${_}/${b}/${T}`+(m?"-temp":""),I=document.createElement("canvas");I.width=g,I.height=g;const H=I.getContext("2d");H.font="60px monospace";const W=this.layer.options.debugOutline;return H.fillStyle=W,H.strokeStyle=W,H.fillText(P,20,g-40),H.beginPath(),H.lineWidth=4,H.moveTo(0,0),H.lineTo(g,0),H.lineTo(g,g),H.lineTo(0,g),H.lineTo(0,0),H.stroke(),this.device.texture({data:I,flipY:!0,mag:"linear",min:"linear"})}_createTerrainMaskTexture(){const i=this.device,g=this.layer.getTileSize().width,m=2*g,_=2*g,b=i.texture({min:"linear",mag:"linear",type:"uint8",format:"rgba",width:m,height:_});this._terrainMaskDepthStencil||(this._terrainMaskDepthStencil=i.texture({width:m,height:_,format:"depth stencil"}));const T={width:m,height:_,colors:[b],colorFormat:"rgba",ignoreStatusCheck:!0};T.depthStencil=this._terrainMaskDepthStencil;const P=i.framebuffer(T);return P.colorTex=b,this._clearMask(P),P}_createTerrainTexture(i){const g=this.layer.getTileSize().width,m=2*g,_=2*g,b=this.device,T=i.colorsTexture;let P;P=T&&T instanceof Uint8Array?b.texture({data:T,min:"linear",mag:"linear",type:"uint8",width:m,height:_,flipY:!0}):b.texture({min:"linear",mag:"linear",type:"uint8",width:m,height:_,flipY:!0});const I=b.framebuffer({width:m,height:_,colors:[P],colorFormat:"rgba",ignoreStatusCheck:!0,depthStencil:!1,depth:!1,stencil:!1});return I.colorTex=P,I}_endFrame(i){this._painter.endFrame(i)&&!Object.keys(this.tilesLoading).length&&this.layer.fire("terrainreadyandrender")}_clipParentTerrain(i,g){const{image:m,info:_}=i,b=m.data,T=b.width,{extent2d:P,res:I}=_,{extent2d:H,res:W}=g,q=P.getWidth(),$=P.getHeight();let ye=(H.xmin*W/I-P.xmin)/q*(T-1),Re=(P.ymax-H.ymax*W/I)/$*(T-1);let Be=Math.round((H.xmax*W/I-P.xmin)/q*(T-1)-ye);const Ge=Math.log2(Be);Be=Math.pow(2,Math.round(Ge))+1,ye=Math.floor(ye),Re=Math.floor(Re);const je=new Float32Array(Be*Be);let Xe=1/0,Ze=-1/0;for(let i=0;i<Be;i++)for(let g=0;g<Be;g++){let m=i+ye,_=g+Re;m>T-1?m=T-1:m<0&&(m=0),_>T-1?_=T-1:_<0&&(_=0);const P=b.data[m+_*T];je[i+g*Be]=P,P<Xe&&(Xe=P),P>Ze&&(Ze=P)}return{width:Be,height:Be,data:je,min:Xe,max:Ze}}getTileOpacity(i){return this._isSkinReady(i)?super.getTileOpacity(i):(this.resetTileLoadTime(i),0)}_isSkinReady(i){const g=this.layer.getSkinCount();if(!g)return!0;if(!i.skinStatus)return!1;for(let m=0;m<g;m++)if(!i.skinStatus[m])return!1;return!0}_needRefreshTerrainSkins(i){const g=this.getMap().getZoom(),m=this.layer.getSkinLayers();for(let _=0;_<m.length;_++){const b=m[_]&&m[_].getRenderer();if(b){if(b.isAnimating&&b.isAnimating())return!0;if(b.needToRefreshTerrainTileOnZooming&&b.needToRefreshTerrainTileOnZooming()&&i!==g)return!0}}return!1}isValidCachedTile(i){return i.image&&!i.image.temp&&(!i.image.skinStatus||this._isSkinReady(i.image))}isTileComplete(i){return i.image&&!i.image.temp&&this._isSkinReady(i.image)}_getTerrainWidth(){const i=this.layer.options,g=this.layer.getTileSize().width;return AI(i.terrainWidth)?g/4+1:i.terrainWidth}_getParentTileRequest(i,g){const m=this.layer.options.maxAvailableZoom-this.layer.options.zoomOffset,_=Math.pow(2,i.z-m),b=Math.floor(i.x/_),T=Math.floor(i.y/_),P=Math.floor(i.idx/_),I=Math.floor(i.idy/_),H=xO(b,T);this._parentRequests||(this._parentRequests={});const W=!this._parentRequests[H];return W&&g&&(this._parentRequests[H]=new Set,this._parentRequests[H].url=this.layer.getTileUrl(b,T,m+this.layer.options.zoomOffset)),{x:b,y:T,idx:P,idy:I,requests:this._parentRequests[H],isFirst:W,key:H}}loadTile(i){const g=this.layer,m=this._getTerrainWidth(),_=g.getSpatialReference().getResolution(i.z);let b=this.getMap().pointAtResToDistance(1,1,_);const T=g.options.maxAvailableZoom&&g.options.maxAvailableZoom-(g.options.zoomOffset||0);if(T&&i.z>T){const m=this._createTerrainFromParent(i);if(-1!==m.sourceZoom)return this.onTileLoad(m,i),m;{const{requests:_,isFirst:P,x:I,y:H,idx:W,idy:q}=this._getParentTileRequest(i,!0);if(_.add(i),!P)return m;const $=i.z-T;b*=Math.pow(2,$);const ye=[I,H,T,W,q,i.res*Math.pow(2,$),i.error*Math.pow(2,$)];i=g.createTileNode?g.createTileNode(...ye):g._createTileNode(...ye)}}const P=i.url,I={},H=g.options,W=g.getTileSize(),q={terrainWidth:m,type:H.type,accessToken:H.accessToken,cesiumIonTokenURL:H.cesiumIonTokenURL,error:b,colors:H.colors,tileSize:W?[W.width,W.height]:[256,256],command:"loadTile"},$=()=>{this.workerConn.fetchTerrain(P,q,((g,m)=>{if(this._parentRequests){const g=xO(i.x,i.y),m=this._parentRequests[g];if(m&&m.size){this.tileCache.add(i.id,{info:i,image:I});for(const i of m)this.removeTileLoading(i)}delete this._parentRequests[g]}g?ye(g):(Po.extend(I,m),i.colorsTexture=I.colorsTexture,this.onTileLoad(I,i))}))},ye=g=>{g&&g.canceled||(console.warn(g),this.onTileError(I,i))};return this.loadTileBitmap&&_I(this.loadTileBitmap)?this.loadTileBitmap(P,i,((i,g)=>{i?ye(i):g&&g instanceof ImageBitmap?(q.tileImage=g,$()):ye(new Error("bitmap is not ImageBitmap"))}),q):$(),I}deleteTile(i){if(!i||!i.image)return;super.deleteTile(i);const{info:g,image:m}=i;m.temp||(delete g.skinTileIds,this._deleteTerrainImage(i.info,m))}_deleteTerrainImage(i,g){const m=g.skin;m&&(m.destroy(),m.colorTex.destroy(),delete m.colorTex);const _=g.mask;_&&(_.destroy(),_.colorTex.destroy(),delete _.colorTex),g.debugTexture&&(g.debugTexture.destroy(),delete g.debugTexture,g.skinDebugMesh.dispose(),delete g.skinDebugMesh);const b=g.skinImages;if(b&&b.length){let m=i.id;g.temp&&(m+="-temp");for(let i=0;i<b.length;i++){const g=b[i];if(g){for(let i=0;i<g.length;i++){if(!g[i]||!g[i].tile)continue;const _=this._skinImageCache&&this._skinImageCache.get(g[i].tile.info.id);_&&this._deleteCachedSkinImage(_,m)}g.length=0}}}g.terrainMesh&&this._painter.deleteMesh(g.terrainMesh),g.image&&g.image.close&&g.image.close(),delete g.skinImages,delete g.skin,delete g.mask,delete g.skinStatus,delete g.skinTileIds,delete g.terrainMesh,delete g.image,delete g.data,delete g.mesh,delete g.rendered}_deleteCachedSkinImage(i,g,m){i&&(i.refs.delete(g),i.refs.size||(m?m.push(i):this._deleteSkinImage(i)))}_deleteSkinImage(i){if(!i||!i.tile)return;const g=i.tile.info.id,m=i.layer.getRenderer();delete i.canvas,delete i.layer,i.refs.clear(),i.texture&&(m?m.deleteTerrainTexture(i.texture):i.texture.destroy&&i.texture.destroy(),delete i.texture),i.skinMesh&&(i.skinMesh.dispose(),delete i.skinMesh),m&&(m.removeTileCache&&m.removeTileCache(g),m.deleteTile&&m.constructor.prototype.deleteTile.call(m,i.tile)),delete i.tile,this._skinImageCache.delete(g)}_clearSkinImageCache(){if(!this._skinImageCache)return;const i=this._skinImageCache.keys();for(const g of i){const i=this._getCachedSkinImage(g);this._deleteSkinImage(i)}this._skinImageCache.clear()}abortTileLoading(i,g){const m=this.layer,_=m.options.maxAvailableZoom&&m.options.maxAvailableZoom-m.options.zoomOffset,b=(i,g)=>{this.loadTileBitmap&&_I(this.loadTileBitmap)?this.loadTileBitmap(i,g,(()=>{}),{command:"abortTile"}):this.workerConn&&this.workerConn.abortTerrain(i)};if(g)if(_&&g.z>_){const{requests:i,key:m}=this._getParentTileRequest(g);i&&i.size&&(i.delete(g),i.size||(delete this._parentRequests[m],b(i.url,g)))}else g&&g.url&&b(g.url,g);super.abortTileLoading(i,g)}onTileError(i,g){super.onTileError(i,g)}_getTerrainTileAtPrjCoord(i){const g=this.getCurrentTileZoom(),m=this.layer.getSpatialReference().getResolution(g),_=this.layer._getTileConfig().getTileIndex(i,m,this.layer.options.repeatWorld);return _.z=g,_}_queryTerrain(i,g,m,_,b){const T=this.layer.getMinZoom(),P=this._findTerrainData(g,m.x,m.y,m.z,T);if(P&&P.image&&P.image.data){const g=P.info.extent2d,T=P.info.res/b,I=g.ymax*T-_.y;let H=this._queryAltitudeInHeights(P.image.data,(_.x-g.xmin*T)/(g.getWidth()*T),I/(g.getHeight()*T));const W=this.layer._getExaggeration();0!==W&&(H*=W),i[0]=H,i[1]=null===H?0:+(P.info.z===m.z)}else i[0]=null,i[1]=0;return i}_findTerrainData(i,g,m,_,b){i||(i=this.layer._getTileId(g,m,_));const T=this.tilesInView[i]||this.tileCache.get(i);return!T&&_-1>=b?this._findTerrainData(null,Math.floor(g/2),Math.floor(m/2),_-1,b):T}_queryAltitudeInHeights(i,g,m){const{width:_,height:b,data:T}=i,P=Math.floor((_-1)*g),I=Math.floor((b-1)*m)*_+P;return void 0===T[I]?null:T[I]}_queryTileAltitude(i,g,m){i||(i={tiles:{},dirty:!0,complete:!1});const _=this.layer,b=this.getCurrentTileZoom(),T=_.getSpatialReference().getResolution(b),{xmin:P,ymin:I,xmax:H,ymax:W}=g,q=_._getTileConfig();pO.set(P,I)._multi(m);const $=q._getTileNum(pO,m,!0);gO.set(H,W)._multi(m);const ye=q._getTileNum(gO,m,!0),Re=Math.min($.x,ye.x),Be=Math.max($.x,ye.x),Ge=Math.min($.y,ye.y),je=Math.max($.y,ye.y),Xe=m/T;pO.set(P,I)._multi(Xe),gO.set(H,W)._multi(Xe);const Ze=mO.set(pO.x,pO.y,gO.x,gO.y),Ye=_.getTileSize().width+1;Ze._expand(Ze.getWidth()/Ye),i.array=i.array||new Float32Array(Ye*Ye);const Qe=i.tiles;i.complete=!0,i.array.fill(0);for(let g=Re;g<=Be;g++)for(let m=Ge;m<=je;m++){const _=this.layer._getTileId(g,m,b);if(Qe[_])continue;const T=this.tileCache.get(_);T?(this._fillAltitudeData(i.array,T,Ze,Ye),i.dirty=!0,Qe[_]=1):(i.dirty=i.dirty||void 0!==i.tiles[_],i.tiles[_]&&delete i.tiles[_],i.complete=!1)}return i}_fillAltitudeData(i,g,m,_){const b=g.info.extent2d,T=b.intersection(m),{xmin:P,ymin:I,xmax:H,ymax:W}=T,{data:q}=g.image,$=q.width,ye=m.getWidth()/_,Re=Math.floor((P-m.xmin)/ye),Be=Math.floor((I-m.ymin)/ye),Ge=Math.floor((H-m.xmin)/ye)-Re,je=Math.floor((W-m.ymin)/ye)-Be,Xe=b.getWidth()/$,Ze=Math.floor((P-b.xmin)/Xe),Ye=Math.floor((I-b.ymin)/Xe),Qe=Math.floor(ye/Xe);for(let g=0;g<=Ge;g++)for(let m=0;m<=je;m++){const b=g+Re+(Be+m)*_;let T=0;for(let i=0;i<Qe;i++)for(let _=0;_<Qe;_++){const b=(Ze+Math.floor(g*Qe))*$+i+Ye+Math.floor(m*Qe)+_;T+=q.data[b]}i[b]=T/Math.max(Qe,1)}return i}clear(){return this.clearTempResources(),this.clearTileCaches(),super.clear()}clearTempResources(){this._tempTilesPool&&(this._tempTilesPool.reset(),delete this._tempTilesPool),this._skinImageCache&&this._clearSkinImageCache()}onAdd(){super.onAdd(),this.prepareWorker()}onRemove(){this.workerConn&&(this.workerConn.removeLayer(this.layer.getId(),(i=>{if(i)throw i})),this.workerConn.remove(),delete this.workerConn),this.clearTempResources(),this._skinShader&&(this._skinShader.dispose(),delete this._skinShader),this._skinGeometry&&(this._skinGeometry.dispose(),delete this._skinGeometry),this._terrainMaskDepthStencil&&(this._terrainMaskDepthStencil.colorTex&&this._terrainMaskDepthStencil.colorTex.destroy(),this._terrainMaskDepthStencil.destroy(),delete this._terrainMaskDepthStencil),delete this._parentRequests,super.onRemove(),this._painter&&(this._painter.delete(),delete this._painter)}prepareWorker(){const i=this.layer.getMap();this.workerConn||(this.workerConn=new TerrainWorkerConnection(i.id));const g=this.workerConn;if(!g.isActive())return;const m=this.layer.options||{},_=this.layer.getId();g.addLayer(_,m,(i=>{if(i)throw i;this.layer&&(this.ready=!0,this.setToRedraw(),this.layer.fire("workerready"))}))}initContext(){super.initContext();const{regl:i,device:g}=this.context;this.regl=i,this.device=g||i,this.renderer=new Renderer(i||g),this.layer.fire("contextcreate",{regl:i,device:g})}_createPainter(){const i=this._painter;"lit"===this.layer.options.shader||"pbr"===this.layer.options.shader?(i&&i.constructor===TerrainPainter||!i)&&(i&&(i.delete(),this.clear(),this.setToRedraw()),this._painter=new TerrainLitPainter(this.layer),this.layer.fire("paintercreated")):(i&&i.constructor===TerrainLitPainter||!i)&&(i&&(i.delete(),this.clear(),this.setToRedraw()),this._painter=new TerrainPainter(this.layer),this.layer.fire("paintercreated"))}_initSkinShader(){if(this._skinShader)return;const i=this.layer.getTileSize().width;this._skinShader=new MeshShader({name:"terrain-skin",vert:"#define SHADER_NAME TERRAIN_SKIN\nattribute vec2 aPosition;\nvoid main() {\n  gl_Position = vec4(aPosition, .0, 1.);\n}",frag:"#define SHADER_NAME TERRAIN_SKIN\nprecision mediump float;\nuniform float tileSize;\nuniform sampler2D skinTexture;\nuniform vec3 skinDim;\nuniform float opacity;\nvoid main() {\n  vec2 c = gl_FragCoord.xy / 2.;\n  vec2 d = vec2(tileSize);\n  vec2 e = (c - skinDim.xy) / (d * skinDim.z);\n  if(e.x >= .0 && e.x <= 1. && e.y >= .0 && e.y <= 1.) {\n    gl_FragColor = texture2D(skinTexture, e) * opacity;\n  } else {\n    gl_FragColor = vec4(.0);\n  }\n}",wgslVert:"",wgslFrag:"",extraCommandProps:{cull:{enable:!1},viewport:{x:0,y:0,width:2*i,height:2*i},depth:{enable:!1},blend:{enable:!0,func:{src:"one",dst:"one minus src alpha"},equation:"add"}}});const g=new Int16Array([-1,-1,1,1,-1,1,1,1,-1,-1,1,-1]);this._skinGeometry=this._skinGeometry||new Geometry({aPosition:g},0,6,{positionSize:2}),this._skinGeometry.generateBuffers(this.device),this._skinScene=this._skinScene||new Scene}updateMaterial(i){this._painter&&i&&this._painter.updateMaterial&&(void 0===this._matVer&&(this._matVer=1),this._painter.updateMaterial(i,this._matVer++))}setMaterial(i){this._painter&&i&&this._painter.setMaterial&&(void 0===this._matVer&&(this._matVer=1),this._painter.setMaterial(i,this._matVer++))}getAnalysisMeshes(){return this._painter&&this._painter._leafScene?this._painter._leafScene.getMeshes():[]}_debugTile(i,g,m){if(this.layer.options.debugTile){if(Array.isArray(i)){for(let _=0;_<i.length;_++)i[_]&&this._debugTile(i[_],g+" at "+_,m);return}if(!i)return;const{x:_,y:b,z:T}=this.layer.options.debugTile,{info:P}=i;P&&(i=P),_===i.x&&b===i.y&&T===i.z&&console.log(`Found debug tile in TerrainLayerRenderer.${g}:`,i)}}}function vO(i,g,m){const{res:_,extent2d:b,offset:T}=i,{info:P}=g,I=P.res/_,H=P.offset;return[P.extent2d.xmin*I-b.xmin+(T[0]-H[0]),-(b.ymin-P.extent2d.ymin*I+(H[1]-T[1])),I*P.tileSize/m]}function xO(i,g){return i+"-"+g}const bO={"clip-inside":.1,"clip-outside":.2,"flat-inside":.3,"flat-outside":.4,color:.5,texture:.6,elevate:.7},wO=[],TO=[1,1,1],SO={polygonFill:[255,0,0],polygonOpacity:.8},MO=new pl(0,0),CO=new pl(0,0),PO=[],IO=new pl(0,0),kO=new un(0,0),OO=new un(0,0),EO=new un(0,0);class Mask extends gf{getMode(){return this._mode}remove(){const i=this.getLayer();return i?(i.removeMask(this),this._dispose(),super.remove(),this):this}getMesh(i,g,m){return this.isVisible()&&this.getLayer()?(this._mesh||(this._mesh=this._createMesh(i,g,m)),this._updateUniforms(this._mesh,g,m),this._mesh):null}setCoordinates(i){super.setCoordinates(i);const g=this.getLayer();if(g&&(delete g._maskProjViewMatrix,delete g._maskExtentInWorld),!this._mesh)return this;const m=this.getMode(),_=this.toGeoJSON();_.geometry.coordinates[0].reverse();const b=Vx.flatten(_.geometry.coordinates),{positions:T,uvs:P,triangles:I}="texture"===m?this._createBilinearPOSITON(b):this._createPOSITION(b),H=this._mesh.geometry;if(H.updateData("POSITION",T),H.updateData("TEXCOORD",P),H.setElements(I),this._setLocalTransform(this._mesh),this._copyMesh){const i=this._createPOSITION(Vx.flatten(_.geometry.coordinates),!0).positions;this._copyMesh.geometry.updateData("POSITION",i),this._setLocalTransform(this._copyMesh)}}_createGeometry(i){const g=this.getMode(),m=this.toGeoJSON();m.geometry.coordinates[0].reverse();const _=Vx.flatten(m.geometry.coordinates),{positions:b,uvs:T,triangles:P}="texture"===g?this._createBilinearPOSITON(_):this._createPOSITION(_),I=this._createPOSITION(Vx.flatten(m.geometry.coordinates),!0).positions,H=new Geometry({POSITION:b,TEXCOORD:T},P,0,{positionAttribute:"POSITION",uv0Attribute:"TEXCOORD"});H.generateBuffers(i);const W=new Geometry({POSITION:I,TEXCOORD:T},P,0,{positionAttribute:"POSITION",uv0Attribute:"TEXCOORD"});return W.generateBuffers(i),"texture"===g?{geometry:H,copyGeometry:W}:H}_createPOSITION(i,g){const m=this.getMap(),_=i.dimensions;for(let g=0;g<i.vertices.length;g+=_){IO.x=i.vertices[g],IO.y=i.vertices[g+1];const _=CI(m,IO);i.vertices[g]=_[0],i.vertices[g+1]=_[1]}const b=CI(m,this.getCenter()),T=[],P=.01*this.getLayer().getMasks().indexOf(this),I="texture"===this.getMode()?4:i.vertices.length/_;for(let H=0;H<I;H++)T.push(i.vertices[H*_]-b[0]),T.push(i.vertices[H*_+1]-b[1]),T.push(P+g?m.altitudeToPoint(i.vertices[H*_+2],m.getGLRes()):0);return{positions:T,uvs:this._createTexcoords(i.vertices,_),triangles:Vx(T,i.holes,3)}}_createTexcoords(i,g){const m=[0,0,0,1,1,1,1,0];if(this.hasHoles()){const _=i.length/g*2;for(let i=m.length/2-1;i<_;i+=2)m[i]=m[i+1]=0}return m}_createBilinearPOSITON(i){const g=i.dimensions,m=[],_=[],b=[],T=this.getMap();for(let m=0;m<i.vertices.length;m+=g){IO.x=i.vertices[m],IO.y=i.vertices[m+1];const g=CI(T,IO);i.vertices[m]=g[0],i.vertices[m+1]=g[1]}const P=CI(this.getMap(),this.getCenter()),I={};I.a={x:i.vertices[0*g]-P[0],y:i.vertices[0*g+1]-P[1]},I.b={x:i.vertices[1*g]-P[0],y:i.vertices[1*g+1]-P[1]},I.c={x:i.vertices[2*g]-P[0],y:i.vertices[2*g+1]-P[1]},I.d={x:i.vertices[3*g]-P[0],y:i.vertices[3*g+1]-P[1]},this._positions=[];for(let m=0;m<4;m++)this._positions.push(i.vertices[m*g]-P[0]),this._positions.push(i.vertices[m*g+1]-P[1]),this._positions.push(0);for(let i=0;i<=20;i++)for(let g=0;g<=20;g++){const b=g/20,T=i/20;m.push((1-b)*(1-T)*I.a.x+b*(1-T)*I.b.x+b*T*I.c.x+(1-b)*T*I.d.x,(1-b)*(1-T)*I.a.y+b*(1-T)*I.b.y+b*T*I.c.y+(1-b)*T*I.d.y,0),_.push(b,1-T)}for(let i=0;i<20;i++)for(let g=0;g<20;g++){const m=21*i+g,_=21*(i+1)+g,T=_+1;b.push(m,m+1,T),b.push(m,T,_)}return{positions:m,uvs:_,triangles:b}}clearMesh(){this._dispose(),delete this._mesh,this.maskGeoJSON&&(this.maskGeoJSON=null)}_getMaskMode(){return bO[this._mode]}_getMaskColor(){const i=this.getSymbol(),{polygonFill:g,polygonOpacity:m}=i||SO,_=SI([],g);return _[3]=yI(m)?m:"texture"===this.getMode()?1:SO.polygonOpacity,_}_altitudeToPoint(i=0){const g=this.getMap(),m=g.getGLRes();return g.altitudeToPoint(i,m)}_setLocalTransform(i){const g=CI(this.getMap(),this.getCenter()),m=OA(i.localTransform,$y(wO),g,TO);i.localTransform=m}_dispose(){this._mesh&&(this._mesh.material&&this._mesh.material.dispose(),this._mesh.geometry&&this._mesh.geometry.dispose(),this._copyMesh&&this._copyMesh.geometry&&(this._copyMesh.geometry.dispose(),this._copyMesh.dispose()),this._mesh.dispose(),delete this._mesh,delete this._copyMesh)}containsPoint(i){const g=this.getExtent();if(IO.set(i[0],i[1]),!g||!g.contains(IO))return!1;const m=this.getHoles();for(let g=0;g<m.length;g++)if(this._contains(m[g],i))return!1;const _=this.getShell();return this._contains(_,i)}_contains(i,g){const m=this._calArea(i);let _=0;for(let m=0;m<i.length;m++){MO.x=i[m].x,MO.y=i[m].y;const b=m+1>=i.length?0:m+1;CO.x=i[b].x,CO.y=i[b].y,IO.x=g[0],IO.y=g[1],PO[0]=IO,PO[1]=MO,PO[2]=CO;_+=this._calArea(PO)}return!(Math.abs(_-m)>1e-8)}_calArea(i){const g=this.getMap();let m=0;const _=g.getGLRes(),b=g.coordToPointAtRes(i[0],_,kO);for(let H=1;H<i.length-1;H++){const W=g.coordToPointAtRes(i[H],_,OO),q=g.coordToPointAtRes(i[H+1],_,EO);m+=(((P=W).x-(T=b).x)*((I=q).y-T.y)-(P.y-T.y)*(I.x-T.x))/2}var T,P,I;
/*!
  * Contains code from THREE.js
  * MIT License
  * https://github.com/mrdoob/three.js
  */return m}}for(var RO=[],LO=0;LO<6;LO++)RO[LO]=[];var DO=[];function FO(i,g,m){!function(i){var g=i,m=g[0],_=g[1],b=g[2],T=g[3],P=g[4],I=g[5],H=g[6],W=g[7],q=g[8],$=g[9],ye=g[10],Re=g[11],Be=g[12],Ge=g[13],je=g[14],Xe=g[15];NO(RO[0],T-m,W-P,Re-q,Xe-Be),NO(RO[1],T+m,W+P,Re+q,Xe+Be),NO(RO[2],T+_,W+I,Re+$,Xe+Ge),NO(RO[3],T-_,W-I,Re-$,Xe-Ge),NO(RO[4],T-b,W-H,Re-ye,Xe-je),NO(RO[5],T+b,W+H,Re+ye,Xe+je)}(i);for(var _=0;_<6;_++){var b=RO[_];if(DO[0]=b[0]>0?g[1][0]:g[0][0],DO[1]=b[1]>0?g[1][1]:g[0][1],DO[2]=b[2]>0?g[1][2]:g[0][2],HO(b,DO)<0)return!1}return!0}function NO(i,g,m,_,b){var T=1/Math.sqrt(g*g+m*m+_*_);return i[0]=g*T,i[1]=m*T,i[2]=_*T,i[3]=b*T,i}function HO(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]+i[3]}const BO=new pl(0,0),zO=[0,0,0],VO=[0,0,0],UO=mA([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);function GO(){return this._maskList?(this._maskList.forEach((i=>{i.remove()})),this._maskList=[],this.updateMaskExtent(),this):this}function jO(){for(let i=0;i<this._maskList.length;i++)if(this._maskList[i].isVisible())return!0;return!1}function WO(i){return class MaskLayerMixin extends i{removeMask(i){if(!this._maskList)return this;if(!i)return GO.call(this),this;const g=Array.isArray(i)?i:[i];for(let i=0;i<g.length;i++){const m=this._maskList.indexOf(g[i]);m>-1&&this._maskList.splice(m,1)}return this.updateMaskExtent(),this.fire("removemask",{masks:i}),this}setMask(i){return this.removeMask(null),this._maskList||(this._maskList=[]),Array.isArray(i)?i.forEach((i=>{this._maskList.push(i)})):this._maskList.push(i),this._maskList.forEach((i=>{i._bindLayer(this),i._updateCoordinates&&i._updateCoordinates()})),this.updateMaskExtent(),this.fire("setmask",{masks:i}),this}onAdd(){super.onAdd(),this.updateMaskExtent()}getMasks(){return this._maskList||[]}onGeometryEvent(i){if(!i||!i.target)return;"shapechange"===i.type&&i.target instanceof Mask&&i.target.clearMesh(),i.target instanceof Mask&&this.updateMaskExtent(),super.onGeometryEvent&&super.onGeometryEvent(i)}identifyMask(i,g){if(!this.getMap())return[];if(!this._maskList||!this._maskList.length)return[];const m=mI({},g);m.excludeMasks=!0;const _=this.identifyAtPoint(i,m),b=_.length&&_[0].coordinate;if(b){const i=this._maskList;if(!i)return[];const g=[];for(let m=0;m<i.length;m++){const _=i[m].getMode();!i[m].containsPoint(b)||"color"!==_&&"texture"!==_||g.push(i[m])}return g}return[]}remove(){this._maskList&&this._maskList.length&&this._maskList.forEach((i=>{i.remove()})),super.remove()}updateMask(i){const g=this.getMap(),{projViewMatrix:m,mapExtent:_}=this.getProjViewMatrixInOrtho(i);BO.x=_.xmin,BO.y=_.ymin;const b=qO(zO,BO,g);BO.x=_.xmax,BO.y=_.ymax;const T=qO(VO,BO,g);return{projViewMatrix:m,extentInWorld:[b[0],b[1],T[0],T[1]]}}getProjViewMatrixInOrtho(i){const g=this.getMap(),m=g.getView(),_=g.getFitZoom(i),b=i.getCenter();g.setView({center:b,zoom:_,pitch:0,bearing:0});const T=g.getExtent(),P=gA(UO,g.projViewMatrix);return g.setView(m),{mapExtent:T,projViewMatrix:P}}updateMaskExtent(){if(!this._maskList)return;if(!this.getMap())return;const i=this.getRenderer();if(i&&!this._maskList.length)return void i._clearMask();if(i&&!jO.call(this))return i._deleteMaskUniforms(),void i.setToRedraw();const g=this.getMaskExtent();if(!g)return;const{extent:m,ratio:_,minHeight:b}=g,{projViewMatrix:T,extentInWorld:P}=this.updateMask(m);this._maskProjViewMatrix=T,this._maskExtentInWorld=P,i?i.setMask(this._maskExtentInWorld,this._maskProjViewMatrix,_,b):this.once("renderercreate",(i=>{i.renderer.setMask(this._maskExtentInWorld,this._maskProjViewMatrix,_,b)}))}getMaskExtent(){let i=1/0,g=1/0,m=-1/0,_=-1/0,b=-1/0,T=1/0,P=!1;const I=this.getMap();for(let H=0;H<this._maskList.length;H++){const W=this._maskList[H];if(!W.isVisible())continue;const q=W.getExtent();if(q){if(W._mesh&&W.getBBox){const i=W.getBBox();if(!FO(I.projViewMatrix,i))continue}if(P=!0,q.xmin<i&&(i=q.xmin),q.ymin<g&&(g=q.ymin),q.xmax>m&&(m=q.xmax),q.ymax>_&&(_=q.ymax),W._getHeightRange){const i=W._getHeightRange();i[0]<T&&(T=i[0]),i[1]>b&&(b=i[1])}}}if(!P)return null;const{ratio:H,minHeight:W}=function(i,g){const m=i===1/0?0:i,_=Math.abs((g===-1/0?0:g)-m);return 0===_?{ratio:1,minHeight:0}:{ratio:Math.pow(_,-1),minHeight:m}}(T,b);return{extent:new Pl(i,g,m,_),ratio:H,minHeight:W}}}}function qO(i,g,m,_=0){if(!(m&&g instanceof pl))return null;const b=m.coordinateToPointAtRes(g,m.getGLRes());return i[0]=b.x,i[1]=b.y,i[2]=_,i}const XO=new pl(0,0),ZO=new pl(0,0),$O=new un(0,0),YO=[],QO={tileGrids:[],count:0},JO="01",KO="1";class TerrainLayer extends(WO(Up)){constructor(i,g){g&&!g.tileSystem&&("cesium"===g.type||"cesium-ion"===g.type?g.tileSystem=[1,1,-180,-90]:"tianditu"===g.type&&(g.tileSystem=[1,-1,-180,90])),g.tileSize||"mapbox"===g.type&&(g.tileSize=512),g.spatialReference||"mapbox"===g.type&&(g.spatialReference="preset-3857-512"),super(i,g)}onAdd(){const i=this.options,g=this.getMap().getProjection(),m="EPSG:3857"===g.code;512!==i.tileSize||i.spatialReference||("mapbox"===i.type?"EPSG:4326"===g.code||"EPSG:4490"===g.code?i.spatialReference="preset-4326-512":m&&(i.spatialReference="preset-3857-512"):"cesium"===i.type||"cesium-ion"===i.type?i.spatialReference="preset-4326-512":"tianditu"===i.type&&(i.spatialReference={projection:"EPSG:4326",fullExtent:{top:90,left:-180,bottom:-90,right:180},resolutions:function(){const i=[];for(let g=0;g<=22;g++)i[g]=90/(128*Math.pow(2,g));return i}()})),i.terrainWidth||"tianditu"!==i.type||(i.terrainWidth=65)}getTileUrl(i,g,m){let _=super.getTileUrl(i,g,m);return"mapbox"===this.options.type&&this.options.requireSkuToken&&(this._skuToken||(this._skuToken=this._createSkuToken()),_.indexOf("?")>-1?_+="&sku="+this._skuToken:_+="?sku="+this._skuToken),_}getMaxAvailableZoom(){return this.getSpatialReference().getMaxZoom()}_createSkuToken(){let i="";for(let g=0;g<10;g++)i+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62*Math.random())];return[KO,JO,i].join("")}_getExaggeration(){let i=this.options.exaggeration;return AI(i)&&(i=1),i}setSkinLayers(i){this._skinLayers=i;const g=this.getRenderer();g&&(g.clear(),g.setToRedraw())}getSkinTiles(i){const g=this.getRenderer();if(!g)return QO;const m=g.getTileGridsInCurrentFrame().tileGrids[0];if(!m)return QO;const _=i.getId(),b=this._getTileConfig().tileSystem.scale,T=i.getTileSize().width,P=m.tiles;if(!P.length)return QO;const I=this.getMap(),H=m.parents||YO,W=H.length,q=H.concat(P),$=i.getSpatialReference(),ye=P[0].extent2d.getWidth(),Re=b.x,Be=b.y,Ge=[],je=[],Xe=new Set,Ze=this._getTileConfig().tileSystem.scale.y;for(let g=0;g<q.length;g++){const m=q[g],{res:b}=m;let P=m.nw;P||(P=m.nw=I.pointAtResToCoord(m.extent2d.getMin($O),m.res));const{res:H,zoom:Ye}=Wk($,m.z,b),Qe=H/b,Je=jk(H,T,b,ye),{extent2d:Ke,offset:et}=m,tt=Je*m.x,at=Je*m.y;if(m.skinTileIds||(m.skinTileIds={}),!m.skinTileIds[_]){const g=new Set,b=[],I=Gk(i,m.x,m.y,Ye,P,et,Be,Je,0);for(let m=0;m<I.length;m++){const _=I[m];if(g.has(_.id))continue;_.idx=_.x,_.idy=_.y,_.res=H,_.url=i.getTileUrl(_.x,_.y,_.z+i.options.zoomOffset);const P=Be*(_.skinY-at)*T,W=Ke.xmin*Qe+Re*(_.x-tt)*T,q=Ke.ymax*Qe+P,$=Ke.ymin*Qe+P;_.extent2d=Ze>0?new kl(W,$,W+T,$+T):new kl(W,q-T,W+T,q),g.add(_.id),b.push(_)}m.skinTileIds[_]=b}const ht=m.skinTileIds[_];for(let i=0;i<ht.length;i++)Xe.has(ht[i].id)||(g<W?Ge.push(ht[i]):je.push(ht[i]),Xe.add(ht[i].id))}return{tileGrids:[{extent:m.extent,tiles:je,parents:Ge,count:je.length}],count:je.length}}getSkinLayer(i){return this.getSkinLayers()[i]}getSkinLayers(){return this._skinLayers||YO}getSkinCount(){return this._skinLayers&&this._skinLayers.length||0}queryTerrainByProjCoord(i,g){g=g||[];const m=this.getRenderer();if(!m)return g[0]=null,g[1]=0,g;const _=this.getMap(),b=m._getTerrainTileAtPrjCoord(i);if(!b)return g[0]=null,g[1]=0,g;const T=_._prjToPointAtRes(i,1,$O);return m._queryTerrain(g,b.id,b,T,1)}queryTileTerrainByProjCoord(i,g,m,_){_=_||[];const b=this.getRenderer();if(!b)return _[0]=null,_[1]=0,_;const T=this.getMap()._prjToPointAtRes(i,1,$O);return b._queryTerrain(_,g,m,T,1)}queryTileTerrainByPointAtRes(i,g,m,_,b){b=b||[];const T=this.getRenderer();return T?T._queryTerrain(b,m,_,i,g):(b[0]=null,b[1]=0,b)}queryTerrain(i,g){g=g||[];if(!this.getRenderer())return g[0]=null,g[1]=0,g;const m=this.getMap().getProjection().project(i,XO);return this.queryTerrainByProjCoord(m,g)}queryTileMesh(i,g){const m=this.getRenderer();m&&m._queryTileMesh(i,g)}getTerrainTiles(i,g){const{x:m,y:_,z:b,res:T,offset:P}=g,I=g.extent2d.getWidth(),H=this._getTileConfig(),W=i._getTileConfig(),q=this.getSpatialReference(),{res:$,zoom:ye}=Wk(q,b,T),Re=this.getTileSize().width,Be=jk($,Re,T,I);let Ge=g.nw;Ge||(Ge=g.nw=this.getMap().pointAtResToCoord(g.extent2d.getMin($O),g.res));const je=Vk(this,m,_,ye,Ge,P,W.tileSystem.scale.y,Be,1)[0];for(let i=0;i<je.length;i++){const{x:g,y:m}=je[i],_=H.getTilePointNW(g,m,$,$O);je[i].res=$,je[i].extent2d=new kl(_.x,_.y,_.x+Re,_.y-Re)}return je}isTerrainTileLoaded(i){const g=this.getRenderer();return!!g&&g.isTileCached(i)}updateMaterial(i){if(!i)return;this.options.material||(this.options.material={}),mI(this.options.material,i);const g=this.getRenderer();g&&g.updateMaterial(i)}setMaterial(i){if(!i)return;this.options.material=i;const g=this.getRenderer();g&&g.setMaterial(i)}_createTileNode(i,g,m,_,b,T,P,I,H,W){const q=this.getMap(),$=this.options.zoomOffset;if(!H){H=this._getTileConfig().getTilePrjExtent(i,g,T).convertTo((i=>q._prjToPointAtRes(i,T,ZO)))}const ye=this._getTileOffset(m);return{parent:I,layer:this.getId(),x:i,y:g,z:m,idx:_,idy:b,res:T,extent2d:H,id:W||this._getTileId(i,g,m),url:this.getTileUrl(i,g,m+$),offset:ye,error:P,children:[]}}}TerrainLayer.mergeOptions({forceRenderOnMoving:!0,forceRenderOnZooming:!0,forceRenderOnRotating:!0,fadeAnimation:!1,fadeDuration:1e3/60*15,tileLimitPerFrame:2,newTerrainTileRenderLimitPerFrameOnInteracting:1,opacity:1,renderer:"gl",pyramidMode:1,tileSize:512,terrainWidth:null,backZoomOffset:0,depthMask:!0,blendSrc:"one",blendDst:"one minus src alpha",requireSkuToken:!0,cesiumIonTokenURL:"https://api.cesium.com/v1/assets/1/endpoint?access_token=",tileRetryCount:0,shader:"default",terrainTileMode:!0,tempTileCacheSize:64,tileStackStartDepth:7,tileStackDepth:6,currentTilesFirst:!1,exaggeration:1,colors:[]}),TerrainLayer.registerJSONType("TerrainLayer"),TerrainLayer.registerRenderer("gl",TerrainLayerRenderer),TerrainLayer.registerRenderer("gpu",TerrainLayerRenderer);const eE=[],tE=[],nE=[],rE=[],iE=new un(0,0),oE=[],sE=[],aE=[],lE=[],hE=[],cE=[],uE=[],fE=[],dE=[];class RayCaster{constructor(i,g,m=!0){this._from=i,this._to=g,this._isLngLat=m}setFromPoint(i){this._from=Array.isArray(i)?new pl(i):i}setToPoint(i){this._to=Array.isArray(i)?new pl(i):i}test(i,g,m={}){const _=m.count||0,b=[];let T=this._from,P=this._to;this._isLngLat&&(T=gE(g,this._from.x,this._from.y,this._from.z),P=gE(g,this._to.x,this._to.y,this._to.z));const I=new Ts.Ray(T,P);for(let m=0;m<i.length;m++){const T=i[m];if(!this._checkBBox(T.getBoundingBox(),I))continue;const P=T.localTransform,H=T.geometry,W=H.data[H.desc.positionAttribute].array,q=H.data[H.desc.altitudeAttribute]&&H.data[H.desc.altitudeAttribute].array||oE,$=H.indices;if(!(W&&W.length&&$&&$.length))continue;const ye=_A(lE,P,T.positionMatrix),Re=this._testMesh(T,I,g,W,q,$,H.desc.positionSize,ye,_);if(Re){if(b.push({mesh:T,coordinates:Re}),0!==_&&b.length>=_)break}}return b}_testMesh(i,g,m,_,b,T,P,I,H){const W=[];for(let q=0;q<T.length&&!(q>i.properties.skirtOffset);q+=3){const i=T[q],$=T[q+1],ye=T[q+2],Re=qA(hE,_[i*P],_[i*P+1],_[i*P+2]),Be=this._toWorldPosition(tE,m,Re,b[i]/100,I),Ge=qA(cE,_[$*P],_[$*P+1],_[$*P+2]),je=this._toWorldPosition(nE,m,Ge,b[$]/100,I),Xe=qA(uE,_[ye*P],_[ye*P+1],_[ye*P+2]),Ze=this._toWorldPosition(rE,m,Xe,b[ye]/100,I),Ye=qA(eE,Be,je,Ze),Qe=cy(sE,Be,je),Je=cy(aE,Be,Ze),Ke=this._testIntersection(fE,Ye,g);if(Ke){const g=m.pointAtResToAltitude(Ke[2],m.getGLRes());iE.x=Ke[0],iE.y=Ke[1];const _=m.pointAtResToCoordinate(iE,m.getGLRes());if(_.z=g,W.push({coordinate:_,indices:[i,$,ye],normal:iy([],Qe,Je)}),0!==H&&W.length>=H)break}}return W.length?W:null}_toWorldPosition(i,g,m,_,b){let T;return Po.isNumber(_)?(T=g.altitudeToPoint(_,g.getGLRes()),wy(i,m[0],m[1],0,1),Fy(i,i,b),i[2]=T):(wy(i,m[0],m[1],m[2],1),Fy(i,i,b)),i}_testIntersection(i,g,m){return m.intersectTriangle(g[0],g[1],g[2],!0,i)}_checkBBox(i,g){return!!i&&g.intersectBox(i,dE)}}const pE=new pl(0,0);function gE(i,g,m,_){if(!i)return null;pE.set(g,m);const b=i.coordinateToPointAtRes(pE,i.getGLRes()),T=i.altitudeToPoint(_||0,i.getGLRes());return[b.x,b.y,T]}const mE=()=>{},AE=new pl(0,0),yE=[0,0,0],_E=[0,0,0],vE=[0,0,0];class GroupGLLayer extends Fu{static fromJSON(i){if(!i||"GroupGLLayer"!==i.type)return null;const g=i.layers.map((i=>Fu.fromJSON(i)));return new GroupGLLayer(i.id,g,i.options)}constructor(i,g,m){super(i,m),this.layers=g&&g.slice()||[],this.layers.forEach((i=>{if(i.getMap())throw new Error(`layer(${i.getId()} is already added on map`)})),this._checkChildren(),this.sortLayersByZIndex(),this._layerMap={}}sortLayersByZIndex(){if(this.layers&&this.layers.length){for(let i=0,g=this.layers.length;i<g;i++)this.layers[i].__group_gl_order=i;this.layers.sort(bE)}}setSceneConfig(i){this.options.sceneConfig=i;const g=this.getRenderer();return g&&g.updateSceneConfig(),this}getSceneConfig(){return JSON.parse(JSON.stringify(this._getSceneConfig()))}_getSceneConfig(){return this.options.sceneConfig||{}}getGroundConfig(){return this._getSceneConfig().ground}getWeatherConfig(){return this._getSceneConfig().weather}getScanEffectConfig(){const i=this._getSceneConfig();return i.postProcess&&i.postProcess.scanEffect}addLayer(i,g){if(i.getMap())throw new Error(`layer(${i.getId()}) is already added on map`);if("gl"!==i.options.renderer)throw new Error(`layer(${i.getId()})'s renderer is canvas, not supported to be added to GroupGLLayer`);void 0===g?this.layers.push(i):this.layers.splice(g,0,i),this._checkChildren(),this.sortLayersByZIndex();const m=this.getRenderer();return m?(this._prepareLayer(i),this._updateTerrainSkinLayers(),m.setToRedraw(),this):this}removeLayer(i){Po.isString(i)&&(i=this.getChildLayer(i));const g=this.layers.indexOf(i);if(g<0)return this;const m=i.getRenderer();m&&m.setTerrainHelper&&m.setTerrainHelper(null),i._doRemove(),this._unbindChildListeners(i),delete this._layerMap[i.getId()],this.layers.splice(g,1);const _=this.getRenderer();return _?(this._updateTerrainSkinLayers(),_.setToRedraw(),this):this}clearLayers(){const i=this.getLayers();for(let g=0;g<i.length;g++)i[g]&&i[g].remove();return this}_updatePolygonOffset(){let i=0;for(let g=0;g<this.layers.length;g++){const m=this.layers[g];m.setPolygonOffset&&m.getPolygonOffsetCount&&(i+=m.getPolygonOffsetCount())}let g=0;for(let m=this.layers.length-1;m>=0;m--){const _=this.layers[m];_.setPolygonOffset&&_.getPolygonOffsetCount&&(_.setPolygonOffset(g,i),g+=_.getPolygonOffsetCount())}this._polygonOffset=g}getPolygonOffsetCount(){return this._polygonOffset}getLayers(){return this.layers.slice()}_getLayers(){return this.layers}toJSON(){const i=[];if(this.layers)for(let g=0;g<this.layers.length;g++){const m=this.layers[g];m&&(m&&m.toJSON&&i.push(m.toJSON()))}return{type:this.getJSONType(),id:this.getId(),layers:i,options:this.config()}}onLoadEnd(){this.layers.forEach((i=>{this._prepareLayer(i)})),this.options.terrain&&this._initTerrainLayer(),super.onLoadEnd()}_prepareLayer(i){const g=this.getRenderer();this._layerMap[i.getId()]=i,i._canvas=g.canvas,i._bindMap(this),i.once("renderercreate",this._onChildRendererCreate,this),i.remove=()=>(this.removeLayer(i),i.constructor.prototype.remove.call(i),delete i.remove,this),i.load(),this._bindChildListeners(i)}onRemove(){this._removeTerrainLayer(),this.layers.forEach((i=>{this._resetSkinLayer(i),i._doRemove(),this._unbindChildListeners(i)})),this._layerMap={},this.clearAnalysis(),super.onRemove()}getChildLayer(i){return this._layerMap[i]||null}getLayer(i){return this.getChildLayer(i)}_bindChildListeners(i){i.on("show hide",this._onLayerShowHide,this),i.on("idchange",this._onLayerIDChange,this)}_unbindChildListeners(i){i.off("show hide",this._onLayerShowHide,this),i.off("idchange",this._onLayerIDChange,this)}_onLayerShowHide(){const i=this.getRenderer();i&&i.setToRedraw()}_onLayerIDChange(i){const g=i.new,m=i.old,_=this.getLayer(m);delete this._layerMap[m],this._layerMap[g]=_}_onChildRendererCreate(i){i.renderer.clearCanvas=xE}_checkChildren(){const i={};this.layers.forEach((g=>{const m=g.getId();if(i[m])throw new Error(`Duplicate child layer id (${m}) in the GroupGLLayer (${this.getId()})`);i[m]=1}))}addAnalysis(i){this._analysisTaskList=this._analysisTaskList||[],this._analysisTaskList.push(i);const g=this.getRenderer();g&&g.setToRedraw()}removeAnalysis(i){if(this._analysisTaskList){const g=this._analysisTaskList.indexOf(i);g>-1&&(this._analysisTaskList.splice(g,1),i.remove())}const g=this.getRenderer();g&&g.setToRedraw()}clearAnalysis(){this._analysisTaskList&&(this._analysisTaskList.forEach((i=>{i.remove()})),this._analysisTaskList=[]);const i=this.getRenderer();i&&i.setToRedraw()}identify(i,g){const m=this.getMap(),_=this.getRenderer();if(!m||!_)return[];const b=m.coordToContainerPoint(new pl(i));return this.identifyAtPoint(b,g)}identifyAtPoint(i,g={}){const m=g.includeInternals,_=this.getLayers(),b=g&&g.childLayers||_,T=this.getMap();if(!T)return[];const P=AI(g.count)?1:g.count;let I=[];for(let T=b.length-1;T>=0;T--){const P=b[T];if(_.indexOf(P)<0||!P.identifyAtPoint)continue;const H=P.options.geometryEvents;if(m&&(void 0===H||!1===H||0===H))continue;if(P.isGeometryListening&&m&&g.eventTypes.indexOf("mousemove")>=0&&!P.isGeometryListening(g.eventTypes))continue;const W=P.identifyAtPoint(i,g);if(!W||!W.length)continue;const q=P.getId();for(let i=0;i<W.length;i++)W[i]&&(W[i].layer=q);I.push(...W)}if(g.orderByCamera){const i=T.cameraPosition;I.sort(((g,m)=>m.point?g.point?dy(g.point,i)-dy(m.point,i):1:-1))}return P&&(I=I.slice(0,P)),I}getTerrain(){return this.options.terrain}setTerrain(i){return this.options.terrain=i,this.getRenderer()?(this._initTerrainLayer(),this.getMap().updateCenterAltitude(),this):this}removeTerrain(){return this.setTerrain(null)}updateTerrainMaterial(i){this._terrainLayer&&i&&(this.options.terrain.material?mI(this.options.terrain.material,i):this.options.terrain.material=i,this._terrainLayer.updateMaterial(i))}_initTerrainLayer(){const i=this.getRenderer();i&&i.setToRedraw();const g=this.options.terrain;if(this._terrainLayer){const i=this._terrainLayer,m=i.options;if(g&&m.urlTemplate===g.urlTemplate&&m.spatialReference===g.spatialReference){for(const m in g)"material"===m?i.setMaterial(g[m]):"urlTemplate"!==m&&"spatialReference"!==m&&i.config(m,g[m]);return this}this._removeTerrainLayer()}if(this._resetTerrainSkinLayers(),!g)return this;this._terrainLayer=new TerrainLayer("__terrain_in_group",g),this._updateTerrainSkinLayers();const m=this._terrainLayer;m.on("tileload",this._onTerrainTileLoad,this),this._prepareLayer(m);const _=g.masks;return _&&_.length?m.setMask(_):m.removeMask(),this.fire("terrainlayercreated"),this}queryTerrain(i,g){return this._terrainLayer?this._terrainLayer.queryTerrain(i,g):(g&&(g[0]=null,g[1]=0),[null,0])}queryTerrainAtPoint(i){if(!this._terrainLayer)return null;const g=this._terrainLayer.getRenderer().getAnalysisMeshes();return this._queryRayCast(i,g)}query3DTilesAtPoint(i){const g=this._getLayers().filter((i=>i&&i.isGeo3DTilesLayer));if(!g.length)return null;const m={excludeMasks:!0};for(let _=0;_<g.length;_++){if(!g[_].getRenderer())continue;const b=g[_].identifyAtPoint(i,m);if(b.length)return new pl(b[0].coordinate)}return null}_queryRayCast(i,g){const m=this.getMap(),_=m.getGLRes();m.getContainerPointRay(_E,vE,i);const b=new RayCaster(_E,vE,!1).test(g,m,{count:1}),T=[];b.forEach((i=>{i.coordinates.forEach((i=>{T.push(i.coordinate)}))}));const P=m.pointAtResToCoordinate(new un(_E[0],_E[1]),_,AE);this._meterToGLPoint||(this._meterToGLPoint=m.altitudeToPoint(1,_)),P.z=_E[2]/this._meterToGLPoint;const I=qA(yE,P.x,P.y,P.z);return T.sort(((i,g)=>dy(i.toArray(),I)-dy(g.toArray(),I))),T[0]}queryTerrainByProjCoord(i,g){return this._terrainLayer?this._terrainLayer.queryTerrainByProjCoord(i,g):(g&&(g[0]=null,g[1]=0),[null,0])}_updateTerrainSkinLayers(){if(!this._terrainLayer)return;const i=this.layers,g=[];for(let m=0;m<i.length;m++){if(!i[m])continue;const _=i[m],b=_.getRenderer();if(b.renderTerrainSkin){if(b.deleteTile===mE){g.push(i[m]);continue}_.getTiles=()=>this._terrainLayer&&this._terrainLayer.getSkinTiles(_),b.drawTile=b.drawTileOnTerrain?(...i)=>b.drawTileOnTerrain(...i):mE,b.deleteTile=mE,g.push(i[m])}b.setTerrainHelper&&b.setTerrainHelper(this._terrainLayer)}this._terrainLayer.setSkinLayers(g)}_resetSkinLayer(i){if(!function(i){if(!i)return!1;const g=i.getRenderer();if(!g)return!1;return!!g.renderTerrainSkin}(i))return;const g=i.getRenderer();g&&(g.setTerrainHelper&&g.setTerrainHelper(null),g.clear&&g.clear(),delete g.drawTile,delete g.deleteTile),delete i.getTiles}_resetTerrainSkinLayers(){const i=this.layers;for(let g=0;g<i.length;g++)i[g]&&this._resetSkinLayer(i[g])}_onTerrainTileLoad(){const i=this.getRenderer();i&&i.setToRedraw()}_removeTerrainLayer(){if(this._terrainLayer){const i=this._terrainLayer;i.off("tileload",this._onTerrainTileLoad,this),this._unbindChildListeners(i),this._terrainLayer._doRemove(),delete this._terrainLayer,this.fire("terrainlayerremoved")}}getTerrainLayer(){return this._terrainLayer}_bindMap(...i){if(this.options.single){const g=i[0].getLayers();for(let i=0;i<g.length;i++)if(g[i]instanceof GroupGLLayer)throw new Error("Only one GroupGLLayer is allowed in a map instance. Set options.single to false if you want to add two or more GroupGLLayers.")}return super._bindMap(...i)}fire(...i){if("layerload"===i[0]){const i=this._getLayers();for(const g of i){const i=g.getRenderer();i&&i.isRenderComplete()&&g.fire("layerload")}}super.fire(...i)}}function xE(){}function bE(i,g){const m=i.getZIndex()-g.getZIndex();return 0===m?i.__group_gl_order-g.__group_gl_order:m}var wE;let TE;function SE(i,g){const{cubePixels:m,width:_,height:b}=i,T=m.map((i=>i.buffer));(TE||(TE=new Um.Actor("maplight")),TE).send({cubePixels:T,width:_,height:b},T,((i,m)=>{i?console.error(i):g(m.shList)}))}GroupGLLayer.mergeOptions({renderer:"gl",antialias:!0,extensions:[],single:!0,onlyWebGL1:!1,optionalExtensions:["ANGLE_instanced_arrays","OES_element_index_uint","OES_standard_derivatives","OES_vertex_array_object","OES_texture_half_float","OES_texture_half_float_linear","OES_texture_float","OES_texture_float_linear","WEBGL_depth_texture","EXT_shader_texture_lod","EXT_frag_depth","EXT_texture_filter_anisotropic","WEBGL_compressed_texture_astc","WEBGL_compressed_texture_etc","WEBGL_compressed_texture_etc1","WEBGL_compressed_texture_pvrtc","WEBGL_compressed_texture_s3tc","WEBGL_compressed_texture_s3tc_srgb"],forceRenderOnZooming:!0,forceRenderOnMoving:!0,forceRenderOnRotating:!0,viewMoveThreshold:100,geometryEvents:!0,multiSamples:4,forceRedrawPerFrame:!1}),GroupGLLayer.registerJSONType("GroupGLLayer"),GroupGLLayer.registerRenderer("gl",GroupGLLayerRenderer),GroupGLLayer.registerRenderer("gpu",GroupGLLayerRenderer),GroupGLLayer.registerRenderer("canvas",null),function(i){i[i.AMBIENT=0]="AMBIENT",i[i.REALISTIC=1]="REALISTIC"}(wE||(wE={}));class LightManager{constructor(i){this._map=i,this._loader=new ResourceLoader,this.updateTime=Po.now()}getDirectionalLight(){return this._config&&this._config.directional||{}}getAmbientLight(){return this._config&&this._config.ambient||{}}getAmbientResource(){return this._iblMaps}setConfig(i){const g=this._config;this._urlModifier=i.urlModifier,this._config=JSON.parse(JSON.stringify(i));let m=!1;if(i&&i.ambient&&i.ambient.resource){if(!(g&&g.ambient&&function(i,g){if(!i.resource)return!1;if(i.resource.url!==g.resource.url)return!1;return!0}(g.ambient,i.ambient)))return void this._initAmbientResources();if(this._iblMaps){const _=g.ambient&&g.ambient.resource,b=i.ambient.resource;b&&b.prefilterCubeSize!==_&&_.prefilterCubeSize&&this._onHDRLoaded(),m=!0,i.ambient.resource.sh&&(this._iblMaps.sh=i.ambient.resource.sh)}}else this._disposeCubeLight(),m=g&&g.ambient&&g.ambient.resource;this._map.fire("updatelights",{ambientUpdate:m})}_tryToGetREGLContext(i){const g=i.getLayers();for(let i=0;i<g.length;i++){const m=g[i]&&g[i].getRenderer();if(m&&m.regl)return m.regl}const m=document.createElement("canvas"),_=Wm({canvas:m,attributes:{depth:!1,stencil:!1,alpha:!1},optionalExtensions:["OES_standard_derivatives","OES_texture_half_float","OES_texture_half_float_linear","OES_texture_float","OES_texture_float_linear"]});return _._temp=!0,_}_initAmbientResources(){const i=this._config.ambient.resource,g=i&&i.url;if(!g)return;const m=[];let _=0,b=0;const T=()=>{b++,b>=_&&this._onSkyboxLoaded(m)},P=function(){throw new Error(`skybox image with url(${this.src}) failed to load, please check the image's url.`)},I=this._urlModifier;if(g.top||g.nx){const{front:b,back:H,right:W,left:q,top:$,bottom:ye}=g,{nx:Re,ny:Be,px:Ge,py:je,nz:Xe,pz:Ze}=g;let Ye;Ye=b?[q,W,H,b,$,ye]:[Re,Ge,Xe,Ze,je,Be],_=Ye.length;const Qe=i.crossOrigin;for(let i=0;i<_;i++){const g=new Image;g.onload=T,g.onerror=P,Po.isNil(Qe)||(g.crossOrigin=Qe),g.src=I&&I(Ye[i])||Ye[i],m[i]=g}}else{const g={url:i.url,arrayBuffer:!0,hdr:!0,flipY:!0};this._loader.setURLModifier(I),this._hdr=new Texture2D(g,this._loader),this._hdr.once("complete",(()=>{this._onHDRLoaded()})),this._hdr.once("error",(()=>{this._onHDRError()}))}}dispose(){this._disposeCubeLight()}_onHDRLoaded(){this._hdr&&this._createIBLMaps(this._hdr).then((i=>{this._iblMaps=i,this._map.fire("updatelights",{ambientUpdate:!0}),this.getAmbientLight().debug&&console.log("ambientLight hdr loadend")}))}_onHDRError(){this._map.fire("hdrerror")}_onSkyboxLoaded(i){this._createIBLMaps(i).then((i=>{this._iblMaps=i,this._map.fire("updatelights",{ambientUpdate:!0}),this.getAmbientLight().debug&&console.log("ambientLight skybox loadend")}))}_createIBLMaps(i){return this.updateTime=Po.now(),new Promise((g=>{const m=this._config.ambient.resource,_=m.prefilterCubeSize||512,b=this._tryToGetREGLContext(this._map),T=m.asynchronous;xP.PBRHelper.createIBLMapsAsync(b,{updateTime:this.updateTime,asynchronous:T,envTexture:Array.isArray(i)?i:i.getREGLTexture(b),ignoreSH:!!m.sh,envCubeSize:_,prefilterCubeSize:_,environmentExposure:this._config.ambient.exposure,format:"array",projectEnvironmentMapCPU:T?SE:null}).then((i=>{if(i.updateTime===this.updateTime){if(m.sh&&(i.sh=m.sh,Array.isArray(i.sh[0]))){const g=i.sh,m=[];for(let i=0;i<g.length;i++)m.push(...g[i]);i.sh=m}b._temp&&(delete this._hdr,b.destroy()),g(i)}}))}))}_disposeCubeLight(){this._hdr&&(this._hdr.dispose(),delete this._hdr),delete this._iblMaps}}let ME,CE,PE,IE,kE;Uu.include({setLights(i){return this.options.lights=i,this._initLightManager(),this},getLights(){return this.options.lights},_initLightManager(){this._lightManager||(this._lightManager=new LightManager(this)),this._lightManager.setConfig(this.getLights())},getLightManager(){return this._lightManager?this._lightManager:null}}),Uu.addOnLoadHook((function(){this.options.lights&&this._initLightManager()}));const OE={color:[0,0,0,0]},EE={enable:!1};Uu.include({setPostProcessConfig(i){return this.options.postProcessConfig=i,this},getPostProcessConfig(){return this.options.postProcessConfig}});const RE=Om.MapCanvasRenderer.prototype.drawLayerCanvas;Om.MapCanvasRenderer.prototype.drawLayerCanvas=function(){const i=RE.apply(this,arguments);return i&&function(i,g){const m=i.map.getPostProcessConfig();if(!m||!m.enable)return;ME||(_=g.width,b=g.height,ME=document.createElement("canvas",_,b),CE=Wm({canvas:ME,attributes:{depth:!1,stencil:!1,alpha:!0,antialias:!1,premultipliedAlpha:!1}}),PE=CE.texture({mag:"linear",min:"linear",mipmap:!1,flipY:!0,width:_,height:b}),IE=CE.texture());var _,b;ME.width===g.width&&ME.height===g.height||(ME.width=g.width,ME.height=g.height);CE.clear(OE);const T=m.filmicGrain||EE;void 0===T.enable&&(T.enable=!0);const P=m.vignette||EE;void 0===P.enable&&(P.enable=!0);const I=m.colorLUT||EE;void 0===I.enable&&(I.enable=!0);i._postProcessContext||(i._postProcessContext={});const H=i._postProcessContext;if(I.enable){const i=I.lut;if(!H.lutTexture||H.lutTexture.url!==i){const g=new Image;g.onload=function(){const m={data:g,min:"linear",mag:"linear"},_=H.lutTexture?H.lutTexture.texture(m):CE.texture(m);H.lutTexture={url:i,texture:_}},g.src=i}}const W={enableGrain:+!!T.enable,grainFactor:void 0===T.factor?.15:T.factor,timeGrain:performance.now(),enableVignette:+!!P.enable,lensRadius:P.lensRadius||[.8,.25],frameMod:1,enableLut:+!!I.enable,lookupTable:H.lutTexture?H.lutTexture.texture:IE};kE||(kE=new PostProcess(CE));kE.postprocess(null,W,PE({width:ME.width,height:ME.height,data:g,flipY:!0,mag:"linear",min:"linear",mipmap:!1})),i.context.drawImage(ME,0,0,ME.width,ME.height)}(this,this.canvas),i};const LE=Om.MapCanvasRenderer.prototype.renderFrame;Om.MapCanvasRenderer.prototype.renderFrame=function(){const i=LE.apply(this,arguments),g=this.map.getPostProcessConfig(),m=g&&g.filmicGrain;return!m||void 0!==m.enable&&!0!==m.enable||this.setToRedraw(),i};class MapGLRenderer extends Om.MapAbstractRenderer{clearCanvas(){this.regl&&this.regl.clear({color:[0,0,0,0]})}clearLayerCanvasContext(i){if(!this.regl)return;this.regl.clear({depth:1,stencil:0});i.getRenderer().clearContext()}createContext(){const i=this.map,{preserveDrawingBuffer:g,onlyWebGL1:m,extensions:_,optionalExtensions:b}=i.options,T=i.getRenderer().canvas,{gl:P,regl:I,reglGL:H,context:W}=Mk(T,g,m,_,b);return this.gl=P,this.regl=I,this.reglGL=H,this.device=I,this.context=W,Promise.resolve()}_initGL(){const i=this.map,g=this.gl,m=i.options.extensions;m&&m.forEach((i=>{g.getExtension(i)}));const _=i.options.optionalExtensions;_&&_.forEach((i=>{g.getExtension(i)}))}getContextInstance(){return this.gl.wrap()}isWebGL(){return!0}isWebGPU(){return!1}}function DE(i,g,m,_){return new(m||(m=Promise))((function(g,b){function T(i){try{I(_.next(i))}catch(i){b(i)}}function P(i){try{I(_.throw(i))}catch(i){b(i)}}function I(i){var _;i.done?g(i.value):(_=i.value,_ instanceof m?_:new m((function(i){i(_)}))).then(T,P)}I((_=_.apply(i,[])).next())}))}let FE,NE;function HE(){return DE(this,0,void 0,(function*(){var i;return NE||(FE=yield null===(i=navigator.gpu)||void 0===i?void 0:i.requestAdapter(),NE=yield null==FE?void 0:FE.requestDevice({}),{gpuDevice:NE,gpuAdapter:FE})}))}Uu.registerRenderer("gl",MapGLRenderer),"function"==typeof SuppressedError&&SuppressedError;class MapGPURenderer extends Om.MapAbstractRenderer{drawLayers(i,g){const m=super.drawLayers(i,g);return m&&this.device.submit(),m}clearCanvas(){this.device&&this.device.clear({color:[0,0,0,0]})}clearLayerCanvasContext(i){this.device&&this.device.clear({depth:1,stencil:0})}isWebGL(){return!1}isWebGPU(){return!0}createContext(){return DE(this,0,void 0,(function*(){const{gpuDevice:i,gpuAdapter:g}=yield HE(),m=this.canvas.getContext("webgpu");this.device=new GraphicsDevice(i,m,g),this.context={context:m,device:this.device,getImageData:(i,g,m,_)=>{const b=new Uint8Array(m*_*4);return this.device.read({x:i,y:this.canvas.height-g,width:m,height:_,data:b}),new ImageData(new Uint8ClampedArray(b.buffer),m,_)}}}))}}Uu.registerRenderer("gpu",MapGPURenderer);const BE=[];function zE(i){i.properties.showOnlyTimestamp&&(delete i.properties.showOnlyTimestamp,UE(i))}function VE(i,g){const m=i.geometry.properties;m.oldElementsBeforeHighlight||(m.oldElementsBeforeHighlight=i.geometry.elements),m.elements&&(m.oldElementsArrBeforeHighlight||(m.oldElementsArrBeforeHighlight=m.elements),m.elements=g)}function UE(i){const g=i.geometry.properties.oldElementsBeforeHighlight;g&&i.geometry.elements!==g&&(i.geometry.deleteElements(),i.geometry.setElements(i.geometry.properties.oldElementsBeforeHighlight),i.geometry.properties.oldElementsArrBeforeHighlight&&(i.geometry.properties.elements=i.geometry.properties.oldElementsArrBeforeHighlight,delete i.geometry.properties.oldElementsArrBeforeHighlight),delete i.geometry.properties.hasInvisible,delete i.geometry.properties.oldElementsBeforeHighlight)}function GE(i){if(!i.properties.highlightTimestamp)return;const g=i.defines;delete g.HAS_HIGHLIGHT_COLOR,delete g.HAS_HIGHLIGHT_OPACITY,i.setDefines(g),delete i.properties.highlightTimestamp,UE(i),jE(i)}function jE(i){if(!i)return;const{hlBloomMesh:g}=i.properties;if(g){const m=g.geometry;m.elements&&m.elements.destroy&&m.deleteElements(),g.dispose(),delete i.properties.hlBloomMesh}}var WE=Object.freeze({__proto__:null,clearHighlight:GE,clearShowOnly:zE,deleteHighlightBloomMesh:jE,highlightMesh:function(i,g,m,_,b){const{highlightTimestamp:T}=g.properties;if(!m)return void(T&&GE(g));if(_===T)return;const P=g instanceof InstancedMesh,I=P?g.instanceCount:g.geometry.getVertexCount();let{aHighlightColor:H,aHighlightOpacity:W}=g.geometry.properties;H&&H.fill(0),W&&W.fill(255);let q=!1,$=!1;const ye=m.keys();let Re=null,Be=null;for(const i of ye)if(b.has(i)){const _=m.get(i),{color:T,bloom:P,visible:ye,nodeIndex:Ge}=_;if(!AI(Ge)&&Ge!==g.properties.nodeIndex)continue;let je,{opacity:Xe}=_;if(T&&(q||(H||(H=new Uint8Array(4*I)),q=!0),je=MI(BE,T)),Xe=AI(Xe)?1:Xe,Xe<1&&($||(W||(W=new Uint8Array(I),W.fill(255)),$=!0)),!1===ye&&(Be||(Be=new Set),Be.add(i)),je||Xe<1||P){const g=b.get(i);if(g)for(let i=0;i<g.length;i++){const m=g[i];je&&wy(H.subarray(4*m,4*m+4),...je),Xe<1&&(W[m]=255*Xe),P&&(Re||(Re=[]),Re.push(m))}}}const Ge=g.geometry,je=g.defines;if(q?(P?(g.updateInstancedData("aHighlightColor",H),g.generateInstancedBuffers(i)):(Ge.data.aHighlightColor?Ge.updateData("aHighlightColor",H):(Ge.data.aHighlightColor=H,Ge.generateBuffers(i)),Ge.properties.aHighlightColor=H),je.HAS_HIGHLIGHT_COLOR=1):je.HAS_HIGHLIGHT_COLOR&&(P?(g.updateInstancedData("aHighlightColor",H),g.generateInstancedBuffers(i)):Ge.updateData("aHighlightColor",H),delete je.HAS_HIGHLIGHT_COLOR),$?(P?(g.updateInstancedData("aHighlightOpacity",W),g.generateInstancedBuffers(i)):(Ge.data.aHighlightOpacity?Ge.updateData("aHighlightOpacity",W):(Ge.data.aHighlightOpacity=W,Ge.generateBuffers(i)),Ge.properties.aHighlightOpacity=W),je.HAS_HIGHLIGHT_OPACITY=1):je.HAS_HIGHLIGHT_OPACITY&&(P?(g.updateInstancedData("aHighlightOpacity",W),g.generateInstancedBuffers(i)):Ge.updateData("aHighlightOpacity",W),delete je.HAS_HIGHLIGHT_OPACITY),Be&&Be.size>0){let m=[];b.forEach(((i,g)=>{Be.has(g)||wI(m,i)})),Ge.properties.hasInvisible=!0,VE(g,m);const _={data:m,primitive:Ge.getPrimitive()};Ge.elements!==Ge.properties.oldElementsBeforeHighlight&&Ge.elements.destroy&&Ge.deleteElements(),m=i.elements(_),Ge.setElements(m),Ge.generateBuffers(i)}else Ge.properties.hasInvisible&&UE(g);g.setDefines(je),g.properties.highlightTimestamp=_;let Xe=g.properties.hlBloomMesh;if(Re&&Re.length){if(Xe){const i=gA(Xe.localTransform,g.localTransform),m=gA(Xe.positionMatrix,g.positionMatrix);Xe.setLocalTransform(i),Xe.setPositionMatrix(m),g.properties.hlBloomMesh.geometry.setElements(Re)}else{const m=new Geometry(Ge.data,Re,0,Ge.desc);m.generateBuffers(i);Xe=new Mesh(m,g.material,g.config);const _=g.uniforms;for(const i in _)Object.defineProperty(Xe.uniforms,i,{enumerable:!0,get:function(){return g.getUniform(i)}});const b=mI({},g.defines);b.HAS_BLOOM=1;const T=gA([],g.localTransform),P=gA([],g.positionMatrix);Xe.setLocalTransform(T),Xe.setPositionMatrix(P),mI(Xe.properties,g.properties),mI(m.properties,Ge.properties),Xe.setDefines(b),Xe.bloom=1}g.properties.hlBloomMesh=Xe}else Xe&&jE(g)},showOnly:function(i,g,m,_,b){const{showOnlyTimestamp:T}=g.properties;if(!m)return void(T&&zE(g));if(_===T)return;g.properties.showOnlyTimestamp=_;const P=m.keys(),I=[];for(const i of P){if(!b.has(i))continue;const g=b.get(i);g&&wI(I,g)}VE(g,I),g.geometry.elements!==g.geometry.properties.oldElementsBeforeHighlight&&g.geometry.elements.destroy&&g.geometry.deleteElements();const H={data:I,primitive:g.geometry.getPrimitive()};g.geometry.setElements(i.elements(H)),g.geometry.generateBuffers(i)}});const qE=function(i){return class extends i{constructor(){super(...arguments),this._textures=[]}getTexture(){this._textures||(this._textures=[]);const i=this._textures;return i&&i.length>0?i.pop():null}saveTexture(i){this._textures.push(i)}disposeTexturePool(){const i=this._textures;for(let g=0;g<i.length;g++)i[g].dispose();this._textures=[]}}},XE=new un(0,0),ZE=[1,1,1,1];function $E(i,g,m,_,b,T){const P=m.xmax-m.xmin,I=m.ymax-m.ymin,H=XE.set(m.xmin-(_=_||[0,0])[0],m.ymax-_[1]),W=H.x*b,q=H.y*b,$={data:g,mag:"nearest",mipmap:!0,premultiplyAlpha:!0};let ye=this.getTexture();ye?ye.setConfig($):ye=new Texture2D($),T=mI(T||{},{opacity:1,debugLine:0,alphaTest:0,baseColor:ZE,baseColorTexture:ye});const Re=new Material(T),Be=new Mesh(i,Re);Be.properties.minFilter=FS;const Ge=mA([]);return vA(Ge,Ge,[W||0,q||0,0]),xA(Ge,Ge,[b*P,b*I,1]),Be.localTransform=Ge,Be}function YE(i,g,m){const _=function(i){const g=i.getZoom(),m=i.isMoving()&&i.getRenderer().isViewChanged();let _;_=m?HS:i.getBearing()||i.getPitch()||!Number.isInteger(g)?NS:FS;return _}(g);if(i.properties.minFilter!==_){i.material.get("baseColorTexture").setMinFilter(_),i.properties.minFilter=_}const b=g.getDevicePixelRatio(),T=g.getResolution()!==m;let P=FS;if((1!==b||T)&&(P=NS),i.properties.magFilter!==P){i.material.get("baseColorTexture").setMagFilter(P),i.properties.magFilter=P}}const{TileLayerRendererable:QE,LayerAbstractRenderer:JE}=Om,KE=new Int16Array([0,0,0,-1,1,0,1,-1]),eR=new Uint16Array([0,0,0,1,1,0,1,1]),tR={properties:{}},nR=new un(20,20);class TileLayerGLRenderer2 extends(qE(Ck(QE(JE)))){constructor(i){super(i),this.init()}onResize(i){super.onResize(i),this.resizeCanvas()}onDrawTileStart(i,g){if(!this._tileGeometry){this._shader=new ImageShader({extraCommandProps:this._getCommandProps()}),this._tileGeometry=new Geometry({aPosition:KE,aTexCoord:eR},4,0,{positionSize:2,primitive:"triangle strip"});const{regl:i,device:g}=this.context;this._tileGeometry.generateBuffers(i||g),this._tileMeshes=[],this._tileScene=new Scene(this._tileMeshes),this._renderer=new Renderer(i||g)}this._tileMeshes.length=0,this.clearStencil(g)}clearStencil(i){let g;i&&i.renderTarget&&(g=i.renderTarget.fbo);const{regl:m,device:_}=this.context;(m||_).clear({stencil:255,fbo:g})}onDrawTileEnd(i,g){const m=this._getUniformValues();let _;g&&g.renderTarget&&(_=g.renderTarget.fbo),this._tileScene.setMeshes(this._tileMeshes),this._renderer.render(this._shader,m,this._tileScene,_)}_getUniformValues(){return{projViewMatrix:this.getMap().projViewMatrix}}consumeTile(i,g){let m=i.mesh;return m||(m=this._createTileMesh(g,i),i.mesh=m),super.consumeTile(i,g)}drawTile(i,g,m){if(m&&m.sceneFilter&&!m.sceneFilter(tR))return;const _=this.getMap();if(!i||!_||!g)return;let b=g.mesh;b||(b=this._createTileMesh(i,g),g.mesh=b);const T=b.getDefines();if(this.layer.options.debug){let m=b.material.get("debugTexture");m||(m=this._createDebugTexture(i,g.width,g.height),b.material.set("debugTexture",m),g.debugTexture=m),T.HAS_DEBUG||b.setDefines({HAS_DEBUG:1})}else T.HAS_DEBUG&&b.setDefines({});YE(b,_,i.res);let P=this.getTileOpacity(g,i),I=this.layer.options.opacity;AI(I)&&(I=1),P*=I,b.material.set("opacity",P),b.setUniform("isCurrentTiles",+!!this.drawingCurrentTiles),this._tileMeshes.push(b),this.getTileFadingOpacity(g)<1&&this.setToRedraw()}_createDebugTexture(i,g,m){const _=this.getDebugInfo(i.id),b=this.getMap().getDevicePixelRatio()>1?2:1,T=this._debugInfoCanvas=document.createElement("canvas");T.width=g*b,T.height=m*b;const P=T.getContext("2d");P.font="20px monospace",P.scale(b,b);const I=this.layer.options.debugOutline;P.fillStyle=I,P.strokeStyle=I,P.lineWidth=3,P.fillText(_,20,m-12),P.beginPath(),P.moveTo(0,0),P.lineTo(g,0),P.lineTo(g,m),P.lineTo(0,m),P.lineTo(0,0),P.stroke();const H={data:T,width:T.width,height:T.height};let W=this.getTexture();W?W.setConfig(H):W=new Texture2D(H);const{device:q,regl:$}=this.context;return W.getREGLTexture(q||$),W}_createTileMesh(i,g){const m=this.getMap(),_=i.res/m.getGLRes(),b=$E.call(this,this._tileGeometry,g,i.extent2d,i.offset,_,{zoom:i.z}),T=b.material.get("baseColorTexture");return g.texture=T,b}loadTileImage(i,g){const m=this.layer.options.crossOrigin;i.crossOrigin=null!==m?m:"",i.src=g}deleteTile(i){if(!i||!i.image)return super.deleteTile(i);const g=i.image;g.texture&&this.saveTexture(g.texture),g.debugTexture&&this.saveTexture(g.debugTexture),delete g.texture,delete g.debugTexture;const m=g.mesh;return m&&(m.material.set("baseColorTexture",null,!1),m.material.set("debugTexture",null,!1),m.material.dispose(),m.dispose(),delete g.mesh),super.deleteTile(i)}onRemove(){this._tileGeometry&&(this._shader.dispose(),this._tileGeometry.dispose(),delete this._shader,delete this._tileGeometry,delete this._renderer,delete this._tileScene,delete this._tileMeshes),this.disposeTexturePool(),super.onRemove()}_getCommandProps(){const i=this.getMap().getRenderer().canvas,g={units:0,factor:0};return{stencil:{enable:!0,func:{cmp:"<=",ref:(i,g)=>Math.abs(this.getCurrentTileZoom()-g.zoom)},op:{fail:"keep",zfail:"keep",zpass:"replace"}},depth:{enable:!0,func:"<=",mask:()=>!!this.layer.options.depthMask},blend:{enable:!0,func:{src:1,dst:"one minus src alpha"},equation:"add"},viewport:{x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1},polygonOffset:{enable:!0,offset:(i,m)=>{let _=this.layer.getPolygonOffset();return _=m.isCurrentTiles?_:_+1,g.factor=_,g.units=_,g}}}}renderTerrainSkin(i,g,m){const _=this.layer.getTileSize().width,b=g.options.debug;for(let i=0;i<m.length;i++){const{tile:g,texture:T}=m[i];if(!g.image)continue;const P=document.createElement("canvas");m[i].canvas=P,P.width=_,P.height=_;const I=P.getContext("2d");if(I.drawImage(g.image,0,0),b){const{x:i,y:m,z:b}=g.info;rR(I,`${i}/${m}/${b}`,"yellow",1,0,0,_,_,-18)}const H={data:P,width:_,height:_,flipY:!0,min:"linear mipmap linear",mag:"linear"};T.update?T.update(H):T(H)}}createTerrainTexture(i){const g=this.layer.getTileSize().width;return i.texture({width:g,height:g,flipY:!0,min:"linear mipmap linear",mag:"linear",depthStencil:!1,depth:!1,stencil:!1})}deleteTerrainTexture(i){i.destroy()}clear(){this.clearTileCaches(),super.clear()}}function rR(i,g,m,_,b,T,P,I,H=0){i.font="20px monospace",i.fillStyle=m,nR.y=I-30,i.globalAlpha=1,i.fillText(g,nR.x+b,nR.y+T+H),i.globalAlpha=.6,i.strokeStyle=m,i.lineWidth=_,i.beginPath(),i.moveTo(b,T),i.lineTo(b+P,T),i.lineTo(b+P,T+I),i.lineTo(b,T+I),i.lineTo(b,T),i.stroke(),i.globalAlpha=1}Up.registerRenderer("gl",TileLayerGLRenderer2),Up.registerRenderer("gpu",TileLayerGLRenderer2);const{LayerAbstractRenderer:iR,ImageLayerRenderable:oR}=Om,sR=new Int16Array([0,0,0,-1,1,0,1,-1]),aR=new Uint16Array([0,0,0,1,1,0,1,1]);class ImageLayerGLRenderer2 extends(qE(Ck(oR(iR)))){constructor(){super(...arguments),this._imageMeshes=[]}isDrawable(){return!0}drawImage(i,g,m){let _=i.mesh;_||(_=this._createImageMesh(i,g),i.mesh=_);const b=this.getMap();if(YE(_,b,b.getGLRes()),b.getRenderer().canvas===this.canvas){let i=this.layer.options.opacity;AI(i)&&(i=1),m*=i}_.material.set("opacity",m),this._imageMeshes.push(_)}_createImageMesh(i,g){const m=$E.call(this,this._imageGeometry,i,g,null,1),_=m.material.get("baseColorTexture");return i.texture=_,m}drawImages(i,g){this._imageMeshes.length=0,super.drawImages(i,g);const m=this._getUniformValues();let _;g&&g.renderTarget&&(_=g.renderTarget.fbo),this._imageScene.setMeshes(this._imageMeshes),this._renderer.render(this._shader,m,this._imageScene,_)}_getUniformValues(){return{projViewMatrix:this.getMap().projViewMatrix}}retireImage(i){const g=i.texture;if(g&&(this.saveTexture(g),delete i.texture),i.mesh){const g=i.mesh;g.material.set("baseColorTexture",null,!1),g.material.dispose(),i.mesh.dispose()}return delete i.mesh,super.retireImage(i)}initContext(){this._shader=new ImageShader({extraCommandProps:this._getCommandProps()}),this._imageGeometry=new Geometry({aPosition:sR,aTexCoord:aR},4,0,{positionSize:2,primitive:"triangle strip"});const{regl:i,device:g}=this.context;this._imageGeometry.generateBuffers(i||g),this._imageMeshes=[],this._imageScene=new Scene(this._imageMeshes),this._renderer=new Renderer(i||g)}_getCommandProps(){const i=this.getMap().getRenderer().canvas;return{viewport:{x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1},depth:{enable:!0,func:this.layer.options.depthFunc,mask:!!this.layer.options.depthMask},blend:{enable:!0,func:{src:1,dst:"one minus src alpha"},equation:"add"}}}onRemove(){return this.disposeTexturePool(),super.onRemove()}}yg.registerRenderer("gl",ImageLayerGLRenderer2),yg.registerRenderer("gpu",ImageLayerGLRenderer2);const lR=[0,0,0,0];class HeatmapProcess{constructor(i,g,m,_,b,T){this.renderer=new Renderer(i),this.sceneConfig=g,this._layer=m,this._colorStops=_,this._stencil=b,this._polygonOffset=T||{factor:0,units:0},this._init(),this._outputSize=[]}render(i,g,m){this._check();const _=this._layer.getMap();this.renderer.device.clear({color:lR,depth:1,stencil:255,framebuffer:this._heatmapFBO}),this.renderer.render(this._heatmapShader,g,i,this._heatmapFBO);const b=this._layer.getRenderer().canvas;this._outputSize[0]=b.width,this._outputSize[1]=b.height;const T=mI({colorRamp:this._colorRampTex,inputTexture:this._heatmapFBO,projViewMatrix:_.projViewMatrix,textureOutputSize:this._outputSize},g);return this._transformGround(),this.renderer.render(this._displayShader,T,this._groundScene,m)}dispose(){this._heatmapShader&&(this._heatmapShader.dispose(),delete this._heatmapShader),this._displayShader&&(this._displayShader.dispose(),delete this._displayShader),this._ground&&(this._ground.geometry.dispose(),this._ground.dispose(),delete this._ground,delete this._groundScene),this._heatmapFBO&&(this._heatmapFBO.destroy(),delete this._heatmapFBO)}_createColorRamp(){const i=this._colorStops;let g=this._rampCanvas,m=this._rampCtx;m?m.clearRect(0,0,256,1):(g=this._rampCanvas=document.createElement("canvas"),g.width=256,g.height=1,m=this._rampCtx=g.getContext("2d"));const _=m.createLinearGradient(0,0,256,1);for(let g=0;g<i.length;g++)_.addColorStop(i[g][0],i[g][1]);m.fillStyle=_,m.fillRect(0,0,256,1),this._colorRampTex&&this._colorRampTex.destroy();this._colorRampTex=this.renderer.device.texture({width:256,height:1,data:g,min:"linear",mag:"linear",premultiplyAlpha:!0})}_check(){const i=this._layer.getRenderer().canvas,g=Math.ceil(i.width/4),m=Math.ceil(i.height/4),_=this._heatmapFBO;_.width===g&&_.height===m||_.resize(g,m)}_init(){this._createColorRamp(),this._createShader(),this._createHeatmapTex(),this._createGround()}_createGround(){const i=new Plane;i.generateBuffers(this.renderer.device),this._ground=new Mesh(i),this._groundScene=new Scene([this._ground])}_transformGround(){const i=this._layer.getMap(),g=GroundPainter.getGroundTransform(this._ground.localTransform,i);this._ground.setLocalTransform(g)}_createHeatmapTex(){const i=this._layer.getRenderer().canvas,g=this.renderer.device,m=g.hasExtension("OES_texture_half_float")?"half float":"float",_=Math.ceil(i.width/4),b=Math.ceil(i.height/4),T=g.texture({width:_,height:b,type:m,min:"linear",mag:"linear",format:"rgba"});this._heatmapFBO=g.framebuffer({width:_,height:b,color:[T]})}_createShader(){const i=this._layer.getRenderer().canvas,g=this.sceneConfig.depthRange,m={viewport:{x:0,y:0,width:()=>i?Math.ceil(i.width/4):1,height:()=>i?Math.ceil(i.height/4):1},depth:{enable:!0,func:"always"}};this._stencil&&(m.stencil=this._stencil),this._heatmapShader=new HeatmapShader({extraCommandProps:m}),this._displayShader=new HeatmapDisplayShader({x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1},{extraCommandProps:{depth:{enable:!0,range:g||[0,1],func:"<="},polygonOffset:{enable:!0,offset:this._polygonOffset}}})}}class ClipMask extends Mask{constructor(i,g){super(i,g)}_createMesh(i){const g=this._createGeometry(i),m=new Mesh(g);return this._setDefines(m),this._setLocalTransform(m),m}_updateUniforms(i,g,m){const _=this._getMaskMode();i.setUniform("maskMode",_);const b=this._getMaskColor();if(i.setUniform("maskColor",b),yI(g)){const _=this._getHeightRange();_[0]=(_[0]-m)*g,_[1]=(_[1]-m)*g,i.setUniform("heightRange",_)}}setHeightRange(i){this.options.heightRange=i,this._fireEvent("heightrangechange")}getHeightRange(){return this.options.heightRange}_getHeightRange(){const i=[0,0];return this.options.heightRange&&(i[0]=this._altitudeToPoint(this.options.heightRange[0]),i[1]=this._altitudeToPoint(this.options.heightRange[1])),i}_setDefines(i){const g=i.getDefines();g.HAS_MASK_COLOR=1,i.setDefines(g)}}class ClipOutsideMask extends ClipMask{constructor(i,g){super(i,g),this._mode="clip-outside"}}class FlatMask extends Mask{constructor(i,g){super(i,g)}setFlatheight(i){this.options.flatHeight=i,this._fireEvent("flatheightchange")}_createMesh(i){const g=this._createGeometry(i),m=new Mesh(g);return this._setDefines(m),this._setLocalTransform(m),m}_updateUniforms(i){const g=this._getMaskMode();i.setUniform("maskMode",g);const m=this._getMaskColor();i.setUniform("maskColor",m);const _=this._altitudeToPoint(this.options.flatHeight||0);i.setUniform("flatHeight",_)}_setDefines(i){const g=i.getDefines();g.HAS_MASK_FLAT=1,i.setDefines(g)}_getHeightRange(){const i=[0,this.options.flatHeight];return i[1]=this._altitudeToPoint(i[1]),i}}const hR=new un(0,0),cR=new un(0,0),uR=new un(0,0),fR=new un(0,0);class BoxClipMask extends ClipMask{constructor(i,g){super([],g),this._position=i}setPosition(i){this._position=i,this._updateCoordinates()}getPosition(){return this._position}setWidth(i){this.options.width=i,this._updateCoordinates()}setLength(i){this.options.length=i,this._updateCoordinates()}setHeight(i){this.options.height=i,this._updateCoordinates()}setRotation(i){this.options.rotation=i,this._updateCoordinates()}_updateCoordinates(){const i=this.getLayer();if(!i)return;const g=i.getMap();if(g){const{length:i,width:m,height:_}=this.options,b=this._position,T=this.options.rotation||0,{coordinates:P,heightRange:I}=this._generateCoordinates(g,b,i,m,_,T);this.setCoordinates(P),this.setHeightRange(I)}}_generateCoordinates(i,g,m,_,b,T){const P=i.getGLRes(),I=i.distanceToPointAtRes(_/2,0,P,hR),H=i.distanceToPointAtRes(0,m/2,P,cR),W=i.coordinateToPointAtRes(g,P,uR),q=W.x-I.x,$=W.x+I.x,ye=W.y+H.y,Re=W.y-H.y,Be=this._rotatePoint([[q,ye],[$,ye],[$,Re],[q,Re]],W,T);fR.set(Be[0][0],Be[0][1]);const Ge=i.pointAtResToCoordinate(fR,P);fR.set(Be[1][0],Be[1][1]);const je=i.pointAtResToCoordinate(fR,P);fR.set(Be[2][0],Be[2][1]);const Xe=i.pointAtResToCoordinate(fR,P);fR.set(Be[3][0],Be[3][1]);const Ze=i.pointAtResToCoordinate(fR,P),Ye=g.z-b/2;return{coordinates:[[Ge.x,Ge.y,Ye],[je.x,je.y,Ye],[Xe.x,Xe.y,Ye],[Ze.x,Ze.y,Ye],[Ge.x,Ge.y,Ye]],heightRange:[Ye,g.z+b/2]}}_rotatePoint(i,g,m){for(let _=0;_<i.length;_++)Q_(i[_],i[_],[g.x,g.y],m*Math.PI/180);return i}}class Measure3DTool extends ad{constructor(i){super(i),this.on("enable",this._afterEnable,this),this.on("disable",this._afterDisable,this),this._drawCoordinates=[]}addTo(i){return i&&(super.addTo(i),this._map=i,this._addHelperLayer()),this}_addHelperLayer(){this._map.getLayer(Qn+"drawtool").hide()}_afterEnable(){this.on("drawstart",this._msOnDrawStart,this).on("drawvertex",this._msOnDrawVertex,this).on("mousemove",this._msOnMouseMove,this).on("drawend",this._msOnDrawEnd,this)}_afterDisable(){this.off("drawstart",this._msOnDrawStart,this).off("drawvertex",this._msOnDrawVertex,this).off("mousemove",this._msOnMouseMove,this).off("drawend",this._msOnDrawEnd,this)}_getPickedCoordinate(i){const{coordinate:g,containerPoint:m}=i,_=this._map.getLayers((i=>i.queryTerrainAtPoint))[0];if(!_)return g.z=g.z||0,g;const b=_.identify(g,{includeInternals:!1})[0];let T=null;if(b&&b.coordinate?T=new pl(b.coordinate):(g.z=g.z||0,T=g),_.getTerrainLayer()){const i=_.queryTerrainAtPoint(m);return i&&i.z>T.z?i:T}return T}_msOnDrawStart(i){const g=this._getPickedCoordinate(i);g&&(this._first=!0,this._drawCoordinates.push(g),this._addHelperGeometry(g))}_msOnDrawVertex(i){const g=this._getPickedCoordinate(i);g&&(this._first=!0,this._drawCoordinates[this._drawCoordinates.length-1]=g,this._drawVertexMarker())}_msOnMouseMove(i){const g=this._getPickedCoordinate(i);g&&(this._first?this._drawCoordinates.push(g):this._drawCoordinates[this._drawCoordinates.length-1]=g,this._drawVertexMarker(),this._first=!1)}_msOnDrawEnd(i){const g=this._getPickedCoordinate(i);g&&(this._drawCoordinates.push(g),this._drawEnd())}_drawEnd(){this._drawVertexMarker(),this._drawCoordinates=[],this._helperGeometry=null,this._label=null}remove(){this._helperLayer&&this._helperLayer.remove(),this._markerLayer&&this._markerLayer.remove()}clear(){this._helperLayer&&this._helperLayer.clear(),this._markerLayer&&this._markerLayer.clear()}}Measure3DTool.mergeOptions({mode:"LineString",language:"zh-CN",metric:!0,imperial:!1,once:!0,symbol:{lineColor:"#e8542b",lineWidth:2,polygonFill:"#eee",polygonOpacity:.5},vertexSymbol:{markerType:"ellipse",markerFill:"#e8542b",markerLineColor:"#fff",markerLineWidth:2,markerWidth:10,markerHeight:10,markerDy:0},labelSymbol:{boxStyle:{padding:[15,6],verticalAlignment:"top",horizontalAlignment:"left",minWidth:150,minHeight:30,symbol:{markerType:"square",markerFill:"rgb(60, 60, 60)",markerFillOpacity:.8,markerLineColor:"#fff",markerLineWidth:2,textDx:-110}},textSymbol:{textFill:"#fff",textSize:16,textVerticalAlignment:"top"}}});const dR=[["直线距离","垂直高度","水平距离"],["spatial distance","vertical height","horizontal distance"]];const pR="${",gR=`function(t){\n/*!\n     * @maptalks/gltf-loader v0.103.0\n     * LICENSE : UNLICENSED\n     * (c) 2016-2025 maptalks.org\n     */\nvar r,e,i="undefined"!=typeof Float32Array?Float32Array:Array;function n(){var t=new i(3);return i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function s(t,r,e){var n=new i(3);return n[0]=t,n[1]=r,n[2]=e,n}function a(){var t=new i(4);return i!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}Math.hypot||(Math.hypot=function(){for(var t=0,r=arguments.length;r--;)t+=arguments[r]*arguments[r];return Math.sqrt(t)}),n(),r=new i(4),i!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),n(),s(1,0,0),s(0,1,0),a(),a(),e=new i(9),i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1;let o=0;!function(t){t[0]=0,t[1]=0,t[2]=0,t[3]=1}([]),"undefined"!=typeof TextDecoder&&new TextDecoder("utf-8");const h={get:function(t,r={},e){r||(r={});const i=new AbortController,n=i.signal,s=function(t){for(let r=1;r<arguments.length;r++){const e=arguments[r];for(const r in e)t[r]=e[r]}return t}({},r);s.signal=n,s.method||(s.method="GET"),s.referrerPolicy=s.referrerPolicy||"origin","undefined"==typeof window||s.referrer||(s.referrer=window.location.href),e&&(t=e(t));const a=fetch(t,s).then((t=>{const e=this.U(t,r.responseType);return e.message?e:e.then((e=>"arraybuffer"===r.responseType?{data:e,cacheControl:t.headers.get("Cache-Control"),expires:t.headers.get("Expires"),contentType:t.headers.get("Content-Type")}:e)).catch((t=>{if(!t.code||t.code!==DOMException.ABORT_ERR)throw t}))})).catch((t=>{if(!t.code||t.code!==DOMException.ABORT_ERR)throw t}));return a.xhr=i,a},U:(t,r)=>200!==t.status?{status:t.status,statusText:t.statusText,message:\`incorrect http request with status code(${pR}t.status}): ${pR}t.statusText}\`}:"arraybuffer"===r?t.arrayBuffer():"json"===r?t.json():t.text(),getArrayBuffer:(t,r={},e)=>(r||(r={}),r.responseType="arraybuffer",h.get(t,r,e)),getJSON:function(t,r={},e){return r&&r.jsonp?h.jsonp(t):((r=r||{}).responseType="json",h.get(t,r,e))},jsonp:function(t){const r="_maptalks_jsonp_"+o++;t.match(/\\?/)?t+="&callback="+r:t+="?callback="+r;let e=document.createElement("script");return e.type="text/javascript",e.src=t,new Promise((t=>{window[r]=function(i){document.getElementsByTagName("head")[0].removeChild(e),e=null,delete window[r],t(i)},document.getElementsByTagName("head")[0].appendChild(e)}))}};if("undefined"!=typeof TextDecoder&&new TextDecoder("utf-8"),"undefined"!=typeof OffscreenCanvas){let t;try{t=new OffscreenCanvas(2,2).getContext("2d")}catch(i){}}"undefined"!=typeof document&&document.createElement("canvas"),\n/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */function(){function t(t){throw t}var r=void 0,e=!0,i=this;function n(t,e){var n,s=t.split("."),a=i;!(s[0]in a)&&a.execScript&&a.execScript("var "+s[0]);for(;s.length&&(n=s.shift());)s.length||e===r?a=a[n]?a[n]:a[n]={}:a[n]=e}var s="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;function a(r,e){this.index="number"==typeof e?e:0,this.i=0,this.buffer=r instanceof(s?Uint8Array:Array)?r:new(s?Uint8Array:Array)(32768),2*this.buffer.length<=this.index&&t(Error("invalid index")),this.buffer.length<=this.index&&this.f()}a.prototype.f=function(){var t,r=this.buffer,e=r.length,i=new(s?Uint8Array:Array)(e<<1);if(s)i.set(r);else for(t=0;t<e;++t)i[t]=r[t];return this.buffer=i},a.prototype.d=function(t,r,e){var i,n=this.buffer,s=this.index,a=this.i,o=n[s];if(e&&1<r&&(t=8<r?(l[255&t]<<24|l[t>>>8&255]<<16|l[t>>>16&255]<<8|l[t>>>24&255])>>32-r:l[t]>>8-r),8>r+a)o=o<<r|t,a+=r;else for(i=0;i<r;++i)o=o<<1|t>>r-i-1&1,8===++a&&(a=0,n[s++]=l[o],o=0,s===n.length&&(n=this.f()));n[s]=o,this.buffer=n,this.i=a,this.index=s},a.prototype.finish=function(){var t,r=this.buffer,e=this.index;return 0<this.i&&(r[e]<<=8-this.i,r[e]=l[r[e]],e++),s?t=r.subarray(0,e):(r.length=e,t=r),t};var o,h=new(s?Uint8Array:Array)(256);for(o=0;256>o;++o){for(var c=u=o,f=7,u=u>>>1;u;u>>>=1)c<<=1,c|=1&u,--f;h[o]=(c<<f&255)>>>0}var l=h;function d(t){this.buffer=new(s?Uint16Array:Array)(2*t),this.length=0}function y(t){var r,e,i,n,a,o,h,c,f,u,l=t.length,d=0,y=Number.POSITIVE_INFINITY;for(c=0;c<l;++c)t[c]>d&&(d=t[c]),t[c]<y&&(y=t[c]);for(r=1<<d,e=new(s?Uint32Array:Array)(r),i=1,n=0,a=2;i<=d;){for(c=0;c<l;++c)if(t[c]===i){for(o=0,h=n,f=0;f<i;++f)o=o<<1|1&h,h>>=1;for(u=i<<16|c,f=o;f<r;f+=a)e[f]=u;++n}++i,n<<=1,a<<=1}return[e,d,y]}function w(t,r){this.h=v,this.w=0,this.input=s&&t instanceof Array?new Uint8Array(t):t,this.b=0,r&&(r.lazy&&(this.w=r.lazy),"number"==typeof r.compressionType&&(this.h=r.compressionType),r.outputBuffer&&(this.a=s&&r.outputBuffer instanceof Array?new Uint8Array(r.outputBuffer):r.outputBuffer),"number"==typeof r.outputIndex&&(this.b=r.outputIndex)),this.a||(this.a=new(s?Uint8Array:Array)(32768))}d.prototype.getParent=function(t){return 2*((t-2)/4|0)},d.prototype.push=function(t,r){var e,i,n,s=this.buffer;for(e=this.length,s[this.length++]=r,s[this.length++]=t;0<e&&(i=this.getParent(e),s[e]>s[i]);)n=s[e],s[e]=s[i],s[i]=n,n=s[e+1],s[e+1]=s[i+1],s[i+1]=n,e=i;return this.length},d.prototype.pop=function(){var t,r,e,i,n,s=this.buffer;for(r=s[0],t=s[1],this.length-=2,s[0]=s[this.length],s[1]=s[this.length+1],n=0;!((i=2*n+2)>=this.length)&&(i+2<this.length&&s[i+2]>s[i]&&(i+=2),s[i]>s[n]);)e=s[n],s[n]=s[i],s[i]=e,e=s[n+1],s[n+1]=s[i+1],s[i+1]=e,n=i;return{index:t,value:r,length:this.length}};var A,v=2,p={NONE:0,r:1,k:v},b=[];for(A=0;288>A;A++)switch(e){case 143>=A:b.push([A+48,8]);break;case 255>=A:b.push([A-144+400,9]);break;case 279>=A:b.push([A-256+0,7]);break;case 287>=A:b.push([A-280+192,8]);break;default:t("invalid literal: "+A)}function k(t,r){this.length=t,this.G=r}w.prototype.j=function(){var i,n,o,h,c=this.input;switch(this.h){case 0:for(o=0,h=c.length;o<h;){var f,u,l,d=n=s?c.subarray(o,o+65535):c.slice(o,o+65535),y=(o+=n.length)===h,w=r,A=r,p=this.a,k=this.b;if(s){for(p=new Uint8Array(this.a.buffer);p.length<=k+d.length+5;)p=new Uint8Array(p.length<<1);p.set(this.a)}if(f=y?1:0,p[k++]=0|f,l=65536+~(u=d.length)&65535,p[k++]=255&u,p[k++]=u>>>8&255,p[k++]=255&l,p[k++]=l>>>8&255,s)p.set(d,k),k+=d.length,p=p.subarray(0,k);else{for(w=0,A=d.length;w<A;++w)p[k++]=d[w];p.length=k}this.b=k,this.a=p}break;case 1:var m=new a(s?new Uint8Array(this.a.buffer):this.a,this.b);m.d(1,1,e),m.d(1,2,e);var U,E,T,F=g(this,c);for(U=0,E=F.length;U<E;U++)if(T=F[U],a.prototype.d.apply(m,b[T]),256<T)m.d(F[++U],F[++U],e),m.d(F[++U],5),m.d(F[++U],F[++U],e);else if(256===T)break;this.a=m.finish(),this.b=this.a.length;break;case v:var I,S,D,O,C,q,z,j,N,W,Z,V,$,_,B,L=new a(s?new Uint8Array(this.a.buffer):this.a,this.b),R=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],P=Array(19);for(I=v,L.d(1,1,e),L.d(I,2,e),S=g(this,c),z=x(q=M(this.L,15)),N=x(j=M(this.K,7)),D=286;257<D&&0===q[D-1];D--);for(O=30;1<O&&0===j[O-1];O--);var G,H,J,Y,K,X,Q=D,tt=O,rt=new(s?Uint32Array:Array)(Q+tt),et=new(s?Uint32Array:Array)(316),it=new(s?Uint8Array:Array)(19);for(G=H=0;G<Q;G++)rt[H++]=q[G];for(G=0;G<tt;G++)rt[H++]=j[G];if(!s)for(G=0,Y=it.length;G<Y;++G)it[G]=0;for(G=K=0,Y=rt.length;G<Y;G+=H){for(H=1;G+H<Y&&rt[G+H]===rt[G];++H);if(J=H,0===rt[G])if(3>J)for(;0<J--;)et[K++]=0,it[0]++;else for(;0<J;)(X=138>J?J:138)>J-3&&X<J&&(X=J-3),10>=X?(et[K++]=17,et[K++]=X-3,it[17]++):(et[K++]=18,et[K++]=X-11,it[18]++),J-=X;else if(et[K++]=rt[G],it[rt[G]]++,3>--J)for(;0<J--;)et[K++]=rt[G],it[rt[G]]++;else for(;0<J;)(X=6>J?J:6)>J-3&&X<J&&(X=J-3),et[K++]=16,et[K++]=X-3,it[16]++,J-=X}for(i=s?et.subarray(0,K):et.slice(0,K),W=M(it,7),_=0;19>_;_++)P[_]=W[R[_]];for(C=19;4<C&&0===P[C-1];C--);for(Z=x(W),L.d(D-257,5,e),L.d(O-1,5,e),L.d(C-4,4,e),_=0;_<C;_++)L.d(P[_],3,e);for(_=0,B=i.length;_<B;_++)if(V=i[_],L.d(Z[V],W[V],e),16<=V){switch(_++,V){case 16:$=2;break;case 17:$=3;break;case 18:$=7;break;default:t("invalid code: "+V)}L.d(i[_],$,e)}var nt,st,at,ot,ht,ct,ft,ut,lt=[z,q],dt=[N,j];for(ht=lt[0],ct=lt[1],ft=dt[0],ut=dt[1],nt=0,st=S.length;nt<st;++nt)if(at=S[nt],L.d(ht[at],ct[at],e),256<at)L.d(S[++nt],S[++nt],e),ot=S[++nt],L.d(ft[ot],ut[ot],e),L.d(S[++nt],S[++nt],e);else if(256===at)break;this.a=L.finish(),this.b=this.a.length;break;default:t("invalid compression type")}return this.a};var m=function(){function r(r){switch(e){case 3===r:return[257,r-3,0];case 4===r:return[258,r-4,0];case 5===r:return[259,r-5,0];case 6===r:return[260,r-6,0];case 7===r:return[261,r-7,0];case 8===r:return[262,r-8,0];case 9===r:return[263,r-9,0];case 10===r:return[264,r-10,0];case 12>=r:return[265,r-11,1];case 14>=r:return[266,r-13,1];case 16>=r:return[267,r-15,1];case 18>=r:return[268,r-17,1];case 22>=r:return[269,r-19,2];case 26>=r:return[270,r-23,2];case 30>=r:return[271,r-27,2];case 34>=r:return[272,r-31,2];case 42>=r:return[273,r-35,3];case 50>=r:return[274,r-43,3];case 58>=r:return[275,r-51,3];case 66>=r:return[276,r-59,3];case 82>=r:return[277,r-67,4];case 98>=r:return[278,r-83,4];case 114>=r:return[279,r-99,4];case 130>=r:return[280,r-115,4];case 162>=r:return[281,r-131,5];case 194>=r:return[282,r-163,5];case 226>=r:return[283,r-195,5];case 257>=r:return[284,r-227,5];case 258===r:return[285,r-258,0];default:t("invalid length: "+r)}}var i,n,s=[];for(i=3;258>=i;i++)n=r(i),s[i]=n[2]<<24|n[1]<<16|n[0];return s}(),U=s?new Uint32Array(m):m;function g(i,n){function a(r,i){var n,s,a,o,h=r.G,c=[],f=0;switch(n=U[r.length],c[f++]=65535&n,c[f++]=n>>16&255,c[f++]=n>>24,e){case 1===h:s=[0,h-1,0];break;case 2===h:s=[1,h-2,0];break;case 3===h:s=[2,h-3,0];break;case 4===h:s=[3,h-4,0];break;case 6>=h:s=[4,h-5,1];break;case 8>=h:s=[5,h-7,1];break;case 12>=h:s=[6,h-9,2];break;case 16>=h:s=[7,h-13,2];break;case 24>=h:s=[8,h-17,3];break;case 32>=h:s=[9,h-25,3];break;case 48>=h:s=[10,h-33,4];break;case 64>=h:s=[11,h-49,4];break;case 96>=h:s=[12,h-65,5];break;case 128>=h:s=[13,h-97,5];break;case 192>=h:s=[14,h-129,6];break;case 256>=h:s=[15,h-193,6];break;case 384>=h:s=[16,h-257,7];break;case 512>=h:s=[17,h-385,7];break;case 768>=h:s=[18,h-513,8];break;case 1024>=h:s=[19,h-769,8];break;case 1536>=h:s=[20,h-1025,9];break;case 2048>=h:s=[21,h-1537,9];break;case 3072>=h:s=[22,h-2049,10];break;case 4096>=h:s=[23,h-3073,10];break;case 6144>=h:s=[24,h-4097,11];break;case 8192>=h:s=[25,h-6145,11];break;case 12288>=h:s=[26,h-8193,12];break;case 16384>=h:s=[27,h-12289,12];break;case 24576>=h:s=[28,h-16385,13];break;case 32768>=h:s=[29,h-24577,13];break;default:t("invalid distance")}for(n=s,c[f++]=n[0],c[f++]=n[1],c[f++]=n[2],a=0,o=c.length;a<o;++a)v[p++]=c[a];k[c[0]]++,m[c[3]]++,b=r.length+i-1,y=null}var o,h,c,f,u,l,d,y,w,A={},v=s?new Uint16Array(2*n.length):[],p=0,b=0,k=new(s?Uint32Array:Array)(286),m=new(s?Uint32Array:Array)(30),g=i.w;if(!s){for(c=0;285>=c;)k[c++]=0;for(c=0;29>=c;)m[c++]=0}for(k[256]=1,o=0,h=n.length;o<h;++o){for(c=u=0,f=3;c<f&&o+c!==h;++c)u=u<<8|n[o+c];if(A[u]===r&&(A[u]=[]),l=A[u],!(0<b--)){for(;0<l.length&&32768<o-l[0];)l.shift();if(o+3>=h){for(y&&a(y,-1),c=0,f=h-o;c<f;++c)w=n[o+c],v[p++]=w,++k[w];break}0<l.length?(d=E(n,o,l),y?y.length<d.length?(w=n[o-1],v[p++]=w,++k[w],a(d,0)):a(y,-1):d.length<g?y=d:a(d,0)):y?a(y,-1):(w=n[o],v[p++]=w,++k[w])}l.push(o)}return v[p++]=256,k[256]++,i.L=k,i.K=m,s?v.subarray(0,p):v}function E(t,r,e){var i,n,s,a,o,h,c=0,f=t.length;a=0,h=e.length;t:for(;a<h;a++){if(i=e[h-a-1],s=3,3<c){for(o=c;3<o;o--)if(t[i+o-1]!==t[r+o-1])continue t;s=c}for(;258>s&&r+s<f&&t[i+s]===t[r+s];)++s;if(s>c&&(n=i,c=s),258===s)break}return new k(c,r-n)}function M(t,r){var e,i,n,a,o,h=t.length,c=new d(572),f=new(s?Uint8Array:Array)(h);if(!s)for(a=0;a<h;a++)f[a]=0;for(a=0;a<h;++a)0<t[a]&&c.push(a,t[a]);if(e=Array(c.length/2),i=new(s?Uint32Array:Array)(c.length/2),1===e.length)return f[c.pop().index]=1,f;for(a=0,o=c.length/2;a<o;++a)e[a]=c.pop(),i[a]=e[a].value;for(n=function(t,r,e){function i(t){var e=y[t][w[t]];e===r?(i(t+1),i(t+1)):--l[e],++w[t]}var n,a,o,h,c,f=new(s?Uint16Array:Array)(e),u=new(s?Uint8Array:Array)(e),l=new(s?Uint8Array:Array)(r),d=Array(e),y=Array(e),w=Array(e),A=(1<<e)-r,v=1<<e-1;for(f[e-1]=r,a=0;a<e;++a)A<v?u[a]=0:(u[a]=1,A-=v),A<<=1,f[e-2-a]=(f[e-1-a]/2|0)+r;for(f[0]=u[0],d[0]=Array(f[0]),y[0]=Array(f[0]),a=1;a<e;++a)f[a]>2*f[a-1]+u[a]&&(f[a]=2*f[a-1]+u[a]),d[a]=Array(f[a]),y[a]=Array(f[a]);for(n=0;n<r;++n)l[n]=e;for(o=0;o<f[e-1];++o)d[e-1][o]=t[o],y[e-1][o]=o;for(n=0;n<e;++n)w[n]=0;for(1===u[e-1]&&(--l[0],++w[e-1]),a=e-2;0<=a;--a){for(h=n=0,c=w[a+1],o=0;o<f[a];o++)(h=d[a+1][c]+d[a+1][c+1])>t[n]?(d[a][o]=h,y[a][o]=r,c+=2):(d[a][o]=t[n],y[a][o]=n,++n);w[a]=0,1===u[a]&&i(a)}return l}(i,i.length,r),a=0,o=e.length;a<o;++a)f[e[a].index]=n[a];return f}function x(t){var r,e,i,n,a=new(s?Uint16Array:Array)(t.length),o=[],h=[],c=0;for(r=0,e=t.length;r<e;r++)o[t[r]]=1+(0|o[t[r]]);for(r=1,e=16;r<=e;r++)h[r]=c,c+=0|o[r],c<<=1;for(r=0,e=t.length;r<e;r++)for(c=h[t[r]],h[t[r]]+=1,i=a[r]=0,n=t[r];i<n;i++)a[r]=a[r]<<1|1&c,c>>>=1;return a}function T(r,e){switch(this.l=[],this.m=32768,this.e=this.g=this.c=this.q=0,this.input=s?new Uint8Array(r):r,this.s=!1,this.n=I,this.B=!1,!e&&(e={})||(e.index&&(this.c=e.index),e.bufferSize&&(this.m=e.bufferSize),e.bufferType&&(this.n=e.bufferType),e.resize&&(this.B=e.resize)),this.n){case F:this.b=32768,this.a=new(s?Uint8Array:Array)(32768+this.m+258);break;case I:this.b=0,this.a=new(s?Uint8Array:Array)(this.m),this.f=this.J,this.t=this.H,this.o=this.I;break;default:t(Error("invalid inflate mode"))}}var F=0,I=1,S={D:F,C:I};T.prototype.p=function(){for(;!this.s;){var i=J(this,3);switch(1&i&&(this.s=e),i>>>=1){case 0:var n=this.input,a=this.c,o=this.a,h=this.b,c=n.length,f=r,u=o.length,l=r;switch(this.e=this.g=0,a+1>=c&&t(Error("invalid uncompressed block header: LEN")),f=n[a++]|n[a++]<<8,a+1>=c&&t(Error("invalid uncompressed block header: NLEN")),f===~(n[a++]|n[a++]<<8)&&t(Error("invalid uncompressed block header: length verify")),a+f>n.length&&t(Error("input buffer is broken")),this.n){case F:for(;h+f>o.length;){if(f-=l=u-h,s)o.set(n.subarray(a,a+l),h),h+=l,a+=l;else for(;l--;)o[h++]=n[a++];this.b=h,o=this.f(),h=this.b}break;case I:for(;h+f>o.length;)o=this.f({v:2});break;default:t(Error("invalid inflate mode"))}if(s)o.set(n.subarray(a,a+f),h),h+=f,a+=f;else for(;f--;)o[h++]=n[a++];this.c=a,this.b=h,this.a=o;break;case 1:this.o(P,H);break;case 2:var d,w,A,v,p=J(this,5)+257,b=J(this,5)+1,k=J(this,4)+4,m=new(s?Uint8Array:Array)(q.length),U=r,g=r,E=r,M=r,x=r;for(x=0;x<k;++x)m[q[x]]=J(this,3);if(!s)for(x=k,k=m.length;x<k;++x)m[q[x]]=0;for(d=y(m),U=new(s?Uint8Array:Array)(p+b),x=0,v=p+b;x<v;)switch(g=Y(this,d),g){case 16:for(M=3+J(this,2);M--;)U[x++]=E;break;case 17:for(M=3+J(this,3);M--;)U[x++]=0;E=0;break;case 18:for(M=11+J(this,7);M--;)U[x++]=0;E=0;break;default:E=U[x++]=g}w=y(s?U.subarray(0,p):U.slice(0,p)),A=y(s?U.subarray(p):U.slice(p)),this.o(w,A);break;default:t(Error("unknown BTYPE: "+i))}}return this.t()};var D,O,C=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],q=s?new Uint16Array(C):C,z=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],j=s?new Uint16Array(z):z,N=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],W=s?new Uint8Array(N):N,Z=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],V=s?new Uint16Array(Z):Z,$=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],_=s?new Uint8Array($):$,B=new(s?Uint8Array:Array)(288);for(D=0,O=B.length;D<O;++D)B[D]=143>=D?8:255>=D?9:279>=D?7:8;var L,R,P=y(B),G=new(s?Uint8Array:Array)(30);for(L=0,R=G.length;L<R;++L)G[L]=5;var H=y(G);function J(r,e){for(var i,n=r.g,s=r.e,a=r.input,o=r.c,h=a.length;s<e;)o>=h&&t(Error("input buffer is broken")),n|=a[o++]<<s,s+=8;return i=n&(1<<e)-1,r.g=n>>>e,r.e=s-e,r.c=o,i}function Y(r,e){for(var i,n,s=r.g,a=r.e,o=r.input,h=r.c,c=o.length,f=e[0],u=e[1];a<u&&!(h>=c);)s|=o[h++]<<a,a+=8;return(n=(i=f[s&(1<<u)-1])>>>16)>a&&t(Error("invalid code length: "+n)),r.g=s>>n,r.e=a-n,r.c=h,65535&i}function K(t){if("string"==typeof t){var r,e,i=t.split("");for(r=0,e=i.length;r<e;r++)i[r]=(255&i[r].charCodeAt(0))>>>0;t=i}for(var n,s=1,a=0,o=t.length,h=0;0<o;){o-=n=1024<o?1024:o;do{a+=s+=t[h++]}while(--n);s%=65521,a%=65521}return(a<<16|s)>>>0}function X(r,e){var i,n;if(this.input=r,this.c=0,!e&&(e={})||(e.index&&(this.c=e.index),e.verify&&(this.M=e.verify)),i=r[this.c++],n=r[this.c++],(15&i)===Q)this.method=Q;else t(Error("unsupported compression method"));0!=((i<<8)+n)%31&&t(Error("invalid fcheck flag:"+((i<<8)+n)%31)),32&n&&t(Error("fdict flag is not supported")),this.A=new T(r,{index:this.c,bufferSize:e.bufferSize,bufferType:e.bufferType,resize:e.resize})}T.prototype.o=function(t,r){var e=this.a,i=this.b;this.u=t;for(var n,s,a,o,h=e.length-258;256!==(n=Y(this,t));)if(256>n)i>=h&&(this.b=i,e=this.f(),i=this.b),e[i++]=n;else for(o=j[s=n-257],0<W[s]&&(o+=J(this,W[s])),n=Y(this,r),a=V[n],0<_[n]&&(a+=J(this,_[n])),i>=h&&(this.b=i,e=this.f(),i=this.b);o--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},T.prototype.I=function(t,r){var e=this.a,i=this.b;this.u=t;for(var n,s,a,o,h=e.length;256!==(n=Y(this,t));)if(256>n)i>=h&&(h=(e=this.f()).length),e[i++]=n;else for(o=j[s=n-257],0<W[s]&&(o+=J(this,W[s])),n=Y(this,r),a=V[n],0<_[n]&&(a+=J(this,_[n])),i+o>h&&(h=(e=this.f()).length);o--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},T.prototype.f=function(){var t,r,e=new(s?Uint8Array:Array)(this.b-32768),i=this.b-32768,n=this.a;if(s)e.set(n.subarray(32768,e.length));else for(t=0,r=e.length;t<r;++t)e[t]=n[t+32768];if(this.l.push(e),this.q+=e.length,s)n.set(n.subarray(i,i+32768));else for(t=0;32768>t;++t)n[t]=n[i+t];return this.b=32768,n},T.prototype.J=function(t){var r,e,i,n=this.input.length/this.c+1|0,a=this.input,o=this.a;return t&&("number"==typeof t.v&&(n=t.v),"number"==typeof t.F&&(n+=t.F)),2>n?e=(i=(a.length-this.c)/this.u[2]/2*258|0)<o.length?o.length+i:o.length<<1:e=o.length*n,s?(r=new Uint8Array(e)).set(o):r=o,this.a=r},T.prototype.t=function(){var t,r,e,i,n,a=0,o=this.a,h=this.l,c=new(s?Uint8Array:Array)(this.q+(this.b-32768));if(0===h.length)return s?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);for(r=0,e=h.length;r<e;++r)for(i=0,n=(t=h[r]).length;i<n;++i)c[a++]=t[i];for(r=32768,e=this.b;r<e;++r)c[a++]=o[r];return this.l=[],this.buffer=c},T.prototype.H=function(){var t,r=this.b;return s?this.B?(t=new Uint8Array(r)).set(this.a.subarray(0,r)):t=this.a.subarray(0,r):(this.a.length>r&&(this.a.length=r),t=this.a),this.buffer=t},X.prototype.p=function(){var r,e=this.input;return r=this.A.p(),this.c=this.A.c,this.M&&((e[this.c++]<<24|e[this.c++]<<16|e[this.c++]<<8|e[this.c++])>>>0!==K(r)&&t(Error("invalid adler-32 checksum"))),r};var Q=8;function tt(t,r){this.input=t,this.a=new(s?Uint8Array:Array)(32768),this.h=rt.k;var e,i={};for(e in!r&&(r={})||"number"!=typeof r.compressionType||(this.h=r.compressionType),r)i[e]=r[e];i.outputBuffer=this.a,this.z=new w(this.input,i)}var rt=p;function et(t,r){var e,i,s,a;if(Object.keys)e=Object.keys(r);else for(i in e=[],s=0,r)e[s++]=i;for(s=0,a=e.length;s<a;++s)n(t+"."+(i=e[s]),r[i])}tt.prototype.j=function(){var r,e,i,n,a,o,h,c=0;if(h=this.a,(r=Q)===Q)e=Math.LOG2E*Math.log(32768)-8;else t(Error("invalid compression method"));if(i=e<<4|r,h[c++]=i,r===Q)switch(this.h){case rt.NONE:a=0;break;case rt.r:a=1;break;case rt.k:a=2;break;default:t(Error("unsupported compression type"))}else t(Error("invalid compression method"));return n=a<<6,h[c++]=n|31-(256*i+n)%31,o=K(this.input),this.z.b=c,c=(h=this.z.j()).length,s&&((h=new Uint8Array(h.buffer)).length<=c+4&&(this.a=new Uint8Array(h.length+4),this.a.set(h),h=this.a),h=h.subarray(0,c+4)),h[c++]=o>>24&255,h[c++]=o>>16&255,h[c++]=o>>8&255,h[c++]=255&o,h},n("Zlib.Inflate",X),n("Zlib.Inflate.prototype.decompress",X.prototype.p),et("Zlib.Inflate.BufferType",{ADAPTIVE:S.C,BLOCK:S.D}),n("Zlib.Deflate",tt),n("Zlib.Deflate.compress",(function(t,r){return new tt(t,r).j()})),n("Zlib.Deflate.prototype.compress",tt.prototype.j),et("Zlib.Deflate.CompressionType",{NONE:rt.NONE,FIXED:rt.r,DYNAMIC:rt.k})}.call(self);var c="undefined"!=typeof Float32Array?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var t=0,r=arguments.length;r--;)t+=arguments[r]*arguments[r];return Math.sqrt(t)});var f,u=function(t,r,e){return t[0]=r[0]-e[0],t[1]=r[1]-e[1],t[2]=r[2]-e[2],t};function l(t,r,e){return t[0]=r,t[1]=e,t}f=new c(3),c!=Float32Array&&(f[0]=0,f[1]=0,f[2]=0),function(){var t=function(){var t=new c(2);return c!=Float32Array&&(t[0]=0,t[1]=0),t}()}();class d{constructor(t=257){this.gridSize=t;const r=t-1;if(r&r-1)throw new Error(\`Expected grid size to be 2^n+1, got ${pR}t}.\`);this.numTriangles=r*r*2-2,this.numParentTriangles=this.numTriangles-r*r,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let t=0;t<this.numTriangles;t++){let e=t+2,i=0,n=0,s=0,a=0,o=0,h=0;for(1&e?s=a=o=r:i=n=h=r;(e>>=1)>1;){const t=i+s>>1,r=n+a>>1;1&e?(s=i,a=n,i=o,n=h):(i=s,n=a,s=o,a=h),o=t,h=r}const c=4*t;this.coords[c+0]=i,this.coords[c+1]=n,this.coords[c+2]=s,this.coords[c+3]=a}}createTile(t){return new y(t,this)}}class y{constructor(t,r){const e=r.gridSize;if(t.length!==e*e)throw new Error(\`Expected terrain data of length ${pR}e*e} (${pR}e} x ${pR}e}), got ${pR}t.length}.\`);this.terrain=t,this.martini=r,this.errors=new Float32Array(t.length),this.update()}update(){const{numTriangles:t,numParentTriangles:r,coords:e,gridSize:i}=this.martini,{terrain:n,errors:s}=this;for(let a=t-1;a>=0;a--){const t=4*a,o=e[t+0],h=e[t+1],c=e[t+2],f=e[t+3],u=o+c>>1,l=h+f>>1,d=u+l-h,y=l+o-u,w=(n[h*i+o]+n[f*i+c])/2,A=l*i+u,v=Math.abs(w-n[A]);if(s[A]=Math.max(s[A],v),a<r){const t=(h+y>>1)*i+(o+d>>1),r=(f+y>>1)*i+(c+d>>1);s[A]=Math.max(s[A],s[t],s[r])}}}getMesh(t=0){const{gridSize:r,indices:e}=this.martini,{errors:i}=this;let n=0,s=0;const a=r-1;function o(a,h,c,f,u,l){const d=a+c>>1,y=h+f>>1;Math.abs(a-u)+Math.abs(h-l)>1&&i[y*r+d]>t?(o(u,l,a,h,d,y),o(c,f,u,l,d,y)):(e[h*r+a]=e[h*r+a]||++n,e[f*r+c]=e[f*r+c]||++n,e[l*r+u]=e[l*r+u]||++n,s++)}e.fill(0),o(0,0,a,a,a,0),o(a,a,0,0,0,a);const h=new Uint16Array(2*n),c=new Uint32Array(3*s);let f=0;function u(n,s,a,o,l,d){const y=n+a>>1,w=s+o>>1;if(Math.abs(n-l)+Math.abs(s-d)>1&&i[w*r+y]>t)u(l,d,n,s,y,w),u(a,o,l,d,y,w);else{const t=e[s*r+n]-1,i=e[o*r+a]-1,u=e[d*r+l]-1;h[2*t]=n,h[2*t+1]=s,h[2*i]=a,h[2*i+1]=o,h[2*u]=l,h[2*u+1]=d,c[f++]=t,c[f++]=i,c[f++]=u}}return u(0,0,a,a,a,0),u(a,a,0,0,0,a),{vertices:h,triangles:c}}getMeshWithSkirts(t=0,r){const{gridSize:e,indices:i}=this.martini,{errors:n}=this;let s=0,a=0;const o=e-1;let h,c,f=0;const u=[],l=[],d=[],y=[];function w(r,A,v,p,b,k){const m=r+v>>1,U=A+p>>1;Math.abs(r-b)+Math.abs(A-k)>1&&n[U*e+m]>t?(w(b,k,r,A,m,U),w(v,p,b,k,m,U)):(h=A*e+r,c=p*e+v,f=k*e+b,0===i[h]&&(0===r?u.push(s):r===o&&l.push(s),0===A?d.push(s):A===o&&y.push(s),i[h]=++s),0===i[c]&&(0===v?u.push(s):v===o&&l.push(s),0===p?d.push(s):p===o&&y.push(s),i[c]=++s),0===i[f]&&(0===b?u.push(s):b===o&&l.push(s),0===k?d.push(s):k===o&&y.push(s),i[f]=++s),a++)}let A;i.fill(0),w(0,0,o,o,o,0),w(o,o,0,0,0,o),A=r?2*(s+3*u.length-2+3*l.length-2+3*d.length-2+3*y.length-2):2*(s+u.length+l.length+d.length+y.length);const v=3*(a+2*(u.length-1)+2*(l.length-1)+2*(d.length-1)+2*(y.length-1)),p=new Uint16Array(A),b=new Uint32Array(v);let k=0;function m(r,s,a,o,h,c){const f=r+a>>1,u=s+o>>1;if(Math.abs(r-h)+Math.abs(s-c)>1&&n[u*e+f]>t)m(h,c,r,s,f,u),m(a,o,h,c,f,u);else{const t=i[s*e+r]-1,n=i[o*e+a]-1,f=i[c*e+h]-1;p[2*t]=r,p[2*t+1]=s,p[2*n]=a,p[2*n+1]=o,p[2*f]=h,p[2*f+1]=c,b[k++]=t,b[k++]=n,b[k++]=f}}m(0,0,o,o,o,0),m(o,o,0,0,0,o),u.sort(((t,r)=>p[2*t+1]-p[2*r+1])),l.sort(((t,r)=>p[2*r+1]-p[2*t+1])),d.sort(((t,r)=>p[2*r]-p[2*t])),y.sort(((t,r)=>p[2*t]-p[2*r]));let U,g,E,M,x=2*s,T=0;function F(t){T=t.length;for(let e=0;e<T-1;e++)U=t[e],g=t[e+1],E=x/2,M=(x+(r?6:2))/2,p[x++]=2*U,p[x++]=2*U+1,r&&(p[x++]=2*U,p[x++]=2*U+1,p[x++]=2*g,p[x++]=2*g+1),r?(b[k++]=E+1,b[k++]=E,b[k++]=E+2,b[k++]=E,b[k++]=M,b[k++]=E+2):(b[k++]=U,b[k++]=E,b[k++]=g,b[k++]=E,b[k++]=M,b[k++]=g);p[x++]=2*t[T-1],p[x++]=2*t[T-1]+1}F(u);const I=x;F(l);const S=x;F(d);const D=x;F(y);return{vertices:p,triangles:b,numVerticesWithoutSkirts:s,numTrianglesWithoutSkirts:a,leftSkirtIndex:I,rightSkirtIndex:S,bottomSkirtIndex:D,topSkirtIndex:x}}}const w={};let A;const v={width:100,height:10};let p,b=!1;try{const t=new OffscreenCanvas(1,1);t.getContext("2d").fillText("hello",0,0),b=!0}catch(t){b=!1}function k(){if(!A){const{width:t,height:r}=v;b?A=new OffscreenCanvas(t,r):(A=document.createElement("canvas"),A.width=t,A.height=r)}return A}class m{constructor(t,r={}){if(!Array.isArray(t))return void console.error("colors is not array");if(t.length<2)return void console.error("colors.length should >1");this.colors=t;let e=1/0,i=-1/0;for(let r=0,n=t.length;r<n;r++){const n=t[r][0];e=Math.min(n,e),i=Math.max(n,i)}this.min=e,this.max=i,this.valueOffset=this.max-this.min,this.options=Object.assign({},v,r),this.T()}getImageData(){return this.imgData}T(){const t=k(),{width:r,height:e}=this.options;t.width=r,t.height=e;const i=t.getContext("2d");i.clearRect(0,0,t.width,t.height);const n=i.createLinearGradient(0,0,t.width,0),{colors:s,valueOffset:a}=this;for(let t=0,r=s.length;t<r;t++){const[r,e]=s[t],i=(r-this.min)/a;n.addColorStop(i,e)}i.fillStyle=n,i.fillRect(0,0,t.width,t.height),this.imgData=i.getImageData(0,0,t.width,t.height)}getColor(t){t=Math.max(this.min,t);const r=((t=Math.min(t,this.max))-this.min)/this.valueOffset;let e=Math.round(r*this.imgData.width);e=Math.min(e,this.imgData.width-1);const i=4*e;return[this.imgData.data[i],this.imgData.data[i+1],this.imgData.data[i+2],this.imgData.data[i+3]]}}let U=null,g=null;const E=[0,0,0],M=[256,256];function x(){try{U||(U=new OffscreenCanvas(1,1))}catch(t){console.error(t)}}const T={},F={},I=64,S=64,D=3,O=-1e3,C=.001,q=256,z=4,j=.002,N={cesium_request_token:{Accept:"application/json,*/*;q=0.01","Accept-Encoding":"gzip, deflate, br"},tianditu:{"Accept-Encoding":"gzip, deflate, br"},cesium:{"Accept-Encoding":"gzip, deflate, br",Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01"},mapbox:{Accept:"image/webp,*/*"}};N["cesium-ion"]=N.cesium;const W=32767;let Z=null,V=null;function $(t,r){const e=function(t){if(t.length<1e3)return null;const r=new Zlib.Inflate(t);return r?r.decompress():null}(new Uint8Array(t));if(!e)throw new Error((i=new Uint8Array(t),_.decode(i)));var i;const n=function(t){const r=t,e=I,i=S,n=new Uint8Array(e*i*z);let s,a,o,h,c;for(let t=0;t<i;t++)for(let f=0;f<e;f++){h=parseInt(149*t/(i-1)),c=parseInt(149*f/(e-1)),a=2*(150*h+c),s=r[a]+256*r[a+1],(s>1e4||s<-2e3)&&(s=0),o=4*(t*e+f);const u=(s+1e3)/C,l=q;n[o]=u/(l*l),n[o+1]=(u-n[o]*l*l)/l,n[o+2]=u-n[o]*l*l-n[o+1]*l,n[o+3]=255}return n}(e),s=function(t,r){const e=r,i=r,n=e+1,s=i+1,a=D,o=O,h=C,c=q,f=j,u=new Float32Array(n*s);let l=0,d=1/0,y=-1/0;for(let r=0;r<n;r++){const n=r>=i?i-1:r;for(let r=0;r<s;r++){let i=0;const s=n*(4*e)+4*(r>=e?e-1:r);for(let r=0;r<a;r++)i=i*c+t[s+r];i=1*(i*h+o),i-=f,u[l]=i,i<d&&(d=i),i>y&&(y=i),l++}}return{data:u,min:d,max:y}}(n,r-1);return s.width=s.height=r,s}const _=new TextDecoder("utf-8");function B(t){return t>>1^-(1&t)}const L=[];function R(t){let r=0;const e=3*Float64Array.BYTES_PER_ELEMENT,i=3*Uint16Array.BYTES_PER_ELEMENT;let n=Uint16Array.BYTES_PER_ELEMENT;const s=new DataView(t);r+=e;const a=s.getFloat32(r,!0);r+=Float32Array.BYTES_PER_ELEMENT;const o=s.getFloat32(r,!0);r+=Float32Array.BYTES_PER_ELEMENT,r+=e;const h=s.getFloat64(r,!0);r+=Float64Array.BYTES_PER_ELEMENT,r+=e;const c=s.getUint32(r,!0);r+=Uint32Array.BYTES_PER_ELEMENT;const f=new Uint16Array(t,r,3*c);r+=c*i,c>65536&&(n=Uint32Array.BYTES_PER_ELEMENT);!function(t,r,e){const i=t.length;let n=0,s=0,a=0;for(let o=0;o<i;++o)n+=B(t[o]),s+=B(r[o]),t[o]=n,r[o]=s,e&&(a+=B(e[o]),e[o]=a)}(f.subarray(0,c),f.subarray(c,2*c),f.subarray(2*c,3*c)),r%n!==0&&(r+=n-r%n);const u=s.getUint32(r,!0);r+=Uint32Array.BYTES_PER_ELEMENT;const l=c>65536?new Uint32Array(t,r,3*u):new Uint16Array(t,r,3*u);let d=0;const y=l.length;for(let t=0;t<y;++t){const r=l[t];l[t]=d-r,0===r&&++d}const w={quantizedVertices:f}.quantizedVertices,A=w.length/3,v=w.subarray(0,A),p=w.subarray(A,2*A),b=w.subarray(2*A,3*A),k=L;for(let t=0;t<A;++t){const r=v[t],e=p[t],i=r/W,n=e/W,s=(m=a,U=o,(1-(g=b[t]/W))*m+g*U);k[3*t]=i,k[3*t+1]=1-n,k[3*t+2]=s}var m,U,g;return{positions:k,radius:h,min:a,max:o,indices:l}}const P=[],G=[],H=[],J=[],Y=[];class K{constructor(t,r,e,i,n){this.p0=[],this.p1=[],this.p2=[],this.normal=[],this.min=[],this.max=[],this.set(t,r,e,i,n)}set(t,r,e,i,n){this.radius=n;let s=3*r,a=3*r+1,o=3*r+2;this.p0[0]=t[s]*n,this.p0[1]=t[a]*n,this.p0[2]=t[o],s=3*e,a=3*e+1,o=3*e+2,this.p1[0]=t[s]*n,this.p1[1]=t[a]*n,this.p1[2]=t[o],s=3*i,a=3*i+1,o=3*i+2,this.p2[0]=t[s]*n,this.p2[1]=t[a]*n,this.p2[2]=t[o],this.min[0]=Math.min(this.p0[0],this.p1[0],this.p2[0]),this.min[1]=Math.min(this.p0[1],this.p1[1],this.p2[1]),this.max[0]=Math.max(this.p0[0],this.p1[0],this.p2[0]),this.max[1]=Math.max(this.p0[1],this.p1[1],this.p2[1]);const h=u(P,this.p1,this.p0),c=u(G,this.p2,this.p1);this.normal=function(t,r){var e=r[0],i=r[1],n=r[2],s=e*e+i*i+n*n;return s>0&&(s=1/Math.sqrt(s)),t[0]=r[0]*s,t[1]=r[1]*s,t[2]=r[2]*s,t}(this.normal,function(t,r,e){var i=r[0],n=r[1],s=r[2],a=e[0],o=e[1],h=e[2];return t[0]=n*h-s*o,t[1]=s*a-i*h,t[2]=i*o-n*a,t}(this.normal,h,c))}contains(t,r){if(t<this.min[0]||t>this.max[0]||r<this.min[1]||r>this.max[1])return!1;l(H,this.p0[0],this.p0[1]),l(J,this.p1[0],this.p1[1]),l(Y,this.p2[0],this.p2[1]);const e=rt(H[0],H[1],J[0],J[1],Y[0],Y[1]);return rt(t,r,H[0],H[1],Y[0],Y[1])+rt(t,r,H[0],H[1],J[0],J[1])+rt(t,r,J[0],J[1],Y[0],Y[1])-e<=1e-4}getHeight(t,r){const e=this.normal;return this.p0[2]-((t-this.p0[0])*e[0]+(r-this.p0[1])*e[1])/e[2]}}let X=null;function Q(t,r,e){if(X&&X.contains(r,e))return X.getHeight(r,e);for(let i=0;i<t.length;i++)if(t[i].contains(r,e))return X=t[i],t[i].getHeight(r,e);return 0}const tt=[];function rt(t,r,e,i,n,s){return.5*Math.abs(t*i+e*s+n*r-t*s-e*r-n*i)}function et(t,r,e,i,n,s){"cesium-ion"===e&&(r.Authorization="Bearer "+Z),function(t,r,e){const i={method:"GET",referrer:e,headers:r},n=h.getArrayBuffer(t,i),s=n.xhr;return F[t]=s,n.then((r=>(delete F[t],r)))}(t,r,origin).then((t=>{if(!t||t.message)s(t?{empty:!0,originalError:t}:{error:{canceled:!0}});else{const r=t.data;let a=null;if("tianditu"===e){const t=$(r,i);nt(n,t,i,null,!0,s)}else if("cesium-ion"===e||"cesium"===e){a=R(r);const t=function(t,r){const{positions:e,min:i,max:n,indices:s,radius:a}=t,o=[];let h=0;for(let t=0;t<s.length;t+=3){let r=tt[h];r?r.set(e,s[t],s[t+1],s[t+2],2*a):r=tt[h]=new K(e,s[t],s[t+1],s[t+2],2*a),h++,o.push(r)}const c=new Float32Array(r*r);h=0;for(let t=0;t<r;t++)for(let e=0;e<r;e++)c[h++]=Q(o,e/r*a*2,t/r*a*2);return{data:c,min:i,max:n,width:r,height:r}}(a,i);nt(n,t,i,null,!0,s)}else"mapbox"===e&&(a=function(t){const r=new self.Blob([new Uint8Array(t)]);return self.createImageBitmap(r)}(r),a.then((t=>{const r=at(st(t),i);nt(n,r,i,t,!0,s)})))}})).catch((r=>{delete F[t],s({empty:!0,originalError:r})}))}function it(t,r){const e=Math.floor(10*(t+1e4)),i=e>>16,n=e>>8&255,s=255&e;return r?(r[0]=i,r[1]=n,r[2]=s,r):[i,n,s]}function nt(t,r,e,i,n,s){const a=function(t,r,e){let i=w[e];i||(i=w[e]=new d(e));const n=i.createTile(r).getMeshWithSkirts(t,!0),{triangles:s,vertices:a,leftSkirtIndex:o,rightSkirtIndex:h,bottomSkirtIndex:c,topSkirtIndex:f}=n;let{numVerticesWithoutSkirts:u,numTrianglesWithoutSkirts:l}=n;u||(u=a.length/2,l=s.length/3);const y=a.length/2,A=new Float32Array(3*y),v=new Float32Array(2*y);let p=1/0,b=-1/0;const k=e-1;for(let t=0;t<y;t++){const i=a[2*t],n=a[2*t+1];if(t>=u){const r=i/2*3;let e,n=.001;(t-(t<o/2?u:t<h/2?o/2:t<c/2?h/2:c/2))%3==0?(e=Math.min(0,p),n=0):e=A[r+2],A[3*t]=A[r],A[3*t+1]=A[r+1],A[3*t+2]=e,v[2*t]=A[r]/k+n,v[2*t+1]=-A[r+1]/k+n}else{const s=r[n*e+i];A[3*t]=1*i,A[3*t+1]=1*-n,A[3*t+2]=s,v[2*t]=i/k,v[2*t+1]=n/k,s<p&&(p=s),s>b&&(b=s)}}return{positions:A,texcoords:v,triangles:s,leftSkirtIndex:o,rightSkirtIndex:h,bottomSkirtIndex:c,topSkirtIndex:f,numTrianglesWithoutSkirts:l,numVerticesWithoutSkirts:u,minHeight:Math.min(0,p),maxHeight:b,terrainWidth:e}}(t/6,r.data,e),o=[a.positions.buffer,a.texcoords.buffer,a.triangles.buffer];i||(i=function(t){if(x(),!U)return;const{width:r,height:e,data:i}=t;if(r&&e&&i)try{let t=U.getContext("2d",{willReadFrequently:!0});const n=t.createImageData(r,e);for(let t=0,r=i.length;t<r;t++){const r=i[t],[e,s,a]=it(r,E),o=4*t;n.data[o]=e,n.data[o+1]=s,n.data[o+2]=a,n.data[o+3]=255}return U.width=r,U.height=e,t=U.getContext("2d",{willReadFrequently:!0}),ot(t),t.putImageData(n,0,0),U.transferToImageBitmap()}catch(t){console.log(t)}}(r)),i&&o.push(i);const h={mesh:a};h.image=i,h.data=r,o.push(r.data.buffer),s(h,o)}function st(t){const{width:r,height:e}=t;return U||(U=new OffscreenCanvas(1,1),g=U.getContext("2d",{willReadFrequently:!0})),U.width=r,U.height=e,g.drawImage(t,0,0,r,e),g.getImageData(0,0,r,e)}function at(t,r){const{data:e,width:i}=t;let n=1/0,s=-1/0;const a=new Float32Array(r*r),o=Math.round(i/r);for(let t=0;t<r;t++)for(let h=0;h<r;h++){const c=t+h*r;let f=0,u=0;const l=t,d=h;for(let t=0;t<o;t++)for(let r=0;r<o;r++){let n=l*o+t,s=d*o+r;s>i-1&&(s=i-1),n>i-1&&(n=i-1);const a=n+s*i,h=e[4*a],c=e[4*a+1],y=e[4*a+2];0===e[4*a+3]?u+=1:f+=.1*(256*h*256+256*c+y)-1e4}f/=o*o-u||1,f>s&&(s=f),f<n&&(n=f),a[c]=f}return{data:a,width:r,height:r,min:n,max:s}}function ot(t){const r=t.canvas,{width:e,height:i}=r;t.clearRect(0,0,e,i)}function ht(t,r,e){if(!r||!Array.isArray(r)||r.length<2)return;if(!t||!t.image)return null;let{width:i,height:n}=t.image;(e=e||M)[0]===i&&e[1]===n||(i=e[0],n=e[1]),i*=2,n*=2;try{if(x(),!U)return;const e=U;e.width=i,e.height=n;const s=e.getContext("2d",{willReadFrequently:!0});ot(s),s.drawImage(t.image,0,0,i,n);const a=s.getImageData(0,0,i,n);return function(t,r){const e=JSON.stringify(r);T[e]||(T[e]=new m(r));const i=T[e],n=t.data;for(let t=0,r=n.length;t<r;t+=4){const r=n[t],e=n[t+1],s=n[t+2];let a=0;0!==n[t+3]&&(a=.1*(256*r*256+256*e+s)-1e4,a=Math.max(a,0));const[o,h,c]=i.getColor(a);n[t]=o,n[t+1]=h,n[t+2]=c,n[t+3]=255}}(a,r),new Uint8Array(a.data)}catch(t){console.error(t)}}t.initialize=function(){},t.onmessage=function(t,r){const e=t.data;if("addLayer"===e.command||"removeLayer"===e.command)p=t.workerId,self.postMessage({type:"<response>",actorId:e.actorId,workerId:p,params:"ok",callback:t.callback});else if("fetchTerrain"===e.command){const t=(e.params||{}).colors,i=(e.params||{}).tileSize;!function(t,r){const{url:e,origin:i,type:n,accessToken:s,terrainWidth:a,error:o,tileImage:h}=t;if(h&&h.close){const t=at(st(h),a);return void nt(o,t,a,h,0,r)}const c=t.headers||N[n];if("tianditu"===n)et(e,c,n,a,o,r);else if("cesium-ion"===n){const h=t.cesiumIonTokenURL+s;Z?et(e,c,n,a,o,r):(V||(V=fetch(h,{responseType:"json",method:"GET",referrer:i,headers:{Accept:"application/json,*/*;q=0.01","Accept-Encoding":"gzip, deflate, br"}}).then((t=>t.json())).then((t=>{Z=t.accessToken,V=null}))),V.then((()=>{et(e,c,n,a,o,r)})))}else("cesium"===n||"mapbox"===n)&&et(e,c,n,a,o,r)}(e.params,((e,n)=>{const s=ht(e,t,i);s&&(e.colorsTexture=s,(n=n||[]).push(s.buffer)),r(e.error,e,n)}))}else"abortTerrain"===e.command&&(i=e.params.url,F[i]&&(F[i].abort(),delete F[i]));var i}}`;!function(i){tx().maptalks_gltf_loader_bundle=i}(ix),Os("@maptalks/terrain",gR),Os("maplight",'function(n){var t,r="undefined"!=typeof Float32Array?Float32Array:Array;function o(n,t,r){return n[0]=t[0]*r,n[1]=t[1]*r,n[2]=t[2]*r,n}function e(n,t,r,o){return n[0]=t[0]+r[0]*o,n[1]=t[1]+r[1]*o,n[2]=t[2]+r[2]*o,n}function c(n,t){var r=t[0],o=t[1],e=t[2],c=r*r+o*o+e*e;return c>0&&(c=1/Math.sqrt(c)),n[0]=t[0]*c,n[1]=t[1]*c,n[2]=t[2]*c,n}\n/*!\n   * from claygl\n   * https://github.com/pissang/claygl/\n   * License: BSD-2-Clause\n   */\nfunction a(n,t){const r=n[0],o=n[1],e=n[2];return 0===t?1:1===t?r:2===t?o:3===t?e:4===t?r*e:5===t?o*e:6===t?r*o:7===t?3*e*e-1:r*r-o*o}Math.hypot||(Math.hypot=function(){for(var n=0,t=arguments.length;t--;)n+=arguments[t]*arguments[t];return Math.sqrt(n)}),t=new r(3),r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0);const i={px:[2,1,0,-1,-1,1],nx:[2,1,0,1,-1,-1],py:[0,2,1,1,-1,-1],ny:[0,2,1,1,1,1],pz:[0,1,2,-1,-1,-1],nz:[0,1,2,1,-1,1]},u=["px","nx","py","ny","pz","nz"];n.initialize=function(){},n.onmessage=function(n,t){const r=n.data||{},{cubePixels:f,width:l,height:s}=r;if(!f||!l||!s){const n="Invalid parameters to create light projectEnvironmentMapCPU.";return console.error(r),void t({error:n})}const p=function(n,t,r){const f=new Array(9),l=[],s=[],p=[];for(let y=0;y<9;y++){const h=[0,0,0];for(let o=0;o<u.length;o++){const f=n[o],d=[0,0,0];let v=0,x=0;const A=i[u[o]];for(let n=0;n<r;n++)for(let o=0;o<t;o++){l[0]=o/(t-1)*2-1,l[1]=n/(r-1)*2-1,l[2]=-1,c(l,l),p[0]=l[A[0]]*A[3],p[1]=l[A[1]]*A[4],p[2]=l[A[2]]*A[5],s[0]=f[x++]/255,s[1]=f[x++]/255,s[2]=f[x++]/255;const i=f[x++]/255*7;s[0]*=i,s[1]*=i,s[2]*=i,e(d,d,s,a(p,y)*-l[2]),v+=-l[2]}e(h,h,d,1/v)}f[y]=o(h,h,1/6)}return f}(f.map((n=>new Uint8Array(n))),l,s);t(null,{shList:p})}}'),"undefined"!=typeof console&&console.log("@maptalks/gl v0.110.0");var mR={exports:{}},AR={exports:{}},yR=function(i){return!(!i||"string"==typeof i)&&(i instanceof Array||Array.isArray(i)||i.length>=0&&(i.splice instanceof Function||Object.getOwnPropertyDescriptor(i,i.length-1)&&"String"!==i.constructor.name))},_R=Array.prototype.concat,vR=Array.prototype.slice,xR=AR.exports=function(i){for(var g=[],m=0,_=i.length;m<_;m++){var b=i[m];yR(b)?g=_R.call(g,vR.call(b)):g.push(b)}return g};xR.wrap=function(i){return function(){return i(xR(arguments))}};var bR={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},wR=AR.exports,TR=Object.hasOwnProperty,SR=Object.create(null);for(var MR in bR)TR.call(bR,MR)&&(SR[bR[MR]]=MR);var CR=mR.exports={to:{},get:{}};function PR(i,g,m){return Math.min(Math.max(g,i),m)}function IR(i){var g=Math.round(i).toString(16).toUpperCase();return g.length<2?"0"+g:g}CR.get=function(i){var g,m;switch(i.substring(0,3).toLowerCase()){case"hsl":g=CR.get.hsl(i),m="hsl";break;case"hwb":g=CR.get.hwb(i),m="hwb";break;default:g=CR.get.rgb(i),m="rgb"}return g?{model:m,value:g}:null},CR.get.rgb=function(i){if(!i)return null;var g,m,_,b=[0,0,0,1];if(g=i.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(_=g[2],g=g[1],m=0;m<3;m++){var T=2*m;b[m]=parseInt(g.slice(T,T+2),16)}_&&(b[3]=parseInt(_,16)/255)}else if(g=i.match(/^#([a-f0-9]{3,4})$/i)){for(_=(g=g[1])[3],m=0;m<3;m++)b[m]=parseInt(g[m]+g[m],16);_&&(b[3]=parseInt(_+_,16)/255)}else if(g=i.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)){for(m=0;m<3;m++)b[m]=parseInt(g[m+1],0);g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}else{if(!(g=i.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)))return(g=i.match(/^(\w+)$/))?"transparent"===g[1]?[0,0,0,0]:TR.call(bR,g[1])?((b=bR[g[1]])[3]=1,b):null:null;for(m=0;m<3;m++)b[m]=Math.round(2.55*parseFloat(g[m+1]));g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}for(m=0;m<3;m++)b[m]=PR(b[m],0,255);return b[3]=PR(b[3],0,1),b},CR.get.hsl=function(i){if(!i)return null;var g=i.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,PR(parseFloat(g[2]),0,100),PR(parseFloat(g[3]),0,100),PR(isNaN(m)?1:m,0,1)]}return null},CR.get.hwb=function(i){if(!i)return null;var g=i.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,PR(parseFloat(g[2]),0,100),PR(parseFloat(g[3]),0,100),PR(isNaN(m)?1:m,0,1)]}return null},CR.to.hex=function(){var i=wR(arguments);return"#"+IR(i[0])+IR(i[1])+IR(i[2])+(i[3]<1?IR(Math.round(255*i[3])):"")},CR.to.rgb=function(){var i=wR(arguments);return i.length<4||1===i[3]?"rgb("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+")":"rgba("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+", "+i[3]+")"},CR.to.rgb.percent=function(){var i=wR(arguments),g=Math.round(i[0]/255*100),m=Math.round(i[1]/255*100),_=Math.round(i[2]/255*100);return i.length<4||1===i[3]?"rgb("+g+"%, "+m+"%, "+_+"%)":"rgba("+g+"%, "+m+"%, "+_+"%, "+i[3]+")"},CR.to.hsl=function(){var i=wR(arguments);return i.length<4||1===i[3]?"hsl("+i[0]+", "+i[1]+"%, "+i[2]+"%)":"hsla("+i[0]+", "+i[1]+"%, "+i[2]+"%, "+i[3]+")"},CR.to.hwb=function(){var i=wR(arguments),g="";return i.length>=4&&1!==i[3]&&(g=", "+i[3]),"hwb("+i[0]+", "+i[1]+"%, "+i[2]+"%"+g+")"},CR.to.keyword=function(i){return SR[i.slice(0,3)]};var kR=mR.exports,OR={exports:{}},ER={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},RR={};for(var LR in ER)ER.hasOwnProperty(LR)&&(RR[ER[LR]]=LR);var DR=OR.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var FR in DR)if(DR.hasOwnProperty(FR)){if(!("channels"in DR[FR]))throw new Error("missing channels property: "+FR);if(!("labels"in DR[FR]))throw new Error("missing channel labels property: "+FR);if(DR[FR].labels.length!==DR[FR].channels)throw new Error("channel and label counts mismatch: "+FR);var NR=DR[FR].channels,HR=DR[FR].labels;delete DR[FR].channels,delete DR[FR].labels,Object.defineProperty(DR[FR],"channels",{value:NR}),Object.defineProperty(DR[FR],"labels",{value:HR})}function BR(i,g){return Math.pow(i[0]-g[0],2)+Math.pow(i[1]-g[1],2)+Math.pow(i[2]-g[2],2)}DR.rgb.hsl=function(i){var g,m,_=i[0]/255,b=i[1]/255,T=i[2]/255,P=Math.min(_,b,T),I=Math.max(_,b,T),H=I-P;return I===P?g=0:_===I?g=(b-T)/H:b===I?g=2+(T-_)/H:T===I&&(g=4+(_-b)/H),(g=Math.min(60*g,360))<0&&(g+=360),m=(P+I)/2,[g,100*(I===P?0:m<=.5?H/(I+P):H/(2-I-P)),100*m]},DR.rgb.hsv=function(i){var g,m,_,b,T,P=i[0]/255,I=i[1]/255,H=i[2]/255,W=Math.max(P,I,H),q=W-Math.min(P,I,H),$=function(i){return(W-i)/6/q+.5};return 0===q?b=T=0:(T=q/W,g=$(P),m=$(I),_=$(H),P===W?b=_-m:I===W?b=1/3+g-_:H===W&&(b=2/3+m-g),b<0?b+=1:b>1&&(b-=1)),[360*b,100*T,100*W]},DR.rgb.hwb=function(i){var g=i[0],m=i[1],_=i[2];return[DR.rgb.hsl(i)[0],100*(1/255*Math.min(g,Math.min(m,_))),100*(_=1-1/255*Math.max(g,Math.max(m,_)))]},DR.rgb.cmyk=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255;return[100*((1-m-(g=Math.min(1-m,1-_,1-b)))/(1-g)||0),100*((1-_-g)/(1-g)||0),100*((1-b-g)/(1-g)||0),100*g]},DR.rgb.keyword=function(i){var g=RR[i];if(g)return g;var m,_=1/0;for(var b in ER)if(ER.hasOwnProperty(b)){var T=BR(i,ER[b]);T<_&&(_=T,m=b)}return m},DR.keyword.rgb=function(i){return ER[i]},DR.rgb.xyz=function(i){var g=i[0]/255,m=i[1]/255,_=i[2]/255;return[100*(.4124*(g=g>.04045?Math.pow((g+.055)/1.055,2.4):g/12.92)+.3576*(m=m>.04045?Math.pow((m+.055)/1.055,2.4):m/12.92)+.1805*(_=_>.04045?Math.pow((_+.055)/1.055,2.4):_/12.92)),100*(.2126*g+.7152*m+.0722*_),100*(.0193*g+.1192*m+.9505*_)]},DR.rgb.lab=function(i){var g=DR.rgb.xyz(i),m=g[0],_=g[1],b=g[2];return _/=100,b/=108.883,m=(m/=95.047)>.008856?Math.pow(m,1/3):7.787*m+16/116,[116*(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116)-16,500*(m-_),200*(_-(b=b>.008856?Math.pow(b,1/3):7.787*b+16/116))]},DR.hsl.rgb=function(i){var g,m,_,b,T,P=i[0]/360,I=i[1]/100,H=i[2]/100;if(0===I)return[T=255*H,T,T];g=2*H-(m=H<.5?H*(1+I):H+I-H*I),b=[0,0,0];for(var W=0;W<3;W++)(_=P+1/3*-(W-1))<0&&_++,_>1&&_--,b[W]=255*(T=6*_<1?g+6*(m-g)*_:2*_<1?m:3*_<2?g+(m-g)*(2/3-_)*6:g);return b},DR.hsl.hsv=function(i){var g=i[0],m=i[1]/100,_=i[2]/100,b=m,T=Math.max(_,.01);return m*=(_*=2)<=1?_:2-_,b*=T<=1?T:2-T,[g,100*(0===_?2*b/(T+b):2*m/(_+m)),100*((_+m)/2)]},DR.hsv.rgb=function(i){var g=i[0]/60,m=i[1]/100,_=i[2]/100,b=Math.floor(g)%6,T=g-Math.floor(g),P=255*_*(1-m),I=255*_*(1-m*T),H=255*_*(1-m*(1-T));switch(_*=255,b){case 0:return[_,H,P];case 1:return[I,_,P];case 2:return[P,_,H];case 3:return[P,I,_];case 4:return[H,P,_];case 5:return[_,P,I]}},DR.hsv.hsl=function(i){var g,m,_,b=i[0],T=i[1]/100,P=i[2]/100,I=Math.max(P,.01);return _=(2-T)*P,m=T*I,[b,100*(m=(m/=(g=(2-T)*I)<=1?g:2-g)||0),100*(_/=2)]},DR.hwb.rgb=function(i){var g,m,_,b,T,P,I,H=i[0]/360,W=i[1]/100,q=i[2]/100,$=W+q;switch($>1&&(W/=$,q/=$),_=6*H-(g=Math.floor(6*H)),1&g&&(_=1-_),b=W+_*((m=1-q)-W),g){default:case 6:case 0:T=m,P=b,I=W;break;case 1:T=b,P=m,I=W;break;case 2:T=W,P=m,I=b;break;case 3:T=W,P=b,I=m;break;case 4:T=b,P=W,I=m;break;case 5:T=m,P=W,I=b}return[255*T,255*P,255*I]},DR.cmyk.rgb=function(i){var g=i[1]/100,m=i[2]/100,_=i[3]/100;return[255*(1-Math.min(1,i[0]/100*(1-_)+_)),255*(1-Math.min(1,g*(1-_)+_)),255*(1-Math.min(1,m*(1-_)+_))]},DR.xyz.rgb=function(i){var g,m,_,b=i[0]/100,T=i[1]/100,P=i[2]/100;return m=-.9689*b+1.8758*T+.0415*P,_=.0557*b+-.204*T+1.057*P,g=(g=3.2406*b+-1.5372*T+-.4986*P)>.0031308?1.055*Math.pow(g,1/2.4)-.055:12.92*g,m=m>.0031308?1.055*Math.pow(m,1/2.4)-.055:12.92*m,_=_>.0031308?1.055*Math.pow(_,1/2.4)-.055:12.92*_,[255*(g=Math.min(Math.max(0,g),1)),255*(m=Math.min(Math.max(0,m),1)),255*(_=Math.min(Math.max(0,_),1))]},DR.xyz.lab=function(i){var g=i[0],m=i[1],_=i[2];return m/=100,_/=108.883,g=(g/=95.047)>.008856?Math.pow(g,1/3):7.787*g+16/116,[116*(m=m>.008856?Math.pow(m,1/3):7.787*m+16/116)-16,500*(g-m),200*(m-(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116))]},DR.lab.xyz=function(i){var g,m,_;g=i[1]/500+(m=(i[0]+16)/116),_=m-i[2]/200;var b=Math.pow(m,3),T=Math.pow(g,3),P=Math.pow(_,3);return m=b>.008856?b:(m-16/116)/7.787,g=T>.008856?T:(g-16/116)/7.787,_=P>.008856?P:(_-16/116)/7.787,[g*=95.047,m*=100,_*=108.883]},DR.lab.lch=function(i){var g,m=i[0],_=i[1],b=i[2];return(g=360*Math.atan2(b,_)/2/Math.PI)<0&&(g+=360),[m,Math.sqrt(_*_+b*b),g]},DR.lch.lab=function(i){var g,m=i[1];return g=i[2]/360*2*Math.PI,[i[0],m*Math.cos(g),m*Math.sin(g)]},DR.rgb.ansi16=function(i){var g=i[0],m=i[1],_=i[2],b=1 in arguments?arguments[1]:DR.rgb.hsv(i)[2];if(0===(b=Math.round(b/50)))return 30;var T=30+(Math.round(_/255)<<2|Math.round(m/255)<<1|Math.round(g/255));return 2===b&&(T+=60),T},DR.hsv.ansi16=function(i){return DR.rgb.ansi16(DR.hsv.rgb(i),i[2])},DR.rgb.ansi256=function(i){var g=i[0],m=i[1],_=i[2];return g===m&&m===_?g<8?16:g>248?231:Math.round((g-8)/247*24)+232:16+36*Math.round(g/255*5)+6*Math.round(m/255*5)+Math.round(_/255*5)},DR.ansi16.rgb=function(i){var g=i%10;if(0===g||7===g)return i>50&&(g+=3.5),[g=g/10.5*255,g,g];var m=.5*(1+~~(i>50));return[(1&g)*m*255,(g>>1&1)*m*255,(g>>2&1)*m*255]},DR.ansi256.rgb=function(i){if(i>=232){var g=10*(i-232)+8;return[g,g,g]}var m;return i-=16,[Math.floor(i/36)/5*255,Math.floor((m=i%36)/6)/5*255,m%6/5*255]},DR.rgb.hex=function(i){var g=(((255&Math.round(i[0]))<<16)+((255&Math.round(i[1]))<<8)+(255&Math.round(i[2]))).toString(16).toUpperCase();return"000000".substring(g.length)+g},DR.hex.rgb=function(i){var g=i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!g)return[0,0,0];var m=g[0];3===g[0].length&&(m=m.split("").map((function(i){return i+i})).join(""));var _=parseInt(m,16);return[_>>16&255,_>>8&255,255&_]},DR.rgb.hcg=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255,T=Math.max(Math.max(m,_),b),P=Math.min(Math.min(m,_),b),I=T-P;return g=I<=0?0:T===m?(_-b)/I%6:T===_?2+(b-m)/I:4+(m-_)/I+4,g/=6,[360*(g%=1),100*I,100*(I<1?P/(1-I):0)]},DR.hsl.hcg=function(i){var g=i[1]/100,m=i[2]/100,_=1,b=0;return(_=m<.5?2*g*m:2*g*(1-m))<1&&(b=(m-.5*_)/(1-_)),[i[0],100*_,100*b]},DR.hsv.hcg=function(i){var g=i[2]/100,m=i[1]/100*g,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},DR.hcg.rgb=function(i){var g=i[1]/100,m=i[2]/100;if(0===g)return[255*m,255*m,255*m];var _,b=[0,0,0],T=i[0]/360%1*6,P=T%1,I=1-P;switch(Math.floor(T)){case 0:b[0]=1,b[1]=P,b[2]=0;break;case 1:b[0]=I,b[1]=1,b[2]=0;break;case 2:b[0]=0,b[1]=1,b[2]=P;break;case 3:b[0]=0,b[1]=I,b[2]=1;break;case 4:b[0]=P,b[1]=0,b[2]=1;break;default:b[0]=1,b[1]=0,b[2]=I}return[255*(g*b[0]+(_=(1-g)*m)),255*(g*b[1]+_),255*(g*b[2]+_)]},DR.hcg.hsv=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g),_=0;return m>0&&(_=g/m),[i[0],100*_,100*m]},DR.hcg.hsl=function(i){var g=i[1]/100,m=i[2]/100*(1-g)+.5*g,_=0;return m>0&&m<.5?_=g/(2*m):m>=.5&&m<1&&(_=g/(2*(1-m))),[i[0],100*_,100*m]},DR.hcg.hwb=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g);return[i[0],100*(m-g),100*(1-m)]},DR.hwb.hcg=function(i){var g=1-i[2]/100,m=g-i[1]/100,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},DR.apple.rgb=function(i){return[i[0]/65535*255,i[1]/65535*255,i[2]/65535*255]},DR.rgb.apple=function(i){return[i[0]/255*65535,i[1]/255*65535,i[2]/255*65535]},DR.gray.rgb=function(i){return[i[0]/100*255,i[0]/100*255,i[0]/100*255]},DR.gray.hsl=DR.gray.hsv=function(i){return[0,0,i[0]]},DR.gray.hwb=function(i){return[0,100,i[0]]},DR.gray.cmyk=function(i){return[0,0,0,i[0]]},DR.gray.lab=function(i){return[i[0],0,0]},DR.gray.hex=function(i){var g=255&Math.round(i[0]/100*255),m=((g<<16)+(g<<8)+g).toString(16).toUpperCase();return"000000".substring(m.length)+m},DR.rgb.gray=function(i){return[(i[0]+i[1]+i[2])/3/255*100]};var zR=OR.exports,VR=zR;function UR(i){var g=function(){for(var i={},g=Object.keys(VR),m=g.length,_=0;_<m;_++)i[g[_]]={distance:-1,parent:null};return i}(),m=[i];for(g[i].distance=0;m.length;)for(var _=m.pop(),b=Object.keys(VR[_]),T=b.length,P=0;P<T;P++){var I=b[P],H=g[I];-1===H.distance&&(H.distance=g[_].distance+1,H.parent=_,m.unshift(I))}return g}function GR(i,g){return function(m){return g(i(m))}}function jR(i,g){for(var m=[g[i].parent,i],_=VR[g[i].parent][i],b=g[i].parent;g[b].parent;)m.unshift(g[b].parent),_=GR(VR[g[b].parent][b],_),b=g[b].parent;return _.conversion=m,_}var WR=zR,qR=function(i){for(var g=UR(i),m={},_=Object.keys(g),b=_.length,T=0;T<b;T++){var P=_[T];null!==g[P].parent&&(m[P]=jR(P,g))}return m},XR={};Object.keys(WR).forEach((function(i){XR[i]={},Object.defineProperty(XR[i],"channels",{value:WR[i].channels}),Object.defineProperty(XR[i],"labels",{value:WR[i].labels});var g=qR(i);Object.keys(g).forEach((function(m){var _=g[m];XR[i][m]=function(i){var g=function(g){if(null==g)return g;arguments.length>1&&(g=Array.prototype.slice.call(arguments));var m=i(g);if("object"==typeof m)for(var _=m.length,b=0;b<_;b++)m[b]=Math.round(m[b]);return m};return"conversion"in i&&(g.conversion=i.conversion),g}(_),XR[i][m].raw=function(i){var g=function(g){return null==g?g:(arguments.length>1&&(g=Array.prototype.slice.call(arguments)),i(g))};return"conversion"in i&&(g.conversion=i.conversion),g}(_)}))}));var ZR=kR,$R=XR,YR=[].slice,QR=["keyword","gray","hex"],JR={};Object.keys($R).forEach((function(i){JR[YR.call($R[i].labels).sort().join("")]=i}));var KR={};function eL(i,g){if(!(this instanceof eL))return new eL(i,g);if(g&&g in QR&&(g=null),g&&!(g in $R))throw new Error("Unknown model: "+g);var m,_;if(null==i)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(i instanceof eL)this.model=i.model,this.color=i.color.slice(),this.valpha=i.valpha;else if("string"==typeof i){var b=ZR.get(i);if(null===b)throw new Error("Unable to parse color from string: "+i);this.model=b.model,this.color=b.value.slice(0,_=$R[this.model].channels),this.valpha="number"==typeof b.value[_]?b.value[_]:1}else if(i.length){this.model=g||"rgb";var T=YR.call(i,0,_=$R[this.model].channels);this.color=rL(T,_),this.valpha="number"==typeof i[_]?i[_]:1}else if("number"==typeof i)i&=16777215,this.model="rgb",this.color=[i>>16&255,i>>8&255,255&i],this.valpha=1;else{this.valpha=1;var P=Object.keys(i);"alpha"in i&&(P.splice(P.indexOf("alpha"),1),this.valpha="number"==typeof i.alpha?i.alpha:0);var I=P.sort().join("");if(!(I in JR))throw new Error("Unable to parse color from object: "+JSON.stringify(i));this.model=JR[I];var H=$R[this.model].labels,W=[];for(m=0;m<H.length;m++)W.push(i[H[m]]);this.color=rL(W)}if(KR[this.model])for(_=$R[this.model].channels,m=0;m<_;m++){var q=KR[this.model][m];q&&(this.color[m]=q(this.color[m]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}function tL(i,g,m){return(i=Array.isArray(i)?i:[i]).forEach((function(i){(KR[i]||(KR[i]=[]))[g]=m})),i=i[0],function(_){var b;return arguments.length?(m&&(_=m(_)),(b=this[i]()).color[g]=_,b):(b=this[i]().color[g],m&&(b=m(b)),b)}}function nL(i){return function(g){return Math.max(0,Math.min(i,g))}}function rL(i,g){for(var m=0;m<g;m++)"number"!=typeof i[m]&&(i[m]=0);return i}eL.prototype={toString:function(){return this.string()},toJSON:function(){return this[this.model]()},string:function(i){var g=this.model in ZR.to?this:this.rgb(),m=1===(g=g.round("number"==typeof i?i:1)).valpha?g.color:g.color.concat(this.valpha);return ZR.to[g.model](m)},percentString:function(i){var g=this.rgb().round("number"==typeof i?i:1),m=1===g.valpha?g.color:g.color.concat(this.valpha);return ZR.to.rgb.percent(m)},array:function(){return 1===this.valpha?this.color.slice():this.color.concat(this.valpha)},object:function(){for(var i={},g=$R[this.model].channels,m=$R[this.model].labels,_=0;_<g;_++)i[m[_]]=this.color[_];return 1!==this.valpha&&(i.alpha=this.valpha),i},unitArray:function(){var i=this.rgb().color;return i[0]/=255,i[1]/=255,i[2]/=255,1!==this.valpha&&i.push(this.valpha),i},unitObject:function(){var i=this.rgb().object();return i.r/=255,i.g/=255,i.b/=255,1!==this.valpha&&(i.alpha=this.valpha),i},round:function(i){return i=Math.max(i||0,0),new eL(this.color.map(function(i){return function(g){return function(i,g){return Number(i.toFixed(g))}(g,i)}}(i)).concat(this.valpha),this.model)},alpha:function(i){return arguments.length?new eL(this.color.concat(Math.max(0,Math.min(1,i))),this.model):this.valpha},red:tL("rgb",0,nL(255)),green:tL("rgb",1,nL(255)),blue:tL("rgb",2,nL(255)),hue:tL(["hsl","hsv","hsl","hwb","hcg"],0,(function(i){return(i%360+360)%360})),saturationl:tL("hsl",1,nL(100)),lightness:tL("hsl",2,nL(100)),saturationv:tL("hsv",1,nL(100)),value:tL("hsv",2,nL(100)),chroma:tL("hcg",1,nL(100)),gray:tL("hcg",2,nL(100)),white:tL("hwb",1,nL(100)),wblack:tL("hwb",2,nL(100)),cyan:tL("cmyk",0,nL(100)),magenta:tL("cmyk",1,nL(100)),yellow:tL("cmyk",2,nL(100)),black:tL("cmyk",3,nL(100)),x:tL("xyz",0,nL(100)),y:tL("xyz",1,nL(100)),z:tL("xyz",2,nL(100)),l:tL("lab",0,nL(100)),a:tL("lab",1),b:tL("lab",2),keyword:function(i){return arguments.length?new eL(i):$R[this.model].keyword(this.color)},hex:function(i){return arguments.length?new eL(i):ZR.to.hex(this.rgb().round().color)},rgbNumber:function(){var i=this.rgb().color;return(255&i[0])<<16|(255&i[1])<<8|255&i[2]},luminosity:function(){for(var i=this.rgb().color,g=[],m=0;m<i.length;m++){var _=i[m]/255;g[m]=_<=.03928?_/12.92:Math.pow((_+.055)/1.055,2.4)}return.2126*g[0]+.7152*g[1]+.0722*g[2]},contrast:function(i){var g=this.luminosity(),m=i.luminosity();return g>m?(g+.05)/(m+.05):(m+.05)/(g+.05)},level:function(i){var g=this.contrast(i);return g>=7.1?"AAA":g>=4.5?"AA":""},isDark:function(){var i=this.rgb().color;return(299*i[0]+587*i[1]+114*i[2])/1e3<128},isLight:function(){return!this.isDark()},negate:function(){for(var i=this.rgb(),g=0;g<3;g++)i.color[g]=255-i.color[g];return i},lighten:function(i){var g=this.hsl();return g.color[2]+=g.color[2]*i,g},darken:function(i){var g=this.hsl();return g.color[2]-=g.color[2]*i,g},saturate:function(i){var g=this.hsl();return g.color[1]+=g.color[1]*i,g},desaturate:function(i){var g=this.hsl();return g.color[1]-=g.color[1]*i,g},whiten:function(i){var g=this.hwb();return g.color[1]+=g.color[1]*i,g},blacken:function(i){var g=this.hwb();return g.color[2]+=g.color[2]*i,g},grayscale:function(){var i=this.rgb().color,g=.3*i[0]+.59*i[1]+.11*i[2];return eL.rgb(g,g,g)},fade:function(i){return this.alpha(this.valpha-this.valpha*i)},opaquer:function(i){return this.alpha(this.valpha+this.valpha*i)},rotate:function(i){var g=this.hsl(),m=g.color[0];return g.color[0]=m=(m=(m+i)%360)<0?360+m:m,g},mix:function(i,g){if(!i||!i.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof i);var m=i.rgb(),_=this.rgb(),b=void 0===g?.5:g,T=2*b-1,P=m.alpha()-_.alpha(),I=((T*P===-1?T:(T+P)/(1+T*P))+1)/2,H=1-I;return eL.rgb(I*m.red()+H*_.red(),I*m.green()+H*_.green(),I*m.blue()+H*_.blue(),m.alpha()*b+_.alpha()*(1-b))}},Object.keys($R).forEach((function(i){if(-1===QR.indexOf(i)){var g=$R[i].channels;eL.prototype[i]=function(){if(this.model===i)return new eL(this);if(arguments.length)return new eL(arguments,i);var m,_="number"==typeof arguments[g]?g:this.valpha;return new eL((m=$R[this.model][i].raw(this.color),Array.isArray(m)?m:[m]).concat(_),i)},eL[i]=function(m){return"number"==typeof m&&(m=rL(YR.call(arguments),g)),new eL(m,i)}}}));var iL=Gm(eL);let oL;const sL={width:100,height:10};let aL=!1;try{const i=new OffscreenCanvas(1,1);i.getContext("2d").fillText("hello",0,0),aL=!0}catch(i){aL=!1}function lL(){if(!oL){const{width:i,height:g}=sL;aL?oL=new OffscreenCanvas(i,g):(oL=document.createElement("canvas"),oL.width=i,oL.height=g)}return oL}class ColorIn{constructor(i,g={}){if(!Array.isArray(i))return void console.error("colors is not array");if(i.length<2)return void console.error("colors.length should >1");this.colors=i;let m=1/0,_=-1/0;for(let g=0,b=i.length;g<b;g++){const b=i[g][0];m=Math.min(b,m),_=Math.max(b,_)}this.min=m,this.max=_,this.valueOffset=this.max-this.min,this.options=Object.assign({},sL,g),this._initImgData()}getImageData(){return this.imgData}_initImgData(){const i=lL(),{width:g,height:m}=this.options;i.width=g,i.height=m;const _=i.getContext("2d");_.clearRect(0,0,i.width,i.height);const b=_.createLinearGradient(0,0,i.width,0),{colors:T,valueOffset:P}=this;for(let i=0,g=T.length;i<g;i++){const[g,m]=T[i];b.addColorStop((g-this.min)/P,m)}_.fillStyle=b,_.fillRect(0,0,i.width,i.height),this.imgData=_.getImageData(0,0,i.width,i.height)}getColor(i){i=Math.max(this.min,i),i=Math.min(i,this.max);let g=Math.round((i-this.min)/this.valueOffset*this.imgData.width);g=Math.min(g,this.imgData.width-1);const m=4*g;return[this.imgData.data[m],this.imgData.data[m+1],this.imgData.data[m+2],this.imgData.data[m+3]]}}var hL;function cL(i){return null==i}function uL(i){return!cL(i)}function fL(i){return""===i}function dL(i,g){var m,_,b;if(wL(i)){var T,P=i.stops&&"object"==typeof i.stops[0][0],I=P||uL(i.property),H=P||!I,W=i.type||g||"exponential";if("exponential"===W)T=mL;else if("interval"===W)T=gL;else if("categorical"===W)T=pL;else if("identity"===W)T=_L;else if("color-interpolate"===W)T=yL;else{if("calculate-expression"!==W)throw new Error('Unknown function type "'+W+'"');T=vL}if(P){var q={},$=[];for(let g=0;g<i.stops.length;g++){var ye=i.stops[g];void 0===q[ye[0].zoom]&&(q[ye[0].zoom]={zoom:ye[0].zoom,type:i.type,property:i.property,default:i.default,stops:[]}),q[ye[0].zoom].stops.push([ye[0].value,ye[1]])}for(let i in q)$.push([q[i].zoom,dL(q[i])]);m=function(g,m){const _=mL({stops:$,base:i.base},g)(g,m);return"function"==typeof _?_(g,m):_},_=!1,b=!1}else H?(m=function(g){const m=T(i,g);return"function"==typeof m?m(g):m},_=!0,b=!1):(m=function(g,m){const _=T(i,m?m[i.property]:null);return"function"==typeof _?_(g,m):_},_=!1,b=!0)}else m=function(){return i},_=!0,b=!0;return m.isZoomConstant=b,m.isFeatureConstant=_,m}function pL(i,g){for(let m=0;m<i.stops.length;m++)if(g===i.stops[m][0])return i.stops[m][1];return i.default}function gL(i,g){for(var m=0;m<i.stops.length&&!(g<i.stops[m][0]);m++);return i.stops[Math.max(m-1,0)][1]}function mL(i,g){for(var m=uL(i.base)&&!fL(i.base)?i.base:1,_=0;!(_>=i.stops.length||g<=i.stops[_][0]);)_++;return 0===_?i.stops[_][1]:_===i.stops.length?i.stops[_-1][1]:xL(g,m,i.stops[_-1][0],i.stops[_][0],i.stops[_-1][1],i.stops[_][1])}"function"==typeof Map&&(hL=new Map);const AL={width:100,height:1};function yL(i,g){const m=i.stops;if(m&&m.length>1){let i;if(hL){const g=JSON.stringify(m);if(!hL.has(g)){const i=new ColorIn(m,AL);hL.set(g,i)}i=hL.get(g)}else i=new ColorIn(m,AL);const[_,b,T,P]=i.getColor(g);return[_/255,b/255,T/255,P/255]}return m&&1===m.length?m[0][1]:null}function _L(i,g){return function(i,g,m){return uL(i)?i:uL(g)?g:uL(m)?m:null}(g,i.default)}function vL(i,g){const m=String(i.property),_=i.expression,b=g;function T(g){return cL(g)||fL(g)||isNaN(g)?i.default:g}if(!uL(g)||fL(g)||isNaN(g)||g<0)return T(i.default);{const g=function i(g,m,_){const b=Number(_),T=String(m);return Array.isArray(g)?g.map((g=>i(g,T,b))):g===T?b:g}(_,m,b);return T(function g(m){if(!Array.isArray(m)){if("number"==typeof m)return m;throw new Error("Invalid expression format")}{const _=m[0];if(!["+","-","*","/"].includes(_))throw new Error(`Unknown operator: ${_}`);const b=m.slice(1).map((i=>g(i)));switch(_){case"+":return b.reduce(((i,g)=>i+g),0);case"-":return b.reduce(((i,g)=>i-g));case"*":return b.reduce(((i,g)=>i*g),1);case"/":return b.some((i=>0===i))?i.default:b.reduce(((i,g)=>i/g));default:throw new Error(`Unsupported operator: ${_}`)}}}(g))}}function xL(i,g,m,_,b,T){return"function"==typeof b?function(){var P=b.apply(void 0,arguments),I=T.apply(void 0,arguments);return xL(i,g,m,_,P,I)}:b.length?function(i,g,m,_,b,T){var P=[];for(let I=0;I<b.length;I++)P[I]=bL(i,g,m,_,b[I],T[I]);return P}(i,g,m,_,b,T):bL(i,g,m,_,b,T)}function bL(i,g,m,_,b,T){var P,I=_-m,H=i-m;return b*(1-(P=1===g?H/I:(Math.pow(g,H)-1)/(Math.pow(g,I)-1)))+T*P}function wL(i){return i&&"object"==typeof i&&(i.stops||i.property&&"identity"===i.type||i.expression&&"calculate-expression"===i.type)}function TL(i){for(const g in i)if(wL(i[g]))return!0;return!1}function SL(i){return PL(i,"exponential")}function ML(i){return PL(i,"interval")}function CL(i,g){if(!i)return null;var m=!1;if(Array.isArray(i)){var _,b=[];for(let T=0;T<i.length;T++)(_=CL(i[T],g))?(b.push(_),m=!0):b.push(i[T]);return m?b:i}var T,P={__fn_types_loaded:!0},I=[];for(T in i)i.hasOwnProperty(T)&&I.push(T);const H=function(i){Object.defineProperty(P,i,{get:function(){return this["__fn_"+i]||(this["__fn_"+i]=SL(this["_"+i])),this["__fn_"+i].apply(this,g())},set:function(g){this["_"+i]=g},configurable:!0,enumerable:!0})};for(let g=0,_=I.length;g<_;g++)wL(i[T=I[g]])?(m=!0,P["_"+T]=i[T],H(T)):P[T]=i[T];return m?P:i}function PL(i,g){if(!wL(i))return function(){return i};let m=!0,_=!0;const b=(i=JSON.parse(JSON.stringify(i))).stops;if(b)for(let i=0;i<b.length;i++)if(wL(b[i][1])){const T=PL(b[i][1],g);m=m&&T.isZoomConstant,_=_&&T.isFeatureConstant,b[i]=[b[i][0],T]}const T=dL(i,g);return T.isZoomConstant=m&&T.isZoomConstant,T.isFeatureConstant=_&&T.isFeatureConstant,T}
/*!
  * Contains code from jquery.easing
  * BSD License
  * https://github.com/gdsmith/jquery.easing/
  */var IL=Math.pow,kL=Math.sqrt,OL=Math.sin,EL=Math.cos,RL=Math.PI,LL=1.70158,DL=1.525*LL,FL=LL+1,NL=2*RL/3,HL=2*RL/4.5;function BL(i){var g=7.5625,m=2.75;return i<1/m?g*i*i:i<2/m?g*(i-=1.5/m)*i+.75:i<2.5/m?g*(i-=2.25/m)*i+.9375:g*(i-=2.625/m)*i+.984375}function zL(i,g){switch(i=i.toLowerCase()){case"swing":return function(i){return VL(i)}(g);case"easeinquad":return VL(g);case"easeoutquad":return function(i){return 1-(1-i)*(1-i)}(g);case"easeinoutquad":return function(i){return i<.5?2*i*i:1-IL(-2*i+2,2)/2}(g);case"easeincubic":return function(i){return i*i*i}(g);case"easeoutcubic":return function(i){return 1-IL(1-i,3)}(g);case"easeinoutcubic":return function(i){return i<.5?4*i*i*i:1-IL(-2*i+2,3)/2}(g);case"easeinquart":return function(i){return i*i*i*i}(g);case"easeoutquart":return function(i){return 1-IL(1-i,4)}(g);case"easeinoutquart":return function(i){return i<.5?8*i*i*i*i:1-IL(-2*i+2,4)/2}(g);case"easeinquint":return function(i){return i*i*i*i*i}(g);case"easeoutquint":return function(i){return 1-IL(1-i,5)}(g);case"easeinoutquint":return function(i){return i<.5?16*i*i*i*i*i:1-IL(-2*i+2,5)/2}(g);case"easeinsine":return function(i){return 1-EL(i*RL/2)}(g);case"easeoutsine":return function(i){return OL(i*RL/2)}(g);case"easeinoutsine":return function(i){return-(EL(RL*i)-1)/2}(g);case"easeinexpo":return function(i){return 0===i?0:IL(2,10*i-10)}(g);case"easeoutexpo":return function(i){return 1===i?1:1-IL(2,-10*i)}(g);case"easeinoutexpo":return function(i){return 0===i?0:1===i?1:i<.5?IL(2,20*i-10)/2:(2-IL(2,-20*i+10))/2}(g);case"easeincirc":return function(i){return 1-kL(1-IL(i,2))}(g);case"easeoutcirc":return function(i){return kL(1-IL(i-1,2))}(g);case"easeinoutcirc":return function(i){return i<.5?(1-kL(1-IL(2*i,2)))/2:(kL(1-IL(-2*i+2,2))+1)/2}(g);case"easeinelastic":return function(i){return 0===i?0:1===i?1:-IL(2,10*i-10)*OL((10*i-10.75)*NL)}(g);case"easeoutelastic":return function(i){return 0===i?0:1===i?1:IL(2,-10*i)*OL((10*i-.75)*NL)+1}(g);case"easeinoutelastic":return function(i){return 0===i?0:1===i?1:i<.5?-IL(2,20*i-10)*OL((20*i-11.125)*HL)/2:IL(2,-20*i+10)*OL((20*i-11.125)*HL)/2+1}(g);case"easeinback":return function(i){return FL*i*i*i-LL*i*i}(g);case"easeoutback":return function(i){return 1+FL*IL(i-1,3)+LL*IL(i-1,2)}(g);case"easeinoutback":return function(i){return i<.5?IL(2*i,2)*(7.189819*i-DL)/2:(IL(2*i-2,2)*((DL+1)*(2*i-2)+DL)+2)/2}(g);case"easeinbounce":return function(i){return 1-BL(1-i)}(g);case"easeoutbounce":return function(i){return BL(i)}(g);case"easeinoutbounce":return function(i){return i<.5?(1-BL(1-2*i))/2:(1+BL(2*i-1))/2}
/*!
      Feature Filter by

      (c) mapbox 2016 and maptalks 2018
      www.mapbox.com | www.maptalks.org
      License: MIT, header required.
  */(g)}throw new Error("Unsupported easing function:"+i)}function VL(i){return i*i}const UL=["Unknown","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"];function GL(i){return new Function("f",`var p = (f && f.properties || {}); return ${jL(i)}`)}function jL(i){if(!i)return"true";const g=i[0];if(i.length<=1)return"any"===g?"false":"true";const m="=="===g?qL(i[1],i[2],"===",!1):"!="===g?qL(i[1],i[2],"!==",!1):"<"===g||">"===g||"<="===g||">="===g?qL(i[1],i[2],g,!0):"any"===g?ZL(i.slice(1),"||"):"all"===g?ZL(i.slice(1),"&&"):"none"===g?QL(ZL(i.slice(1),"||")):"in"===g?$L(i[1],i.slice(2)):"!in"===g?QL($L(i[1],i.slice(2))):"has"===g?YL(i[1]):"!has"===g?QL(YL(i[1])):"contains"===g?function(i,g,m){const _=WL(i);return void 0!==m?`(${_} + '').indexOf("${g}") === ${m}`:`(${_} + '').indexOf("${g}") >= 0`}(i[1],i[2],i[3]):"true";return`(${m})`}function WL(i){return"$"===i[0]?"f."+i.substring(1):"p["+JSON.stringify(i)+"]"}function qL(i,g,m,_){if("object"==typeof(b=i)&&b&&i.op)return function(i,g,m,_){const b=i.property,T=i.op;let P=WL(b);return"length"!==T?(console.error(`not support ${T} op`),"false"):(P=`((${P}+='').length)`,XL(P,b,g,m,_))}(i,g,m,_);var b;return XL(WL(i),i,g,m,_)}function XL(i,g,m,_,b){const T="$type"===g?UL.indexOf(m):JSON.stringify(m);return(b?`typeof ${i}=== typeof ${T}&&`:"")+i+_+T}function ZL(i,g){return i.map(jL).join(g)}function $L(i,g){"$type"===i&&(g=g.map((i=>UL.indexOf(i))));const m=JSON.stringify(g.sort(JL)),_=WL(i);return g.length<=200?`${m}.indexOf(${_}) !== -1`:`function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(${_}, ${m},0,${g.length-1})`}function YL(i){return"$id"===i?'"id" in f':`${JSON.stringify(i)} in p`}function QL(i){return`!(${i})`}function JL(i,g){return i<g?-1:i>g?1:0}function KL(i){if(!Array.isArray(i))return KL([i]);const g=[];for(let m=0;m<i.length;m++){let _;_=!0===i[m].filter?function(){return!0}:GL(i[m].filter),g.push(eD({},i[m],{filter:_}))}return g}function eD(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}function tD(){}const nD=tD.prototype;nD.getType=function(){return Object.getPrototypeOf(this).constructor.type},nD.isVisible=function(){throw new Error("to be implemented.")},nD.prepareRender=function(){throw new Error("to be implemented.")},nD.updateCollision=function(){throw new Error("to be implemented.")},nD.supportRenderMode=function(){throw new Error("to be implemented.")},nD.startFrame=function(){throw new Error("to be implemented.")},nD.endFrame=function(){throw new Error("to be implemented.")},nD.paintTile=function(){throw new Error("to be implemented.")},nD.getShadowMeshes=function(){throw new Error("to be implemented.")},nD.updateSceneConfig=function(){throw new Error("to be implemented.")},nD.updateDataConfig=function(){throw new Error("to be implemented.")},nD.updateSymbol=function(){throw new Error("to be implemented.")},nD.pick=function(){throw new Error("to be implemented.")},nD.resize=function(){throw new Error("to be implemented.")},nD.deleteTile=function(){throw new Error("to be implemented.")},nD.remove=function(){throw new Error("to be implemented.")},nD.needToRedraw=function(){throw new Error("to be implemented.")},nD.needToRetireFrames=function(){throw new Error("to be implemented.")},nD.outline=function(){throw new Error("to be implemented.")},nD.outlineAll=function(){throw new Error("to be implemented.")},nD.needPolygonOffset=function(){throw new Error("to be implemented.")},nD.constructor=tD;const rD=Object.prototype.hasOwnProperty;function iD(i){i.registerPlugin(this)}function oD(i,g,m=2){const _=g&&g.length,b=_?g[0]*m:i.length;let T=sD(i,0,b,m,!0);const P=[];if(!T||T.next===T.prev)return P;let I,H,W;if(_&&(T=function(i,g,m,_){const b=[];for(let m=0,T=g.length;m<T;m++){const P=sD(i,g[m]*_,m<T-1?g[m+1]*_:i.length,_,!1);P===P.next&&(P.steiner=!0),b.push(AD(P))}b.sort(dD);for(let i=0;i<b.length;i++)m=pD(b[i],m);return m}(i,g,T,m)),i.length>80*m){I=1/0,H=1/0;let g=-1/0,_=-1/0;for(let T=m;T<b;T+=m){const m=i[T],b=i[T+1];m<I&&(I=m),b<H&&(H=b),m>g&&(g=m),b>_&&(_=b)}W=Math.max(g-I,_-H),W=0!==W?32767/W:0}return lD(T,P,m,I,H,W,0),P}function sD(i,g,m,_,b){let T;if(b===function(i,g,m,_){let b=0;for(let T=g,P=m-_;T<m;T+=_)b+=(i[P]-i[T])*(i[T+1]+i[P+1]),P=T;return b}(i,g,m,_)>0)for(let b=g;b<m;b+=_)T=PD(b/_|0,i[b],i[b+1],T);else for(let b=m-_;b>=g;b-=_)T=PD(b/_|0,i[b],i[b+1],T);return T&&bD(T,T.next)&&(ID(T),T=T.next),T}function aD(i,g){if(!i)return i;g||(g=i);let m,_=i;do{if(m=!1,_.steiner||!bD(_,_.next)&&0!==xD(_.prev,_,_.next))_=_.next;else{if(ID(_),_=g=_.prev,_===_.next)break;m=!0}}while(m||_!==g);return g}function lD(i,g,m,_,b,T,P){if(!i)return;!P&&T&&function(i,g,m,_){let b=i;do{0===b.z&&(b.z=mD(b.x,b.y,g,m,_)),b.prevZ=b.prev,b.nextZ=b.next,b=b.next}while(b!==i);b.prevZ.nextZ=null,b.prevZ=null,function(i){let g,m=1;do{let _,b=i;i=null;let T=null;for(g=0;b;){g++;let P=b,I=0;for(let i=0;i<m&&(I++,P=P.nextZ,P);i++);let H=m;for(;I>0||H>0&&P;)0!==I&&(0===H||!P||b.z<=P.z)?(_=b,b=b.nextZ,I--):(_=P,P=P.nextZ,H--),T?T.nextZ=_:i=_,_.prevZ=T,T=_;b=P}T.nextZ=null,m*=2}while(g>1)}(b)}(i,_,b,T);let I=i;for(;i.prev!==i.next;){const H=i.prev,W=i.next;if(T?cD(i,_,b,T):hD(i))g.push(H.i,i.i,W.i),ID(i),i=W.next,I=W.next;else if((i=W)===I){P?1===P?lD(i=uD(aD(i),g),g,m,_,b,T,2):2===P&&fD(i,g,m,_,b,T):lD(aD(i),g,m,_,b,T,1);break}}}function hD(i){const g=i.prev,m=i,_=i.next;if(xD(g,m,_)>=0)return!1;const b=g.x,T=m.x,P=_.x,I=g.y,H=m.y,W=_.y,q=Math.min(b,T,P),$=Math.min(I,H,W),ye=Math.max(b,T,P),Re=Math.max(I,H,W);let Be=_.next;for(;Be!==g;){if(Be.x>=q&&Be.x<=ye&&Be.y>=$&&Be.y<=Re&&_D(b,I,T,H,P,W,Be.x,Be.y)&&xD(Be.prev,Be,Be.next)>=0)return!1;Be=Be.next}return!0}function cD(i,g,m,_){const b=i.prev,T=i,P=i.next;if(xD(b,T,P)>=0)return!1;const I=b.x,H=T.x,W=P.x,q=b.y,$=T.y,ye=P.y,Re=Math.min(I,H,W),Be=Math.min(q,$,ye),Ge=Math.max(I,H,W),je=Math.max(q,$,ye),Xe=mD(Re,Be,g,m,_),Ze=mD(Ge,je,g,m,_);let Ye=i.prevZ,Qe=i.nextZ;for(;Ye&&Ye.z>=Xe&&Qe&&Qe.z<=Ze;){if(Ye.x>=Re&&Ye.x<=Ge&&Ye.y>=Be&&Ye.y<=je&&Ye!==b&&Ye!==P&&_D(I,q,H,$,W,ye,Ye.x,Ye.y)&&xD(Ye.prev,Ye,Ye.next)>=0)return!1;if(Ye=Ye.prevZ,Qe.x>=Re&&Qe.x<=Ge&&Qe.y>=Be&&Qe.y<=je&&Qe!==b&&Qe!==P&&_D(I,q,H,$,W,ye,Qe.x,Qe.y)&&xD(Qe.prev,Qe,Qe.next)>=0)return!1;Qe=Qe.nextZ}for(;Ye&&Ye.z>=Xe;){if(Ye.x>=Re&&Ye.x<=Ge&&Ye.y>=Be&&Ye.y<=je&&Ye!==b&&Ye!==P&&_D(I,q,H,$,W,ye,Ye.x,Ye.y)&&xD(Ye.prev,Ye,Ye.next)>=0)return!1;Ye=Ye.prevZ}for(;Qe&&Qe.z<=Ze;){if(Qe.x>=Re&&Qe.x<=Ge&&Qe.y>=Be&&Qe.y<=je&&Qe!==b&&Qe!==P&&_D(I,q,H,$,W,ye,Qe.x,Qe.y)&&xD(Qe.prev,Qe,Qe.next)>=0)return!1;Qe=Qe.nextZ}return!0}function uD(i,g){let m=i;do{const _=m.prev,b=m.next.next;!bD(_,b)&&wD(_,m,m.next,b)&&MD(_,b)&&MD(b,_)&&(g.push(_.i,m.i,b.i),ID(m),ID(m.next),m=i=b),m=m.next}while(m!==i);return aD(m)}function fD(i,g,m,_,b,T){let P=i;do{let i=P.next.next;for(;i!==P.prev;){if(P.i!==i.i&&vD(P,i)){let I=CD(P,i);return P=aD(P,P.next),I=aD(I,I.next),lD(P,g,m,_,b,T,0),void lD(I,g,m,_,b,T,0)}i=i.next}P=P.next}while(P!==i)}function dD(i,g){let m=i.x-g.x;if(0===m&&(m=i.y-g.y,0===m)){m=(i.next.y-i.y)/(i.next.x-i.x)-(g.next.y-g.y)/(g.next.x-g.x)}return m}function pD(i,g){const m=function(i,g){let m=g;const _=i.x,b=i.y;let T,P=-1/0;if(bD(i,m))return m;do{if(bD(i,m.next))return m.next;if(b<=m.y&&b>=m.next.y&&m.next.y!==m.y){const i=m.x+(b-m.y)*(m.next.x-m.x)/(m.next.y-m.y);if(i<=_&&i>P&&(P=i,T=m.x<m.next.x?m:m.next,i===_))return T}m=m.next}while(m!==g);if(!T)return null;const I=T,H=T.x,W=T.y;let q=1/0;m=T;do{if(_>=m.x&&m.x>=H&&_!==m.x&&yD(b<W?_:P,b,H,W,b<W?P:_,b,m.x,m.y)){const g=Math.abs(b-m.y)/(_-m.x);MD(m,i)&&(g<q||g===q&&(m.x>T.x||m.x===T.x&&gD(T,m)))&&(T=m,q=g)}m=m.next}while(m!==I);return T}(i,g);if(!m)return g;const _=CD(m,i);return aD(_,_.next),aD(m,m.next)}function gD(i,g){return xD(i.prev,i,g.prev)<0&&xD(g.next,i,i.next)<0}function mD(i,g,m,_,b){return(i=1431655765&((i=858993459&((i=252645135&((i=16711935&((i=(i-m)*b|0)|i<<8))|i<<4))|i<<2))|i<<1))|(g=1431655765&((g=858993459&((g=252645135&((g=16711935&((g=(g-_)*b|0)|g<<8))|g<<4))|g<<2))|g<<1))<<1}function AD(i){let g=i,m=i;do{(g.x<m.x||g.x===m.x&&g.y<m.y)&&(m=g),g=g.next}while(g!==i);return m}function yD(i,g,m,_,b,T,P,I){return(b-P)*(g-I)>=(i-P)*(T-I)&&(i-P)*(_-I)>=(m-P)*(g-I)&&(m-P)*(T-I)>=(b-P)*(_-I)}function _D(i,g,m,_,b,T,P,I){return!(i===P&&g===I)&&yD(i,g,m,_,b,T,P,I)}function vD(i,g){return i.next.i!==g.i&&i.prev.i!==g.i&&!function(i,g){let m=i;do{if(m.i!==i.i&&m.next.i!==i.i&&m.i!==g.i&&m.next.i!==g.i&&wD(m,m.next,i,g))return!0;m=m.next}while(m!==i);return!1}(i,g)&&(MD(i,g)&&MD(g,i)&&function(i,g){let m=i,_=!1;const b=(i.x+g.x)/2,T=(i.y+g.y)/2;do{m.y>T!=m.next.y>T&&m.next.y!==m.y&&b<(m.next.x-m.x)*(T-m.y)/(m.next.y-m.y)+m.x&&(_=!_),m=m.next}while(m!==i);return _}(i,g)&&(xD(i.prev,i,g.prev)||xD(i,g.prev,g))||bD(i,g)&&xD(i.prev,i,i.next)>0&&xD(g.prev,g,g.next)>0)}function xD(i,g,m){return(g.y-i.y)*(m.x-g.x)-(g.x-i.x)*(m.y-g.y)}function bD(i,g){return i.x===g.x&&i.y===g.y}function wD(i,g,m,_){const b=SD(xD(i,g,m)),T=SD(xD(i,g,_)),P=SD(xD(m,_,i)),I=SD(xD(m,_,g));return b!==T&&P!==I||(!(0!==b||!TD(i,m,g))||(!(0!==T||!TD(i,_,g))||(!(0!==P||!TD(m,i,_))||!(0!==I||!TD(m,g,_)))))}function TD(i,g,m){return g.x<=Math.max(i.x,m.x)&&g.x>=Math.min(i.x,m.x)&&g.y<=Math.max(i.y,m.y)&&g.y>=Math.min(i.y,m.y)}function SD(i){return i>0?1:i<0?-1:0}function MD(i,g){return xD(i.prev,i,i.next)<0?xD(i,g,i.next)>=0&&xD(i,i.prev,g)>=0:xD(i,g,i.prev)<0||xD(i,i.next,g)<0}function CD(i,g){const m=kD(i.i,i.x,i.y),_=kD(g.i,g.x,g.y),b=i.next,T=g.prev;return i.next=g,g.prev=i,m.next=b,b.prev=m,_.next=m,m.prev=_,T.next=_,_.prev=T,_}function PD(i,g,m,_){const b=kD(i,g,m);return _?(b.next=_.next,b.prev=_,_.next.prev=b,_.next=b):(b.prev=b,b.next=b),b}function ID(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function kD(i,g,m){return{i,x:g,y:m,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function OD(i,g,m,_,b){ED(i,g,m||0,_||i.length-1,b||LD)}function ED(i,g,m,_,b){for(;_>m;){if(_-m>600){var T=_-m+1,P=g-m+1,I=Math.log(T),H=.5*Math.exp(2*I/3),W=.5*Math.sqrt(I*H*(T-H)/T)*(P-T/2<0?-1:1);ED(i,g,Math.max(m,Math.floor(g-P*H/T+W)),Math.min(_,Math.floor(g+(T-P)*H/T+W)),b)}var q=i[g],$=m,ye=_;for(RD(i,m,g),b(i[_],q)>0&&RD(i,m,_);$<ye;){for(RD(i,$,ye),$++,ye--;b(i[$],q)<0;)$++;for(;b(i[ye],q)>0;)ye--}0===b(i[m],q)?RD(i,m,ye):RD(i,++ye,_),ye<=g&&(m=ye+1),g<=ye&&(_=ye-1)}}function RD(i,g,m){var _=i[g];i[g]=i[m],i[m]=_}function LD(i,g){return i<g?-1:i>g?1:0}tD.extend=function(i,g){const m=function(){this.init&&this.init()},_=Object.create(nD);_.constructor=m,m.prototype=_,m.type=i;for(const i in g)rD.call(g,i)&&(m.prototype[i]=g[i]);return m.registerAt=iD.bind(m),m};class RBush{constructor(i=9){this._maxEntries=Math.max(4,i),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()}all(){return this._all(this.data,[])}search(i){let g=this.data;const m=[];if(!qD(i,g))return m;const _=this.toBBox,b=[];for(;g;){for(let T=0;T<g.children.length;T++){const P=g.children[T],I=g.leaf?_(P):P;qD(i,I)&&(g.leaf?m.push(P):WD(i,I)?this._all(P,m):b.push(P))}g=b.pop()}return m}collides(i){let g=this.data;if(!qD(i,g))return!1;const m=[];for(;g;){for(let _=0;_<g.children.length;_++){const b=g.children[_],T=g.leaf?this.toBBox(b):b;if(qD(i,T)){if(g.leaf||WD(i,T))return!0;m.push(b)}}g=m.pop()}return!1}load(i){if(!i||!i.length)return this;if(i.length<this._minEntries){for(let g=0;g<i.length;g++)this.insert(i[g]);return this}let g=this._build(i.slice(),0,i.length-1,0);if(this.data.children.length)if(this.data.height===g.height)this._splitRoot(this.data,g);else{if(this.data.height<g.height){const i=this.data;this.data=g,g=i}this._insert(g,this.data.height-g.height-1,!0)}else this.data=g;return this}insert(i){return i&&this._insert(i,this.data.height-1),this}clear(){return this.data=XD([]),this}remove(i,g){if(!i)return this;let m=this.data;const _=this.toBBox(i),b=[],T=[];let P,I,H;for(;m||b.length;){if(m||(m=b.pop(),I=b[b.length-1],P=T.pop(),H=!0),m.leaf){const _=DD(i,m.children,g);if(-1!==_)return m.children.splice(_,1),b.push(m),this._condense(b),this}H||m.leaf||!WD(m,_)?I?(P++,m=I.children[P],H=!1):m=null:(b.push(m),T.push(P),P=0,I=m,m=m.children[0])}return this}toBBox(i){return i}compareMinX(i,g){return i.minX-g.minX}compareMinY(i,g){return i.minY-g.minY}toJSON(){return this.data}fromJSON(i){return this.data=i,this}_all(i,g){const m=[];for(;i;)i.leaf?g.push(...i.children):m.push(...i.children),i=m.pop();return g}_build(i,g,m,_){const b=m-g+1;let T,P=this._maxEntries;if(b<=P)return T=XD(i.slice(g,m+1)),FD(T,this.toBBox),T;_||(_=Math.ceil(Math.log(b)/Math.log(P)),P=Math.ceil(b/Math.pow(P,_-1))),T=XD([]),T.leaf=!1,T.height=_;const I=Math.ceil(b/P),H=I*Math.ceil(Math.sqrt(P));ZD(i,g,m,H,this.compareMinX);for(let b=g;b<=m;b+=H){const g=Math.min(b+H-1,m);ZD(i,b,g,I,this.compareMinY);for(let m=b;m<=g;m+=I){const b=Math.min(m+I-1,g);T.children.push(this._build(i,m,b,_-1))}}return FD(T,this.toBBox),T}_chooseSubtree(i,g,m,_){for(;_.push(g),!g.leaf&&_.length-1!==m;){let m,_=1/0,b=1/0;for(let T=0;T<g.children.length;T++){const P=g.children[T],I=VD(P),H=GD(i,P)-I;H<b?(b=H,_=I<_?I:_,m=P):H===b&&I<_&&(_=I,m=P)}g=m||g.children[0]}return g}_insert(i,g,m){const _=m?i:this.toBBox(i),b=[],T=this._chooseSubtree(_,this.data,g,b);for(T.children.push(i),HD(T,_);g>=0&&b[g].children.length>this._maxEntries;)this._split(b,g),g--;this._adjustParentBBoxes(_,b,g)}_split(i,g){const m=i[g],_=m.children.length,b=this._minEntries;this._chooseSplitAxis(m,b,_);const T=this._chooseSplitIndex(m,b,_),P=XD(m.children.splice(T,m.children.length-T));P.height=m.height,P.leaf=m.leaf,FD(m,this.toBBox),FD(P,this.toBBox),g?i[g-1].children.push(P):this._splitRoot(m,P)}_splitRoot(i,g){this.data=XD([i,g]),this.data.height=i.height+1,this.data.leaf=!1,FD(this.data,this.toBBox)}_chooseSplitIndex(i,g,m){let _,b=1/0,T=1/0;for(let P=g;P<=m-g;P++){const g=ND(i,0,P,this.toBBox),I=ND(i,P,m,this.toBBox),H=jD(g,I),W=VD(g)+VD(I);H<b?(b=H,_=P,T=W<T?W:T):H===b&&W<T&&(T=W,_=P)}return _||m-g}_chooseSplitAxis(i,g,m){const _=i.leaf?this.compareMinX:BD,b=i.leaf?this.compareMinY:zD;this._allDistMargin(i,g,m,_)<this._allDistMargin(i,g,m,b)&&i.children.sort(_)}_allDistMargin(i,g,m,_){i.children.sort(_);const b=this.toBBox,T=ND(i,0,g,b),P=ND(i,m-g,m,b);let I=UD(T)+UD(P);for(let _=g;_<m-g;_++){const g=i.children[_];HD(T,i.leaf?b(g):g),I+=UD(T)}for(let _=m-g-1;_>=g;_--){const g=i.children[_];HD(P,i.leaf?b(g):g),I+=UD(P)}return I}_adjustParentBBoxes(i,g,m){for(let _=m;_>=0;_--)HD(g[_],i)}_condense(i){for(let g,m=i.length-1;m>=0;m--)0===i[m].children.length?m>0?(g=i[m-1].children,g.splice(g.indexOf(i[m]),1)):this.clear():FD(i[m],this.toBBox)}}function DD(i,g,m){if(!m)return g.indexOf(i);for(let _=0;_<g.length;_++)if(m(i,g[_]))return _;return-1}function FD(i,g){ND(i,0,i.children.length,g,i)}function ND(i,g,m,_,b){b||(b=XD(null)),b.minX=1/0,b.minY=1/0,b.maxX=-1/0,b.maxY=-1/0;for(let T=g;T<m;T++){const g=i.children[T];HD(b,i.leaf?_(g):g)}return b}function HD(i,g){return i.minX=Math.min(i.minX,g.minX),i.minY=Math.min(i.minY,g.minY),i.maxX=Math.max(i.maxX,g.maxX),i.maxY=Math.max(i.maxY,g.maxY),i}function BD(i,g){return i.minX-g.minX}function zD(i,g){return i.minY-g.minY}function VD(i){return(i.maxX-i.minX)*(i.maxY-i.minY)}function UD(i){return i.maxX-i.minX+(i.maxY-i.minY)}function GD(i,g){return(Math.max(g.maxX,i.maxX)-Math.min(g.minX,i.minX))*(Math.max(g.maxY,i.maxY)-Math.min(g.minY,i.minY))}function jD(i,g){const m=Math.max(i.minX,g.minX),_=Math.max(i.minY,g.minY),b=Math.min(i.maxX,g.maxX),T=Math.min(i.maxY,g.maxY);return Math.max(0,b-m)*Math.max(0,T-_)}function WD(i,g){return i.minX<=g.minX&&i.minY<=g.minY&&g.maxX<=i.maxX&&g.maxY<=i.maxY}function qD(i,g){return g.minX<=i.maxX&&g.minY<=i.maxY&&g.maxX>=i.minX&&g.maxY>=i.minY}function XD(i){return{children:i,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function ZD(i,g,m,_,b){const T=[g,m];for(;T.length;){if((m=T.pop())-(g=T.pop())<=_)continue;const P=g+Math.ceil((m-g)/_/2)*_;OD(i,P,g,m,b),T.push(g,P,P,m)}}
/*!
   * @maptalks/vt v0.109.0
   * LICENSE : undefined
   * (c) 2016-2025 maptalks.org
   */const $D="${",YD=`\nfunction (exports) {\n\n    let canvas;\n    const OPTIONS = {\n        width: 100,\n        height: 10\n    };\n    // const ISNODE = typeof undefined === 'object';\n\n    let offscreenCanvas$1 = false;\n    try {\n        const canvas = new OffscreenCanvas(1, 1);\n        const ctx = canvas.getContext('2d');\n        ctx.fillText('hello', 0, 0);\n        offscreenCanvas$1 = true;\n    } catch (err) {\n        offscreenCanvas$1 = false;\n    }\n\n    function getCanvas() {\n        if (!canvas) {\n            const { width, height } = OPTIONS;\n            if (offscreenCanvas$1) {\n                canvas = new OffscreenCanvas(width, height);\n            } else {\n                canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n            }\n        }\n        return canvas;\n    }\n\n    class ColorIn {\n        constructor(colors, options = {}) {\n            if (!Array.isArray(colors)) {\n                console.error('colors is not array');\n                return;\n            }\n            if (colors.length < 2) {\n                console.error('colors.length should >1');\n                return;\n            }\n            this.colors = colors;\n            let min = Infinity, max = -Infinity;\n            for (let i = 0, len = colors.length; i < len; i++) {\n                const value = colors[i][0];\n                min = Math.min(value, min);\n                max = Math.max(value, max);\n            }\n            this.min = min;\n            this.max = max;\n            this.valueOffset = this.max - this.min;\n            this.options = Object.assign({}, OPTIONS, options);\n            this._initImgData();\n        }\n\n        getImageData() {\n            return this.imgData;\n        }\n\n        _initImgData() {\n            const canvas = getCanvas();\n            const { width, height } = this.options;\n            canvas.width = width;\n            canvas.height = height;\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);\n            const { colors, valueOffset } = this;\n            for (let i = 0, len = colors.length; i < len; i++) {\n                const [stop, color] = colors[i];\n                const s = (stop - this.min) / valueOffset;\n                gradient.addColorStop(s, color);\n            }\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            this.imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        }\n\n        getColor(stop) {\n            stop = Math.max(this.min, stop);\n            stop = Math.min(stop, this.max);\n            const s = (stop - this.min) / this.valueOffset;\n            let x = Math.round(s * this.imgData.width);\n            x = Math.min(x, this.imgData.width - 1);\n            const idx = x * 4;\n            const r = this.imgData.data[idx];\n            const g = this.imgData.data[idx + 1];\n            const b = this.imgData.data[idx + 2];\n            const a = this.imgData.data[idx + 3];\n            return [r, g, b, a];\n        }\n    }\n\n    var isMapSupported = typeof Map === 'function';\n    var colorInCache;\n    if (isMapSupported) {\n        colorInCache = new Map();\n    }\n\n\n    function isNull(value) {\n        return value === null || value === undefined;\n    }\n\n    function isNotNull(value) {\n        return !isNull(value);\n    }\n\n    function isEmptyString(value) {\n        return value === '';\n    }\n\n    /*eslint-disable no-var, prefer-const*/\n    function createFunction(parameters, defaultType) {\n        var fun;\n        var isFeatureConstant, isZoomConstant;\n        if (!isFunctionDefinition(parameters)) {\n            fun = function () {\n                return parameters;\n            };\n            isFeatureConstant = true;\n            isZoomConstant = true;\n        } else {\n            var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';\n            var featureDependent = zoomAndFeatureDependent || isNotNull(parameters.property);\n            var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n            var type = parameters.type || defaultType || 'exponential';\n\n            var innerFun;\n            if (type === 'exponential') {\n                innerFun = evaluateExponentialFunction;\n            } else if (type === 'interval') {\n                innerFun = evaluateIntervalFunction;\n            } else if (type === 'categorical') {\n                innerFun = evaluateCategoricalFunction;\n            } else if (type === 'identity') {\n                innerFun = evaluateIdentityFunction;\n            } else if (type === 'color-interpolate') {\n                innerFun = evaluateColorInterpolateFunction;\n            } else if (type === 'calculate-expression') {\n                innerFun = evaluateCalculateExpressionFunction;\n            } else {\n                throw new Error('Unknown function type "' + type + '"');\n            }\n\n            if (zoomAndFeatureDependent) {\n                var featureFunctions = {};\n                var featureFunctionStops = [];\n                for (let s = 0; s < parameters.stops.length; s++) {\n                    var stop = parameters.stops[s];\n                    if (featureFunctions[stop[0].zoom] === undefined) {\n                        featureFunctions[stop[0].zoom] = {\n                            zoom: stop[0].zoom,\n                            type: parameters.type,\n                            property: parameters.property,\n                            default: parameters.default,\n                            stops: []\n                        };\n                    }\n                    featureFunctions[stop[0].zoom].stops.push([stop[0].value, stop[1]]);\n                }\n\n                for (let z in featureFunctions) {\n                    featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z])]);\n                }\n                fun = function (zoom, feature) {\n                    const value = evaluateExponentialFunction({ stops: featureFunctionStops, base: parameters.base }, zoom)(zoom, feature);\n                    return typeof value === 'function' ? value(zoom, feature) : value;\n                };\n                isFeatureConstant = false;\n                isZoomConstant = false;\n            } else if (zoomDependent) {\n                fun = function (zoom) {\n                    const value = innerFun(parameters, zoom);\n                    return typeof value === 'function' ? value(zoom) : value;\n                };\n                isFeatureConstant = true;\n                isZoomConstant = false;\n            } else {\n                fun = function (zoom, feature) {\n                    const value = innerFun(parameters, feature ? feature[parameters.property] : null);\n                    return typeof value === 'function' ? value(zoom, feature) : value;\n                };\n                isFeatureConstant = false;\n                isZoomConstant = true;\n            }\n        }\n        fun.isZoomConstant = isZoomConstant;\n        fun.isFeatureConstant = isFeatureConstant;\n        return fun;\n    }\n\n    function coalesce(a, b, c) {\n        if (isNotNull(a)) return a;\n        if (isNotNull(b)) return b;\n        if (isNotNull(c)) return c;\n        return null;\n    }\n\n    function evaluateCategoricalFunction(parameters, input) {\n        for (let i = 0; i < parameters.stops.length; i++) {\n            if (input === parameters.stops[i][0]) {\n                return parameters.stops[i][1];\n            }\n        }\n        return parameters.default;\n    }\n\n    function evaluateIntervalFunction(parameters, input) {\n        for (var i = 0; i < parameters.stops.length; i++) {\n            if (input < parameters.stops[i][0]) break;\n        }\n        return parameters.stops[Math.max(i - 1, 0)][1];\n    }\n\n    function evaluateExponentialFunction(parameters, input) {\n        var base = isNotNull(parameters.base) && !isEmptyString(parameters.base) ? parameters.base : 1;\n\n        var i = 0;\n        while (true) {\n            if (i >= parameters.stops.length) break;\n            else if (input <= parameters.stops[i][0]) break;\n            else i++;\n        }\n\n        if (i === 0) {\n            return parameters.stops[i][1];\n        } else if (i === parameters.stops.length) {\n            return parameters.stops[i - 1][1];\n        } else {\n            return interpolate(input, base, parameters.stops[i - 1][0], parameters.stops[i][0], parameters.stops[i - 1][1], parameters.stops[i][1]);\n        }\n    }\n    const COLORIN_OPTIONS = {\n        width: 100,\n        height: 1\n    };\n    function evaluateColorInterpolateFunction(parameters, input) {\n        const stops = parameters.stops;\n        if (stops && stops.length > 1) {\n            let colorIn;\n            if (colorInCache) {\n                const key = JSON.stringify(stops);\n                if (!colorInCache.has(key)) {\n                    const colorIn = new ColorIn(stops, COLORIN_OPTIONS);\n                    colorInCache.set(key, colorIn);\n                }\n                colorIn = colorInCache.get(key);\n            } else {\n                colorIn = new ColorIn(stops, COLORIN_OPTIONS);\n            }\n            const [r, g, b, a] = colorIn.getColor(input);\n            return [r / 255, g / 255, b / 255, a / 255];\n        } else if (stops && stops.length === 1) {\n            return stops[0][1];\n        }\n        return null;\n    }\n\n    function evaluateIdentityFunction(parameters, input) {\n        return coalesce(input, parameters.default);\n    }\n    // 2添加修改计算函数\n    // 处理空字符串和未定义属性的函数\n    function evaluateCalculateExpressionFunction(parameters, input) {\n        const targetVariable = String(parameters.property);\n        const expression = parameters.expression;\n        const newValue = input;\n\n        // 定义函数来替换表达式中的变量\n        function traverseAndAssign(expression, targetVariable, newValue) {\n            const newValueAsNumber = Number(newValue);\n            const targetVariableAsString = String(targetVariable);\n\n            if (Array.isArray(expression)) {\n                return expression.map(subExpr => traverseAndAssign(subExpr, targetVariableAsString, newValueAsNumber));\n            } else if (expression === targetVariableAsString) {\n                return newValueAsNumber;\n            } else {\n                return expression;\n            }\n        }\n\n        // 定义函数来计算表达式的结果\n        function evaluateExpression(expression) {\n            if (Array.isArray(expression)) {\n                const operator = expression[0];\n\n                if (!['+', '-', '*', '/'].includes(operator)) {\n                    throw new Error(\`Unknown operator: ${$D}operator}\`);\n                }\n\n                const operands = expression.slice(1).map(op => evaluateExpression(op));\n                switch (operator) {\n                case '+':\n                    return operands.reduce((acc, curr) => acc + curr, 0);\n                case '-':\n                    return operands.reduce((acc, curr) => acc - curr);\n                case '*':\n                    return operands.reduce((acc, curr) => acc * curr, 1);\n                case '/':\n                    // 如果发现有零作为除数，返回默认值\n                    if (operands.some(op => op === 0)) {\n                        return parameters.default;\n                    }\n                    return operands.reduce((acc, curr) => acc / curr);\n                default:\n                    throw new Error(\`Unsupported operator: ${$D}operator}\`);\n                }\n            } else if (typeof expression === 'number') {\n                return expression;\n            } else {\n                throw new Error('Invalid expression format');\n            }\n        }\n\n        // 使用 coalesce 函数处理结果中的默认值\n        function coalesce(value) {\n            return (isNull(value) || isEmptyString(value) || isNaN(value)) ? parameters.default : value;\n        }\n\n        // 如果 input 存在且大于0，则处理表达式\n        if (isNotNull(input) && !isEmptyString(input) && !isNaN(input) && !(input < 0)) {\n            const updatedExpression = traverseAndAssign(expression, targetVariable, newValue);\n            return coalesce(evaluateExpression(updatedExpression));\n        } else {\n            return coalesce(parameters.default);\n        }\n    }\n\n    function interpolate(input, base, inputLower, inputUpper, outputLower, outputUpper) {\n        if (typeof outputLower === 'function') {\n            return function () {\n                var evaluatedLower = outputLower.apply(undefined, arguments);\n                var evaluatedUpper = outputUpper.apply(undefined, arguments);\n                return interpolate(input, base, inputLower, inputUpper, evaluatedLower, evaluatedUpper);\n            };\n        } else if (outputLower.length) {\n            return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);\n        } else {\n            return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);\n        }\n    }\n\n    function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {\n        var difference = inputUpper - inputLower;\n        var progress = input - inputLower;\n\n        var ratio;\n        if (base === 1) {\n            ratio = progress / difference;\n        } else {\n            ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n        }\n\n        return outputLower * (1 - ratio) + outputUpper * ratio;\n    }\n\n    function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {\n        var output = [];\n        for (let i = 0; i < outputLower.length; i++) {\n            output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);\n        }\n        return output;\n    }\n\n    /**\n     * Check if object is a definition of function type\n     * @param  {Object}  obj object\n     * @return {Boolean}\n     * @memberOf MapboxUtil\n     */\n    function isFunctionDefinition(obj) {\n        return (\n            obj &&\n            typeof obj === 'object' &&\n            (obj.stops || (obj.property && obj.type === 'identity') || (obj.expression && obj.type === 'calculate-expression'))\n        );\n    }\n\n    function interpolated(parameters) {\n        return createFunction1(parameters, 'exponential');\n    }\n\n    function piecewiseConstant(parameters) {\n        return createFunction1(parameters, 'interval');\n    }\n    /*eslint-enable no-var, prefer-const*/\n\n    function createFunction1(parameters, defaultType) {\n        if (!isFunctionDefinition(parameters)) {\n            return function () {\n                return parameters;\n            };\n        }\n        parameters = JSON.parse(JSON.stringify(parameters));\n        let isZoomConstant = true;\n        let isFeatureConstant = true;\n        const stops = parameters.stops;\n        if (stops) {\n            for (let i = 0; i < stops.length; i++) {\n                if (isFunctionDefinition(stops[i][1])) {\n                    const fn = createFunction1(stops[i][1], defaultType);\n                    isZoomConstant = isZoomConstant && fn.isZoomConstant;\n                    isFeatureConstant = isFeatureConstant && fn.isFeatureConstant;\n                    stops[i] = [stops[i][0], fn];\n                }\n            }\n        }\n        const fn = createFunction(parameters, defaultType);\n        fn.isZoomConstant = isZoomConstant && fn.isZoomConstant;\n        fn.isFeatureConstant = isFeatureConstant && fn.isFeatureConstant;\n        return fn;\n    }\n\n    let id = 0;\n    function uid() {\n        return id++;\n    }\n\n    const supportAssign = typeof Object.assign === 'function';\n\n    /**\n     * Merges the properties of sources into destination object.\n     * @param  {Object} dest   - object to extend\n     * @param  {...Object} src - sources\n     * @return {Object}\n     * @memberOf Util\n     */\n    function extend$2(dest, ...source) { // (Object[, Object, ...]) ->\n        if (supportAssign) {\n            Object.assign(dest, ...source);\n            return dest;\n        }\n        for (let i = 0; i < source.length; i++) {\n            const src = source[i];\n            for (const k in src) {\n                dest[k] = src[k];\n            }\n        }\n        return dest;\n    }\n\n\n    /**\n     * Check whether the object is a string\n     * @param {Object} obj\n     * @return {Boolean}\n     * @memberOf Util\n     */\n    function isString(obj) {\n        if (isNil(obj)) {\n            return false;\n        }\n        return typeof obj === 'string' || (obj.constructor !== null && obj.constructor === String);\n    }\n\n    /**\n     * Whether val is a number and not a NaN.\n     * @param  {Object}  val - val\n     * @return {Boolean}\n     * @memberOf Util\n     */\n    function isNumber$1(val) {\n        return (typeof val === 'number') && !isNaN(val);\n    }\n\n    /**\n     * Check whether the object is a function\n     * @param {Object} obj\n     * @return {Boolean}\n     * @memberOf Util\n     */\n    function isFunction(obj) {\n        if (isNil(obj)) {\n            return false;\n        }\n        return typeof obj === 'function' || (obj.constructor !== null && obj.constructor === Function);\n    }\n\n    /**\n     * Whether the obj is a javascript object.\n     * @param  {Object}  obj  - object\n     * @return {Boolean}\n     * @memberOf Util\n     */\n    function isObject$1(obj) {\n        return !Array.isArray(obj) && typeof obj === 'object' && !!obj;\n    }\n\n    function isNil(obj) {\n        return obj == null;\n    }\n\n    //push elements in source to target\n    //faster than target.concat(source)\n    //https://jsperf.com/array-concat-vs-push-2/16\n    function pushIn(dest) {\n        for (let i = 1; i < arguments.length; i++) {\n            const src = arguments[i];\n            if (src) {\n                for (let ii = 0, ll = src.length; ii < ll; ii++) {\n                    dest.push(src[ii]);\n                }\n            }\n        }\n        return dest.length;\n    }\n\n    function isFnTypeSymbol(v) {\n        return isFunctionDefinition(v) && v.property;\n    }\n\n    function hasOwn(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    const USE_FETCH = typeof fetch === 'function' && typeof AbortController === 'function';\n\n    /**\n     * @classdesc\n     * Ajax Utilities. It is static and should not be initiated.\n     * @class\n     * @static\n     * @category core\n     */\n    const Ajax = {\n\n        /**\n         * Get JSON data by jsonp\n         * from https://gist.github.com/gf3/132080/110d1b68d7328d7bfe7e36617f7df85679a08968\n         * @param  {String}   url - resource url\n         * @param  {Function} cb  - callback function when completed\n         */\n        jsonp: function (url, callback) {\n            // INIT\n            const name = '_maptalks_jsonp_' + uid();\n            if (url.match(/\\?/)) url += '&callback=' + name;\n            else url += '?callback=' + name;\n\n            // Create script\n            let script = document.createElement('script');\n            script.type = 'text/javascript';\n            script.src = url;\n\n            // Setup handler\n            window[name] = function (data) {\n                callback(null, data);\n                document.getElementsByTagName('head')[0].removeChild(script);\n                script = null;\n                delete window[name];\n            };\n\n            // Load JSON\n            document.getElementsByTagName('head')[0].appendChild(script);\n            return this;\n        },\n\n        /**\n         * Fetch remote resource by HTTP "GET" method\n         * @param  {String}   url - resource url\n         * @param  {Object}   [options=null] - request options\n         * @param  {Object}   [options.headers=null] - HTTP headers\n         * @param  {String}   [options.responseType=null] - responseType\n         * @param  {String}   [options.credentials=null]  - if with credentials, set it to "include"\n         * @param  {Function} cb  - callback function when completed\n         * @return {Ajax}  Ajax\n         * @example\n         * maptalks.Ajax.get(\n         *     'url/to/resource',\n         *     (err, data) => {\n         *         if (err) {\n         *             throw new Error(err);\n         *         }\n         *         // do things with data\n         *     }\n         * );\n         */\n        get: function (url, options, cb) {\n            if (isFunction(options)) {\n                const t = cb;\n                cb = options;\n                options = t;\n            }\n            options = options || {};\n            let errorLog = options.errorLog;\n            if (isNil(errorLog)) {\n                errorLog = true;\n            }\n            if (options.method) {\n                options.method = options.method.toUpperCase();\n            }\n            const isPost = options.method === 'POST';\n            if (!USE_FETCH) {\n                const client = Ajax._getClient(cb);\n                client.open(options.method || 'GET', url, true);\n                if (options) {\n                    for (const k in options.headers) {\n                        client.setRequestHeader(k, options.headers[k]);\n                    }\n                    client.withCredentials = options.credentials === 'include';\n                    if (options['responseType']) {\n                        client.responseType = options['responseType'];\n                    }\n                }\n                client.send(isPost ? options.body : null);\n                return client;\n            } else {\n                const controller = new AbortController();\n                const requestConfig = options;\n                requestConfig.signal = controller.signal;\n                requestConfig.referrerPolicy = requestConfig.referrerPolicy || 'origin';\n                requestConfig.method = requestConfig.method || 'GET';\n                const request = new Request(url, requestConfig);\n                if (options['returnJSON']) {\n                    request.headers.set('Accept', 'application/json');\n                }\n                fetch(request).then(response => {\n                    const parsed = this._parseResponse(response, options['returnJSON'], options['responseType']);\n                    if (parsed.message) {\n                        parsed.url = url;\n                        cb(parsed);\n                    } else {\n                        parsed.then(data => {\n                            if (options.responseType === 'arraybuffer') {\n                                cb(null, {\n                                    data,\n                                    cacheControl: response.headers.get('Cache-Control'),\n                                    expires: response.headers.get('Expires'),\n                                    contentType: response.headers.get('Content-Type')\n                                });\n                            } else {\n                                cb(null, data);\n                            }\n                        }).catch(err => {\n                            if (!err.code || err.code !== DOMException.ABORT_ERR) {\n                                if (errorLog) {\n                                    console.error('Fetch error:', url, err);\n                                }\n                                cb(err);\n                            }\n                        });\n                    }\n                }).catch(err => {\n                    if (!err.code || err.code !== DOMException.ABORT_ERR) {\n                        if (errorLog) {\n                            console.error('Fetch error:', url, err);\n                        }\n                        cb(err);\n                    }\n                });\n                return controller;\n            }\n        },\n\n        _parseResponse(response, isJSON, responseType) {\n            if (response.status !== 200) {\n                return {\n                    status: response.status,\n                    statusText: response.statusText,\n                    message: \`incorrect http request with status code(${$D}response.status}): ${$D}response.statusText}\`,\n                };\n            } else if (responseType === 'arraybuffer') {\n                return response.arrayBuffer();\n            } else {\n                return isJSON ? response.json() : response.text();\n            }\n        },\n\n        _wrapCallback: function (client, cb) {\n            return function () {\n                if (client.readyState === 4) {\n                    if (client.status === 200) {\n                        if (client.responseType === 'arraybuffer') {\n                            const response = client.response;\n                            if (response.byteLength === 0) {\n                                cb({\n                                    status: 200,\n                                    statusText: client.statusText,\n                                    message: 'http status 200 returned without content.'\n                                });\n                            } else {\n                                cb(null, {\n                                    data: client.response,\n                                    cacheControl: client.getResponseHeader('Cache-Control'),\n                                    expires: client.getResponseHeader('Expires'),\n                                    contentType: client.getResponseHeader('Content-Type')\n                                });\n                            }\n                        } else {\n                            cb(null, client.responseText);\n                        }\n                    } else {\n                        cb({\n                            status: client.status,\n                            statusText: client.statusText,\n                            message: \`incorrect http request with status code(${$D}client.status}): ${$D}client.statusText}\`,\n                        });\n                    }\n                }\n            };\n        },\n\n        _getClient: function (cb) {\n            /*eslint-disable no-empty, no-undef*/\n            let client;\n            try {\n                client = new XMLHttpRequest();\n            } catch (e) {\n                try { client = new ActiveXObject('Msxml2.XMLHTTP'); } catch (e) {\n                    try { client = new ActiveXObject('Microsoft.XMLHTTP'); } catch (e) { }\n                }\n            }\n            client.onreadystatechange = Ajax._wrapCallback(client, cb);\n            return client;\n            /*eslint-enable no-empty, no-undef*/\n        },\n        /**\n         * Fetch resource as arraybuffer.\n         * @param {String} url    - url\n         * @param {Object} [options=null] - options, same as Ajax.get\n         * @param {Function} cb   - callback function when completed.\n         * @example\n         * maptalks.Ajax.getArrayBuffer(\n         *     'url/to/resource.bin',\n         *     (err, data) => {\n         *         if (err) {\n         *             throw new Error(err);\n         *         }\n         *         // data is a binary array\n         *     }\n         * );\n         */\n        getArrayBuffer(url, options, cb) {\n            if (isFunction(options)) {\n                const t = cb;\n                cb = options;\n                options = t;\n            }\n            if (!options) {\n                options = {};\n            }\n            options['responseType'] = 'arraybuffer';\n            return Ajax.get(url, options, cb);\n        }\n    };\n\n    /**\n     * Fetch resource as a JSON Object.\n     * @param {String} url          - json's url\n     * @param {Object} [options=null]        - optional options\n     * @param {String} [options.jsonp=false] - fetch by jsonp, false by default\n     * @param {Function} cb   - callback function when completed.\n     * @example\n     * maptalks.Ajax.getJSON(\n     *     'url/to/resource.json',\n     *     { jsonp : true },\n     *     (err, json) => {\n     *         if (err) {\n     *             throw new Error(err);\n     *         }\n     *         // json is a JSON Object\n     *         console.log(json.foo);\n     *     }\n     * );\n     * @static\n     */\n    Ajax.getJSON = function (url, options, cb) {\n        if (isFunction(options)) {\n            const t = cb;\n            cb = options;\n            options = t;\n        }\n        const callback = function (err, resp) {\n            const data = typeof resp === 'string' ? JSON.parse(resp) : resp || null;\n            cb(err, data);\n        };\n        if (options && options['jsonp']) {\n            return Ajax.jsonp(url, callback);\n        }\n        options = options || {};\n        options['returnJSON'] = true;\n        return Ajax.get(url, options, callback);\n    };\n\n    // calculate simplification data using optimized Douglas-Peucker algorithm\n\n    function simplify(coords, first, last, sqTolerance, stride = 3) {\n        let maxSqDist = sqTolerance;\n        const mid = (last - first) >> 1;\n        let minPosToMid = last - first;\n        let index;\n\n        const ax = coords[first];\n        const ay = coords[first + 1];\n        const bx = coords[last];\n        const by = coords[last + 1];\n\n        for (let i = first + stride; i < last; i += stride) {\n            const d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);\n\n            if (d > maxSqDist) {\n                index = i;\n                maxSqDist = d;\n\n            } else if (d === maxSqDist) {\n                // a workaround to ensure we choose a pivot close to the middle of the list,\n                // reducing recursion depth, for certain degenerate inputs\n                // https://github.com/mapbox/geojson-vt/issues/104\n                const posToMid = Math.abs(i - mid);\n                if (posToMid < minPosToMid) {\n                    index = i;\n                    minPosToMid = posToMid;\n                }\n            }\n        }\n\n        if (maxSqDist > sqTolerance) {\n            if (index - first > stride) simplify(coords, first, index, sqTolerance, stride);\n            coords[index + 2] = maxSqDist;\n            if (last - index > stride) simplify(coords, index, last, sqTolerance, stride);\n        }\n    }\n\n    // square distance from a point to a segment\n    function getSqSegDist(px, py, x, y, bx, by) {\n\n        let dx = bx - x;\n        let dy = by - y;\n\n        if (dx !== 0 || dy !== 0) {\n\n            const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n            if (t > 1) {\n                x = bx;\n                y = by;\n\n            } else if (t > 0) {\n                x += dx * t;\n                y += dy * t;\n            }\n        }\n\n        dx = px - x;\n        dy = py - y;\n\n        return dx * dx + dy * dy;\n    }\n\n    function createFeature(id, type, geom, tags, layer, hasAltitude) {\n        const feature = {\n            id: id == null ? null : id,\n            type,\n            geometry: geom,\n            tags,\n            minX: Infinity,\n            minY: Infinity,\n            maxX: -Infinity,\n            maxY: -Infinity\n        };\n        if (layer) {\n            feature.layer = layer;\n        }\n        const stride = hasAltitude ? 4 : 3;\n        calcBBox$1(feature, stride);\n        return feature;\n    }\n\n    function calcBBox$1(feature, stride) {\n        const geom = feature.geometry;\n        const type = feature.type;\n\n        if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n            calcLineBBox(feature, geom, stride);\n\n        } else if (type === 'Polygon') {\n            // the outer ring (ie [0]) contains all inner rings\n            calcLineBBox(feature, geom[0], stride);\n\n        } else if (type === 'MultiLineString') {\n            for (const line of geom) {\n                calcLineBBox(feature, line, stride);\n            }\n\n        } else if (type === 'MultiPolygon') {\n            for (const polygon of geom) {\n                // the outer ring (ie [0]) contains all inner rings\n                calcLineBBox(feature, polygon[0], stride);\n            }\n        }\n\n        return feature;\n    }\n\n    function calcLineBBox(feature, geom, stride) {\n        for (let i = 0; i < geom.length; i += stride) {\n            feature.minX = Math.min(feature.minX, geom[i]);\n            feature.minY = Math.min(feature.minY, geom[i + 1]);\n            feature.maxX = Math.max(feature.maxX, geom[i]);\n            feature.maxY = Math.max(feature.maxY, geom[i + 1]);\n        }\n    }\n\n    // converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\n    function convert(data, options) {\n        const features = [];\n\n        if (Array.isArray(data)) {\n            for (let i = 0; i < data.length; i++) {\n                convertLayerData(features, data[i].layer, data[i].data, options);\n            }\n            return features;\n        }\n\n        if (data.type === 'FeatureCollection') {\n            for (let i = 0; i < data.features.length; i++) {\n                convertFeature(features, data.features[i], options, i);\n            }\n\n        } else if (data.type === 'Feature') {\n            convertFeature(features, data, options);\n\n        } else {\n            // single geometry or a geometry collection\n            convertFeature(features, {geometry: data}, options);\n        }\n\n        return features;\n    }\n\n    function convertLayerData(features, layer, data, options) {\n        // FIXME: ugly to pass 'layer' to 'convertFeature' in this way\n        options.layer = layer;\n\n        if (data.type === 'FeatureCollection') {\n            for (let i = 0; i < data.features.length; i++) {\n                convertFeature(features, data.features[i], options, i);\n            }\n\n        } else if (data.type === 'Feature') {\n            convertFeature(features, data, options);\n\n        } else {\n            // single geometry or a geometry collection\n            convertFeature(features, {geometry: data}, options);\n        }\n    }\n\n    function convertFeature(features, geojson, options, index) {\n        if (!geojson.geometry) return;\n\n        const coords = geojson.geometry.coordinates;\n        const type = geojson.geometry.type;\n        const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n        let geometry = [];\n        let id = geojson.id;\n        if (options.promoteId) {\n            id = geojson.properties[options.promoteId];\n        } else if (options.generateId) {\n            id = index || 0;\n        }\n        if (type === 'Point') {\n            convertPoint(coords, geometry, options);\n\n        } else if (type === 'MultiPoint') {\n            for (const p of coords) {\n                convertPoint(p, geometry, options);\n            }\n\n        } else if (type === 'LineString') {\n            convertLine(coords, geometry, tolerance, false, options);\n\n        } else if (type === 'MultiLineString') {\n            if (options.lineMetrics) {\n                // explode into linestrings to be able to track metrics\n                for (const line of coords) {\n                    geometry = [];\n                    convertLine(line, geometry, tolerance, false, options);\n                    features.push(createFeature(id, 'LineString', geometry, geojson.properties, options.layer, options.hasAltitude));\n                }\n                return;\n            } else {\n                convertLines(coords, geometry, tolerance, false, options);\n            }\n\n        } else if (type === 'Polygon') {\n            convertLines(coords, geometry, tolerance, true, options);\n\n        } else if (type === 'MultiPolygon') {\n            for (const polygon of coords) {\n                const newPolygon = [];\n                convertLines(polygon, newPolygon, tolerance, true, options);\n                geometry.push(newPolygon);\n            }\n        } else if (type === 'GeometryCollection') {\n            for (const singleGeometry of geojson.geometry.geometries) {\n                convertFeature(features, {\n                    id,\n                    geometry: singleGeometry,\n                    properties: geojson.properties\n                }, options, index);\n            }\n            return;\n        } else {\n            throw new Error('Input data is not a valid GeoJSON object.');\n        }\n\n        features.push(createFeature(id, type, geometry, geojson.properties, options.layer, options.hasAltitude));\n    }\n\n    function convertPoint(coords, out, options) {\n        out.push(projectX(coords[0]), projectY(coords[1], options.projection), 0);\n        if (options.hasAltitude) {\n            if (coords.length > 2) {\n                out.push(coords[2]);\n            } else {\n                out.push(0);\n            }\n        }\n    }\n\n    function convertLine(ring, out, tolerance, isPolygon, options) {\n        let x0, y0;\n        let size = 0;\n\n        for (let j = 0; j < ring.length; j++) {\n            const x = projectX(ring[j][0]);\n            const y = projectY(ring[j][1], options.projection);\n\n            out.push(x, y, 0);\n\n            if (options.hasAltitude) {\n                if (ring[j].length > 2) {\n                    out.push(ring[j][2]);\n                } else {\n                    out.push(0);\n                }\n            }\n\n            if (j > 0) {\n                if (isPolygon) {\n                    size += (x0 * y - x * y0) / 2; // area\n                } else {\n                    size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n                }\n            }\n            x0 = x;\n            y0 = y;\n        }\n\n        const stride = options.hasAltitude ? 4 : 3;\n        const last = out.length - stride;\n        out[2] = 1;\n        simplify(out, 0, last, tolerance, stride);\n        out[last + 2] = 1;\n\n        out.size = Math.abs(size);\n        out.start = 0;\n        out.end = out.size;\n    }\n\n    function convertLines(rings, out, tolerance, isPolygon, options) {\n        for (let i = 0; i < rings.length; i++) {\n            const geom = [];\n            convertLine(rings[i], geom, tolerance, isPolygon, options);\n            out.push(geom);\n        }\n    }\n\n    function projectX(x) {\n        return x / 360 + 0.5;\n    }\n\n    function projectY(y, proj) {\n        switch (proj) {\n        case 'EPSG:4326':\n            return (90 - y) / 360.0;\n        }\n        const sin = Math.sin(y * Math.PI / 180);\n        const y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n        return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n    }\n\n    /* clip features between two vertical or horizontal axis-parallel lines:\n     *     |        |\n     *  ___|___     |     /\n     * /   |   \\____|____/\n     *     |        |\n     *\n     * k1 and k2 are the line coordinates\n     * axis: 0 for x, 1 for y\n     * minAll and maxAll: minimum and maximum coordinate value for all features\n     */\n    function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {\n        k1 /= scale;\n        k2 /= scale;\n\n        if (minAll >= k1 && maxAll < k2) return features; // trivial accept\n        else if (maxAll < k1 || minAll >= k2) return null; // trivial reject\n\n        const clipped = [];\n\n        for (const feature of features) {\n            const geometry = feature.geometry;\n            let type = feature.type;\n\n            const min = axis === 0 ? feature.minX : feature.minY;\n            const max = axis === 0 ? feature.maxX : feature.maxY;\n\n            if (min >= k1 && max < k2) { // trivial accept\n                clipped.push(feature);\n                continue;\n            } else if (max < k1 || min >= k2) { // trivial reject\n                continue;\n            }\n\n            let newGeometry = [];\n\n            if (type === 'Point' || type === 'MultiPoint') {\n                clipPoints(geometry, newGeometry, k1, k2, axis, options.hasAltitude);\n\n            } else if (type === 'LineString') {\n                clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics, options.hasAltitude);\n\n            } else if (type === 'MultiLineString') {\n                clipLines(geometry, newGeometry, k1, k2, axis, false, options.hasAltitude);\n\n            } else if (type === 'Polygon') {\n                clipLines(geometry, newGeometry, k1, k2, axis, true, options.hasAltitude);\n\n            } else if (type === 'MultiPolygon') {\n                for (const polygon of geometry) {\n                    const newPolygon = [];\n                    clipLines(polygon, newPolygon, k1, k2, axis, true, options.hasAltitude);\n                    if (newPolygon.length) {\n                        newGeometry.push(newPolygon);\n                    }\n                }\n            }\n\n            if (newGeometry.length) {\n                if (options.lineMetrics && type === 'LineString') {\n                    for (const line of newGeometry) {\n                        clipped.push(createFeature(feature.id, type, line, feature.tags, feature.layer, options.hasAltitude));\n                    }\n                    continue;\n                }\n\n                if (type === 'LineString' || type === 'MultiLineString') {\n                    if (newGeometry.length === 1) {\n                        type = 'LineString';\n                        newGeometry = newGeometry[0];\n                    } else {\n                        type = 'MultiLineString';\n                    }\n                }\n                if (type === 'Point' || type === 'MultiPoint') {\n                    type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n                }\n\n                clipped.push(createFeature(feature.id, type, newGeometry, feature.tags, feature.layer, options.hasAltitude));\n            }\n        }\n\n        return clipped.length ? clipped : null;\n    }\n\n    function clipPoints(geom, newGeom, k1, k2, axis, hasAltitude) {\n        const stride = hasAltitude ? 4 : 3;\n        for (let i = 0; i < geom.length; i += stride) {\n            const a = geom[i + axis];\n\n            if (a >= k1 && a <= k2) {\n                addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n                if (hasAltitude) {\n                    newGeom.push(geom[i + 3]);\n                }\n            }\n        }\n    }\n\n    function clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics, hasAltitude) {\n\n        let slice = newSlice(geom);\n        const intersect = axis === 0 ? intersectX : intersectY;\n        let len = geom.start;\n        let segLen, t;\n\n        const stride = hasAltitude ? 4 : 3;\n        const count = isPolygon ? geom.length : geom.length - stride;\n\n        for (let i = 0; i < count; i += stride) {\n            const ax = geom[i];\n            const ay = geom[i + 1];\n            const az = geom[i + 2];\n            let bx, by;\n            if (isPolygon && i === count - stride) {\n                bx = geom[0];\n                by = geom[1];\n            } else {\n                bx = geom[i + stride];\n                by = geom[i + stride + 1];\n            }\n\n            let ah, bh;\n            if (hasAltitude) {\n                ah = geom[i + 3];\n                bh = (isPolygon && i === count - stride) ? geom[3] : geom[i + stride + 3];\n            }\n            const a = axis === 0 ? ax : ay;\n            const b = axis === 0 ? bx : by;\n            let exited = false;\n\n            if (trackMetrics) segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\n            if (a < k1) {\n                // ---|--\x3e  | (line enters the clip region from the left)\n                if (b > k1) {\n                    t = intersect(slice, ax, ay, bx, by, k1);\n                    if (hasAltitude) {\n                        slice.push(newHeight(ah, bh, t));\n                    }\n                    if (trackMetrics) slice.start = len + segLen * t;\n                }\n            } else if (a > k2) {\n                // |  <--|--- (line enters the clip region from the right)\n                if (b < k2) {\n                    t = intersect(slice, ax, ay, bx, by, k2);\n                    if (hasAltitude) {\n                        slice.push(newHeight(ah, bh, t));\n                    }\n                    if (trackMetrics) slice.start = len + segLen * t;\n                }\n            } else {\n                addPoint(slice, ax, ay, az);\n                if (hasAltitude) {\n                    slice.push(ah);\n                }\n            }\n            if (b < k1 && a >= k1) {\n                // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (hasAltitude) {\n                    slice.push(newHeight(ah, bh, t));\n                }\n                exited = true;\n            }\n            if (b > k2 && a <= k2) {\n                // |  ---|--\x3e or ---|-----|--\x3e (line exits the clip region on the right)\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (hasAltitude) {\n                    slice.push(newHeight(ah, bh, t));\n                }\n                exited = true;\n            }\n\n            if (!isPolygon && exited) {\n                if (trackMetrics) slice.end = len + segLen * t;\n                newGeom.push(slice);\n                slice = newSlice(geom);\n            }\n\n            if (trackMetrics) len += segLen;\n        }\n\n        let last = geom.length - stride;\n        if (!isPolygon) {\n            // add the last point\n            const ax = geom[last];\n            const ay = geom[last + 1];\n            const az = geom[last + 2];\n            const a = axis === 0 ? ax : ay;\n            if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n            if (a >= k1 && a <= k2) {\n                if (hasAltitude) {\n                    const ah = geom[last + 3];\n                    slice.push(ah);\n                }\n            }\n        }\n\n\n        // close the polygon if its endpoints are not the same after clipping\n        last = slice.length - stride;\n        if (isPolygon && last >= stride && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n            addPoint(slice, slice[0], slice[1], slice[2]);\n            if (hasAltitude) {\n                slice.push(slice[3]);\n            }\n        }\n\n        // add the final slice\n        if (slice.length) {\n            newGeom.push(slice);\n        }\n    }\n\n    function newSlice(line) {\n        const slice = [];\n        slice.size = line.size;\n        slice.start = line.start;\n        slice.end = line.end;\n        return slice;\n    }\n\n    function clipLines(geom, newGeom, k1, k2, axis, isPolygon, hasAltitude) {\n        for (const line of geom) {\n            clipLine(line, newGeom, k1, k2, axis, isPolygon, false, hasAltitude);\n        }\n    }\n\n    function addPoint(out, x, y, z) {\n        out.push(x, y, z);\n    }\n\n    function intersectX(out, ax, ay, bx, by, x) {\n        const t = (x - ax) / (bx - ax);\n        addPoint(out, x, ay + (by - ay) * t, 1);\n        return t;\n    }\n\n    function intersectY(out, ax, ay, bx, by, y) {\n        const t = (y - ay) / (by - ay);\n        addPoint(out, ax + (bx - ax) * t, y, 1);\n        return t;\n    }\n\n    function newHeight(ah, bh, t) {\n        return ah + (bh - ah) * t;\n    }\n\n    function wrap(features, options) {\n        const buffer = options.buffer / options.extent;\n        let merged = features;\n        const left  = clip(features, 1, -1 - buffer, buffer,     0, -1, 2, options); // left world copy\n        const right = clip(features, 1,  1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n\n        if (left || right) {\n            merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n\n            if (left) merged = shiftFeatureCoords(left, 1, options.hasAltitude).concat(merged); // merge left into center\n            if (right) merged = merged.concat(shiftFeatureCoords(right, -1, options.hasAltitude)); // merge right into center\n        }\n\n        return merged;\n    }\n\n    function shiftFeatureCoords(features, offset, hasAltitude) {\n        const newFeatures = [];\n\n        for (let i = 0; i < features.length; i++) {\n            const feature = features[i];\n            const type = feature.type;\n\n            let newGeometry;\n\n            if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n                newGeometry = shiftCoords(feature.geometry, offset, hasAltitude);\n\n            } else if (type === 'MultiLineString' || type === 'Polygon') {\n                newGeometry = [];\n                for (const line of feature.geometry) {\n                    newGeometry.push(shiftCoords(line, offset, hasAltitude));\n                }\n            } else if (type === 'MultiPolygon') {\n                newGeometry = [];\n                for (const polygon of feature.geometry) {\n                    const newPolygon = [];\n                    for (const line of polygon) {\n                        newPolygon.push(shiftCoords(line, offset, hasAltitude));\n                    }\n                    newGeometry.push(newPolygon);\n                }\n            }\n\n            newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags, feature.layer, hasAltitude));\n        }\n\n        return newFeatures;\n    }\n\n    function shiftCoords(points, offset, hasAltitude) {\n        const newPoints = [];\n        newPoints.size = points.size;\n\n        if (points.start !== undefined) {\n            newPoints.start = points.start;\n            newPoints.end = points.end;\n        }\n\n        const stride = hasAltitude ? 4 : 3;\n\n        for (let i = 0; i < points.length; i += stride) {\n            newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n            if (hasAltitude) {\n                newPoints.push(points[i + 3]);\n            }\n        }\n        return newPoints;\n    }\n\n    // Transforms the coordinates of each feature in the given tile from\n    // mercator-projected space into (extent x extent) tile space.\n    function transformTile(tile, extent, hasAltitude) {\n        if (tile.transformed) return tile;\n\n        const z2 = 1 << tile.z;\n        const tx = tile.x;\n        const ty = tile.y;\n\n        const stride = hasAltitude ? 3 : 2;\n\n        for (const feature of tile.features) {\n            const geom = feature.geometry;\n            const type = feature.type;\n\n            feature.geometry = [];\n\n            if (type === 1) {\n                for (let j = 0; j < geom.length; j += stride) {\n                    feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));\n                    if (hasAltitude) {\n                        feature.geometry[feature.geometry.length - 1].push(geom[j + 2]);\n                    }\n                }\n            } else {\n                for (let j = 0; j < geom.length; j++) {\n                    const ring = [];\n                    for (let k = 0; k < geom[j].length; k += stride) {\n                        ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));\n                        if (hasAltitude) {\n                            ring[ring.length - 1].push(geom[j][k + 2]);\n                        }\n                    }\n                    feature.geometry.push(ring);\n                }\n            }\n        }\n\n        tile.transformed = true;\n\n        return tile;\n    }\n\n    function transformPoint(x, y, extent, z2, tx, ty) {\n        return [\n            Math.round(extent * (x * z2 - tx)),\n            Math.round(extent * (y * z2 - ty))];\n    }\n\n    function createTile(features, z, tx, ty, options) {\n        const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n        const tile = {\n            features: [],\n            numPoints: 0,\n            numSimplified: 0,\n            numFeatures: features.length,\n            source: null,\n            x: tx,\n            y: ty,\n            z,\n            transformed: false,\n            minX: 2,\n            minY: 1,\n            maxX: -1,\n            maxY: 0\n        };\n        for (const feature of features) {\n            addFeature(tile, feature, tolerance, options);\n        }\n        return tile;\n    }\n\n    function addFeature(tile, feature, tolerance, options) {\n        const geom = feature.geometry;\n        const type = feature.type;\n        const simplified = [];\n        const stride = options.hasAltitude ? 4 : 3;\n\n        tile.minX = Math.min(tile.minX, feature.minX);\n        tile.minY = Math.min(tile.minY, feature.minY);\n        tile.maxX = Math.max(tile.maxX, feature.maxX);\n        tile.maxY = Math.max(tile.maxY, feature.maxY);\n\n        if (type === 'Point' || type === 'MultiPoint') {\n            for (let i = 0; i < geom.length; i += stride) {\n                simplified.push(geom[i], geom[i + 1]);\n                if (options.hasAltitude) {\n                    simplified.push(geom[i + 3]);\n                }\n                tile.numPoints++;\n                tile.numSimplified++;\n            }\n\n        } else if (type === 'LineString') {\n            addLine(simplified, geom, tile, tolerance, false, false, options);\n\n        } else if (type === 'MultiLineString' || type === 'Polygon') {\n            for (let i = 0; i < geom.length; i++) {\n                addLine(simplified, geom[i], tile, tolerance, type === 'Polygon', i === 0, options);\n            }\n\n        } else if (type === 'MultiPolygon') {\n\n            for (let k = 0; k < geom.length; k++) {\n                const polygon = geom[k];\n                for (let i = 0; i < polygon.length; i++) {\n                    addLine(simplified, polygon[i], tile, tolerance, true, i === 0, options);\n                }\n            }\n        }\n\n        if (simplified.length) {\n            let tags = feature.tags || null;\n\n            if (type === 'LineString' && options.lineMetrics) {\n                tags = {};\n                for (const key in feature.tags) tags[key] = feature.tags[key];\n                tags['mapbox_clip_start'] = geom.start / geom.size;\n                tags['mapbox_clip_end'] = geom.end / geom.size;\n            }\n\n            const tileFeature = {\n                geometry: simplified,\n                type: type === 'Polygon' || type === 'MultiPolygon' ? 3 :\n                (type === 'LineString' || type === 'MultiLineString' ? 2 : 1),\n                tags\n            };\n            if (feature.layer) {\n                tileFeature.layer = feature.layer;\n            }\n            if (feature.id !== null) {\n                tileFeature.id = feature.id;\n            }\n            tile.features.push(tileFeature);\n        }\n    }\n\n    // workaround for #6, should use simplify3d?\n    function keepSimplified(geom, i, hasAltitude) {\n        // FIXME: geom[i + 2] < Number.EPSILON or Number.MIN_VALUE ?\n        // NOTE: SqSegDist in 2D       altitude\n        return geom[i + 2] === 0 && geom[i + 3] > 0 && hasAltitude;\n    }\n\n    function addLine(result, geom, tile, tolerance, isPolygon, isOuter, options) {\n        const sqTolerance = tolerance * tolerance;\n        const {hasAltitude, disableFilter} = options;\n        const stride = hasAltitude ? 4 : 3;\n\n        if (!disableFilter && tolerance > 0 && (geom.size < (isPolygon ? sqTolerance : tolerance))) {\n            tile.numPoints += geom.length / stride;\n            return;\n        }\n\n        const ring = [];\n\n        for (let i = 0; i < geom.length; i += stride) {\n            if (tolerance === 0 || geom[i + 2] > sqTolerance || keepSimplified(geom, i, hasAltitude)) {\n                tile.numSimplified++;\n                ring.push(geom[i], geom[i + 1]);\n                if (hasAltitude) {\n                    ring.push(geom[i + 3]);\n                }\n            }\n            tile.numPoints++;\n        }\n\n        if (isPolygon) rewind(ring, isOuter, hasAltitude);\n\n        result.push(ring);\n    }\n\n    function rewind(ring, clockwise, hasAltitude) {\n        const stride = hasAltitude ? 3 : 2;\n        let area = 0;\n        for (let i = 0, len = ring.length, j = len - stride; i < len; j = i, i += stride) {\n            area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n        }\n        if (area > 0 === clockwise) {\n            const posX = stride;\n            const posY = stride - 1;\n            const posA = stride - 2;\n            for (let i = 0, len = ring.length; i < len / 2; i += stride) {\n                const x = ring[i];\n                const y = ring[i + 1];\n                let altitude;\n                if (hasAltitude) {\n                    altitude = ring[i + 2];\n                }\n                ring[i] = ring[len - posX - i];\n                ring[i + 1] = ring[len - posY - i];\n                if (hasAltitude) {\n                    ring[i + 2] = ring[len - posA - i];\n                }\n                ring[len - posX - i] = x;\n                ring[len - posY - i] = y;\n                if (hasAltitude) {\n                    ring[len - posA - i] = altitude;\n                }\n            }\n        }\n    }\n\n    const defaultOptions = {\n        maxZoom: 14,            // max zoom to preserve detail on\n        indexMaxZoom: 5,        // max zoom in the tile index\n        indexMaxPoints: 100000, // max number of points per tile in the tile index\n        tolerance: 3,           // simplification tolerance (higher means simpler)\n        extent: 4096,           // tile extent\n        buffer: 64,             // tile buffer on each side\n        lineMetrics: false,     // whether to calculate line metrics\n        promoteId: null,        // name of a feature property to be promoted to feature.id\n        generateId: false,      // whether to generate feature ids. Cannot be used with promoteId\n        hasAltitude: false,     // whether input data has altitude\n        disableFilter: false,   // whether filter by size(length for polyline, area for polygon)\n        debug: 0                // logging level (0, 1 or 2)\n    };\n\n    class GeoJSONVT {\n        constructor(data, options) {\n            options = this.options = extend$1(Object.create(defaultOptions), options);\n\n            const debug = options.debug;\n\n            if (debug) console.time('preprocess data');\n\n            if (options.maxZoom < 0 || options.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range');\n            if (options.promoteId && options.generateId) throw new Error('promoteId and generateId cannot be used together.');\n\n            // projects and adds simplification info\n            let features = convert(data, options);\n\n            // tiles and tileCoords are part of the public API\n            this.tiles = {};\n            this.tileCoords = [];\n\n            if (debug) {\n                console.timeEnd('preprocess data');\n                console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n                console.time('generate tiles');\n                this.stats = {};\n                this.total = 0;\n            }\n\n            // wraps features (ie extreme west and extreme east)\n            features = wrap(features, options);\n\n            // start slicing from the top tile down\n            if (features.length) this.splitTile(features, 0, 0, 0);\n\n            if (debug) {\n                if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n                console.timeEnd('generate tiles');\n                console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n            }\n        }\n\n        // splits features from a parent tile to sub-tiles.\n        // z, x, and y are the coordinates of the parent tile\n        // cz, cx, and cy are the coordinates of the target tile\n        //\n        // If no target tile is specified, splitting stops when we reach the maximum\n        // zoom or the number of points is low as specified in the options.\n        splitTile(features, z, x, y, cz, cx, cy) {\n\n            const stack = [features, z, x, y];\n            const options = this.options;\n            const debug = options.debug;\n\n            // avoid recursion by using a processing queue\n            while (stack.length) {\n                y = stack.pop();\n                x = stack.pop();\n                z = stack.pop();\n                features = stack.pop();\n\n                const z2 = 1 << z;\n                const id = toID(z, x, y);\n                let tile = this.tiles[id];\n\n                if (!tile) {\n                    if (debug > 1) console.time('creation');\n\n                    tile = this.tiles[id] = createTile(features, z, x, y, options);\n                    this.tileCoords.push({z, x, y});\n\n                    if (debug) {\n                        if (debug > 1) {\n                            console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                                z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                            console.timeEnd('creation');\n                        }\n                        const key = \`z${$D}  z}\`;\n                        this.stats[key] = (this.stats[key] || 0) + 1;\n                        this.total++;\n                    }\n                }\n\n                // save reference to original geometry in tile so that we can drill down later if we stop now\n                tile.source = features;\n\n                // if it's the first-pass tiling\n                if (cz == null) {\n                    // stop tiling if we reached max zoom, or if the tile is too simple\n                    if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n                // if a drilldown to a specific tile\n                } else if (z === options.maxZoom || z === cz) {\n                    // stop tiling if we reached base zoom or our target tile zoom\n                    continue;\n                } else if (cz != null) {\n                    // stop tiling if it's not an ancestor of the target tile\n                    const zoomSteps = cz - z;\n                    if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) continue;\n                }\n\n                // if we slice further down, no need to keep source geometry\n                tile.source = null;\n\n                if (features.length === 0) continue;\n\n                if (debug > 1) console.time('clipping');\n\n                // values we'll use for clipping\n                const k1 = 0.5 * options.buffer / options.extent;\n                const k2 = 0.5 - k1;\n                const k3 = 0.5 + k1;\n                const k4 = 1 + k1;\n\n                let tl = null;\n                let bl = null;\n                let tr = null;\n                let br = null;\n\n                let left  = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n                let right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n                features = null;\n\n                if (left) {\n                    tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                    bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                    left = null;\n                }\n\n                if (right) {\n                    tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                    br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                    right = null;\n                }\n\n                if (debug > 1) console.timeEnd('clipping');\n\n                stack.push(tl || [], z + 1, x * 2,     y * 2);\n                stack.push(bl || [], z + 1, x * 2,     y * 2 + 1);\n                stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n                stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n            }\n        }\n\n        getTile(z, x, y) {\n            z = +z;\n            x = +x;\n            y = +y;\n\n            const options = this.options;\n            const {extent, debug} = options;\n            const {hasAltitude, wrapX} = options;\n\n            if (z < 0 || z > 24) return null;\n\n            if (wrapX) {\n                const z2 = 1 << z;\n                x = (x + z2) & (z2 - 1); // wrap tile x coordinate\n            }\n\n\n            const id = toID(z, x, y);\n            if (this.tiles[id]) return transformTile(this.tiles[id], extent, hasAltitude);\n\n            if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n\n            let z0 = z;\n            let x0 = x;\n            let y0 = y;\n            let parent;\n\n            while (!parent && z0 > 0) {\n                z0--;\n                x0 = x0 >> 1;\n                y0 = y0 >> 1;\n                parent = this.tiles[toID(z0, x0, y0)];\n            }\n\n            if (!parent || !parent.source) return null;\n\n            // if we found a parent tile containing the original geometry, we can drill down from it\n            if (debug > 1) {\n                console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n                console.time('drilling down');\n            }\n            this.splitTile(parent.source, z0, x0, y0, z, x, y);\n            if (debug > 1) console.timeEnd('drilling down');\n\n            return this.tiles[id] ? transformTile(this.tiles[id], extent, hasAltitude) : null;\n        }\n    }\n\n    function toID(z, x, y) {\n        return (((1 << z) * y + x) * 32) + z;\n    }\n\n    function extend$1(dest, src) {\n        for (const i in src) dest[i] = src[i];\n        return dest;\n    }\n\n    function geojsonvt(data, options) {\n        return new GeoJSONVT(data, options);\n    }\n\n    /**\n     * Iterate features, and caculate vertex count in typedarray position\n     * @param {Object[]} features - features to iterate\n     * @param {Boolean} isLine - whether it's a line\n     * @returns {Number}\n     */\n    function countVertexes(features, isLine) {\n        let num = 0;\n        for (let i = 0, l = features.length; i < l; i++) {\n            const feature = features[i];\n            if (isNumber$1(feature.geometry[0][0])) {\n                //a multi geometry\n                const count = feature.geometry.length * 3;\n                num += count;\n            } else {\n                for (let ii = 0, ll = feature.geometry.length; ii < ll; ii++) {\n                    let count = feature.geometry[ii].length * 3;\n                    if (feature.type === 3) { //polygon\n                        count -= 3; //remove the last vertex\n                    }\n                    num += count;\n                }\n            }\n        }\n        return num;\n    }\n\n    /**\n     *\n     * @param {TypedArray} vertices - vertices array to fill\n     * @param {Number} offset - start offset\n     * @param {Number[][]|Object[]} segment - segment, can be [[x, y], [x, y]...] or [{x, y}, {x, y}]\n     * @param {Number} scale - scale\n     * @param {Number|Number[]} altitude - altitude or altitude[]\n     * @param {Boolean} isLine\n     */\n    function fillPosArray(vertices, offset, segment, scale, altitude, isLine, positionType) {\n        const isCoordArr = segment && Array.isArray(segment[0]);\n        for (let i = 0, l = segment.length; i < l; i++) {\n            vertices[offset] = (isCoordArr ? segment[i][0] : segment[i].x) * scale;\n            vertices[offset + 1] = (isCoordArr ? segment[i][1] : segment[i].y) * scale;\n            if (positionType !== Float32Array) {\n                vertices[offset] = Math.round(vertices[offset]);\n                vertices[offset + 1] = Math.round(vertices[offset + 1]);\n            }\n\n            let alt = altitude || 0;\n            if (Array.isArray(altitude)) {\n                alt = altitude[i];\n            }\n            alt = alt ? Math.round(scale * alt) : 0;\n            vertices[offset + 2] = alt; // for altitude\n\n            offset += 3;\n\n            if (isLine && i !== 0 && i !== l - 1) {\n                // start of the next line segment\n                vertices[offset] = vertices[offset - 3];\n                vertices[offset + 1] = vertices[offset - 2];\n                vertices[offset + 2] = vertices[offset - 1];\n                offset += 3;\n            }\n        }\n        if (vertices.trySetLength) {\n            vertices.trySetLength(offset);\n        }\n        return offset;\n    }\n\n    function isClippedEdge(vertices, i0, i1, EXTENT) {\n        const x0 = vertices[i0 * 3], y0 = vertices[i0 * 3 + 1],\n            x1 = vertices[i1 * 3], y1 = vertices[i1 * 3 + 1];\n        return (x0 === x1 && (x0 < 0 || x0 > EXTENT)) ||\n            (y0 === y1 && (y0 < 0 || y0 > EXTENT));\n    }\n\n    /**\n     * Common utilities\n     * @module glMatrix\n     */\n    // Configuration Constants\n    var ARRAY_TYPE$1 = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n    if (!Math.hypot) Math.hypot = function () {\n      var y = 0,\n          i = arguments.length;\n\n      while (i--) {\n        y += arguments[i] * arguments[i];\n      }\n\n      return Math.sqrt(y);\n    };\n\n    /**\n     * 3 Dimensional Vector\n     * @module vec3\n     */\n\n    /**\n     * Creates a new, empty vec3\n     *\n     * @returns {vec3} a new 3D vector\n     */\n\n    function create$6() {\n      var out = new ARRAY_TYPE$1(3);\n\n      if (ARRAY_TYPE$1 != Float32Array) {\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n      }\n\n      return out;\n    }\n    /**\n     * Set the components of a vec3 to the given values\n     *\n     * @param {vec3} out the receiving vector\n     * @param {Number} x X component\n     * @param {Number} y Y component\n     * @param {Number} z Z component\n     * @returns {vec3} out\n     */\n\n    function set$3(out, x, y, z) {\n      out[0] = x;\n      out[1] = y;\n      out[2] = z;\n      return out;\n    }\n    /**\n     * Perform some operation over an array of vec3s.\n     *\n     * @param {Array} a the array of vectors to iterate over\n     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n     * @param {Number} offset Number of elements to skip at the beginning of the array\n     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n     * @param {Function} fn Function to call for each vector in the array\n     * @param {Object} [arg] additional argument to pass to fn\n     * @returns {Array} a\n     * @function\n     */\n\n    (function () {\n      var vec = create$6();\n      return function (a, stride, offset, count, fn, arg) {\n        var i, l;\n\n        if (!stride) {\n          stride = 3;\n        }\n\n        if (!offset) {\n          offset = 0;\n        }\n\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];\n          vec[1] = a[i + 1];\n          vec[2] = a[i + 2];\n          fn(vec, vec, arg);\n          a[i] = vec[0];\n          a[i + 1] = vec[1];\n          a[i + 2] = vec[2];\n        }\n\n        return a;\n      };\n    })();\n\n    /**\n     * 4 Dimensional Vector\n     * @module vec4\n     */\n\n    /**\n     * Creates a new, empty vec4\n     *\n     * @returns {vec4} a new 4D vector\n     */\n\n    function create$5() {\n      var out = new ARRAY_TYPE$1(4);\n\n      if (ARRAY_TYPE$1 != Float32Array) {\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n      }\n\n      return out;\n    }\n    /**\n     * Copy the values from one vec4 to another\n     *\n     * @param {vec4} out the receiving vector\n     * @param {ReadonlyVec4} a the source vector\n     * @returns {vec4} out\n     */\n\n    function copy$1(out, a) {\n      out[0] = a[0];\n      out[1] = a[1];\n      out[2] = a[2];\n      out[3] = a[3];\n      return out;\n    }\n    /**\n     * Set the components of a vec4 to the given values\n     *\n     * @param {vec4} out the receiving vector\n     * @param {Number} x X component\n     * @param {Number} y Y component\n     * @param {Number} z Z component\n     * @param {Number} w W component\n     * @returns {vec4} out\n     */\n\n    function set$2(out, x, y, z, w) {\n      out[0] = x;\n      out[1] = y;\n      out[2] = z;\n      out[3] = w;\n      return out;\n    }\n    /**\n     * Divides two vec4's\n     *\n     * @param {vec4} out the receiving vector\n     * @param {ReadonlyVec4} a the first operand\n     * @param {ReadonlyVec4} b the second operand\n     * @returns {vec4} out\n     */\n\n    function divide(out, a, b) {\n      out[0] = a[0] / b[0];\n      out[1] = a[1] / b[1];\n      out[2] = a[2] / b[2];\n      out[3] = a[3] / b[3];\n      return out;\n    }\n    /**\n     * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n     *\n     * @param {ReadonlyVec4} a The first vector.\n     * @param {ReadonlyVec4} b The second vector.\n     * @returns {Boolean} True if the vectors are equal, false otherwise.\n     */\n\n    function exactEquals(a, b) {\n      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n    }\n    /**\n     * Perform some operation over an array of vec4s.\n     *\n     * @param {Array} a the array of vectors to iterate over\n     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n     * @param {Number} offset Number of elements to skip at the beginning of the array\n     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n     * @param {Function} fn Function to call for each vector in the array\n     * @param {Object} [arg] additional argument to pass to fn\n     * @returns {Array} a\n     * @function\n     */\n\n    (function () {\n      var vec = create$5();\n      return function (a, stride, offset, count, fn, arg) {\n        var i, l;\n\n        if (!stride) {\n          stride = 4;\n        }\n\n        if (!offset) {\n          offset = 0;\n        }\n\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];\n          vec[1] = a[i + 1];\n          vec[2] = a[i + 2];\n          vec[3] = a[i + 3];\n          fn(vec, vec, arg);\n          a[i] = vec[0];\n          a[i + 1] = vec[1];\n          a[i + 2] = vec[2];\n          a[i + 3] = vec[3];\n        }\n\n        return a;\n      };\n    })();\n\n    /**\n     * 2 Dimensional Vector\n     * @module vec2\n     */\n\n    /**\n     * Creates a new, empty vec2\n     *\n     * @returns {vec2} a new 2D vector\n     */\n\n    function create$4() {\n      var out = new ARRAY_TYPE$1(2);\n\n      if (ARRAY_TYPE$1 != Float32Array) {\n        out[0] = 0;\n        out[1] = 0;\n      }\n\n      return out;\n    }\n    /**\n     * Set the components of a vec2 to the given values\n     *\n     * @param {vec2} out the receiving vector\n     * @param {Number} x X component\n     * @param {Number} y Y component\n     * @returns {vec2} out\n     */\n\n    function set$1(out, x, y) {\n      out[0] = x;\n      out[1] = y;\n      return out;\n    }\n    /**\n     * Calculates the euclidian distance between two vec2's\n     *\n     * @param {ReadonlyVec2} a the first operand\n     * @param {ReadonlyVec2} b the second operand\n     * @returns {Number} distance between a and b\n     */\n\n    function distance(a, b) {\n      var x = b[0] - a[0],\n          y = b[1] - a[1];\n      return Math.hypot(x, y);\n    }\n    /**\n     * Perform some operation over an array of vec2s.\n     *\n     * @param {Array} a the array of vectors to iterate over\n     * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n     * @param {Number} offset Number of elements to skip at the beginning of the array\n     * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n     * @param {Function} fn Function to call for each vector in the array\n     * @param {Object} [arg] additional argument to pass to fn\n     * @returns {Array} a\n     * @function\n     */\n\n    (function () {\n      var vec = create$4();\n      return function (a, stride, offset, count, fn, arg) {\n        var i, l;\n\n        if (!stride) {\n          stride = 2;\n        }\n\n        if (!offset) {\n          offset = 0;\n        }\n\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];\n          vec[1] = a[i + 1];\n          fn(vec, vec, arg);\n          a[i] = vec[0];\n          a[i + 1] = vec[1];\n        }\n\n        return a;\n      };\n    })();\n\n    const rad = Math.PI / 180;\n    const metersPerDegree = 6378137 * Math.PI / 180;\n    const maxLatitude = 85.0511287798;\n\n    function project(out, lnglat, projection) {\n        if (projection === 'EPSG:3857') {\n            return project3857(out, lnglat);\n        } else if (projection === 'EPSG:4326' || projection === 'EPSG:4490' || projection === 'identity') {\n            return project4326(out, lnglat);\n        } else if (projection === 'baidu') {\n            return project4326(out, lnglat);\n        } else {\n            throw new Error('unsupported projection:' + projection);\n        }\n    }\n\n    function project4326(out, lnglat) {\n        out[0] = lnglat[0];\n        out[1] = lnglat[1];\n        return out;\n    }\n\n    function project3857(out, lnglat) {\n        const max = maxLatitude;\n        const lng = lnglat[0],\n            lat = Math.max(Math.min(max, lnglat[1]), -85.0511287798);\n        let c;\n        if (lat === 0) {\n            c = 0;\n        } else {\n            c = Math.log(Math.tan((90 + lat) * rad / 2)) / rad;\n        }\n        out[0] = lng * metersPerDegree;\n        out[1] = c * metersPerDegree;\n        return out;\n    }\n\n    // 按照原来的uv计算时的缩放比例，计算的 meter 到 gl point 坐标的比例\n    // export const METER_TO_GL_POINT = 46.5;\n\n\n    function buildFaceUV(mode, start, offset, uvs, vertices, uvOrigin, centimeterToPoint, tileRatio, texWidth, texHeight, ombb, res, glScale, projectionCode, center) {\n        if (mode === 0) {\n            buildFlatUV(start, offset, uvs, vertices, uvOrigin, centimeterToPoint, tileRatio, texWidth, texHeight);\n        } else if (mode === 1) {\n            buildOmbbUV(ombb, start, offset, uvs, vertices, uvOrigin, tileRatio, res, glScale, projectionCode);\n        }\n    }\n\n    //inspired by https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n    function buildOmbbUV(obox, start, offset, uvs, vertices, uvOrigin, tileRatio, res, glScale, projectionCode, isExtrudePolygonLayer) {\n        if (!obox) {\n            return;\n        }\n        const idx = obox[4];\n        let v0, v1, v2, v3;\n        if (idx === 0) {\n            v0 = obox[0];\n            v1 = obox[1];\n            v2 = obox[2];\n            v3 = obox[3];\n        } else {\n            v0 = obox[1];\n            v1 = obox[2];\n            v2 = obox[3];\n            v3 = obox[0];\n        }\n        // 长边\n        const w = distance(v0, v1);\n        const h = distance(v1, v2);\n\n        const pt = [];\n        const perpX = [];\n        const perpY = [];\n\n        //为了提升精度，计算uvOrigin的小数部分\n        for (let i = start; i < offset; i += 3) {\n            const idx = i / 3 * 2;\n            const x = (uvOrigin.x / glScale + vertices[i] / tileRatio) * res;\n            const y = uvOrigin.y / glScale * res + (-vertices[i + 1]) / tileRatio * res;\n            set$1(pt, x, y);\n            if (projectionCode === 'EPSG:4326' || projectionCode === 'EPSG:4490') {\n                project(pt, pt, 'EPSG:3857');\n            }\n            getFootOfPerpendicular(perpX, pt, v0, v1);\n            getFootOfPerpendicular(perpY, pt, v3, v0);\n            uvs[idx] = distance(v0, perpX) / w;\n            uvs[idx + 1] = distance(v0, perpY) / h;\n        }\n    }\n\n    function getFootOfPerpendicular(\n        out,\n        pt,     // 直线外一点\n        begin,  // 直线开始点\n        end)   // 直线结束点\n    {\n\n        const dx = begin[0] - end[0];\n        const dy = begin[1] - end[1];\n\n        let u = (pt[0] - begin[0]) * (begin[0] - end[0]) +\n            (pt[1] - begin[1]) * (begin[1] - end[1]);\n        u = u / ((dx * dx)+(dy * dy));\n\n        out[0] = begin[0] + u * dx;\n        out[1] = begin[1] + u * dy;\n\n        return out;\n    }\n\n    function buildFlatUV(start, offset, uvs, vertices, uvOrigin, centimeterToPoint, tileRatio, texWidth, texHeight, center) {\n        const xPointToMeter = 1 / (centimeterToPoint[0] * 100);\n        const yPointToMeter = 1 / (centimeterToPoint[1] * 100);\n        //为了提升精度，计算uvOrigin的小数部分\n        // console.log([(uvOrigin.x / texWidth), (uvOrigin.y / texHeight)]);\n        // const uvStart = [(uvOrigin.x / texWidth) % 1, (uvOrigin.y / texHeight) % 1];\n        const centerX = (0);\n        const centerY = (0);\n        const uvStart = [0, 0];\n        for (let i = start; i < offset; i += 3) {\n            const idx = i / 3 * 2;\n            const x = vertices[i] - centerX;\n            const y = vertices[i + 1] - centerY;\n            uvs[idx] = uvStart[0] + (x / tileRatio * xPointToMeter) / texWidth;\n            uvs[idx + 1] = uvStart[1] - (y / tileRatio * yPointToMeter) / texHeight;\n        }\n    }\n\n    function buildSideUV(sideUVMode, sideVerticalUVMode, textureYOrigin, uvs, vertices, indices, indiceStart, texWidth, texHeight, tileRatio, verticalCentimeterToPoint, needReverseTriangle) {\n        let maxz = 0, minz = 0, h;\n        let lensofar = 0;\n        let seg = 0;\n\n        const segStart = 5;\n        const segEnd = needReverseTriangle ? [1, 3, 4] : [2, 3, 4];\n        //因为是逆时针，需要倒序遍历\n        const count = indices.getLength();\n        for (let i = count - 1; i >= indiceStart; i--) {\n            const idx = indices[i];\n            const ix = idx * 3, iy = idx * 3 + 1, iz = idx * 3 + 2;\n            const x = vertices[ix], y = vertices[iy], z = vertices[iz];\n            if (!maxz && !minz) {\n                maxz = Math.max(vertices[iz], vertices[indices[i - 3] * 3 + 2]);\n                minz = Math.min(vertices[iz], vertices[indices[i - 3] * 3 + 2]);\n                h = maxz - minz;\n            }\n            let len = lensofar;\n            const m = i % 6;\n            //每6个点构成一个矩形，其顺序如下：\n            //  1 -- 2(3)\n            //  |    |\n            // 0(5)- 4\n            // 如果是needReverseTriangle\n            //  2 -- 1(4)\n            //  |    |\n            // 0(5)- 3\n            if (sideUVMode === 0) {\n                //连续\n                if (m === segStart) {\n                    seg = getSegLength(vertices, indices, i, x, y);\n                }\n                if (m === segEnd[0] || m === segEnd[1] || m === segEnd[2]) {\n                    len = lensofar;\n                } else {\n                    len = lensofar + seg;\n                }\n            } else if (sideUVMode === 1) {\n                if (m === segEnd[0] || m === segEnd[1] || m === segEnd[2]) {\n                    len = 0;\n                } else if (m === segStart) {\n                    seg = getSegLength(vertices, indices, i, x, y);\n                    len = seg;\n                } else {\n                    len = seg;\n                }\n            }\n\n            // len * glScale = gl point， tileRatio = extent / tileSize\n            const pointToMeter = 1 / (verticalCentimeterToPoint * 100);\n            const u = len / tileRatio * pointToMeter / texWidth; //0 ? 1.0 - len * glScale / texWidth :\n            // const u = len * tileRatio * glScale / texWidth;\n            let v;\n\n            if (sideVerticalUVMode === 1) {\n                // 垂直平铺\n                // https://github.com/maptalks/issues/issues/294\n                v = z === maxz ? 1 : 0;\n            } else {\n                if (textureYOrigin === 'bottom') {\n                    // 除以 100 是从厘米转换为米\n                    v = (z === maxz ? h / 100 / texHeight : 0);\n                } else {\n                    v = (z === maxz ? 0 : -h / 100 / texHeight);\n                }\n            }\n\n            uvs[idx * 2] = u;\n            uvs[idx * 2 + 1] = v;\n\n            if (m === 0) {\n                lensofar += seg;\n            }\n            // prex = x;\n            // prey = y;\n        }\n    }\n\n    function getSegLength(vertices, indices, i, x, y) {\n        const ix = indices[i - 1] * 3, iy = indices[i - 1] * 3 + 1;\n        const nextx = vertices[ix], nexty = vertices[iy];\n        return distanceTo(x, y, nextx, nexty);\n    }\n\n    /**\n     * caculate 2 points' distance\n     * @param {Number} x0 - x0\n     * @param {Number} y0 - y0\n     * @param {Number} x1 - x1\n     * @param {Number} y1 - y1\n     */\n    function distanceTo(x0, y0, x1, y1) {\n        return Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n    }\n\n    function earcut(data, holeIndices, dim = 2) {\n\n        const hasHoles = holeIndices && holeIndices.length;\n        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n        let outerNode = linkedList(data, 0, outerLen, dim, true);\n        const triangles = [];\n\n        if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n        let minX, minY, invSize;\n\n        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n        if (data.length > 80 * dim) {\n            minX = Infinity;\n            minY = Infinity;\n            let maxX = -Infinity;\n            let maxY = -Infinity;\n\n            for (let i = dim; i < outerLen; i += dim) {\n                const x = data[i];\n                const y = data[i + 1];\n                if (x < minX) minX = x;\n                if (y < minY) minY = y;\n                if (x > maxX) maxX = x;\n                if (y > maxY) maxY = y;\n            }\n\n            // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n            invSize = Math.max(maxX - minX, maxY - minY);\n            invSize = invSize !== 0 ? 32767 / invSize : 0;\n        }\n\n        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n        return triangles;\n    }\n\n    // create a circular doubly linked list from polygon points in the specified winding order\n    function linkedList(data, start, end, dim, clockwise) {\n        let last;\n\n        if (clockwise === (signedArea$1(data, start, end, dim) > 0)) {\n            for (let i = start; i < end; i += dim) last = insertNode$1(i / dim | 0, data[i], data[i + 1], last);\n        } else {\n            for (let i = end - dim; i >= start; i -= dim) last = insertNode$1(i / dim | 0, data[i], data[i + 1], last);\n        }\n\n        if (last && equals(last, last.next)) {\n            removeNode(last);\n            last = last.next;\n        }\n\n        return last;\n    }\n\n    // eliminate colinear or duplicate points\n    function filterPoints(start, end) {\n        if (!start) return start;\n        if (!end) end = start;\n\n        let p = start,\n            again;\n        do {\n            again = false;\n\n            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n                removeNode(p);\n                p = end = p.prev;\n                if (p === p.next) break;\n                again = true;\n\n            } else {\n                p = p.next;\n            }\n        } while (again || p !== end);\n\n        return end;\n    }\n\n    // main ear slicing loop which triangulates a polygon (given as a linked list)\n    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n        if (!ear) return;\n\n        // interlink polygon nodes in z-order\n        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n        let stop = ear;\n\n        // iterate through ears, slicing them one by one\n        while (ear.prev !== ear.next) {\n            const prev = ear.prev;\n            const next = ear.next;\n\n            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n                triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n                removeNode(ear);\n\n                // skipping the next vertex leads to less sliver triangles\n                ear = next.next;\n                stop = next.next;\n\n                continue;\n            }\n\n            ear = next;\n\n            // if we looped through the whole remaining polygon and can't find any more ears\n            if (ear === stop) {\n                // try filtering points and slicing again\n                if (!pass) {\n                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n                } else if (pass === 1) {\n                    ear = cureLocalIntersections(filterPoints(ear), triangles);\n                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n                } else if (pass === 2) {\n                    splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                }\n\n                break;\n            }\n        }\n    }\n\n    // check whether a polygon node forms a valid ear with adjacent nodes\n    function isEar(ear) {\n        const a = ear.prev,\n            b = ear,\n            c = ear.next;\n\n        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n        // now make sure we don't have other points inside the potential ear\n        const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n        // triangle bbox\n        const x0 = Math.min(ax, bx, cx),\n            y0 = Math.min(ay, by, cy),\n            x1 = Math.max(ax, bx, cx),\n            y1 = Math.max(ay, by, cy);\n\n        let p = c.next;\n        while (p !== a) {\n            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0) return false;\n            p = p.next;\n        }\n\n        return true;\n    }\n\n    function isEarHashed(ear, minX, minY, invSize) {\n        const a = ear.prev,\n            b = ear,\n            c = ear.next;\n\n        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n        const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n        // triangle bbox\n        const x0 = Math.min(ax, bx, cx),\n            y0 = Math.min(ay, by, cy),\n            x1 = Math.max(ax, bx, cx),\n            y1 = Math.max(ay, by, cy);\n\n        // z-order range for the current triangle bbox;\n        const minZ = zOrder(x0, y0, minX, minY, invSize),\n            maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n        let p = ear.prevZ,\n            n = ear.nextZ;\n\n        // look for points inside the triangle in both directions\n        while (p && p.z >= minZ && n && n.z <= maxZ) {\n            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n            p = p.prevZ;\n\n            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n            n = n.nextZ;\n        }\n\n        // look for remaining points in decreasing z-order\n        while (p && p.z >= minZ) {\n            if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n            p = p.prevZ;\n        }\n\n        // look for remaining points in increasing z-order\n        while (n && n.z <= maxZ) {\n            if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n                pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n            n = n.nextZ;\n        }\n\n        return true;\n    }\n\n    // go through all polygon nodes and cure small local self-intersections\n    function cureLocalIntersections(start, triangles) {\n        let p = start;\n        do {\n            const a = p.prev,\n                b = p.next.next;\n\n            if (!equals(a, b) && intersects$2(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n                triangles.push(a.i, p.i, b.i);\n\n                // remove two nodes involved\n                removeNode(p);\n                removeNode(p.next);\n\n                p = start = b;\n            }\n            p = p.next;\n        } while (p !== start);\n\n        return filterPoints(p);\n    }\n\n    // try splitting polygon into two and triangulate them independently\n    function splitEarcut(start, triangles, dim, minX, minY, invSize) {\n        // look for a valid diagonal that divides the polygon into two\n        let a = start;\n        do {\n            let b = a.next.next;\n            while (b !== a.prev) {\n                if (a.i !== b.i && isValidDiagonal(a, b)) {\n                    // split the polygon in two by the diagonal\n                    let c = splitPolygon(a, b);\n\n                    // filter colinear points around the cuts\n                    a = filterPoints(a, a.next);\n                    c = filterPoints(c, c.next);\n\n                    // run earcut on each half\n                    earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                    earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                    return;\n                }\n                b = b.next;\n            }\n            a = a.next;\n        } while (a !== start);\n    }\n\n    // link every hole into the outer loop, producing a single-ring polygon without holes\n    function eliminateHoles(data, holeIndices, outerNode, dim) {\n        const queue = [];\n\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            const list = linkedList(data, start, end, dim, false);\n            if (list === list.next) list.steiner = true;\n            queue.push(getLeftmost(list));\n        }\n\n        queue.sort(compareXYSlope);\n\n        // process holes from left to right\n        for (let i = 0; i < queue.length; i++) {\n            outerNode = eliminateHole(queue[i], outerNode);\n        }\n\n        return outerNode;\n    }\n\n    function compareXYSlope(a, b) {\n        let result = a.x - b.x;\n        // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n        // the bridge to the outer shell is always the point that they meet at.\n        if (result === 0) {\n            result = a.y - b.y;\n            if (result === 0) {\n                const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n                const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n                result = aSlope - bSlope;\n            }\n        }\n        return result;\n    }\n\n    // find a bridge between vertices that connects hole with an outer ring and and link it\n    function eliminateHole(hole, outerNode) {\n        const bridge = findHoleBridge(hole, outerNode);\n        if (!bridge) {\n            return outerNode;\n        }\n\n        const bridgeReverse = splitPolygon(bridge, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(bridgeReverse, bridgeReverse.next);\n        return filterPoints(bridge, bridge.next);\n    }\n\n    // David Eberly's algorithm for finding a bridge between hole and outer polygon\n    function findHoleBridge(hole, outerNode) {\n        let p = outerNode;\n        const hx = hole.x;\n        const hy = hole.y;\n        let qx = -Infinity;\n        let m;\n\n        // find a segment intersected by a ray from the hole's leftmost point to the left;\n        // segment's endpoint with lesser x will be potential connection point\n        // unless they intersect at a vertex, then choose the vertex\n        if (equals(hole, p)) return p;\n        do {\n            if (equals(hole, p.next)) return p.next;\n            else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                if (x <= hx && x > qx) {\n                    qx = x;\n                    m = p.x < p.next.x ? p : p.next;\n                    if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n                }\n            }\n            p = p.next;\n        } while (p !== outerNode);\n\n        if (!m) return null;\n\n        // look for points inside the triangle of hole point, segment intersection and endpoint;\n        // if there are no points found, we have a valid connection;\n        // otherwise choose the point of the minimum angle with the ray as connection point\n\n        const stop = m;\n        const mx = m.x;\n        const my = m.y;\n        let tanMin = Infinity;\n\n        p = m;\n\n        do {\n            if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                    pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n                const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n                if (locallyInside(p, hole) &&\n                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                    m = p;\n                    tanMin = tan;\n                }\n            }\n\n            p = p.next;\n        } while (p !== stop);\n\n        return m;\n    }\n\n    // whether sector in vertex m contains sector in vertex p in the same coordinates\n    function sectorContainsSector(m, p) {\n        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n    }\n\n    // interlink polygon nodes in z-order\n    function indexCurve(start, minX, minY, invSize) {\n        let p = start;\n        do {\n            if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n            p.prevZ = p.prev;\n            p.nextZ = p.next;\n            p = p.next;\n        } while (p !== start);\n\n        p.prevZ.nextZ = null;\n        p.prevZ = null;\n\n        sortLinked(p);\n    }\n\n    // Simon Tatham's linked list merge sort algorithm\n    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n    function sortLinked(list) {\n        let numMerges;\n        let inSize = 1;\n\n        do {\n            let p = list;\n            let e;\n            list = null;\n            let tail = null;\n            numMerges = 0;\n\n            while (p) {\n                numMerges++;\n                let q = p;\n                let pSize = 0;\n                for (let i = 0; i < inSize; i++) {\n                    pSize++;\n                    q = q.nextZ;\n                    if (!q) break;\n                }\n                let qSize = inSize;\n\n                while (pSize > 0 || (qSize > 0 && q)) {\n\n                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    } else {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    }\n\n                    if (tail) tail.nextZ = e;\n                    else list = e;\n\n                    e.prevZ = tail;\n                    tail = e;\n                }\n\n                p = q;\n            }\n\n            tail.nextZ = null;\n            inSize *= 2;\n\n        } while (numMerges > 1);\n\n        return list;\n    }\n\n    // z-order of a point given coords and inverse of the longer side of data bbox\n    function zOrder(x, y, minX, minY, invSize) {\n        // coords are transformed into non-negative 15-bit integer range\n        x = (x - minX) * invSize | 0;\n        y = (y - minY) * invSize | 0;\n\n        x = (x | (x << 8)) & 0x00FF00FF;\n        x = (x | (x << 4)) & 0x0F0F0F0F;\n        x = (x | (x << 2)) & 0x33333333;\n        x = (x | (x << 1)) & 0x55555555;\n\n        y = (y | (y << 8)) & 0x00FF00FF;\n        y = (y | (y << 4)) & 0x0F0F0F0F;\n        y = (y | (y << 2)) & 0x33333333;\n        y = (y | (y << 1)) & 0x55555555;\n\n        return x | (y << 1);\n    }\n\n    // find the leftmost node of a polygon ring\n    function getLeftmost(start) {\n        let p = start,\n            leftmost = start;\n        do {\n            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n            p = p.next;\n        } while (p !== start);\n\n        return leftmost;\n    }\n\n    // check if a point lies within a convex triangle\n    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n               (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n               (bx - px) * (cy - py) >= (cx - px) * (by - py);\n    }\n\n    // check if a point lies within a convex triangle but false if its equal to the first point of the triangle\n    function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n        return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n    }\n\n    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n    function isValidDiagonal(a, b) {\n        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n               (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n                (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n                equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n    }\n\n    // signed area of a triangle\n    function area(p, q, r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    }\n\n    // check if two points are equal\n    function equals(p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n    }\n\n    // check if two segments intersect\n    function intersects$2(p1, q1, p2, q2) {\n        const o1 = sign(area(p1, q1, p2));\n        const o2 = sign(area(p1, q1, q2));\n        const o3 = sign(area(p2, q2, p1));\n        const o4 = sign(area(p2, q2, q1));\n\n        if (o1 !== o2 && o3 !== o4) return true; // general case\n\n        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n        return false;\n    }\n\n    // for collinear points p, q, r, check if point q lies on segment pr\n    function onSegment(p, q, r) {\n        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n    }\n\n    function sign(num) {\n        return num > 0 ? 1 : num < 0 ? -1 : 0;\n    }\n\n    // check if a polygon diagonal intersects any polygon segments\n    function intersectsPolygon(a, b) {\n        let p = a;\n        do {\n            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                    intersects$2(p, p.next, a, b)) return true;\n            p = p.next;\n        } while (p !== a);\n\n        return false;\n    }\n\n    // check if a polygon diagonal is locally inside the polygon\n    function locallyInside(a, b) {\n        return area(a.prev, a, a.next) < 0 ?\n            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n    }\n\n    // check if the middle point of a polygon diagonal is inside the polygon\n    function middleInside(a, b) {\n        let p = a;\n        let inside = false;\n        const px = (a.x + b.x) / 2;\n        const py = (a.y + b.y) / 2;\n        do {\n            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n                inside = !inside;\n            p = p.next;\n        } while (p !== a);\n\n        return inside;\n    }\n\n    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n    // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n    function splitPolygon(a, b) {\n        const a2 = createNode$1(a.i, a.x, a.y),\n            b2 = createNode$1(b.i, b.x, b.y),\n            an = a.next,\n            bp = b.prev;\n\n        a.next = b;\n        b.prev = a;\n\n        a2.next = an;\n        an.prev = a2;\n\n        b2.next = a2;\n        a2.prev = b2;\n\n        bp.next = b2;\n        b2.prev = bp;\n\n        return b2;\n    }\n\n    // create a node and optionally link it with previous one (in a circular doubly linked list)\n    function insertNode$1(i, x, y, last) {\n        const p = createNode$1(i, x, y);\n\n        if (!last) {\n            p.prev = p;\n            p.next = p;\n\n        } else {\n            p.next = last.next;\n            p.prev = last;\n            last.next.prev = p;\n            last.next = p;\n        }\n        return p;\n    }\n\n    function removeNode(p) {\n        p.next.prev = p.prev;\n        p.prev.next = p.next;\n\n        if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n        if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n    }\n\n    function createNode$1(i, x, y) {\n        return {\n            i, // vertex index in coordinates array\n            x, y, // vertex coordinates\n            prev: null, // previous and next vertex nodes in a polygon ring\n            next: null,\n            z: 0, // z-order curve value\n            prevZ: null, // previous and next nodes in z-order\n            nextZ: null,\n            steiner: false // indicates whether this is a steiner point\n        };\n    }\n\n    function signedArea$1(data, start, end, dim) {\n        let sum = 0;\n        for (let i = start, j = end - dim; i < end; i += dim) {\n            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n            j = i;\n        }\n        return sum;\n    }\n\n    const KEY_IDX = '__fea_idx';\n\n    // an impossible altitude to mark invalid altitude values\n    new Float32Array([-1e12])[0];\n\n    const PROP_OMBB = 'maptalks_ombb';\n\n    /* eslint-disable no-undef */\n    const PACKER_KEY = 'maptalks_vt_packers';\n    const getGlobal = function () {\n        if (typeof undefinedThis !== 'undefined') { return globalThis; }\n        if (typeof self !== 'undefined') { return self; }\n        if (typeof window !== 'undefined') { return window; }\n        if (typeof undefined !== 'undefined') { return global; }\n        throw new Error('unable to locate global object');\n    };\n\n    function getVectorPacker() {\n        return getGlobal()[PACKER_KEY];\n    }\n\n    const { PackUtil: PackUtil$5, ArrayPool: ArrayPool$1 } = getVectorPacker();\n\n    function buildExtrudeFaces(\n        features, EXTENT,\n        {\n            altitudeScale, altitudeProperty, defaultAltitude, heightProperty, minHeightProperty, defaultHeight\n        },\n        {\n            center,\n            side,\n            top,\n            topThickness,\n            uvOrigin,\n            uv,\n            uvSize,\n            topUVMode,\n            sideUVMode,\n            sideVerticalUVMode,\n            textureYOrigin,\n            // vScale用于将meter转为gl point值\n            // tileRatio = extent / tileSize\n            tileRatio,\n            // 厘米到tile point\n            centimeterToPoint,\n            verticalCentimeterToPoint,\n            positionType,\n            res,\n            glScale,\n            projectionCode\n        },\n        debugIndex, arrayPool\n    ) {\n        // debugger\n        let scale = EXTENT / features[0].extent;\n        if (EXTENT === Infinity) {\n            scale = 1;\n        }\n        // Vector3DLayer下，需要反向的triangle\n        const needReverseTriangle = EXTENT === Infinity;\n\n        // const size = countVertexes(features) * 2;\n        //featIndexes : index of indices for each feature\n        // const arrCtor = getIndexArrayType(features.length);\n\n        // !! 这里是危险区域，需要格外注意：\n        // 2024年06月，为了提升arrayPool中数组的性能，arrayPool.get方法范围的数组不再使用Proxy对array进行包装，导致array.length不再返回array中的数据条数，而是数组本身的大小。\n        // 所以使用该类数组时，需要使用 array.getLength() 才能返回正确的数据条数，而用 array.length 会返回错误的值\n\n        const featIndexes = arrayPool.get();\n        const pickingIds = arrayPool.get();\n        const featIds = arrayPool.get();\n        // arrayPool.getProxy() 返回的数组会用Proxy包装，其 .length 和 .getLength() 返回的值是一致的，但读取性能比 arrayPool.get() 返回的数组慢很多，多用于传递给第三方库作为参数（例如这里的earcut）\n        const geoVertices = arrayPool.getProxy();\n        const vertices = arrayPool.get();\n        const indices = arrayPool.get();\n        const verticeTypes = arrayPool.get();\n        const generateUV = !!uv,\n            generateTop = !!top,\n            generateSide = !!side;\n        const uvs = generateUV ? arrayPool.get() : null;\n        // const clipEdges = [];\n        function fillData(start, offset, holes, height, ombb, needReverseTriangle) {\n            let typeStartOffset = offset;\n            //just ignore bottom faces never appear in sight\n            if (generateTop) {\n                const triangles = earcut(geoVertices, holes, 3); //vertices, holes, dimension(2|3)\n                if (triangles.length === 0) {\n                    return offset;\n                }\n                //TODO caculate earcut deviation\n                // pushIn(vertices, geoVertices);\n                let count = geoVertices.getLength();\n                let index = vertices.currentIndex;\n                for (let i = 0; i < count; i++) {\n                    vertices[index++] = geoVertices[i];\n                }\n                vertices.currentIndex = index;\n\n                offset += geoVertices.getLength();\n                //switch triangle's i + 1 and i + 2 to make it ccw winding\n                if (needReverseTriangle) {\n                    for (let i = 2, l = triangles.length; i < l; i += 3) {\n                        triangles[i] += start / 3;\n                        triangles[i - 1] += start / 3;\n                        triangles[i - 2] += start / 3;\n                    }\n                } else {\n                    let tmp;\n                    for (let i = 2, l = triangles.length; i < l; i += 3) {\n                        tmp = triangles[i - 1];\n                        triangles[i - 1] = triangles[i] + start / 3;\n                        triangles[i] = tmp + start / 3;\n                        triangles[i - 2] += start / 3;\n                    }\n                }\n\n                //top face indices\n                // pushIn(indices, triangles);\n                count = triangles.length;\n                index = indices.currentIndex;\n                for (let i = 0; i < count; i++) {\n                    indices[index++] = triangles[i];\n                }\n                indices.currentIndex = index;\n                if (generateUV) {\n                    // debugger\n                    buildFaceUV(topUVMode || 0, start, offset, uvs, vertices, uvOrigin, centimeterToPoint, tileRatio, uvSize[0], uvSize[1], ombb, res, glScale, projectionCode);\n                }\n\n                if (topThickness > 0 && !generateSide) {\n                    const reverseSide = height < 0;\n                    offset = buildSide(vertices, geoVertices, holes, indices, offset, uvs, 0, topThickness, EXTENT, generateUV, sideUVMode || 0, sideVerticalUVMode || 0, textureYOrigin, uvSize, tileRatio, verticalCentimeterToPoint, reverseSide ? !needReverseTriangle : needReverseTriangle);\n                }\n                verticeTypes.setLength(offset / 3);\n                verticeTypes.fill(1, typeStartOffset / 3, offset / 3);\n            }\n            // debugger\n            if (generateSide) {\n                if (generateTop) {\n                    topThickness = 0;\n                }\n                const reverseSide = height < 0;\n                typeStartOffset = offset;\n                offset = buildSide(vertices, geoVertices, holes, indices, offset, uvs, topThickness, height, EXTENT, generateUV, sideUVMode || 0, sideVerticalUVMode || 0, textureYOrigin, uvSize, tileRatio, verticalCentimeterToPoint, reverseSide ? !needReverseTriangle : needReverseTriangle);\n                verticeTypes.setLength(offset / 3);\n                const count = geoVertices.getLength() / 3;\n                verticeTypes.fill(1, typeStartOffset / 3, typeStartOffset / 3 + count);\n                verticeTypes.fill(0, typeStartOffset / 3 + count, typeStartOffset / 3 + 2 * count);\n                verticeTypes.fill(1, typeStartOffset / 3 + 2 * count, typeStartOffset / 3 + 3 * count);\n                verticeTypes.fill(0, typeStartOffset / 3 + 3 * count, offset / 3);\n            }\n            return offset;\n        }\n\n        let maxAltitude = -Infinity;\n        let minAltitude = Infinity;\n        let offset = 0;\n        const BOUNDS = [-1, -1, EXTENT + 1, EXTENT + 1];\n\n        let r = 0, n = features.length;\n        if (isNumber$1(debugIndex)) {\n            r = debugIndex;\n            n = debugIndex + 1;\n        }\n        let maxFeaId = 0;\n        let hasNegative = false;\n        const holes = arrayPool.getProxy();\n        let hasNegativeHeight = false;\n        for (; r < n; r++) {\n            const feature = features[r];\n            const feaId = feature.id;\n            if (isNumber$1(feaId)) {\n                if (Math.abs(feaId) > maxFeaId) {\n                    maxFeaId = Math.abs(feaId);\n                }\n                if (feaId < 0) {\n                    hasNegative = true;\n                }\n            }\n\n            const geometry = feature.geometry;\n            const ombb = feature.properties[PROP_OMBB];\n            const isMultiOmbb = Array.isArray(ombb && ombb[0] && ombb[0][0]);\n            let ringOmbb = isMultiOmbb ? ombb[0] : ombb;\n\n            const { altitude, height } = PackUtil$5.getFeaAltitudeAndHeight(feature, altitudeScale, altitudeProperty, defaultAltitude, heightProperty, defaultHeight, minHeightProperty);\n            if (height < 0) {\n                hasNegativeHeight = true;\n                minAltitude = Math.min(altitude, minAltitude);\n                maxAltitude = Math.max(altitude - height, maxAltitude);\n            } else {\n                maxAltitude = Math.max(altitude, maxAltitude);\n                minAltitude = Math.min(altitude - height, minAltitude);\n            }\n\n            const verticeCount = vertices.getLength();\n\n            let exteriorIndex = 0;\n            let start = offset;\n            holes.setLength(0);\n            geoVertices.setLength(0);\n            const shellIsClockwise = PackUtil$5.calculateSignedArea(geometry[0]) < 0;\n            for (let i = 0, l = geometry.length; i < l; i++) {\n                let ring = geometry[i];\n                if (shellIsClockwise) {\n                    ring = ring.reverse();\n                }\n                ring = cleanVertices(ring);\n                const isHole = PackUtil$5.calculateSignedArea(ring) < 0;\n                //fill bottom vertexes\n                if (!isHole && i > 0) {\n                    exteriorIndex++;\n                    ringOmbb = ombb && ombb[exteriorIndex];\n                    //an exterior ring (multi polygon)\n                    offset = fillData(start, offset, holes, height * scale, ringOmbb, needReverseTriangle); //need to multiply with scale as altitude is\n                    geoVertices.setLength(0);\n                    holes.setLength(0);\n                    start = offset;\n                }\n                if (EXTENT !== Infinity) {\n                    ring = PackUtil$5.clipPolygon(ring, BOUNDS);\n                }\n                if (!ring.length) {\n                    if (i === l - 1) {\n                        offset = fillData(start, offset, holes, height * scale, ringOmbb, needReverseTriangle); //need to multiply with scale as altitude is\n                    }\n                    continue;\n                }\n                const ringLen = ring.length;\n                if (Array.isArray(ring[0])) {\n                    if (ring[0][0] !== ring[ringLen - 1][0] || ring[0][1] !== ring[ringLen - 1][1]) {\n                        //首尾不一样时，在末尾添加让首尾封闭\n                        ring.push([ring[0][0], ring[0][1]]);\n                    }\n                } else if (ring[0].x !== ring[ringLen - 1].x || ring[0].y !== ring[ringLen - 1].y) {\n                    //首尾不一样时，在末尾添加让首尾封闭\n                    ring.push(ring[0]);\n                }\n                if (isHole) {\n                    let index = holes.currentIndex;\n                    holes[index++] = geoVertices.getLength() / 3;\n                    holes.currentIndex = index;\n                }\n                //a seg or a ring in line or polygon\n                fillPosArray(geoVertices, geoVertices.getLength(), ring, scale, altitude, false, positionType);\n\n                if (i === l - 1) {\n                    offset = fillData(start, offset, holes, height * scale, ringOmbb, needReverseTriangle); //need to multiply with scale as altitude is\n                }\n            }\n\n            const count = vertices.getLength() - verticeCount;\n            const keyName = (KEY_IDX + '').trim();\n            for (let i = 0; i < count / 3; i++) {\n                let index = pickingIds.currentIndex;\n                pickingIds[index++] = feature[keyName] === undefined ? r : feature[keyName];\n                pickingIds.currentIndex = index;\n\n                index = featIndexes.currentIndex;\n                featIndexes[index++] = r;\n                featIndexes.currentIndex = index;\n\n                // pickingIds.push(feature[keyName] === undefined ? r : feature[keyName]);\n                // featIndexes.push(r);\n                if (isNumber$1(feaId)) {\n                    index = featIds.currentIndex;\n                    featIds[index++] = feaId;\n                    featIds.currentIndex = index;\n                    // featIds.push(feaId);\n                }\n            }\n        }\n        const pickingCtor = PackUtil$5.getUnsignedArrayType(pickingIds.getLength() ? pickingIds[pickingIds.getLength() - 1] : 0);\n\n        const data = {\n            hasNegativeHeight,\n            maxAltitude: maxAltitude === -Infinity ? 0 : maxAltitude,\n            minAltitude: minAltitude === Infinity ? 0 : minAltitude,\n            vertices: vertices,        // vertexes\n            verticeTypes,\n            indices,                                    // indices for drawElements\n            pickingIds: ArrayPool$1.createTypedArray(pickingIds, pickingCtor),   // vertex index of each feature\n            featureIndexes: featIndexes\n        };\n        if (featIds.getLength()) {\n            const feaCtor = hasNegative ? PackUtil$5.getPosArrayType(maxFeaId) : PackUtil$5.getUnsignedArrayType(maxFeaId);\n            data.featureIds = ArrayPool$1.createTypedArray(featIds, feaCtor);\n        } else {\n            data.featureIds = [];\n        }\n        if (uvs) {\n            //因为vertices中最后一位不在indices中引用，uvs为保持位数与vertices一致，需补充2位\n            uvs.setLength(vertices.getLength() / 3 * 2);\n            //改成int16\n            data.uvs = uvs;\n        }\n        return data;\n    }\n\n    function buildSide(vertices, topVertices, holes, indices, offset, uvs, topThickness, height, EXTENT, generateUV, sideUVMode, sideVerticalUVMode, textureYOrigin, uvSize, tileRatio, verticalCentimeterToPoint, needReverseTriangle) {\n        const count = topVertices.getLength();\n        const startIdx = offset / 3;\n        //拷贝两次top和bottom，是为了让侧面的三角形使用不同的端点，避免uv和normal值因为共端点产生错误\n        //top vertexes\n        for (let i = 2, l = count; i < l; i += 3) {\n            vertices[offset + i - 2] = topVertices[i - 2];\n            vertices[offset + i - 1] = topVertices[i - 1];\n            vertices[offset + i - 0] = topVertices[i] - topThickness;\n        }\n        offset += count;\n        //bottom vertexes\n        for (let i = 2, l = count; i < l; i += 3) {\n            vertices[offset + i - 2] = topVertices[i - 2];\n            vertices[offset + i - 1] = topVertices[i - 1];\n            vertices[offset + i - 0] = topVertices[i] - height;\n        }\n        offset += count;\n        //top vertexes\n        // for (let i = 2, l = count; i < l; i += 3) {\n        //     vertices[offset + i - 2] = topVertices[i - 2];\n        //     vertices[offset + i - 1] = topVertices[i - 1];\n        //     vertices[offset + i - 0] = topVertices[i] - topThickness;\n        // }\n        vertices.trySetLength(offset + count);\n        vertices.copyWithin(offset, offset - 2 * count, offset - count);\n        offset += count;\n        //bottom vertexes\n        vertices.trySetLength(offset + count);\n        vertices.copyWithin(offset, offset - 2 * count, offset - count);\n        // for (let i = 2, l = count; i < l; i += 3) {\n        //     vertices[offset + i - 2] = topVertices[i - 2];\n        //     vertices[offset + i - 1] = topVertices[i - 1];\n        //     vertices[offset + i - 0] = topVertices[i] - height;\n        // }\n        offset += count;\n        // vertices.trySetLength(offset);\n        holes = holes || [];\n        holes.push(count / 3);\n        const holeCount = holes.getLength();\n        for (let r = 0; r < holeCount; r++) {\n            // #287, 遍历geometry中的每个ring，构造侧面三角形和uv坐标\n            const ringStart = startIdx + (holes[r - 1] || 0);\n            const ringEnd = startIdx + holes[r];\n\n            buildRingSide(ringStart, ringEnd, vertices, count / 3, EXTENT, indices,\n                generateUV, sideUVMode, sideVerticalUVMode, textureYOrigin, uvs, uvSize, tileRatio, verticalCentimeterToPoint, needReverseTriangle);\n        }\n        return offset;\n    }\n\n    function buildRingSide(ringStart, ringEnd, vertices, vertexCount, EXTENT, indices,\n        generateUV, sideUVMode, sideVerticalUVMode, textureYOrigin, uvs, uvSize, tileRatio, verticalCentimeterToPoint, needReverseTriangle) {\n        const indiceStart = indices.getLength();\n        let current, next;\n        for (let i = ringStart, l = ringEnd; i < l - 1; i++) {\n            current = i;\n            next = i + 1;\n            if (EXTENT !== Infinity && isClippedEdge(vertices, current, next, EXTENT)) {\n                continue;\n            }\n            if ((i - ringStart) % 2 === 1) {\n                //加上 2 * vertexCount，使用与 i % 2 === 0 时，不同的另一组端点，以避免共端点\n                current += 2 * vertexCount;\n                next += 2 * vertexCount;\n            }\n\n            if (!needReverseTriangle) {\n                let index = indices.currentIndex;\n                //bottom[i], top[i], top[i + 1]\n                indices[index++] = current + vertexCount;\n                indices[index++] = current;\n                indices[index++] = next;\n                //top[i + 1], bottom[i + 1],  bottom[i]\n                indices[index++] = next;\n                indices[index++] = next + vertexCount;\n                indices[index++] = current + vertexCount;\n\n                indices.currentIndex = index;\n                //bottom[i], top[i], top[i + 1]\n                // indices.push(current + vertexCount, current, next);\n                //top[i + 1], bottom[i + 1],  bottom[i]\n                // indices.push(next, next + vertexCount, current + vertexCount);\n            } else {\n                let index = indices.currentIndex;\n                //bottom[i], top[i], top[i + 1]\n                indices[index++] = current + vertexCount;\n                indices[index++] = next;\n                indices[index++] = current;\n                //top[i + 1], bottom[i + 1],  bottom[i]\n                indices[index++] = next + vertexCount;\n                indices[index++] = next;\n                indices[index++] = current + vertexCount;\n\n                indices.currentIndex = index;\n                // indices.push(current + vertexCount, next, current);\n                // indices.push(next + vertexCount, next, current + vertexCount);\n            }\n\n        }\n        if (generateUV) {\n            buildSideUV(sideUVMode, sideVerticalUVMode, textureYOrigin, uvs, vertices, indices, indiceStart, uvSize[0], uvSize[1], tileRatio, verticalCentimeterToPoint, needReverseTriangle); //convert uvSize[1] to meter\n        }\n    }\n\n    function cleanVertices(ring) {\n        const result = [ring[0]];\n        let currentVertice = ring[0];\n        for (let i = 1; i < ring.length; i++) {\n            if (Array.isArray(ring[i])) {\n                if (ring[i][0] !== currentVertice[0] || ring[i][1] !== currentVertice[1] || ring[i][2] !== currentVertice[2]) {\n                    result.push(ring[i]);\n                }\n            } else {\n                if (ring[i].x !== currentVertice.x || ring[i].y !== currentVertice.y || ring[i].z !== currentVertice.z) {\n                    result.push(ring[i]);\n                }\n            }\n            currentVertice = ring[i];\n        }\n        return result;\n    }\n\n    /**\n     * Common utilities\n     * @module glMatrix\n     */\n\n    // Configuration Constants\n    var EPSILON = 0.000001;\n    var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\n    /**\n     * 3x3 Matrix\n     * @module mat3\n     */\n\n    /**\n     * Creates a new identity mat3\n     *\n     * @returns {mat3} a new 3x3 matrix\n     */\n    function create$3() {\n      var out = new ARRAY_TYPE(9);\n      if (ARRAY_TYPE != Float32Array) {\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[5] = 0;\n        out[6] = 0;\n        out[7] = 0;\n      }\n      out[0] = 1;\n      out[4] = 1;\n      out[8] = 1;\n      return out;\n    }\n\n    /**\n     * 3 Dimensional Vector\n     * @module vec3\n     */\n\n    /**\n     * Creates a new, empty vec3\n     *\n     * @returns {vec3} a new 3D vector\n     */\n    function create$2() {\n      var out = new ARRAY_TYPE(3);\n      if (ARRAY_TYPE != Float32Array) {\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n      }\n      return out;\n    }\n\n    /**\n     * Calculates the length of a vec3\n     *\n     * @param {vec3} a vector to calculate length of\n     * @returns {Number} length of a\n     */\n    function length(a) {\n      var x = a[0];\n      var y = a[1];\n      var z = a[2];\n      return Math.sqrt(x * x + y * y + z * z);\n    }\n\n    /**\n     * Creates a new vec3 initialized with the given values\n     *\n     * @param {Number} x X component\n     * @param {Number} y Y component\n     * @param {Number} z Z component\n     * @returns {vec3} a new 3D vector\n     */\n    function fromValues(x, y, z) {\n      var out = new ARRAY_TYPE(3);\n      out[0] = x;\n      out[1] = y;\n      out[2] = z;\n      return out;\n    }\n\n    /**\n     * Copy the values from one vec3 to another\n     *\n     * @param {vec3} out the receiving vector\n     * @param {vec3} a the source vector\n     * @returns {vec3} out\n     */\n    function copy(out, a) {\n      out[0] = a[0];\n      out[1] = a[1];\n      out[2] = a[2];\n      return out;\n    }\n\n    /**\n     * Set the components of a vec3 to the given values\n     *\n     * @param {vec3} out the receiving vector\n     * @param {Number} x X component\n     * @param {Number} y Y component\n     * @param {Number} z Z component\n     * @returns {vec3} out\n     */\n    function set(out, x, y, z) {\n      out[0] = x;\n      out[1] = y;\n      out[2] = z;\n      return out;\n    }\n\n    /**\n     * Adds two vec3's\n     *\n     * @param {vec3} out the receiving vector\n     * @param {vec3} a the first operand\n     * @param {vec3} b the second operand\n     * @returns {vec3} out\n     */\n    function add(out, a, b) {\n      out[0] = a[0] + b[0];\n      out[1] = a[1] + b[1];\n      out[2] = a[2] + b[2];\n      return out;\n    }\n\n    /**\n     * Subtracts vector b from vector a\n     *\n     * @param {vec3} out the receiving vector\n     * @param {vec3} a the first operand\n     * @param {vec3} b the second operand\n     * @returns {vec3} out\n     */\n    function subtract(out, a, b) {\n      out[0] = a[0] - b[0];\n      out[1] = a[1] - b[1];\n      out[2] = a[2] - b[2];\n      return out;\n    }\n\n    /**\n     * Scales a vec3 by a scalar number\n     *\n     * @param {vec3} out the receiving vector\n     * @param {vec3} a the vector to scale\n     * @param {Number} b amount to scale the vector by\n     * @returns {vec3} out\n     */\n    function scale$2(out, a, b) {\n      out[0] = a[0] * b;\n      out[1] = a[1] * b;\n      out[2] = a[2] * b;\n      return out;\n    }\n\n    /**\n     * Normalize a vec3\n     *\n     * @param {vec3} out the receiving vector\n     * @param {vec3} a vector to normalize\n     * @returns {vec3} out\n     */\n    function normalize$2(out, a) {\n      var x = a[0];\n      var y = a[1];\n      var z = a[2];\n      var len = x * x + y * y + z * z;\n      if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n        out[2] = a[2] * len;\n      }\n      return out;\n    }\n\n    /**\n     * Calculates the dot product of two vec3's\n     *\n     * @param {vec3} a the first operand\n     * @param {vec3} b the second operand\n     * @returns {Number} dot product of a and b\n     */\n    function dot(a, b) {\n      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n\n    /**\n     * Computes the cross product of two vec3's\n     *\n     * @param {vec3} out the receiving vector\n     * @param {vec3} a the first operand\n     * @param {vec3} b the second operand\n     * @returns {vec3} out\n     */\n    function cross$1(out, a, b) {\n      var ax = a[0],\n          ay = a[1],\n          az = a[2];\n      var bx = b[0],\n          by = b[1],\n          bz = b[2];\n\n      out[0] = ay * bz - az * by;\n      out[1] = az * bx - ax * bz;\n      out[2] = ax * by - ay * bx;\n      return out;\n    }\n\n    /**\n     * Alias for {@link vec3.subtract}\n     * @function\n     */\n    var sub = subtract;\n\n    /**\n     * Alias for {@link vec3.length}\n     * @function\n     */\n    var len = length;\n\n    /**\n     * Perform some operation over an array of vec3s.\n     *\n     * @param {Array} a the array of vectors to iterate over\n     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n     * @param {Number} offset Number of elements to skip at the beginning of the array\n     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n     * @param {Function} fn Function to call for each vector in the array\n     * @param {Object} [arg] additional argument to pass to fn\n     * @returns {Array} a\n     * @function\n     */\n    (function () {\n      var vec = create$2();\n\n      return function (a, stride, offset, count, fn, arg) {\n        var i = void 0,\n            l = void 0;\n        if (!stride) {\n          stride = 3;\n        }\n\n        if (!offset) {\n          offset = 0;\n        }\n\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];\n          fn(vec, vec, arg);\n          a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];\n        }\n\n        return a;\n      };\n    })();\n\n    /**\n     * 4 Dimensional Vector\n     * @module vec4\n     */\n\n    /**\n     * Creates a new, empty vec4\n     *\n     * @returns {vec4} a new 4D vector\n     */\n    function create$1() {\n      var out = new ARRAY_TYPE(4);\n      if (ARRAY_TYPE != Float32Array) {\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n      }\n      return out;\n    }\n\n    /**\n     * Scales a vec4 by a scalar number\n     *\n     * @param {vec4} out the receiving vector\n     * @param {vec4} a the vector to scale\n     * @param {Number} b amount to scale the vector by\n     * @returns {vec4} out\n     */\n    function scale$1(out, a, b) {\n      out[0] = a[0] * b;\n      out[1] = a[1] * b;\n      out[2] = a[2] * b;\n      out[3] = a[3] * b;\n      return out;\n    }\n\n    /**\n     * Normalize a vec4\n     *\n     * @param {vec4} out the receiving vector\n     * @param {vec4} a vector to normalize\n     * @returns {vec4} out\n     */\n    function normalize$1(out, a) {\n      var x = a[0];\n      var y = a[1];\n      var z = a[2];\n      var w = a[3];\n      var len = x * x + y * y + z * z + w * w;\n      if (len > 0) {\n        len = 1 / Math.sqrt(len);\n        out[0] = x * len;\n        out[1] = y * len;\n        out[2] = z * len;\n        out[3] = w * len;\n      }\n      return out;\n    }\n\n    /**\n     * Perform some operation over an array of vec4s.\n     *\n     * @param {Array} a the array of vectors to iterate over\n     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n     * @param {Number} offset Number of elements to skip at the beginning of the array\n     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n     * @param {Function} fn Function to call for each vector in the array\n     * @param {Object} [arg] additional argument to pass to fn\n     * @returns {Array} a\n     * @function\n     */\n    (function () {\n      var vec = create$1();\n\n      return function (a, stride, offset, count, fn, arg) {\n        var i = void 0,\n            l = void 0;\n        if (!stride) {\n          stride = 4;\n        }\n\n        if (!offset) {\n          offset = 0;\n        }\n\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];\n          fn(vec, vec, arg);\n          a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];\n        }\n\n        return a;\n      };\n    })();\n\n    /**\n     * Quaternion\n     * @module quat\n     */\n\n    /**\n     * Creates a new identity quat\n     *\n     * @returns {quat} a new quaternion\n     */\n    function create() {\n      var out = new ARRAY_TYPE(4);\n      if (ARRAY_TYPE != Float32Array) {\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n      }\n      out[3] = 1;\n      return out;\n    }\n\n    /**\n     * Sets a quat from the given angle and rotation axis,\n     * then returns it.\n     *\n     * @param {quat} out the receiving quaternion\n     * @param {vec3} axis the axis around which to rotate\n     * @param {Number} rad the angle in radians\n     * @returns {quat} out\n     **/\n    function setAxisAngle(out, axis, rad) {\n      rad = rad * 0.5;\n      var s = Math.sin(rad);\n      out[0] = s * axis[0];\n      out[1] = s * axis[1];\n      out[2] = s * axis[2];\n      out[3] = Math.cos(rad);\n      return out;\n    }\n\n    /**\n     * Performs a spherical linear interpolation between two quat\n     *\n     * @param {quat} out the receiving quaternion\n     * @param {quat} a the first operand\n     * @param {quat} b the second operand\n     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n     * @returns {quat} out\n     */\n    function slerp(out, a, b, t) {\n      // benchmarks:\n      //    http://jsperf.com/quaternion-slerp-implementations\n      var ax = a[0],\n          ay = a[1],\n          az = a[2],\n          aw = a[3];\n      var bx = b[0],\n          by = b[1],\n          bz = b[2],\n          bw = b[3];\n\n      var omega = void 0,\n          cosom = void 0,\n          sinom = void 0,\n          scale0 = void 0,\n          scale1 = void 0;\n\n      // calc cosine\n      cosom = ax * bx + ay * by + az * bz + aw * bw;\n      // adjust signs (if necessary)\n      if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n      }\n      // calculate coefficients\n      if (1.0 - cosom > EPSILON) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n      } else {\n        // "from" and "to" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n      }\n      // calculate final values\n      out[0] = scale0 * ax + scale1 * bx;\n      out[1] = scale0 * ay + scale1 * by;\n      out[2] = scale0 * az + scale1 * bz;\n      out[3] = scale0 * aw + scale1 * bw;\n\n      return out;\n    }\n\n    /**\n     * Creates a quaternion from the given 3x3 rotation matrix.\n     *\n     * NOTE: The resultant quaternion is not normalized, so you should be sure\n     * to renormalize the quaternion yourself where necessary.\n     *\n     * @param {quat} out the receiving quaternion\n     * @param {mat3} m rotation matrix\n     * @returns {quat} out\n     * @function\n     */\n    function fromMat3(out, m) {\n      // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n      // article "Quaternion Calculus and Fast Animation".\n      var fTrace = m[0] + m[4] + m[8];\n      var fRoot = void 0;\n\n      if (fTrace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0); // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot; // 1/(4w)\n        out[0] = (m[5] - m[7]) * fRoot;\n        out[1] = (m[6] - m[2]) * fRoot;\n        out[2] = (m[1] - m[3]) * fRoot;\n      } else {\n        // |w| <= 1/2\n        var i = 0;\n        if (m[4] > m[0]) i = 1;\n        if (m[8] > m[i * 3 + i]) i = 2;\n        var j = (i + 1) % 3;\n        var k = (i + 2) % 3;\n\n        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n      }\n\n      return out;\n    }\n\n    /**\n     * Scales a quat by a scalar number\n     *\n     * @param {quat} out the receiving vector\n     * @param {quat} a the vector to scale\n     * @param {Number} b amount to scale the vector by\n     * @returns {quat} out\n     * @function\n     */\n    var scale = scale$1;\n\n    /**\n     * Normalize a quat\n     *\n     * @param {quat} out the receiving quaternion\n     * @param {quat} a quaternion to normalize\n     * @returns {quat} out\n     * @function\n     */\n    var normalize = normalize$1;\n\n    /**\n     * Sets a quaternion to represent the shortest rotation from one\n     * vector to another.\n     *\n     * Both vectors are assumed to be unit length.\n     *\n     * @param {quat} out the receiving quaternion.\n     * @param {vec3} a the initial vector\n     * @param {vec3} b the destination vector\n     * @returns {quat} out\n     */\n    (function () {\n      var tmpvec3 = create$2();\n      var xUnitVec3 = fromValues(1, 0, 0);\n      var yUnitVec3 = fromValues(0, 1, 0);\n\n      return function (out, a, b) {\n        var dot$1 = dot(a, b);\n        if (dot$1 < -0.999999) {\n          cross$1(tmpvec3, xUnitVec3, a);\n          if (len(tmpvec3) < 0.000001) cross$1(tmpvec3, yUnitVec3, a);\n          normalize$2(tmpvec3, tmpvec3);\n          setAxisAngle(out, tmpvec3, Math.PI);\n          return out;\n        } else if (dot$1 > 0.999999) {\n          out[0] = 0;\n          out[1] = 0;\n          out[2] = 0;\n          out[3] = 1;\n          return out;\n        } else {\n          cross$1(tmpvec3, a, b);\n          out[0] = tmpvec3[0];\n          out[1] = tmpvec3[1];\n          out[2] = tmpvec3[2];\n          out[3] = 1 + dot$1;\n          return normalize(out, out);\n        }\n      };\n    })();\n\n    /**\n     * Performs a spherical linear interpolation with two control points\n     *\n     * @param {quat} out the receiving quaternion\n     * @param {quat} a the first operand\n     * @param {quat} b the second operand\n     * @param {quat} c the third operand\n     * @param {quat} d the fourth operand\n     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n     * @returns {quat} out\n     */\n    (function () {\n      var temp1 = create();\n      var temp2 = create();\n\n      return function (out, a, b, c, d, t) {\n        slerp(temp1, a, d, t);\n        slerp(temp2, b, c, t);\n        slerp(out, temp1, temp2, 2 * t * (1 - t));\n\n        return out;\n      };\n    })();\n\n    /**\n     * Sets the specified quaternion with values corresponding to the given\n     * axes. Each axis is a vec3 and is expected to be unit length and\n     * perpendicular to all other specified axes.\n     *\n     * @param {vec3} view  the vector representing the viewing direction\n     * @param {vec3} right the vector representing the local "right" direction\n     * @param {vec3} up    the vector representing the local "up" direction\n     * @returns {quat} out\n     */\n    (function () {\n      var matr = create$3();\n\n      return function (out, view, right, up) {\n        matr[0] = right[0];\n        matr[3] = right[1];\n        matr[6] = right[2];\n\n        matr[1] = up[0];\n        matr[4] = up[1];\n        matr[7] = up[2];\n\n        matr[2] = -view[0];\n        matr[5] = -view[1];\n        matr[8] = -view[2];\n\n        return normalize(out, fromMat3(out, matr));\n      };\n    })();\n\n    /*!\n     * Contains code from google filament\n     * https://github.com/google/filament/\n     * License Apache-2.0\n     */\n\n    const CHAR_BIT = 8;\n\n    const MAT0 = [];\n    const TMP0 = [];\n    const TMP1 = [];\n    const TMP2 = [];\n\n    function packTangentFrame(q, /* vec3 */n, /* vec4 */t) {\n        const c = cross$1(TMP0, n, t);\n        const mat = toMat3(MAT0, t[0], t[1], t[2], ...c, ...n);\n        q = fromMat3(q, mat);\n        q = normalize(q, q);\n        q = positive(q);\n\n        const storageSize = 2; //sizeof(int16_t)\n        // Ensure w is never 0.0\n        // Bias is 2^(nb_bits - 1) - 1\n        const bias = 1 / ((1 << (storageSize * CHAR_BIT - 1)) - 1);\n        if (q[3] < bias) {\n            q[3] = bias;\n            const factor = Math.sqrt(1.0 - bias * bias);\n            q[0] *= factor;\n            q[1] *= factor;\n            q[2] *= factor;\n        }\n\n        const b = t[3] > 0 ? cross$1(TMP1, t, n) : cross$1(TMP1, n, t);\n        \n        // If there's a reflection ((n x t) . b <= 0), make sure w is negative\n        const cc = cross$1(TMP2, t, n);\n        if (dot(cc, b) < 0) {\n            scale(q, q, -1);\n        }\n        return q;\n    }\n\n    function toMat3(out, c00, c01, c02, c10, c11, c12, c20, c21, c22) {\n        out[0] = c00;\n        out[1] = c01;\n        out[2] = c02;\n\n        out[3] = c10;\n        out[4] = c11;\n        out[5] = c12;\n\n        out[6] = c20;\n        out[7] = c21;\n        out[8] = c22;\n\n        return out;\n    }\n\n\n    function positive(q) {\n        if (q[3] < 0) {\n            return scale(q, q, -1);\n        } else {\n            return q;\n        }\n    }\n\n    const COUNTS = [];\n    function buildNormals(positions, indices, out) {\n        const normals = out || [];\n        if (normals.setLength) {\n            // array from arraypool\n            normals.setLength(positions.length);\n        }\n        const counts = COUNTS;\n        if (counts.length < positions.length / 3) {\n            counts.length = positions.length / 3;\n        }\n        counts.fill(0, 0, positions.length / 3);\n        const len = indices.length === undefined ? indices : indices.length;//indices may be number\n        for (let i = 0; i < len / 3; i++) {\n            if (indices.length === undefined) {\n                computeNormal(positions, i * 3, i * 3 + 1, i * 3 + 2, normals, counts);\n            } else {\n                computeNormal(positions, indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2], normals, counts);\n            }\n        }\n        \n        //Calculate the sum of the normal vectors of the shared faces of each vertex, then average it.\n        for (let i = 0; i < normals.length; i += 3) {\n            const count = counts[i / 3];\n            if (count === 0) {\n                normals[i] = 0;\n                normals[i + 1] = 0;\n                normals[i + 2] = 0;\n                continue;\n            }\n            normals[i] /= count;\n            normals[i + 1] /= count;\n            normals[i + 2] /= count;\n        }\n        return normals;\n    }\n\n    const V0 = [];\n    const V1 = [];\n    const V2 = [];\n\n    const vA = [];\n    const vB = [];\n    const vC = [];\n    const normal = [];\n    function computeNormal(vertices, v1, v2, v3, normals, counts) {\n        set(vA, vertices[v1 * 3], vertices[v1 * 3 + 1], vertices[v1 * 3 + 2]);\n        set(vB, vertices[v2 * 3], vertices[v2 * 3 + 1], vertices[v2 * 3 + 2]);\n        set(vC, vertices[v3 * 3], vertices[v3 * 3 + 1], vertices[v3 * 3 + 2]);\n        const cb = sub(V0, vC, vB);\n        const ab = sub(V1, vA, vB);\n        const cross = cross$1(V2, cb, ab);\n        normalize$2(normal, cross);\n\n        normals[v1 * 3] = normals[v1 * 3] || 0;\n        normals[v2 * 3] = normals[v2 * 3] || 0;\n        normals[v3 * 3] = normals[v3 * 3] || 0;\n        normals[v1 * 3 + 1] = normals[v1 * 3 + 1] || 0;\n        normals[v2 * 3 + 1] = normals[v2 * 3 + 1] || 0;\n        normals[v3 * 3 + 1] = normals[v3 * 3 + 1] || 0;\n        normals[v1 * 3 + 2] = normals[v1 * 3 + 2] || 0;\n        normals[v2 * 3 + 2] = normals[v2 * 3 + 2] || 0;\n        normals[v3 * 3 + 2] = normals[v3 * 3 + 2] || 0;\n\n\n        normals[v1 * 3] += normal[0];\n        normals[v2 * 3] += normal[0];\n        normals[v3 * 3] += normal[0];\n\n        normals[v1 * 3 + 1] += normal[1];\n        normals[v2 * 3 + 1] += normal[1];\n        normals[v3 * 3 + 1] += normal[1];\n\n        normals[v1 * 3 + 2] += normal[2];\n        normals[v2 * 3 + 2] += normal[2];\n        normals[v3 * 3 + 2] += normal[2];\n\n        counts[v1] += 1;\n        counts[v2] += 1;\n        counts[v3] += 1;\n    }\n\n    /*!\n     * Contains code from THREE.JS\n     * https://github.com/mrdoob/three.js/\n     * License MIT\n     * \n     * Generate tangents per vertex.\n     */\n    function buildTangents(positions, normals, uvs, indices, out) {\n        const nVertices = positions.length / 3;\n\n        const tangents = out || new Array(4 * nVertices);\n\n        const tan1 = [], tan2 = [];\n\n        for (let i = 0; i < nVertices; i++) {\n\n            tan1[ i ] = [0, 0, 0];\n            tan2[ i ] = [0, 0, 0];\n\n        }\n\n        const vA = [0, 0, 0],\n            vB = [0, 0, 0],\n            vC = [0, 0, 0],\n\n            uvA = [0, 0],\n            uvB = [0, 0],\n            uvC = [0, 0],\n\n            sdir = [0, 0, 0],\n            tdir = [0, 0, 0];\n\n        function handleTriangle(a, b, c) {\n\n            fromArray3(vA, positions, a * 3);\n            fromArray3(vB, positions, b * 3);\n            fromArray3(vC, positions, c * 3);\n\n            fromArray2(uvA, uvs, a * 2);\n            fromArray2(uvB, uvs, b * 2);\n            fromArray2(uvC, uvs, c * 2);\n\n            const x1 = vB[0] - vA[0];\n            const x2 = vC[0] - vA[0];\n\n            const y1 = vB[1] - vA[1];\n            const y2 = vC[1] - vA[1];\n\n            const z1 = vB[2] - vA[2];\n            const z2 = vC[2] - vA[2];\n\n            const s1 = uvB[0] - uvA[0];\n            const s2 = uvC[0] - uvA[0];\n\n            const t1 = uvB[1] - uvA[1];\n            const t2 = uvC[1] - uvA[1];\n\n            const r = 1.0 / (s1 * t2 - s2 * t1);\n\n            set(\n                sdir,\n                (t2 * x1 - t1 * x2) * r,\n                (t2 * y1 - t1 * y2) * r,\n                (t2 * z1 - t1 * z2) * r\n            );\n\n            set(\n                tdir,\n                (s1 * x2 - s2 * x1) * r,\n                (s1 * y2 - s2 * y1) * r,\n                (s1 * z2 - s2 * z1) * r\n            );\n\n            add(tan1[ a ], tan1[ a ], sdir);\n            add(tan1[ b ], tan1[ b ], sdir);\n            add(tan1[ c ], tan1[ c ], sdir);\n\n            add(tan2[ a ], tan2[ a ], tdir);\n            add(tan2[ b ], tan2[ b ], tdir);\n            add(tan2[ c ], tan2[ c ], tdir);\n\n        }\n\n        for (let j = 0, jl = indices.length; j < jl; j += 3) {\n\n            handleTriangle(\n                indices[ j + 0 ],\n                indices[ j + 1 ],\n                indices[ j + 2 ]\n            );\n\n        }\n\n        const tmp = [], tmp2 = [];\n        const n = [], n2 = [];\n        let w, t, test;\n\n        function handleVertex(v) {\n\n            fromArray3(n, normals, v * 3);\n            copy(n2, n);\n            // n2.copy(n);\n\n            t = tan1[ v ];\n\n            // Gram-Schmidt orthogonalize\n\n            copy(tmp, t);\n            sub(tmp, tmp, scale$2(n, n, dot(n, t)));\n            normalize$2(tmp, tmp);\n            // tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n            // Calculate handedness\n\n            cross$1(tmp2, n2, t);\n            test = dot(tmp2, tan2[ v ]);\n            // tmp2.crossVectors(n2, t);\n            // test = tmp2.dot(tan2[ v ]);\n            w = (test < 0.0) ? -1 : 1.0;\n\n            tangents[ v * 4 ] = tmp[0];\n            tangents[ v * 4 + 1 ] = tmp[1];\n            tangents[ v * 4 + 2 ] = tmp[2];\n            tangents[ v * 4 + 3 ] = w;\n\n        }\n\n        for (let j = 0, jl = indices.length; j < jl; j += 3) {\n\n            handleVertex(indices[ j + 0 ]);\n            handleVertex(indices[ j + 1 ]);\n            handleVertex(indices[ j + 2 ]);\n\n        }\n\n        return tangents;\n    }\n\n    function fromArray3(out, array, offset) {\n        out[0] = array[offset];\n        out[1] = array[offset + 1];\n        out[2] = array[offset + 2];\n        return out;\n    }\n\n    function fromArray2(out, array, offset) {\n        out[0] = array[offset];\n        out[1] = array[offset + 1];\n        return out;\n    }\n\n    const { StyleUtil: StyleUtil$2, PackUtil: PackUtil$4, ArrayPool } = getVectorPacker();\n\n    const arrayPool = ArrayPool.getInstance();\n\n    function build3DExtrusion (features, dataConfig, extent, uvOrigin, textureSize, res, glScale,\n        tileRatio, centimeterToPoint, verticalCentimeterToPoint, symbol, zoom, projectionCode, debugIndex, positionType, center) {\n        if (dataConfig.top === undefined) {\n            dataConfig.top = true;\n        }\n        if (dataConfig.side === undefined) {\n            dataConfig.side = true;\n        }\n        arrayPool.reset();\n        const {\n            altitudeScale,\n            altitudeProperty,\n            defaultAltitude,\n            heightProperty,\n            minHeightProperty,\n            defaultHeight,\n            tangent,\n            uv,\n            topUVMode,\n            sideUVMode, sideVerticalUVMode,\n            top, side,\n            textureYOrigin,\n            topThickness,\n        } = dataConfig;\n        const faces = buildExtrudeFaces(\n            features, extent,\n            {\n                altitudeScale, altitudeProperty,\n                defaultAltitude: defaultAltitude || 0,\n                heightProperty,\n                minHeightProperty,\n                defaultHeight: defaultHeight || 0\n            },\n            {\n                center,\n                top, side,\n                topThickness: topThickness * 10 || 0,\n                uv: uv || tangent, //tangent也需要计算uv\n                uvSize: [textureSize, textureSize],\n                uvOrigin,\n                topUVMode,\n                sideUVMode,\n                sideVerticalUVMode,\n                textureYOrigin,\n                // tileRatio = extent / tileSize\n                tileRatio,\n                // 厘米到point的比例系数\n                centimeterToPoint,\n                verticalCentimeterToPoint,\n                positionType,\n                // tile的resolution\n                res,\n                glScale,\n                projectionCode\n            }, debugIndex, arrayPool);\n        const buffers = [];\n        const vertexCount = faces.vertices.getLength() / 3;\n        const ctor = PackUtil$4.getIndexArrayType(vertexCount);\n        const indices = ArrayPool.createTypedArray(faces.indices, ctor);\n        delete faces.indices;\n        buffers.push(indices.buffer, faces.pickingIds.buffer);\n        const maxAltitudeValue = Math.max(Math.abs(faces.maxAltitude), Math.abs(faces.minAltitude));\n        const posArrayType = PackUtil$4.getPosArrayType(Math.max(512, maxAltitudeValue));\n        faces.vertices = ArrayPool.createTypedArray(faces.vertices, posArrayType);\n\n        const normalArr = tangent ? arrayPool.getProxy() : new Float32Array(vertexCount * 3);\n        if (normalArr.setLength) {\n            normalArr.setLength(vertexCount * 3);\n        }\n        const normals = buildNormals(faces.vertices, indices, normalArr);\n        let simpleNormal = true;\n        const delta = 1E-6;\n        //因为aPosition中的数据是在矢量瓦片坐标体系里的，y轴和webgl坐标体系相反，所以默认计算出来的normal是反的\n        const normalLen = normals.getLength ? normals.getLength() : normals.length;\n        for (let i = 0; i < normalLen; i++) {\n            {\n                normals[i] = -normals[i];\n            }\n            const m = normals[i] % 1;\n            if (1 - Math.abs(m) > delta) {\n                simpleNormal = false;\n            } else if (m !== 0) {\n                normals[i] = Math.round(normals[i]);\n            }\n        }\n        faces.normals = normals;\n        if (tangent) {\n            let tangents = arrayPool.get();\n            tangents.setLength(vertexCount * 4);\n            tangents = buildTangents(faces.vertices, faces.normals, faces.uvs, indices, tangents);\n            tangents = createQuaternion(faces.normals, tangents);\n            faces.tangents = tangents;\n            buffers.push(tangents.buffer);\n            //normal被封装在了tangents中\n            delete faces.normals;\n        }\n        if (faces.normals) {\n            //如果只有顶面，normal数据只有0, 1, -1时，则为simple normal，可以改用Int8Array\n            if (simpleNormal) {\n                faces.normals = ArrayPool.createTypedArray(faces.normals, Int8Array);\n            }\n\n            buffers.push(faces.normals.buffer);\n        }\n        if (faces.uvs) {\n            const uvs = faces.uvs;\n            faces.uvs = ArrayPool.createTypedArray(uvs, Float32Array);\n            buffers.push(faces.uvs.buffer);\n        }\n\n\n        const fnTypes = buildFnTypes(features, symbol, zoom, faces.featureIndexes);\n        const vertexColors = buildVertexColorTypes(faces.verticeTypes, faces.featureIndexes, features, symbol, zoom);\n        const data =  {\n            data: {\n                data: {\n                    aVertexColorType: vertexColors.length <= 252 ? ArrayPool.createTypedArray(faces.verticeTypes, Uint8Array) : ArrayPool.createTypedArray(faces.verticeTypes, Uint16Array),\n                    aPosition: faces.vertices,\n                    aNormal: faces.normals,\n                    aTexCoord0: faces.uvs,\n                    aTangent: faces.tangents,\n                    aPickingId: faces.pickingIds,\n                },\n                indices,\n                properties: {\n                    maxAltitude: faces.maxAltitude / 100,\n                    minAltitude: faces.minAltitude / 100,\n                    hasNegativeHeight: faces.hasNegativeHeight\n                },\n                dynamicAttributes: fnTypes.dynamicAttributes,\n                vertexColors\n            },\n            buffers\n        };\n        // featureIds 在Extrusion中已经转换为了普通数组，不需要用 getLength() 返回数据条数\n        if (faces.featureIds.length) {\n            data.data.featureIds = faces.featureIds;\n            buffers.push(data.data.featureIds.buffer);\n        } else {\n            data.data.featureIds = [];\n        }\n        if (fnTypes.aColor) {\n            data.data.data.aColor = fnTypes.aColor;\n            data.buffers.push(fnTypes.aColor.buffer);\n        }\n        if (fnTypes.aOpacity) {\n            data.data.data.aOpacity = fnTypes.aOpacity;\n            data.buffers.push(fnTypes.aOpacity.buffer);\n        }\n        data.buffers.push(data.data.data.aPosition.buffer);\n        data.data.pickingIdIndiceMap = PackUtil$4.generatePickingIndiceIndex(data.data.data.aPickingId, data.data.indices);\n        return data;\n    }\n\n    function createQuaternion(normals, tangents) {\n        const count = tangents.getLength();\n        const aTangent = new Float32Array(count);\n        const t = [], n = [], q = [];\n\n        for (let i = 0; i < count; i += 4) {\n            const ni = i / 4 * 3;\n            set$3(n, normals[ni] || 0, normals[ni + 1] || 0, normals[ni + 2] || 0);\n            set$2(t, tangents[i] || 0, tangents[i + 1] || 0, tangents[i + 2] || 0, tangents[i + 3] || 0);\n            packTangentFrame(q, n, t);\n            copy$1(aTangent.subarray(i, i + 4), q);\n        }\n        return aTangent;\n    }\n\n    const ARR0 = [];\n    function buildFnTypes(features, symbol, zoom, feaIndexes) {\n        const dynamicAttributes = {};\n        const fnTypes = {};\n        const count = feaIndexes.getLength();\n        if (isFnTypeSymbol(symbol['polygonFill'])) {\n            let colorFn = piecewiseConstant(symbol.polygonFill);\n            const aColor = new Uint8Array(count * 4);\n            aColor.fill(255);\n            for (let i = 0; i < count; i++) {\n                const feature = features[feaIndexes[i]];\n                const properties = feature.properties || {};\n                properties['$layer'] = feature.layer;\n                properties['$type'] = feature.type;\n                let color = colorFn(zoom, properties);\n                if (isFunctionDefinition(color)) {\n                    dynamicAttributes['aColor'] = 1;\n                    colorFn = piecewiseConstant(color);\n                    color = colorFn(zoom, properties);\n                }\n                delete properties['$layer'];\n                delete properties['$type'];\n                StyleUtil$2.normalizeColor(ARR0, color);\n                aColor[i * 4] = ARR0[0];\n                aColor[i * 4 + 1] = ARR0[1];\n                aColor[i * 4 + 2] = ARR0[2];\n                aColor[i * 4 + 3] = ARR0[3];\n            }\n            fnTypes.aColor = aColor;\n        }\n        if (isFnTypeSymbol(symbol['polygonOpacity'])) {\n            let opacityFn = interpolated(symbol.polygonOpacity);\n            const aOpacity = new Uint8Array(count);\n            aOpacity.fill(255);\n            for (let i = 0; i < count; i++) {\n                const feature = features[feaIndexes[i]];\n                const properties = feature.properties || {};\n                properties['$layer'] = feature.layer;\n                properties['$type'] = feature.type;\n                let opacity = opacityFn(zoom, properties);\n                if (isFunctionDefinition(opacity)) {\n                    dynamicAttributes['aOpacity'] = 1;\n                    opacityFn = piecewiseConstant(opacity);\n                    opacity = opacityFn(zoom, properties);\n                }\n                delete properties['$layer'];\n                delete properties['$type'];\n                aOpacity[i] = opacity * 255;\n            }\n            fnTypes.aOpacity = aOpacity;\n        }\n        fnTypes.dynamicAttributes = dynamicAttributes;\n        return fnTypes;\n    }\n\n    function buildVertexColorTypes(verticeTypes, feaIndexes, features, symbol, zoom) {\n        const vertexColors = [[], []];\n        const isTopFn = isFnTypeSymbol(symbol['topPolygonFill']);\n        const isBottomFn = isFnTypeSymbol(symbol['bottomPolygonFill']);\n        const colorNormalize = [255, 255, 255, 255];\n        const count = feaIndexes.getLength();\n        if (isTopFn || isBottomFn) {\n            let topFillFn = isTopFn && piecewiseConstant(symbol.topPolygonFill);\n            let bottomFillFn = isBottomFn && piecewiseConstant(symbol.bottomPolygonFill);\n            let currentTopFeatureId = null;\n            let currentBottomFeatureId = null;\n            let currentTopValue = null;\n            let currentBottomValue = null;\n            for (let i = 0; i < count; i++) {\n                if (verticeTypes[i] === 1 && !isTopFn || verticeTypes[i] === 0 && !isBottomFn) {\n                    continue;\n                }\n                const isTop = verticeTypes[i] === 1;\n                if (isTop && feaIndexes[i] === currentTopFeatureId) {\n                    verticeTypes[i] = currentTopValue;\n                    continue;\n                }\n                if (!isTop && feaIndexes[i] === currentBottomFeatureId) {\n                    verticeTypes[i] = currentBottomValue;\n                    continue;\n                }\n                const feature = features[feaIndexes[i]];\n                const properties = feature.properties || {};\n                properties['$layer'] = feature.layer;\n                properties['$type'] = feature.type;\n                let fillFn = isTop ? topFillFn : bottomFillFn;\n                let color = fillFn(zoom, properties);\n                if (isFunctionDefinition(color)) {\n                    fillFn = piecewiseConstant(color);\n                    color = fillFn(zoom, properties);\n                }\n                delete properties['$layer'];\n                delete properties['$type'];\n                StyleUtil$2.normalizeColor(ARR0, color);\n                divide(ARR0, ARR0, colorNormalize);\n                let index = findColor(vertexColors, ARR0);\n                if (index < 0) {\n                    index = vertexColors.length;\n                    vertexColors.push(copy$1([], ARR0));\n                }\n                verticeTypes[i] = index;\n                if (isTop) {\n                    currentTopFeatureId = feaIndexes[i];\n                    currentTopValue = index;\n                } else {\n                    currentBottomFeatureId = feaIndexes[i];\n                    currentBottomValue = index;\n                }\n\n            }\n        }\n        return vertexColors.slice(2);\n    }\n\n    function findColor(colors, color) {\n        for (let i = 0; i < colors.length; i++) {\n            if (exactEquals(color, colors[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    const { PackUtil: PackUtil$3, StyleUtil: StyleUtil$1, FilterUtil: FilterUtil$1 } = getVectorPacker();\n\n    function buildWireframe$1(\n        features, EXTENT, colorSymbol, opacity,\n        {\n            altitudeScale, altitudeProperty, defaultAltitude, heightProperty, minHeightProperty, defaultHeight,\n            bottom\n        }\n    ) {\n        const drawBottom = bottom;\n        const scale = EXTENT / features[0].extent;\n        // debugger\n        const size = countVertexes(features) * 2 + features.length * 3 * 2; //wireframe need to count last point in\n\n        const featIndexes = [];\n        const vertices = new Int16Array(size);\n        const colors = new Uint8Array(vertices.length / 3 * 4);\n        if (isFunctionDefinition(colorSymbol)) {\n            colorSymbol = FilterUtil$1.compileFilter(colorSymbol);\n        }\n        const indices = [];\n\n        function fillIndices(start, offset, height) {\n            // debugger\n            const count = offset - start;\n\n            const top = vertices.subarray(start, offset);\n            //fill bottom vertexes\n            const bottom = vertices.subarray(offset, offset + count);\n            bottom.set(top);\n            for (let i = 2, l = bottom.length; i < l; i += 3) {\n                bottom[i] = top[i] - height; //top[i] is altitude\n            }\n\n            //build indices\n            const startIdx = start / 3;\n            const vertexCount = count / 3;\n            let current, next;\n            for (let i = startIdx, l = vertexCount + startIdx; i < l; i++) {\n                if (i < l - 1) {\n                    current = i;\n                    next = i + 1;\n                } else {\n                    current = i;\n                    next = startIdx;\n                }\n                if (isClippedEdge(vertices, current, next, EXTENT)) {\n                    continue;\n                }\n                //top\n                indices.push(current, next);\n                //bottom\n                if (drawBottom) {\n                    indices.push(current + vertexCount, next + vertexCount);\n                }\n                if (hasClippedPoint(vertices, current, EXTENT)) {\n                    continue;\n                }\n                //vertical top -> bottom\n                indices.push(current, current + vertexCount);\n            }\n            return offset + count;\n        }\n\n        let offset = 0;\n        let maxAltitude = -Infinity;\n        let minAltitude = Infinity;\n        const keyName = (KEY_IDX + '').trim();\n        const rgb = [];\n        for (let r = 0, n = features.length; r < n; r++) {\n            const feature = features[r];\n            const geometry = feature.geometry;\n            if (colorSymbol) {\n                let color;\n                if (typeof colorSymbol === 'function') {\n                    color = colorSymbol(feature && feature.properties);\n                } else {\n                    color = colorSymbol;\n                }\n                StyleUtil$1.normalizeColor(rgb, color);\n            } else {\n                set$3(rgb, 255, 255, 255);\n            }\n\n            const colorStart = offset / 3 * 4;\n            const { altitude, height } = PackUtil$3.getFeaAltitudeAndHeight(feature, altitudeScale, altitudeProperty, defaultAltitude, heightProperty, defaultHeight, minHeightProperty);\n            if (height < 0) {\n                minAltitude = Math.min(altitude, minAltitude);\n                maxAltitude = Math.max(altitude - height, maxAltitude);\n            } else {\n                minAltitude = Math.min(altitude - height, minAltitude);\n                maxAltitude = Math.max(altitude, maxAltitude);\n            }\n\n            let start = offset;\n            for (let i = 0, l = geometry.length; i < l; i++) {\n                // const ring = geometry[i];\n                let ring = geometry[i];\n                //earcut required the first and last position must be different\n                const ringLen = ring.length;\n                if (ring[0][0] === ring[ringLen - 1][0] && ring[0][1] === ring[ringLen - 1][1]) {\n                    ring = ring.slice(0, ringLen - 1);\n                }\n                offset = fillPosArray(vertices, start, ring, scale, altitude);\n                offset = fillIndices(start, offset, height * scale); //need to multiply with scale as altitude is\n                start = offset;\n            }\n\n            const colorEnd = start / 3 * 4;\n            for (let i = colorStart; i < colorEnd; i += 4) {\n                colors[i] = rgb[0];\n                colors[i + 1] = rgb[1];\n                colors[i + 2] = rgb[2];\n                colors[i + 3] = 255 * (opacity || 1);\n            }\n            const count = indices.length - featIndexes.length;\n            for (let i = 0; i < count; i++) {\n                featIndexes.push(feature[keyName]);\n            }\n        }\n        const maxIndex = indices.reduce((a, b) => {\n            return Math.max(a, b);\n        }, 0);\n\n        const ctor = PackUtil$3.getIndexArrayType(maxIndex);\n        const tIndices = new ctor(indices);\n\n        const feaCtor = PackUtil$3.getUnsignedArrayType(features.length);\n        const maxAltitudeValue = Math.max(Math.abs(maxAltitude, Math.abs(minAltitude)));\n        const posArrayType = PackUtil$3.getPosArrayType(Math.max(512, maxAltitudeValue));\n        const data = {\n            aPosition: new posArrayType(vertices),  // vertexes\n            indices: tIndices,    // indices for drawElements\n            aPickingId: new feaCtor(featIndexes),     // vertex index of each feature\n            aColor: colors,\n            maxAltitude: maxAltitude === -Infinity ? 0 : maxAltitude / 100,\n            minAltitude: minAltitude === Infinity ? 0 : minAltitude / 100\n        };\n        return data;\n    }\n\n    function hasClippedPoint(vertices, i0, EXTENT) {\n        const x0 = vertices[i0 * 3], y0 = vertices[i0 * 3 + 1];\n        return (x0 < 0 || x0 > EXTENT ||\n            y0 < 0 || y0 > EXTENT);\n    }\n\n    function buildWireframe (features, extent, symbol, dataConfig) {\n        const frames = buildWireframe$1(features, extent, symbol.lineColor, symbol.lineOpacity, dataConfig);\n        const { minAltitude, maxAltitude } = frames;\n        delete frames.minAltitude;\n        delete frames.maxAltitude;\n        const buffers = [frames.aPosition.buffer, frames.indices.buffer, frames.aPickingId.buffer];\n        const indices = frames.indices;\n        delete frames.indices;\n        return {\n            data: {\n                data: frames,\n                properties: {\n                    minAltitude,\n                    maxAltitude\n                },\n                indices\n            },\n            buffers\n        };\n    }\n\n    /*!\n        Feature Filter by\n\n        (c) mapbox 2016 and maptalks 2018\n        www.mapbox.com | www.maptalks.org\n        License: MIT, header required.\n    */\n    const types = ['Unknown', 'Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];\n\n    function isObject(obj) {\n        return typeof obj === 'object' && !!obj;\n    }\n\n    /**\n     * Given a filter expressed as nested arrays, return a new function\n     * that evaluates whether a given feature (with a .properties or .tags property)\n     * passes its test.\n     *\n     * @param {Array} filter mapbox gl filter\n     * @returns {Function} filter-evaluating function\n     */\n    function createFilter(filter) {\n        return new Function('f', \`var p = (f && f.properties || {}); return ${$D}compile(filter)}\`);\n    }\n\n    function compile(filter) {\n        if (!filter) return 'true';\n        const op = filter[0];\n        if (filter.length <= 1) return op === 'any' ? 'false' : 'true';\n        const str =\n            op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) :\n                op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) :\n                    op === '<' ||\n                        op === '>' ||\n                        op === '<=' ||\n                        op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) :\n                        op === 'any' ? compileLogicalOp(filter.slice(1), '||') :\n                            op === 'all' ? compileLogicalOp(filter.slice(1), '&&') :\n                                op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) :\n                                    op === 'in' ? compileInOp(filter[1], filter.slice(2)) :\n                                        op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) :\n                                            op === 'has' ? compileHasOp(filter[1]) :\n                                                op === '!has' ? compileNegation(compileHasOp(filter[1])) :\n                                                    // op === 'test' ? compileRegex(filter[1], filter[2]) :\n                                                    op === 'contains' ? compileContains(filter[1], filter[2], filter[3]) :\n                                                        'true';\n        return \`(${$D}str})\`;\n    }\n\n    function compileFunction(propertyObj, value, op, checkType) {\n        const property = propertyObj.property, funName = propertyObj.op;\n        let left = compilePropertyReference(property);\n        if (funName === 'length') {\n            left = \`((${$D}left}+='').length)\`;\n        } else {\n            // TODO\n            //  other functions\n            console.error(\`not support ${$D}funName} op\`);\n            return 'false';\n        }\n        return getComparisonCode(left, property, value, op, checkType);\n\n    }\n\n    function compileContains(property, str, index) {\n        const prop = compilePropertyReference(property);\n        if (index !== undefined) {\n            return \`(${$D}prop} + '').indexOf("${$D}str}") === ${$D}index}\`;\n        } else {\n            return \`(${$D}prop} + '').indexOf("${$D}str}") >= 0\`;\n        }\n    }\n\n    // function compileRegex(property, regex) {\n    //     const prop = compilePropertyReference(property);\n    //     return \`new RegExp("${$D}regex}").test(${$D}prop})\`;\n    // }\n\n    function compilePropertyReference(property) {\n        // const ref =\n        //     property === '$type' ? 'f.type' :\n        //         property === '$id' ? 'f.id' : \`p[${$D}JSON.stringify(property)}]\`;\n        // return ref;\n        return property[0] === '$' ? 'f.' + property.substring(1) : 'p[' + JSON.stringify(property) + ']';\n    }\n\n    function compileComparisonOp(property, value, op, checkType) {\n        if (isObject(property) && property.op) {\n            return compileFunction(property, value, op, checkType);\n        }\n        const left = compilePropertyReference(property);\n        return getComparisonCode(left, property, value, op, checkType);\n    }\n\n    function getComparisonCode(left, property, value, op, checkType) {\n        const right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);\n        return (checkType ? \`typeof ${$D}left}=== typeof ${$D}right}&&\` : '') + left + op + right;\n    }\n\n    function compileLogicalOp(expressions, op) {\n        return expressions.map(compile).join(op);\n    }\n\n    function compileInOp(property, values) {\n        if (property === '$type') values = values.map((value) => {\n            return types.indexOf(value);\n        });\n        const left = JSON.stringify(values.sort(compare));\n        const right = compilePropertyReference(property);\n\n        if (values.length <= 200) return \`${$D}left}.indexOf(${$D}right}) !== -1\`;\n\n        return \`function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(${$D}right}, ${$D}left},0,${$D}values.length - 1})\`;\n    }\n\n    function compileHasOp(property) {\n        return property === '$id' ? '"id" in f' : \`${$D}JSON.stringify(property)} in p\`;\n    }\n\n    function compileNegation(expression) {\n        return \`!(${$D}expression})\`;\n    }\n\n    // Comparison function to sort numbers and strings\n    function compare(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n\n    let offscreenCanvas = false;\n    try {\n        const canvas = new OffscreenCanvas(1, 1);\n        const ctx = canvas.getContext('2d');\n        ctx.fillText('hello', 0, 0);\n        offscreenCanvas = true;\n    } catch (err) {\n        offscreenCanvas = false;\n    }\n\n    var Browser = {\n        offscreenCanvas\n    };\n\n    const { VectorPack, PolygonPack, NativeLinePack, LinePack, PointPack, NativePointPack,\n        LineExtrusionPack, CirclePack, RoundTubePack, SquareTubePack, FilterUtil,\n        PackUtil: PackUtil$2, StyleUtil, TextUtil, DEFAULT_TEX_WIDTH, GlyphRequestor } = getVectorPacker();\n    // let FONT_CANVAS;\n\n    const oldPropsKey = '__original_properties';\n    const fntypePropsKey = '__fn-type_properties';\n\n    class BaseLayerWorker {\n        constructor(id, options, upload, tileCache, tileLoading) {\n            this.id = id;\n            this.options = options;\n            this.upload = upload;\n            this._compileStyle(options.style);\n            this.requests = {};\n            this._cache = tileCache;\n            this._styleCounter = 1;\n            this.loadings = tileLoading;\n        }\n\n        updateStyle(style, cb) {\n            this.options.style = style;\n            this._styleCounter = style.styleCounter;\n            this._compileStyle(style);\n            cb();\n        }\n\n        updateOptions(options, cb) {\n            this.options = extend$2(this.options, options);\n            cb();\n        }\n\n        /**\n         * Load a tile, paint and return gl directives\n         * @param {Object} tileInfo  - tileInfo, xyz, res, extent, etc\n         * @param {Function} cb - callback function when finished\n         */\n        loadTile(context, cb) {\n            const loadings = this.loadings;\n            const url = context.tileInfo.url;\n            const debugTile = this.options.debugTile;\n            if (debugTile) {\n                const { x, y, z } = context.tileInfo;\n                let hit = false;\n                for (let i = 0; i < debugTile.length; i++) {\n                    if (x === debugTile[i].x && y === debugTile[i].y && z === debugTile[i].z) {\n                        hit = true;\n                        break;\n                    }\n                }\n                if (!hit) {\n                    cb();\n                    return;\n                }\n            }\n\n\n\n            if (loadings[url]) {\n                loadings[url].push({\n                    // 必须要保存context，因为context中的值可能会发生变化，例如styleCounter，导致逻辑发生错误\n                    context,\n                    callback: cb,\n                    ref: this\n                });\n                return;\n            }\n            loadings[url] = [{\n                context,\n                callback: cb,\n                ref: this\n            }];\n            const feaIdProp = this.options.featureIdProperty;\n            this.requests[url] = this.getTileFeatures(context, (err, features, layers, props) => {\n                const waitings = loadings[url];\n                delete loadings[url];\n                if (this.checkIfCanceled(url)) {\n                    delete this.requests[url];\n                    this._callWaitings(waitings, null, { canceled: true });\n                    return;\n                }\n                delete this.requests[url];\n                if ((this.options.debug || feaIdProp) && features) {\n                    for (let i = 0; i < features.length; i++) {\n                        if (this.options.debug) {\n                            features[i]['_debug_info'] = {\n                                index: i,\n                                id: features[i].id,\n                                tileId: context.tileInfo.id\n                            };\n                        }\n                        if (feaIdProp) {\n                            const propName = isObject$1(feaIdProp) ? feaIdProp[features[i].layer] : feaIdProp;\n                            const properties = features[i].properties;\n                            features[i].id = properties && properties[propName] || null;\n                        }\n                    }\n                }\n                if (err) {\n                    this._callWaitings(waitings, err);\n                    return;\n                }\n                if (!features || !features.length) {\n                    this._callWaitings(waitings);\n                    return;\n                }\n                if (waitings) {\n                    for (let i = 0; i < waitings.length; i++) {\n                        this._onTileLoad.call(waitings[i].ref, waitings[i].context, waitings[i].callback, url, layers, features, props);\n                    }\n                }\n            });\n\n        }\n\n        _onTileLoad(context, cb, url, layers, features, props) {\n            this._createTileData(layers, features, context).then(data => {\n                if (data.canceled) {\n                    cb(null, { canceled: true });\n                    return;\n                }\n                data.data.styleCounter = context.styleCounter;\n                if (props) {\n                    extend$2(data.data, props);\n                }\n                cb(null, data.data, data.buffers);\n            }).catch(err => {\n                cb(err);\n            });\n        }\n\n        abortTile(url, cb) {\n            delete this.requests[url];\n            this._cancelLoadings(url);\n            cb();\n        }\n\n        _cancelLoadings(url) {\n            const waitings = this.loadings[url];\n            if (waitings) {\n                for (let i = 0; i < waitings.length; i++) {\n                    waitings[i].callback(null, { canceled: true });\n                }\n            }\n            delete this.loadings[url];\n        }\n\n        _callWaitings(waitings, err, data) {\n            if (waitings) {\n                for (let i = 0; i < waitings.length; i++) {\n                    waitings[i].callback(err, data);\n                }\n            }\n        }\n\n        checkIfCanceled(url) {\n            return !this.requests[url];\n        }\n\n        onRemove() {\n            this.loadings = {};\n            if (this._cache) {\n                this._cache.reset();\n            }\n            delete this._cache;\n            this.requests = {};\n        }\n\n        fetchIconGlyphs(icons, glyphs, cb) {\n            //2019-03-20 win10 chrome 74 64位，OffscreenCanvas fillText性能只有主线程的10%，还不可用\n            // 2021-02-25 Offscreen.fillText会造成程序出错，还不可用\n            // 2023-07-32 改用Offscreen来创建glyph，用以提升性能\n            if (this.options.workerGlyph && Browser.offscreenCanvas) {\n                const promises = [];\n                if (icons && Object.keys(icons).length) {\n                    const promise = new Promise((resolve) => {\n                        this.upload('fetchIconGlyphs', { icons }, null, (err, data) => {\n                            resolve({ err, iconData: data });\n                        });\n                    });\n                    promises.push(promise);\n                }\n                if (glyphs && Object.keys(glyphs).length) {\n                    const promise = new Promise((resolve) => {\n                        if (!this._glyphRequestor) {\n                            this._glyphRequestor = new GlyphRequestor();\n                        }\n                        this._glyphRequestor.getGlyphs(glyphs, (err, glyphData) => {\n                            resolve({ err, glyphData });\n                        });\n                    });\n                    promises.push(promise);\n                }\n\n\n                Promise.all(promises).then(datas => {\n                    const data = { icons: null, glyphs: null };\n                    for (let i = 0; i < datas.length; i++) {\n                        if (datas[i].err) {\n                            cb(datas[i].err);\n                            return;\n                        } else if (datas[i].iconData) {\n                            data.icons = datas[i].iconData.icons;\n                        } else if (datas[i].glyphData) {\n                            data.glyphs = datas[i].glyphData.glyphs;\n                        }\n                    }\n                    return data;\n                }).then(data => {\n                    cb(null, data);\n                });\n\n                // if (!this._iconRequestor) {\n                //     this._iconRequestor = new IconRequestor();\n                // }\n\n            } else {\n                //command, params, buffers and callback\n                this.upload('fetchIconGlyphs', { icons, glyphs }, null, cb);\n            }\n            // this.upload('fetchIconGlyphs', { icons, glyphs }, null, cb);\n        }\n\n        _createTileData(layers, features, context) {\n            if (!features.length) {\n                return Promise.resolve({\n                    data: null,\n                    buffers: []\n                });\n            }\n            const { glScale, tileInfo } = context;\n            const useDefault = !this.options.style.style.length && !this.options.style.featureStyle.length;\n            let pluginConfigs = this.pluginConfig.slice(0);\n            if (useDefault) {\n                //图层没有定义任何style，通过数据动态生成pluginConfig\n                pluginConfigs = this._updateLayerPluginConfig(layers);\n            }\n            if (this.featurePlugins) {\n                pushIn(pluginConfigs, this.featurePlugins);\n            }\n            const allCustomProps = {};\n            for (let i = 0; i < pluginConfigs.length; i++) {\n                cloneFeaAndAppendCustomTags(features, context.tileInfo.z, pluginConfigs[i], allCustomProps);\n            }\n            const feas = [];\n            const copies = [];\n            for (let i = 0; i < features.length; i++) {\n                const feature = features[i];\n                const customProps = allCustomProps[i];\n                if (customProps) {\n                    copies.fill(null);\n                    let count = 0;\n                    for (const p in customProps) {\n                        let index = 0;\n                        const props = customProps[p].values();\n                        for (const v of props) {\n                            let fea = copies[index];\n                            if (!fea) {\n                                fea = proxyFea(feature);\n                                copies[index] = fea;\n                            }\n                            fea.properties[p] = v;\n                            index++;\n                        }\n                        if (index > count) {\n                            count = index;\n                        }\n                    }\n                    for (let i = 0; i < count; i++) {\n                        feas.push(copies[i]);\n                    }\n                } else {\n                    feas.push(feature);\n                }\n            }\n\n            features = feas;\n\n            const EXTENT = features[0].extent;\n            const zoom = tileInfo.z,\n                tilePoint = { x: tileInfo.extent2d.xmin * glScale, y: tileInfo.extent2d.ymax * glScale },\n                data = [],\n                featureData = [],\n                pluginIndexes = [],\n                options = this.options,\n                buffers = [];\n            const feaTags = {};\n            const promises = [\n                Promise.resolve(context.styleCounter)\n            ];\n            let currentType = 0;\n            let typeIndex = -1;\n\n            const fnTypeProps = [];\n            let hasFnTypeProps = false;\n\n            for (let i = 0; i < pluginConfigs.length; i++) {\n                typeIndex++;\n                const pluginConfig = pluginConfigs[i];\n                if (pluginConfig.type !== currentType) {\n                    //plugin类型变成 feature plugin\n                    typeIndex = 0;\n                    currentType = pluginConfig.type;\n                }\n                // type = 0 是普通 style， type = 1 是 feature style\n                const targetData = pluginConfig.type === 0 ? data : featureData;\n                getFnTypeProps(pluginConfig.symbol, fnTypeProps, i);\n                hasFnTypeProps = hasFnTypeProps || fnTypeProps[i] && fnTypeProps[i].size > 0;\n\n                const { tileFeatures, tileFeaIndexes } = this._filterFeatures(zoom, pluginConfig.type, pluginConfig.filter, features, feaTags, i);\n\n                if (!tileFeatures.length) {\n                    targetData[typeIndex] = null;\n                    continue;\n                }\n\n                const maxIndex = tileFeaIndexes[tileFeaIndexes.length - 1];\n                const arrCtor = PackUtil$2.getIndexArrayType(maxIndex);\n                targetData[typeIndex] = {\n                    //[feature_index, style_index, ...]\n                    styledFeatures: new arrCtor(tileFeaIndexes)\n                };\n\n                //index of plugin with data\n                pluginIndexes.push({\n                    idx: i,\n                    typeIdx: typeIndex\n                });\n\n                buffers.push(targetData[typeIndex].styledFeatures.buffer);\n                const tileContext = extend$2({}, context, { extent: EXTENT, zoom, tilePoint });\n                if (this.options.debugTile) {\n                    const debugTile = this.options.debugTile;\n                    for (let i = 0; i < debugTile.length; i++) {\n                        const { x, y, z } = debugTile[i];\n                        if (tileInfo.x === x && tileInfo.y === y && tileInfo.z === z) {\n                            tileContext.debugIndex = debugTile[i].index;\n                            break;\n                        }\n                    }\n                }\n                let promise = this._createTileGeometry(tileFeatures, pluginConfig, tileContext);\n                if (useDefault) {\n                    promise = promise.then(tileData => {\n                        if (!tileData) {\n                            return null;\n                        }\n                        if (tileData.data) {\n                            tileData.data.layer = tileFeatures[0].layer;\n                        } else if (Array.isArray(tileData)) {\n                            for (let i = 0; i < tileData.length; i++) {\n                                if (tileData[i] && tileData[i].data) tileData[i].data.layer = tileFeatures[0].layer;\n                            }\n                        }\n                        return tileData;\n                    });\n                }\n                promises.push(promise);\n            }\n\n            return Promise.all(promises).then(([styleCounter, ...tileDatas]) => {\n                if (styleCounter !== this._styleCounter) {\n                    return { canceled: true };\n                }\n                function handleTileData(tileData, i) {\n                    if (tileData.data.ref !== undefined) {\n                        return;\n                    }\n                    const pluginConfig = pluginConfigs[pluginIndexes[i].idx];\n                    const dataConfig = pluginConfig.renderPlugin.dataConfig;\n                    tileData.data.type = dataConfig.type;\n                    tileData.data.filter = pluginConfig.filter.def;\n                    if (dataConfig.altitudeOffset) {\n                        tileData.data.properties.minAltitude += dataConfig.altitudeOffset;\n                        tileData.data.properties.maxAltitude += dataConfig.altitudeOffset;\n                    }\n\n                    if (tileData.buffers && tileData.buffers.length) {\n                        for (let i = 0; i < tileData.buffers.length; i++) {\n                            buffers.push(tileData.buffers[i]);\n                        }\n                    }\n                }\n                for (let i = 0; i < tileDatas.length; i++) {\n                    if (!tileDatas[i]) {\n                        continue;\n                    }\n                    const tileData = tileDatas[i];\n                    const targetData = pluginConfigs[pluginIndexes[i].idx].type === 0 ? data : featureData;\n                    if (Array.isArray(tileData)) {\n                        const datas = [];\n                        for (let ii = 0; ii < tileData.length; ii++) {\n                            if (!tileData[ii]) {\n                                continue;\n                            }\n                            handleTileData(tileData[ii], i);\n                            if (tileData[ii].data.ref !== undefined && !tileData[tileData[ii].data.ref]) {\n                                continue;\n                            }\n                            datas.push(tileData[ii].data);\n                        }\n                        if (datas.length) {\n                            targetData[pluginIndexes[i].typeIdx].data = datas;\n                        }\n                    } else {\n                        handleTileData(tileData, i);\n                        targetData[pluginIndexes[i].typeIdx].data = tileData.data;\n                    }\n                }\n                const allFeas = {};\n                const schema = layers;\n                if (options.features || options.schema || hasFnTypeProps) {\n                    let needClearNoneFnTypeProps = false;\n                    let feature;\n                    for (let i = 0, l = features.length; i < l; i++) {\n                        feature = features[i];\n                        if (!schema[feature.layer].properties) {\n                            schema[feature.layer].properties = getPropTypes(feature.properties);\n                        }\n                        if (feature && (options.features || hasFnTypeProps && feaTags[i])) {\n                            //reset feature's marks\n                            if (options.features === 'id') {\n                                allFeas[i] = feature.id;\n                            } else {\n                                if (!options.pickingGeometry) {\n                                    delete feature.geometry;\n                                }\n                                delete feature.extent;\n                                delete feature.properties['$layer'];\n                                delete feature.properties['$type'];\n                                // _getFeaturesToMerge 中用于排序的临时字段\n                                delete feature['__index'];\n                                const originalFeature = feature.originalFeature;\n                                if (originalFeature) {\n                                    const properties = feature.properties;\n                                    const fea = extend$2({}, feature.originalFeature);\n                                    // fea.properties = extend({}, feature.originalFeature.properties, properties);\n                                    delete properties[oldPropsKey];\n                                    fea.customProps = extend$2({}, properties);\n\n                                    feature = fea;\n                                }\n                                const o = extend$2({}, feature);\n                                if (hasFnTypeProps && feaTags[i] && (!options.features || options.features === 'transient')) {\n                                    // 只输出symbol中用到的属性\n                                    const pluginIndexs = feaTags[i];\n                                    for (let j = 0; j < pluginIndexs.length; j++) {\n                                        const props = fnTypeProps[j];\n                                        if (!props) {\n                                            continue;\n                                        }\n                                        props.forEach(p => {\n                                            const properties = originalFeature ? originalFeature.properties : feature.properties;\n                                            if (!properties[fntypePropsKey]) {\n                                                properties[fntypePropsKey] = new Set();\n                                            }\n                                            properties[fntypePropsKey].add(p);\n                                            needClearNoneFnTypeProps = true;\n                                        });\n                                    }\n                                }\n                                allFeas[i] = o;\n                            }\n                        }\n                    }\n                    if (needClearNoneFnTypeProps) {\n                        // 验证batch底图的内存情况\n                        // http://localhost/bugs/designer-947/\n                        // 删除feature中，不是fn-type的属性\n                        for (const p in allFeas) {\n                            const feature = allFeas[p];\n                            const keys = feature.properties[fntypePropsKey];\n                            if (keys) {\n                                delete feature.properties[fntypePropsKey];\n                                if (options.features === 'transient') {\n                                    feature.fnTypeProps = extend$2({}, feature.properties);\n                                }\n                                for (const pp in feature.properties) {\n                                    if (!keys.has(pp)) {\n                                        if (options.features === 'transient') {\n                                            delete feature.fnTypeProps[pp];\n                                        } else {\n                                            delete feature.properties[pp];\n                                        }\n\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return {\n                    data: {\n                        styleCounter,\n                        schema,\n                        data,\n                        featureData,\n                        extent: EXTENT,\n                        features: allFeas\n                    },\n                    buffers\n                };\n            }).catch(err => {\n                console.error(err);\n            });\n\n        }\n\n        _createTileGeometry(tileFeatures, pluginConfig, context) {\n            let features = tileFeatures;\n            const dataConfig = pluginConfig.renderPlugin.dataConfig;\n            const symbol = pluginConfig.symbol;\n            const tileSize = this.options.tileSize;\n            const { extent, glScale, zScale, zoom, tilePoint, centimeterToPoint, verticalCentimeterToPoint } = context;\n            const tileRatio = extent / tileSize;\n            const type = dataConfig.type;\n            const debugIndex = context.debugIndex;\n            // console.log(context.tileInfo.id, tileFeatures.length);\n            let options = extend$2({}, dataConfig, {\n                EXTENT: extent,\n                zoom,\n                debugIndex,\n                features: this.options.features,\n                isWebGPU: this.options.isWebGPU,\n                isWebGL1: this.options.isWebGL1\n            });\n            if (type === '3d-extrusion') {\n                const t = hasTexture(symbol);\n                if (t) {\n                    dataConfig.uv = 1;\n                }\n                const projectionCode = this.options.projectionCode;\n                const textureWidth = symbol.material && symbol.material.textureWidth || DEFAULT_TEX_WIDTH;\n                return Promise.all([Promise.resolve(build3DExtrusion(features, dataConfig, extent, tilePoint,\n                    textureWidth, context.tileInfo.res, glScale, extent / this.options['tileSize'], centimeterToPoint, verticalCentimeterToPoint, symbol, zoom, projectionCode, debugIndex))]);\n            } else if (type === '3d-wireframe') {\n                return Promise.all([Promise.resolve(buildWireframe(features, extent, symbol, dataConfig))]);\n            } else if (type === 'point') {\n                options = extend$2(options, {\n                    requestor: this.fetchIconGlyphs.bind(this),\n                    //把 altitude 转为瓦片坐标\n                    altitudeToTileScale: zScale * extent / this.options['tileSize'] / glScale,\n                    pluginType: pluginConfig.renderPlugin.type\n                });\n                let symbols = symbol;\n                if (!Array.isArray(symbol)) {\n                    symbols = [symbol];\n                }\n                symbols = symbols.map((symbol, index) => {\n                    if (symbol) {\n                        symbol.index = { index };\n                        symbol.isIconText = ifIsIconText(symbol);\n                    }\n                    return symbol;\n                }).filter(symbol => !!symbol);\n                return Promise.all(symbols.map((symbol) => {\n                    options.defaultMarkerVerticalAlignment = 'middle';\n                    const fnTypes = VectorPack.genFnTypes(symbol);\n                    let packFeatures = features;\n                    if (PointPack.needMerge(symbol, fnTypes, zoom)) {\n                        packFeatures = PointPack.mergeLineFeatures(features, symbol, fnTypes, zoom);\n                    }\n                    return new PointPack(packFeatures, symbol, options).load(tileRatio);\n                }));\n            } else if (type === 'native-point') {\n                const altitudeToTileScale = zScale * extent / this.options['tileSize'] / glScale;\n                options.altitudeToTileScale = altitudeToTileScale;\n                return parseSymbolAndGenPromises(features, symbol, options, NativePointPack, tileRatio);\n            } else if (type === 'line') {\n                options = extend$2(options, {\n                    requestor: this.fetchIconGlyphs.bind(this),\n                    tileRatio\n                });\n                return parseSymbolAndGenPromises(features, symbol, options, LinePack, 1, true);\n                // return Promise.resolve(null);\n            } else if (type === 'native-line') {\n                return parseSymbolAndGenPromises(features, symbol, options, NativeLinePack, 1, true);\n            } /*else if (type === 'pixel-line') {\n                options = extend(options, {\n                    requestor: this.fetchIconGlyphs.bind(this),\n                    tileRatio\n                });\n                return parseSymbolAndGenPromises(features, symbol, options, PixelLinePack);\n            } */else if (type === 'fill') {\n                options = extend$2(options, {\n                    requestor: this.fetchIconGlyphs.bind(this)\n                });\n                return parseSymbolAndGenPromises(features, symbol, options, PolygonPack);\n            } else if (type === 'line-extrusion') {\n                //line-extrusion 不需要 lineGradientProperty 属性，以免错误的把linesofar转化到了 0-2^15\n                delete symbol['lineGradientProperty'];\n                symbol['lineJoin'] = 'miter';\n                symbol['lineCap'] = 'butt';\n                const t = hasTexture(symbol);\n                if (t) {\n                    dataConfig.uv = 1;\n                }\n                options = extend$2(options, {\n                    tileSize,\n                    zScale,\n                    glScale\n                });\n                if (symbol.mergeOnProperty) {\n                    const fnTypes = VectorPack.genFnTypes(symbol);\n                    features = LinePack.mergeLineFeatures(features, symbol, fnTypes, options.zoom);\n                }\n                if (t) {\n                    const packs = [];\n                    if (dataConfig.top !== false) {\n                        const opt = extend$2({}, options);\n                        opt.side = false;\n                        packs.push(new LineExtrusionPack(features, symbol, opt));\n                    }\n                    if (dataConfig.side !== false) {\n                        options.side = true;\n                        options.top = false;\n                        packs.push(new LineExtrusionPack(features, symbol, options));\n                    }\n                    return Promise.all(packs.map(pack => pack.load()));\n                } else {\n                    return Promise.all([new LineExtrusionPack(features, symbol, options).load()]);\n                }\n            } else if (type === 'circle') {\n                return parseSymbolAndGenPromises(features, symbol, options, CirclePack);\n                // const pack = new CirclePack(features, symbol, options);\n                // return pack.load();\n            } else if (type === 'round-tube' || type === 'square-tube') {\n                const clazz = type === 'round-tube' ? RoundTubePack : SquareTubePack;\n                options = extend$2(options, {\n                    requestor: this.fetchIconGlyphs.bind(this),\n                    radialSegments: type === 'round-tube' ? (dataConfig.radialSegments || 8) : 4,\n                    centimeterToPoint,\n                    verticalCentimeterToPoint,\n                    tileRatio,\n                    isTube: true\n                });\n                return parseSymbolAndGenPromises(features, symbol, options, clazz);\n            }\n            return Promise.resolve([]);\n        }\n\n        /**\n         * Filter\n         * @param {*} filter\n         * @param {*} features\n         */\n        _filterFeatures(zoom, styleType, filter, features, tags, index) {\n            const keyName = (KEY_IDX + '').trim();\n            const indexes = [];\n            const filtered = [];\n            const l = features.length;\n            for (let i = 0; i < l; i++) {\n                if (styleType !== 1 && features[i].id !== undefined && this.styledFeatures[features[i].id]) {\n                    continue;\n                }\n\n                //filter.def没有定义，或者为default时，说明其实默认样式，feature之前没有其他样式时的应用样式\n                // 并识别哪些feature归类到默认样式\n                if ((!filter.def || filter.def === 'default') && !tags[i] ||\n                    (filter.def === true || filter.def && (filter.def.condition !== undefined || Array.isArray(filter.def)) && filter(features[i], zoom))) {\n                    const fea = features[i];\n                    if (fea[keyName] === undefined) {\n                        fea[keyName] = i;\n                    }\n                    if (!tags[i]) {\n                        tags[i] = [];\n                    }\n                    tags[i].push(index);\n                    filtered.push(fea);\n                    indexes.push(i);\n                    if (styleType === 1) {\n                        break;\n                    }\n                }\n            }\n            return {\n                tileFeatures: filtered,\n                tileFeaIndexes: indexes\n            };\n        }\n\n        _compileStyle(layerStyle) {\n            const { style, featureStyle } = layerStyle;\n            const styledFeatures = {};\n            featureStyle.forEach(style => {\n                if (Array.isArray(style.id)) {\n                    style.id.forEach(id => {\n                        styledFeatures[id] = 1;\n                    });\n                    style.filter = ['in', '$id', ...style.id];\n                } else {\n                    styledFeatures[style.id] = 1;\n                    style.filter = ['==', '$id', style.id];\n                }\n            });\n            const pluginConfigs = FilterUtil.compileStyle(style);\n            for (let i = 0; i < style.length; i++) {\n                if (pluginConfigs[i].filter) {\n                    // filter.value 是为方便studio，定义的对象结构\n                    // 设置def，是为了识别哪些feature归类到默认样式\n                    pluginConfigs[i].filter.def = style[i].filter ? (style[i].filter.value || style[i].filter) : undefined;\n                }\n                pluginConfigs[i].type = 0;\n            }\n\n            const featurePlugins = [];\n            const compiledFeatureStyle = FilterUtil.compileStyle(featureStyle);\n            for (let i = 0; i < featureStyle.length; i++) {\n                compiledFeatureStyle[i].type = 1;\n                // 定义def，是为了与默认样式相区分(默认样式的filter没有def)\n                compiledFeatureStyle[i].filter.def = featureStyle[i].filter ? (featureStyle[i].filter.value || featureStyle[i].filter) : undefined;\n                //没有renderPlugin就不生成数据，必须和VectorTileLayerRenderer的_initPlugins中的逻辑对应起来\n                if (compiledFeatureStyle[i].renderPlugin) {\n                    featurePlugins.push(compiledFeatureStyle[i]);\n                }\n            }\n\n            this.pluginConfig = pluginConfigs;\n            this.featurePlugins = featurePlugins;\n            this.styledFeatures = styledFeatures;\n        }\n\n        _updateLayerPluginConfig(layers) {\n            let layerPlugins = this._layerPlugins;\n            if (!this._layerPlugins) {\n                layerPlugins = this._layerPlugins = {};\n            }\n            const TYPES = [\n                '',\n                'Point',\n                'LineString',\n                'Polygon',\n                'MultiPoint',\n                'MultiLineString',\n                'MultiPolygon'\n            ];\n            const framePlugins = [];\n            for (const p in layers) {\n                const layer = p;\n                if (!layerPlugins[p]) {\n                    const stylePlugins = [];\n                    for (let i = 0; i < layers[p].types.length; i++) {\n                        const type = layers[p].types[i];\n                        const def = ['all', ['==', '$layer', layer], ['==', '$type', TYPES[type]]];\n                        const plugin = {\n                            filter: createFilter(def),\n                            renderPlugin: getDefaultRenderPlugin(type),\n                            symbol: getDefaultSymbol(type)\n                        };\n                        plugin.filter.def = def;\n                        plugin.type = 0;\n                        stylePlugins.push(plugin);\n                    }\n                    layerPlugins[layer] = stylePlugins;\n                }\n                // const type = Math.min(...layers[p].types);\n                // if (!layerPlugins[layer]) {\n                //     const def = ['==', '$layer', layer];\n                //     layerPlugins[layer] = {\n                //         filter: createFilter(def),\n                //         renderPlugin: getDefaultRenderPlugin(type),\n                //         symbol: getDefaultSymbol(type)\n                //     };\n                //     layerPlugins[layer].filter.def = def;\n                // }\n                framePlugins.push(...layerPlugins[layer]);\n            }\n            return framePlugins;\n        }\n    }\n\n    // LayerWorker.prototype.getProjViewMatrix = function (transform) {\n    //     const m = new Float64Array(16);\n    //     const m1 = new Float32Array(16);\n    //     return function (tileInfo, matrix) {\n    //         const tilePos = tileInfo.point;\n    //         const tileSize = this.tileSize;\n\n    //         const tileMatrix = mat4.identity(m);\n    //         mat4.translate(tileMatrix, tileMatrix, [tilePos.x, tilePos.y, 0]);\n    //         mat4.scale(tileMatrix, tileMatrix, [tileSize / EXTENT, tileSize / EXTENT, 1]);\n\n    //         //local transform in current frame\n    //         if (transform) {\n    //             mat4.multiply(tileMatrix, tileMatrix, transform);\n    //         }\n\n    //         mat4.multiply(tileMatrix, matrix, tileMatrix);\n\n    //         return mat4.copy(m1, tileMatrix);\n    //     };\n    // }();\n\n    function getDefaultRenderPlugin(type) {\n        switch (type) {\n        case 1:\n            return {\n                type: 'native-point',\n                dataConfig: {\n                    type: 'native-point',\n                    only2D: true\n                }\n            };\n        case 2:\n            return {\n                type: 'native-line',\n                dataConfig: {\n                    type: 'native-line',\n                    only2D: true\n                }\n            };\n        case 3:\n            return {\n                type: 'fill',\n                dataConfig: {\n                    type: 'fill',\n                    only2D: true\n                }\n            };\n        }\n        return null;\n    }\n\n\n    function getDefaultSymbol(type) {\n        switch (type) {\n        case 1:\n            return {\n                markerFill: '#f00',\n                markerSize: 10\n            };\n        case 2:\n            return {\n                lineColor: '#fff'\n            };\n        case 3:\n            return {\n                polygonFill: '#00f',\n                polygonOpacity: 0.4\n            };\n        }\n        return null;\n    }\n\n    function getPropTypes(properties) {\n        if (Array.isArray(properties) || !isObject$1(properties)) {\n            return {};\n        }\n        const types = {};\n        for (const p in properties) {\n            const v = properties[p];\n            if (isString(v)) {\n                types[p] = 'string';\n            } else if (isNumber$1(v)) {\n                types[p] = 'number';\n            } else if (v === true || v === false) {\n                types[p] = 'boolean';\n            } else if (Array.isArray(v)) {\n                types[p] = 'array';\n            } else {\n                types[p] = 'object';\n            }\n        }\n        return types;\n    }\n\n    function hasTexture(symbol) {\n        if (!symbol) {\n            return 0;\n        }\n        let t = 0;\n        for (const p in symbol) {\n            if ((p === 'normalTexture' || p === 'bumpTexture') && symbol[p]) {\n                return 2;\n            } else if (p.indexOf('Texture') > 0 && symbol[p]) {\n                t = 1;\n            } else if (isObject$1(symbol[p])) {\n                const t0 = hasTexture(symbol[p]);\n                if (t0 === 2) {\n                    return t0;\n                } else if (t0 === 1) {\n                    t = 1;\n                }\n            }\n        }\n        return t;\n    }\n\n    function parseSymbolAndGenPromises(features, symbol, options, clazz, scale, isLine) {\n        const parsed = {};\n        const symbols = Array.isArray(symbol) ? symbol : [symbol];\n        let first = -1;\n        for (let i = 0; i < symbols.length; i++) {\n            parsed[i] = hasFnTypeKeys(symbols[i]);\n            if (!parsed[i] && symbols[i] && first === -1) {\n                first = i;\n            }\n        }\n        const promises = [];\n        for (let i = 0; i < symbols.length; i++) {\n            if (!symbols[i]) {\n                // promises.push({ data: { symbolIndex: { index: i } } });\n                continue;\n            }\n            // 用来在 VectorPack 中生成 symbolIndex\n            symbols[i].index = { index: i };\n            let packFeatures = features;\n            if (isLine && symbols[i].mergeOnProperty) {\n                const fnTypes = VectorPack.genFnTypes(symbols[i]);\n                packFeatures = LinePack.mergeLineFeatures(features, symbols[0], fnTypes, options.zoom);\n            }\n            if (!parsed[i]) {\n                if (i === first) {\n                    promises.push(new clazz(packFeatures, symbols[i], options).load(scale));\n                } else {\n                    promises.push({ data: { ref: first, symbolIndex: { index: i } } });\n                }\n            } else {\n                promises.push(new clazz(packFeatures, symbols[i], options).load(scale));\n            }\n        }\n        return Promise.all(promises);\n    }\n\n    function hasFnTypeKeys(symbol) {\n        if (!symbol) {\n            return 0;\n        }\n        for (const p in symbol) {\n            if (isFnTypeSymbol(symbol[p])) {\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    function cloneFeaAndAppendCustomTags(features, zoom, pluginConfig, customProps) {\n        const customProperties = pluginConfig.customProperties;\n        if (!customProperties) {\n            return features;\n        }\n        if (customProperties) {\n            for (let i = 0; i < customProperties.length; i++) {\n                customProperties[i].fn = FilterUtil.compileFilter(customProperties[i].filter);\n            }\n        }\n        for (let j = 0; j < customProperties.length; j++) {\n            for (let i = 0, l = features.length; i < l; i++) {\n                if (customProperties[j].fn(features[i], zoom)) {\n                    for (const p in customProperties[j].properties) {\n                        const v = customProperties[j].properties[p];\n                        if (isNil(v)) {\n                            continue;\n                        }\n                        if (!customProps[i]) {\n                            customProps[i] = {};\n                        }\n                        if (!customProps[i][p]) {\n                            customProps[i][p] = new Set();\n                        }\n                        customProps[i][p].add(v);\n                    }\n                }\n            }\n        }\n    }\n\n    const proxyGetter0 = {\n        get (obj, prop) {\n            return prop in obj ? obj[prop] : obj.originalFeature[prop];\n        },\n        has(obj, key) {\n            return (key in obj) || (key in obj.originalFeature);\n        }\n    };\n\n    const proxyGetter1 = {\n        get: function(obj, prop) {\n            return prop in obj ? obj[prop] : obj[oldPropsKey][prop];\n        },\n        has(obj, key) {\n            return (key in obj) || (key in obj[oldPropsKey]);\n        }\n    };\n\n    const EMPTY_PROPS = {};\n\n    function proxyFea(feature) {\n        const fea = {};\n        fea.originalFeature = feature;\n        const result = new Proxy(fea, proxyGetter0);\n        result.properties = new Proxy({}, proxyGetter1);\n        result.properties[oldPropsKey] = feature.properties || EMPTY_PROPS;\n        return result;\n    }\n\n    function addFnTypeProp(props, i, property) {\n        if (!props[i]) {\n            props[i] = new Set();\n        }\n        props[i].add(property);\n    }\n\n    const EMPTY_ARRAY = [];\n    function getFnTypeProps(symbol, props, i) {\n        if (!symbol) {\n            return EMPTY_ARRAY;\n        }\n        for (const p in symbol) {\n            // 只保留支持zoom fn-type的样式属性，其他的属性忽略掉\n            if (!symbol[p] || !StyleUtil.checkIfZoomFnTypeSymbol(p)) {\n                continue;\n            }\n            if (isFnTypeSymbol(symbol[p])) {\n                addFnTypeProp(props, i, symbol[p].property);\n            } else if (p === 'lineGradientProperty') {\n                addFnTypeProp(props, i, symbol[p]);\n                continue;\n            } else if (p === 'textName') {\n                // 返回 textName 中可能用到的属性名\n                if (isString(symbol[p])) {\n                    const vars = TextUtil.resolveVarNames(symbol[p]);\n                    if (vars) {\n                        for (let j = 0; j < vars.length; j++) {\n                            addFnTypeProp(props, i, vars[j]);\n                        }\n                    }\n                } else if (FilterUtil.isExpression(symbol[p])) {\n                    const vars = [];\n                    TextUtil.resolveExpVarNames(vars, symbol[p]);\n                    for (let j = 0; j < vars.length; j++) {\n                        addFnTypeProp(props, i, vars[j]);\n                    }\n                }\n            }\n            const stops = symbol[p].stops;\n            if (stops && stops.length) {\n                for (let i = 0; i < stops.length; i++) {\n                    if (isFnTypeSymbol(stops[i][1])) {\n                        addFnTypeProp(props, i, stops[i][1].property);\n                    }\n                }\n            }\n\n        }\n        return props[i];\n    }\n\n    function ifIsIconText(symbol) {\n        // 如果symbol中没有marker，只有text时，则iconText为true\n        // isIconText 主要用在 getAnchors 和各种判断是否是沿线文字的判断逻辑中\n        return symbol.markerType || symbol.markerFile;\n    }\n\n    function bbox(geojson) {\n      let b = [\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n      ];\n      switch (geojson.type) {\n        case 'FeatureCollection':\n          const len = geojson.features.length;\n          for (let i = 0; i < len; i++) {\n            feature(geojson.features[i], b);\n          }\n          break;\n        case 'Feature':\n          feature(geojson, b);\n          break;\n        default:\n          geometry(geojson, b);\n          break;\n      }\n      return b;\n    }\n\n    function feature(f, b) {\n      geometry(f.geometry, b);\n    }\n\n    function geometry(g, b) {\n      if (!g) {\n        return;\n      }\n      switch (g.type) {\n        case 'Point':\n          point(g.coordinates, b);\n          break;\n        case 'MultiPoint':\n          line(g.coordinates, b);\n          break;\n        case 'LineString':\n          line(g.coordinates, b);\n          break;\n        case 'MultiLineString':\n          multiline(g.coordinates, b);\n          break;\n        case 'Polygon':\n          polygon(g.coordinates, b);\n          break;\n        case 'MultiPolygon':\n          multipolygon(g.coordinates, b);\n          break;\n        case 'GeometryCollection':\n          const len = g.geometries.length;\n          for (let i = 0; i < len; i++) {\n            geometry(g.geometries[i], b);\n          }\n          break;\n      }\n    }\n\n    function point(p, b) {\n      b[0] = Math.min(b[0], p[0]);\n      b[1] = Math.min(b[1], p[1]);\n      b[2] = Math.max(b[2], p[0]);\n      b[3] = Math.max(b[3], p[1]);\n    }\n\n    function line(l, b) {\n      for (let i = 0, len = l.length; i < len; i++) {\n        point(l[i], b);\n      }\n    }\n\n    function multiline(ml, b) {\n      for (let i = 0, len = ml.length; i < len; i++) {\n        line(ml[i], b);\n      }\n    }\n\n    function polygon(p, b) {\n      //Just calculate the outer ring,Don't participate in the calculation of holes\n      //测试10000个鄱阳湖的数据,表现为性能可以提高25%\n      if (p.length) {\n        line(p[0], b);\n      }\n    }\n\n    function multipolygon(mp, b) {\n      for (let i = 0, len = mp.length; i < len; i++) {\n        polygon(mp[i], b);\n      }\n    }\n\n    function quickselect(arr, k, left, right, compare) {\n        quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare$1);\n    }\n\n    function quickselectStep(arr, k, left, right, compare) {\n\n        while (right > left) {\n            if (right - left > 600) {\n                var n = right - left + 1;\n                var m = k - left + 1;\n                var z = Math.log(n);\n                var s = 0.5 * Math.exp(2 * z / 3);\n                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n                quickselectStep(arr, k, newLeft, newRight, compare);\n            }\n\n            var t = arr[k];\n            var i = left;\n            var j = right;\n\n            swap(arr, left, k);\n            if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n            while (i < j) {\n                swap(arr, i, j);\n                i++;\n                j--;\n                while (compare(arr[i], t) < 0) i++;\n                while (compare(arr[j], t) > 0) j--;\n            }\n\n            if (compare(arr[left], t) === 0) swap(arr, left, j);\n            else {\n                j++;\n                swap(arr, j, right);\n            }\n\n            if (j <= k) left = j + 1;\n            if (k <= j) right = j - 1;\n        }\n    }\n\n    function swap(arr, i, j) {\n        var tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n\n    function defaultCompare$1(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n\n    class RBush {\n        constructor(maxEntries = 9) {\n            // max entries in a node is 9 by default; min node fill is 40% for best performance\n            this._maxEntries = Math.max(4, maxEntries);\n            this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n            this.clear();\n        }\n\n        all() {\n            return this._all(this.data, []);\n        }\n\n        search(bbox) {\n            let node = this.data;\n            const result = [];\n\n            if (!intersects$1(bbox, node)) return result;\n\n            const toBBox = this.toBBox;\n            const nodesToSearch = [];\n\n            while (node) {\n                for (let i = 0; i < node.children.length; i++) {\n                    const child = node.children[i];\n                    const childBBox = node.leaf ? toBBox(child) : child;\n\n                    if (intersects$1(bbox, childBBox)) {\n                        if (node.leaf) result.push(child);\n                        else if (contains(bbox, childBBox)) this._all(child, result);\n                        else nodesToSearch.push(child);\n                    }\n                }\n                node = nodesToSearch.pop();\n            }\n\n            return result;\n        }\n\n        collides(bbox) {\n            let node = this.data;\n\n            if (!intersects$1(bbox, node)) return false;\n\n            const nodesToSearch = [];\n            while (node) {\n                for (let i = 0; i < node.children.length; i++) {\n                    const child = node.children[i];\n                    const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                    if (intersects$1(bbox, childBBox)) {\n                        if (node.leaf || contains(bbox, childBBox)) return true;\n                        nodesToSearch.push(child);\n                    }\n                }\n                node = nodesToSearch.pop();\n            }\n\n            return false;\n        }\n\n        load(data) {\n            if (!(data && data.length)) return this;\n\n            if (data.length < this._minEntries) {\n                for (let i = 0; i < data.length; i++) {\n                    this.insert(data[i]);\n                }\n                return this;\n            }\n\n            // recursively build the tree with the given data from scratch using OMT algorithm\n            let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n            if (!this.data.children.length) {\n                // save as is if tree is empty\n                this.data = node;\n\n            } else if (this.data.height === node.height) {\n                // split root if trees have the same height\n                this._splitRoot(this.data, node);\n\n            } else {\n                if (this.data.height < node.height) {\n                    // swap trees if inserted one is bigger\n                    const tmpNode = this.data;\n                    this.data = node;\n                    node = tmpNode;\n                }\n\n                // insert the small tree into the large tree at appropriate level\n                this._insert(node, this.data.height - node.height - 1, true);\n            }\n\n            return this;\n        }\n\n        insert(item) {\n            if (item) this._insert(item, this.data.height - 1);\n            return this;\n        }\n\n        clear() {\n            this.data = createNode([]);\n            return this;\n        }\n\n        remove(item, equalsFn) {\n            if (!item) return this;\n\n            let node = this.data;\n            const bbox = this.toBBox(item);\n            const path = [];\n            const indexes = [];\n            let i, parent, goingUp;\n\n            // depth-first iterative tree traversal\n            while (node || path.length) {\n\n                if (!node) { // go up\n                    node = path.pop();\n                    parent = path[path.length - 1];\n                    i = indexes.pop();\n                    goingUp = true;\n                }\n\n                if (node.leaf) { // check current node\n                    const index = findItem(item, node.children, equalsFn);\n\n                    if (index !== -1) {\n                        // item found, remove the item and condense tree upwards\n                        node.children.splice(index, 1);\n                        path.push(node);\n                        this._condense(path);\n                        return this;\n                    }\n                }\n\n                if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                    path.push(node);\n                    indexes.push(i);\n                    i = 0;\n                    parent = node;\n                    node = node.children[0];\n\n                } else if (parent) { // go right\n                    i++;\n                    node = parent.children[i];\n                    goingUp = false;\n\n                } else node = null; // nothing found\n            }\n\n            return this;\n        }\n\n        toBBox(item) { return item; }\n\n        compareMinX(a, b) { return a.minX - b.minX; }\n        compareMinY(a, b) { return a.minY - b.minY; }\n\n        toJSON() { return this.data; }\n\n        fromJSON(data) {\n            this.data = data;\n            return this;\n        }\n\n        _all(node, result) {\n            const nodesToSearch = [];\n            while (node) {\n                if (node.leaf) result.push(...node.children);\n                else nodesToSearch.push(...node.children);\n\n                node = nodesToSearch.pop();\n            }\n            return result;\n        }\n\n        _build(items, left, right, height) {\n\n            const N = right - left + 1;\n            let M = this._maxEntries;\n            let node;\n\n            if (N <= M) {\n                // reached leaf level; return leaf\n                node = createNode(items.slice(left, right + 1));\n                calcBBox(node, this.toBBox);\n                return node;\n            }\n\n            if (!height) {\n                // target height of the bulk-loaded tree\n                height = Math.ceil(Math.log(N) / Math.log(M));\n\n                // target number of root entries to maximize storage utilization\n                M = Math.ceil(N / Math.pow(M, height - 1));\n            }\n\n            node = createNode([]);\n            node.leaf = false;\n            node.height = height;\n\n            // split the items into M mostly square tiles\n\n            const N2 = Math.ceil(N / M);\n            const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n            multiSelect(items, left, right, N1, this.compareMinX);\n\n            for (let i = left; i <= right; i += N1) {\n\n                const right2 = Math.min(i + N1 - 1, right);\n\n                multiSelect(items, i, right2, N2, this.compareMinY);\n\n                for (let j = i; j <= right2; j += N2) {\n\n                    const right3 = Math.min(j + N2 - 1, right2);\n\n                    // pack each entry recursively\n                    node.children.push(this._build(items, j, right3, height - 1));\n                }\n            }\n\n            calcBBox(node, this.toBBox);\n\n            return node;\n        }\n\n        _chooseSubtree(bbox, node, level, path) {\n            while (true) {\n                path.push(node);\n\n                if (node.leaf || path.length - 1 === level) break;\n\n                let minArea = Infinity;\n                let minEnlargement = Infinity;\n                let targetNode;\n\n                for (let i = 0; i < node.children.length; i++) {\n                    const child = node.children[i];\n                    const area = bboxArea(child);\n                    const enlargement = enlargedArea(bbox, child) - area;\n\n                    // choose entry with the least area enlargement\n                    if (enlargement < minEnlargement) {\n                        minEnlargement = enlargement;\n                        minArea = area < minArea ? area : minArea;\n                        targetNode = child;\n\n                    } else if (enlargement === minEnlargement) {\n                        // otherwise choose one with the smallest area\n                        if (area < minArea) {\n                            minArea = area;\n                            targetNode = child;\n                        }\n                    }\n                }\n\n                node = targetNode || node.children[0];\n            }\n\n            return node;\n        }\n\n        _insert(item, level, isNode) {\n            const bbox = isNode ? item : this.toBBox(item);\n            const insertPath = [];\n\n            // find the best node for accommodating the item, saving all nodes along the path too\n            const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n            // put the item into the node\n            node.children.push(item);\n            extend(node, bbox);\n\n            // split on node overflow; propagate upwards if necessary\n            while (level >= 0) {\n                if (insertPath[level].children.length > this._maxEntries) {\n                    this._split(insertPath, level);\n                    level--;\n                } else break;\n            }\n\n            // adjust bboxes along the insertion path\n            this._adjustParentBBoxes(bbox, insertPath, level);\n        }\n\n        // split overflowed node into two\n        _split(insertPath, level) {\n            const node = insertPath[level];\n            const M = node.children.length;\n            const m = this._minEntries;\n\n            this._chooseSplitAxis(node, m, M);\n\n            const splitIndex = this._chooseSplitIndex(node, m, M);\n\n            const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n            newNode.height = node.height;\n            newNode.leaf = node.leaf;\n\n            calcBBox(node, this.toBBox);\n            calcBBox(newNode, this.toBBox);\n\n            if (level) insertPath[level - 1].children.push(newNode);\n            else this._splitRoot(node, newNode);\n        }\n\n        _splitRoot(node, newNode) {\n            // split root node\n            this.data = createNode([node, newNode]);\n            this.data.height = node.height + 1;\n            this.data.leaf = false;\n            calcBBox(this.data, this.toBBox);\n        }\n\n        _chooseSplitIndex(node, m, M) {\n            let index;\n            let minOverlap = Infinity;\n            let minArea = Infinity;\n\n            for (let i = m; i <= M - m; i++) {\n                const bbox1 = distBBox(node, 0, i, this.toBBox);\n                const bbox2 = distBBox(node, i, M, this.toBBox);\n\n                const overlap = intersectionArea(bbox1, bbox2);\n                const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n                // choose distribution with minimum overlap\n                if (overlap < minOverlap) {\n                    minOverlap = overlap;\n                    index = i;\n\n                    minArea = area < minArea ? area : minArea;\n\n                } else if (overlap === minOverlap) {\n                    // otherwise choose distribution with minimum area\n                    if (area < minArea) {\n                        minArea = area;\n                        index = i;\n                    }\n                }\n            }\n\n            return index || M - m;\n        }\n\n        // sorts node children by the best axis for split\n        _chooseSplitAxis(node, m, M) {\n            const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n            const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n            const xMargin = this._allDistMargin(node, m, M, compareMinX);\n            const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n            // if total distributions margin value is minimal for x, sort by minX,\n            // otherwise it's already sorted by minY\n            if (xMargin < yMargin) node.children.sort(compareMinX);\n        }\n\n        // total margin of all possible split distributions where each node is at least m full\n        _allDistMargin(node, m, M, compare) {\n            node.children.sort(compare);\n\n            const toBBox = this.toBBox;\n            const leftBBox = distBBox(node, 0, m, toBBox);\n            const rightBBox = distBBox(node, M - m, M, toBBox);\n            let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n            for (let i = m; i < M - m; i++) {\n                const child = node.children[i];\n                extend(leftBBox, node.leaf ? toBBox(child) : child);\n                margin += bboxMargin(leftBBox);\n            }\n\n            for (let i = M - m - 1; i >= m; i--) {\n                const child = node.children[i];\n                extend(rightBBox, node.leaf ? toBBox(child) : child);\n                margin += bboxMargin(rightBBox);\n            }\n\n            return margin;\n        }\n\n        _adjustParentBBoxes(bbox, path, level) {\n            // adjust bboxes along the given tree path\n            for (let i = level; i >= 0; i--) {\n                extend(path[i], bbox);\n            }\n        }\n\n        _condense(path) {\n            // go through the path, removing empty nodes and updating bboxes\n            for (let i = path.length - 1, siblings; i >= 0; i--) {\n                if (path[i].children.length === 0) {\n                    if (i > 0) {\n                        siblings = path[i - 1].children;\n                        siblings.splice(siblings.indexOf(path[i]), 1);\n\n                    } else this.clear();\n\n                } else calcBBox(path[i], this.toBBox);\n            }\n        }\n    }\n\n    function findItem(item, items, equalsFn) {\n        if (!equalsFn) return items.indexOf(item);\n\n        for (let i = 0; i < items.length; i++) {\n            if (equalsFn(item, items[i])) return i;\n        }\n        return -1;\n    }\n\n    // calculate node's bbox from bboxes of its children\n    function calcBBox(node, toBBox) {\n        distBBox(node, 0, node.children.length, toBBox, node);\n    }\n\n    // min bounding rectangle of node children from k to p-1\n    function distBBox(node, k, p, toBBox, destNode) {\n        if (!destNode) destNode = createNode(null);\n        destNode.minX = Infinity;\n        destNode.minY = Infinity;\n        destNode.maxX = -Infinity;\n        destNode.maxY = -Infinity;\n\n        for (let i = k; i < p; i++) {\n            const child = node.children[i];\n            extend(destNode, node.leaf ? toBBox(child) : child);\n        }\n\n        return destNode;\n    }\n\n    function extend(a, b) {\n        a.minX = Math.min(a.minX, b.minX);\n        a.minY = Math.min(a.minY, b.minY);\n        a.maxX = Math.max(a.maxX, b.maxX);\n        a.maxY = Math.max(a.maxY, b.maxY);\n        return a;\n    }\n\n    function compareNodeMinX(a, b) { return a.minX - b.minX; }\n    function compareNodeMinY(a, b) { return a.minY - b.minY; }\n\n    function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\n    function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\n    function enlargedArea(a, b) {\n        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n               (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n    }\n\n    function intersectionArea(a, b) {\n        const minX = Math.max(a.minX, b.minX);\n        const minY = Math.max(a.minY, b.minY);\n        const maxX = Math.min(a.maxX, b.maxX);\n        const maxY = Math.min(a.maxY, b.maxY);\n\n        return Math.max(0, maxX - minX) *\n               Math.max(0, maxY - minY);\n    }\n\n    function contains(a, b) {\n        return a.minX <= b.minX &&\n               a.minY <= b.minY &&\n               b.maxX <= a.maxX &&\n               b.maxY <= a.maxY;\n    }\n\n    function intersects$1(a, b) {\n        return b.minX <= a.maxX &&\n               b.minY <= a.maxY &&\n               b.maxX >= a.minX &&\n               b.maxY >= a.minY;\n    }\n\n    function createNode(children) {\n        return {\n            children,\n            height: 1,\n            leaf: true,\n            minX: Infinity,\n            minY: Infinity,\n            maxX: -Infinity,\n            maxY: -Infinity\n        };\n    }\n\n    // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n    // combines selection algorithm with binary divide & conquer approach\n\n    function multiSelect(arr, left, right, n, compare) {\n        const stack = [left, right];\n\n        while (stack.length) {\n            right = stack.pop();\n            left = stack.pop();\n\n            if (right - left <= n) continue;\n\n            const mid = left + Math.ceil((right - left) / n / 2) * n;\n            quickselect(arr, mid, left, right, compare);\n\n            stack.push(left, mid, mid, right);\n        }\n    }\n\n    class TinyQueue {\n        constructor(data = [], compare = defaultCompare) {\n            this.data = data;\n            this.length = this.data.length;\n            this.compare = compare;\n\n            if (this.length > 0) {\n                for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n            }\n        }\n\n        push(item) {\n            this.data.push(item);\n            this.length++;\n            this._up(this.length - 1);\n        }\n\n        pop() {\n            if (this.length === 0) return undefined;\n\n            const top = this.data[0];\n            const bottom = this.data.pop();\n            this.length--;\n\n            if (this.length > 0) {\n                this.data[0] = bottom;\n                this._down(0);\n            }\n\n            return top;\n        }\n\n        peek() {\n            return this.data[0];\n        }\n\n        _up(pos) {\n            const {data, compare} = this;\n            const item = data[pos];\n\n            while (pos > 0) {\n                const parent = (pos - 1) >> 1;\n                const current = data[parent];\n                if (compare(item, current) >= 0) break;\n                data[pos] = current;\n                pos = parent;\n            }\n\n            data[pos] = item;\n        }\n\n        _down(pos) {\n            const {data, compare} = this;\n            const halfLength = this.length >> 1;\n            const item = data[pos];\n\n            while (pos < halfLength) {\n                let left = (pos << 1) + 1;\n                let best = data[left];\n                const right = left + 1;\n\n                if (right < this.length && compare(data[right], best) < 0) {\n                    left = right;\n                    best = data[right];\n                }\n                if (compare(best, item) >= 0) break;\n\n                data[pos] = best;\n                pos = left;\n            }\n\n            data[pos] = item;\n        }\n    }\n\n    function defaultCompare(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n\n    function getDefaultExportFromCjs (x) {\n    \treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n    }\n\n    var pointInPolygon = {exports: {}};\n\n    var flat = function pointInPolygonFlat (point, vs, start, end) {\n        var x = point[0], y = point[1];\n        var inside = false;\n        if (start === undefined) start = 0;\n        if (end === undefined) end = vs.length;\n        var len = (end-start)/2;\n        for (var i = 0, j = len - 1; i < len; j = i++) {\n            var xi = vs[start+i*2+0], yi = vs[start+i*2+1];\n            var xj = vs[start+j*2+0], yj = vs[start+j*2+1];\n            var intersect = ((yi > y) !== (yj > y))\n                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n            if (intersect) inside = !inside;\n        }\n        return inside;\n    };\n\n    // ray-casting algorithm based on\n    // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n\n    var nested$1 = function pointInPolygonNested (point, vs, start, end) {\n        var x = point[0], y = point[1];\n        var inside = false;\n        if (start === undefined) start = 0;\n        if (end === undefined) end = vs.length;\n        var len = end - start;\n        for (var i = 0, j = len - 1; i < len; j = i++) {\n            var xi = vs[i+start][0], yi = vs[i+start][1];\n            var xj = vs[j+start][0], yj = vs[j+start][1];\n            var intersect = ((yi > y) !== (yj > y))\n                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n            if (intersect) inside = !inside;\n        }\n        return inside;\n    };\n\n    var pointInPolygonFlat = flat;\n    var pointInPolygonNested = nested$1;\n\n    pointInPolygon.exports = function pointInPolygon (point, vs, start, end) {\n        if (vs.length > 0 && Array.isArray(vs[0])) {\n            return pointInPolygonNested(point, vs, start, end);\n        } else {\n            return pointInPolygonFlat(point, vs, start, end);\n        }\n    };\n    var nested = pointInPolygon.exports.nested = pointInPolygonNested;\n    pointInPolygon.exports.flat = pointInPolygonFlat;\n\n    const epsilon = 1.1102230246251565e-16;\n    const splitter = 134217729;\n    const resulterrbound = (3 + 8 * epsilon) * epsilon;\n\n    // fast_expansion_sum_zeroelim routine from oritinal code\n    function sum(elen, e, flen, f, h) {\n        let Q, Qnew, hh, bvirt;\n        let enow = e[0];\n        let fnow = f[0];\n        let eindex = 0;\n        let findex = 0;\n        if ((fnow > enow) === (fnow > -enow)) {\n            Q = enow;\n            enow = e[++eindex];\n        } else {\n            Q = fnow;\n            fnow = f[++findex];\n        }\n        let hindex = 0;\n        if (eindex < elen && findex < flen) {\n            if ((fnow > enow) === (fnow > -enow)) {\n                Qnew = enow + Q;\n                hh = Q - (Qnew - enow);\n                enow = e[++eindex];\n            } else {\n                Qnew = fnow + Q;\n                hh = Q - (Qnew - fnow);\n                fnow = f[++findex];\n            }\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n            while (eindex < elen && findex < flen) {\n                if ((fnow > enow) === (fnow > -enow)) {\n                    Qnew = Q + enow;\n                    bvirt = Qnew - Q;\n                    hh = Q - (Qnew - bvirt) + (enow - bvirt);\n                    enow = e[++eindex];\n                } else {\n                    Qnew = Q + fnow;\n                    bvirt = Qnew - Q;\n                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n                    fnow = f[++findex];\n                }\n                Q = Qnew;\n                if (hh !== 0) {\n                    h[hindex++] = hh;\n                }\n            }\n        }\n        while (eindex < elen) {\n            Qnew = Q + enow;\n            bvirt = Qnew - Q;\n            hh = Q - (Qnew - bvirt) + (enow - bvirt);\n            enow = e[++eindex];\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n        while (findex < flen) {\n            Qnew = Q + fnow;\n            bvirt = Qnew - Q;\n            hh = Q - (Qnew - bvirt) + (fnow - bvirt);\n            fnow = f[++findex];\n            Q = Qnew;\n            if (hh !== 0) {\n                h[hindex++] = hh;\n            }\n        }\n        if (Q !== 0 || hindex === 0) {\n            h[hindex++] = Q;\n        }\n        return hindex;\n    }\n\n    function estimate(elen, e) {\n        let Q = e[0];\n        for (let i = 1; i < elen; i++) Q += e[i];\n        return Q;\n    }\n\n    function vec(n) {\n        return new Float64Array(n);\n    }\n\n    const ccwerrboundA = (3 + 16 * epsilon) * epsilon;\n    const ccwerrboundB = (2 + 12 * epsilon) * epsilon;\n    const ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;\n\n    const B = vec(4);\n    const C1 = vec(8);\n    const C2 = vec(12);\n    const D = vec(16);\n    const u = vec(4);\n\n    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {\n        let acxtail, acytail, bcxtail, bcytail;\n        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;\n\n        const acx = ax - cx;\n        const bcx = bx - cx;\n        const acy = ay - cy;\n        const bcy = by - cy;\n\n        s1 = acx * bcy;\n        c = splitter * acx;\n        ahi = c - (c - acx);\n        alo = acx - ahi;\n        c = splitter * bcy;\n        bhi = c - (c - bcy);\n        blo = bcy - bhi;\n        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n        t1 = acy * bcx;\n        c = splitter * acy;\n        ahi = c - (c - acy);\n        alo = acy - ahi;\n        c = splitter * bcx;\n        bhi = c - (c - bcx);\n        blo = bcx - bhi;\n        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n        _i = s0 - t0;\n        bvirt = s0 - _i;\n        B[0] = s0 - (_i + bvirt) + (bvirt - t0);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 - t1;\n        bvirt = _0 - _i;\n        B[1] = _0 - (_i + bvirt) + (bvirt - t1);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        B[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        B[3] = u3;\n\n        let det = estimate(4, B);\n        let errbound = ccwerrboundB * detsum;\n        if (det >= errbound || -det >= errbound) {\n            return det;\n        }\n\n        bvirt = ax - acx;\n        acxtail = ax - (acx + bvirt) + (bvirt - cx);\n        bvirt = bx - bcx;\n        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);\n        bvirt = ay - acy;\n        acytail = ay - (acy + bvirt) + (bvirt - cy);\n        bvirt = by - bcy;\n        bcytail = by - (bcy + bvirt) + (bvirt - cy);\n\n        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {\n            return det;\n        }\n\n        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);\n        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);\n        if (det >= errbound || -det >= errbound) return det;\n\n        s1 = acxtail * bcy;\n        c = splitter * acxtail;\n        ahi = c - (c - acxtail);\n        alo = acxtail - ahi;\n        c = splitter * bcy;\n        bhi = c - (c - bcy);\n        blo = bcy - bhi;\n        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n        t1 = acytail * bcx;\n        c = splitter * acytail;\n        ahi = c - (c - acytail);\n        alo = acytail - ahi;\n        c = splitter * bcx;\n        bhi = c - (c - bcx);\n        blo = bcx - bhi;\n        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n        _i = s0 - t0;\n        bvirt = s0 - _i;\n        u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 - t1;\n        bvirt = _0 - _i;\n        u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        u[3] = u3;\n        const C1len = sum(4, B, 4, u, C1);\n\n        s1 = acx * bcytail;\n        c = splitter * acx;\n        ahi = c - (c - acx);\n        alo = acx - ahi;\n        c = splitter * bcytail;\n        bhi = c - (c - bcytail);\n        blo = bcytail - bhi;\n        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n        t1 = acy * bcxtail;\n        c = splitter * acy;\n        ahi = c - (c - acy);\n        alo = acy - ahi;\n        c = splitter * bcxtail;\n        bhi = c - (c - bcxtail);\n        blo = bcxtail - bhi;\n        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n        _i = s0 - t0;\n        bvirt = s0 - _i;\n        u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 - t1;\n        bvirt = _0 - _i;\n        u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        u[3] = u3;\n        const C2len = sum(C1len, C1, 4, u, C2);\n\n        s1 = acxtail * bcytail;\n        c = splitter * acxtail;\n        ahi = c - (c - acxtail);\n        alo = acxtail - ahi;\n        c = splitter * bcytail;\n        bhi = c - (c - bcytail);\n        blo = bcytail - bhi;\n        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);\n        t1 = acytail * bcxtail;\n        c = splitter * acytail;\n        ahi = c - (c - acytail);\n        alo = acytail - ahi;\n        c = splitter * bcxtail;\n        bhi = c - (c - bcxtail);\n        blo = bcxtail - bhi;\n        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);\n        _i = s0 - t0;\n        bvirt = s0 - _i;\n        u[0] = s0 - (_i + bvirt) + (bvirt - t0);\n        _j = s1 + _i;\n        bvirt = _j - s1;\n        _0 = s1 - (_j - bvirt) + (_i - bvirt);\n        _i = _0 - t1;\n        bvirt = _0 - _i;\n        u[1] = _0 - (_i + bvirt) + (bvirt - t1);\n        u3 = _j + _i;\n        bvirt = u3 - _j;\n        u[2] = _j - (u3 - bvirt) + (_i - bvirt);\n        u[3] = u3;\n        const Dlen = sum(C2len, C2, 4, u, D);\n\n        return D[Dlen - 1];\n    }\n\n    function orient2d(ax, ay, bx, by, cx, cy) {\n        const detleft = (ay - cy) * (bx - cx);\n        const detright = (ax - cx) * (by - cy);\n        const det = detleft - detright;\n\n        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;\n\n        const detsum = Math.abs(detleft + detright);\n        if (Math.abs(det) >= ccwerrboundA * detsum) return det;\n\n        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);\n    }\n\n    // esm version of concaveman\n    // https://github.com/archilogic-com/concaveman/\n\n\n    function concaveman(points, concavity, lengthThreshold) {\n        // a relative measure of concavity; higher value means simpler hull\n        concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n        // when a segment goes below this length threshold, it won't be drilled down further\n        lengthThreshold = lengthThreshold || 0;\n\n        // start with a convex hull of the points\n        var hull = fastConvexHull(points);\n\n        // index the points with an R-tree\n        var tree = new RBush(16);\n        tree.toBBox = function (a) {\n            return {\n                minX: a[0],\n                minY: a[1],\n                maxX: a[0],\n                maxY: a[1]\n            };\n        };\n        tree.compareMinX = function (a, b) { return a[0] - b[0]; };\n        tree.compareMinY = function (a, b) { return a[1] - b[1]; };\n\n        tree.load(points);\n\n        // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n        var queue = [];\n        for (var i = 0, last; i < hull.length; i++) {\n            var p = hull[i];\n            tree.remove(p);\n            last = insertNode(p, last);\n            queue.push(last);\n        }\n\n        // index the segments with an R-tree (for intersection checks)\n        var segTree = new RBush(16);\n        for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n        var sqConcavity = concavity * concavity;\n        var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n        // process edges one by one\n        while (queue.length) {\n            var node = queue.shift();\n            var a = node.p;\n            var b = node.next.p;\n\n            // skip the edge if it's already short enough\n            var sqLen = getSqDist(a, b);\n            if (sqLen < sqLenThreshold) continue;\n\n            var maxSqLen = sqLen / sqConcavity;\n\n            // find the best connection point for the current edge to flex inward to\n            p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n            // if we found a connection and it satisfies our concavity measure\n            if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n                // connect the edge endpoints through this point and add 2 new edges to the queue\n                queue.push(node);\n                queue.push(insertNode(p, node));\n\n                // update point and segment indexes\n                tree.remove(p);\n                segTree.remove(node);\n                segTree.insert(updateBBox(node));\n                segTree.insert(updateBBox(node.next));\n            }\n        }\n\n        // convert the resulting hull linked list to an array of points\n        node = last;\n        var concave = [];\n        do {\n            concave.push(node.p);\n            node = node.next;\n        } while (node !== last);\n\n        concave.push(node.p);\n\n        return concave;\n    }\n\n    function findCandidate(tree, a, b, c, d, maxDist, segTree) {\n        var queue = new TinyQueue([], compareDist);\n        var node = tree.data;\n\n        // search through the point R-tree with a depth-first search using a priority queue\n        // in the order of distance to the edge (b, c)\n        while (node) {\n            for (var i = 0; i < node.children.length; i++) {\n                var child = node.children[i];\n\n                var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n                if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n                queue.push({\n                    node: child,\n                    dist: dist\n                });\n            }\n\n            while (queue.length && !queue.peek().node.children) {\n                var item = queue.pop();\n                var p = item.node;\n\n                // skip all points that are as close to adjacent edges (a,b) and (c,d),\n                // and points that would introduce self-intersections when connected\n                var d0 = sqSegDist(p, a, b);\n                var d1 = sqSegDist(p, c, d);\n                if (item.dist < d0 && item.dist < d1 &&\n                    noIntersections(b, p, segTree) &&\n                    noIntersections(c, p, segTree)) return p;\n            }\n\n            node = queue.pop();\n            if (node) node = node.node;\n        }\n\n        return null;\n    }\n\n    function compareDist(a, b) {\n        return a.dist - b.dist;\n    }\n\n    // square distance from a segment bounding box to the given one\n    function sqSegBoxDist(a, b, bbox) {\n        if (inside(a, bbox) || inside(b, bbox)) return 0;\n        var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n        if (d1 === 0) return 0;\n        var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n        if (d2 === 0) return 0;\n        var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n        if (d3 === 0) return 0;\n        var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n        if (d4 === 0) return 0;\n        return Math.min(d1, d2, d3, d4);\n    }\n\n    function inside(a, bbox) {\n        return a[0] >= bbox.minX &&\n               a[0] <= bbox.maxX &&\n               a[1] >= bbox.minY &&\n               a[1] <= bbox.maxY;\n    }\n\n    // check if the edge (a,b) doesn't intersect any other edges\n    function noIntersections(a, b, segTree) {\n        var minX = Math.min(a[0], b[0]);\n        var minY = Math.min(a[1], b[1]);\n        var maxX = Math.max(a[0], b[0]);\n        var maxY = Math.max(a[1], b[1]);\n\n        var edges = segTree.search({ minX: minX, minY: minY, maxX: maxX, maxY: maxY });\n        for (var i = 0; i < edges.length; i++) {\n            if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n        }\n        return true;\n    }\n\n    function cross(p1, p2, p3) {\n        return orient2d(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n    }\n\n    // check if the edges (p1,q1) and (p2,q2) intersect\n    function intersects(p1, q1, p2, q2) {\n        return p1 !== q2 && q1 !== p2 &&\n            cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&\n            cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\n    }\n\n    // update the bounding box of a node's edge\n    function updateBBox(node) {\n        var p1 = node.p;\n        var p2 = node.next.p;\n        node.minX = Math.min(p1[0], p2[0]);\n        node.minY = Math.min(p1[1], p2[1]);\n        node.maxX = Math.max(p1[0], p2[0]);\n        node.maxY = Math.max(p1[1], p2[1]);\n        return node;\n    }\n\n    // speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\n    function fastConvexHull(points) {\n        var left = points[0];\n        var top = points[0];\n        var right = points[0];\n        var bottom = points[0];\n\n        // find the leftmost, rightmost, topmost and bottommost points\n        for (var i = 0; i < points.length; i++) {\n            var p = points[i];\n            if (p[0] < left[0]) left = p;\n            if (p[0] > right[0]) right = p;\n            if (p[1] < top[1]) top = p;\n            if (p[1] > bottom[1]) bottom = p;\n        }\n\n        // filter out points that are inside the resulting quadrilateral\n        var cull = [left, top, right, bottom];\n        var filtered = cull.slice();\n        for (i = 0; i < points.length; i++) {\n            if (!nested(points[i], cull)) filtered.push(points[i]);\n        }\n\n        // get convex hull around the filtered points\n        return convexHull(filtered);\n    }\n\n    // create a new node in a doubly linked list\n    function insertNode(p, prev) {\n        var node = {\n            p: p,\n            prev: null,\n            next: null,\n            minX: 0,\n            minY: 0,\n            maxX: 0,\n            maxY: 0\n        };\n\n        if (!prev) {\n            node.prev = node;\n            node.next = node;\n\n        } else {\n            node.next = prev.next;\n            node.prev = prev;\n            prev.next.prev = node;\n            prev.next = node;\n        }\n        return node;\n    }\n\n    // square distance between 2 points\n    function getSqDist(p1, p2) {\n\n        var dx = p1[0] - p2[0],\n            dy = p1[1] - p2[1];\n\n        return dx * dx + dy * dy;\n    }\n\n    // square distance from a point to a segment\n    function sqSegDist(p, p1, p2) {\n\n        var x = p1[0],\n            y = p1[1],\n            dx = p2[0] - x,\n            dy = p2[1] - y;\n\n        if (dx !== 0 || dy !== 0) {\n\n            var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n            if (t > 1) {\n                x = p2[0];\n                y = p2[1];\n\n            } else if (t > 0) {\n                x += dx * t;\n                y += dy * t;\n            }\n        }\n\n        dx = p[0] - x;\n        dy = p[1] - y;\n\n        return dx * dx + dy * dy;\n    }\n\n    // segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\n    function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var ux = x1 - x0;\n        var uy = y1 - y0;\n        var vx = x3 - x2;\n        var vy = y3 - y2;\n        var wx = x0 - x2;\n        var wy = y0 - y2;\n        var a = ux * ux + uy * uy;\n        var b = ux * vx + uy * vy;\n        var c = vx * vx + vy * vy;\n        var d = ux * wx + uy * wy;\n        var e = vx * wx + vy * wy;\n        var D = a * c - b * b;\n\n        var sc, sN, tc, tN;\n        var sD = D;\n        var tD = D;\n\n        if (D === 0) {\n            sN = 0;\n            sD = 1;\n            tN = e;\n            tD = c;\n        } else {\n            sN = b * e - c * d;\n            tN = a * e - b * d;\n            if (sN < 0) {\n                sN = 0;\n                tN = e;\n                tD = c;\n            } else if (sN > sD) {\n                sN = sD;\n                tN = e + b;\n                tD = c;\n            }\n        }\n\n        if (tN < 0.0) {\n            tN = 0.0;\n            if (-d < 0.0) sN = 0.0;\n            else if (-d > a) sN = sD;\n            else {\n                sN = -d;\n                sD = a;\n            }\n        } else if (tN > tD) {\n            tN = tD;\n            if ((-d + b) < 0.0) sN = 0;\n            else if (-d + b > a) sN = sD;\n            else {\n                sN = -d + b;\n                sD = a;\n            }\n        }\n\n        sc = sN === 0 ? 0 : sN / sD;\n        tc = tN === 0 ? 0 : tN / tD;\n\n        var cx = (1 - sc) * x0 + sc * x1;\n        var cy = (1 - sc) * y0 + sc * y1;\n        var cx2 = (1 - tc) * x2 + tc * x3;\n        var cy2 = (1 - tc) * y2 + tc * y3;\n        var dx = cx2 - cx;\n        var dy = cy2 - cy;\n\n        return dx * dx + dy * dy;\n    }\n\n    function compareByX(a, b) {\n        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n    }\n\n    function convexHull(points) {\n        points.sort(compareByX);\n\n        var lower = [];\n        for (var i = 0; i < points.length; i++) {\n            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n                lower.pop();\n            }\n            lower.push(points[i]);\n        }\n\n        var upper = [];\n        for (var ii = points.length - 1; ii >= 0; ii--) {\n            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {\n                upper.pop();\n            }\n            upper.push(points[ii]);\n        }\n\n        upper.pop();\n        lower.pop();\n        return lower.concat(upper);\n    }\n\n    const { PackUtil: PackUtil$1 } = getVectorPacker();\n\n    // Computing oriented minimum bounding boxes\n    // credits of https://github.com/geidav/ombb-rotating-calipers\n\n    //------------Vector.js------------------\n    class Vector {\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        clone() {\n            return new Vector(this.x, this.y);\n        }\n\n        normalize() {\n            const len = this.length();\n            this.x /= len;\n            this.y /= len;\n        }\n\n        negate() {\n            this.x = -this.x;\n            this.y = -this.y;\n        }\n\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n\n        diff(vec) {\n            return new Vector(this.x - vec.x, this.y - vec.y);\n        }\n\n        distance(vec) {\n            const x = this.x - vec.x;\n            const y = this.y - vec.y;\n            return Math.sqrt(x * x + y * y);\n        }\n\n        dot(vec) {\n            return this.x * vec.x + this.y * vec.y;\n        }\n\n        equals(vec) {\n            return this.x === vec.x && this.y === vec.y;\n        }\n\n        orthogonal() {\n            return new Vector(this.y, -this.x);\n        }\n\n    }\n\n    //-------------convexhull.js---------------------\n    // const ON = 0;\n    // const LEFT = 1;\n    // const RIGHT = 2;\n    // const ALMOST_ZERO = 0.00001;\n\n    // function GetSideOfLine(lineStart, lineEnd, point) {\n    //     const d = (lineEnd.x - lineStart.x) * (point.y - lineStart.y) - (lineEnd.y - lineStart.y) * (point.x - lineStart.x);\n    //     return (d > ALMOST_ZERO ? LEFT : (d < -ALMOST_ZERO ? RIGHT : ON));\n    // }\n\n    // returns convex hull in CCW order\n    // (required by Rotating Calipers implementation)\n    // function CalcConvexHull(points) {\n    //     // bad input?\n    //     if (points.length < 3)\n    //         return points;\n\n    //     // find first hull point\n    //     let hullPt = points[0];\n    //     const convexHull = [];\n\n    //     for (let i = 1; i < points.length; i++) {\n    //         // perform lexicographical compare\n    //         if (points[i].x < hullPt.x)\n    //             hullPt = points[i];\n    //         else if (Math.abs(points[i].x - hullPt.x) < ALMOST_ZERO) // equal\n    //             if (points[i].y < hullPt.y)\n    //                 hullPt = points[i];\n    //     }\n\n    //     let endPt = points[0];\n    //     // find remaining hull points\n    //     do {\n    //         convexHull.unshift(hullPt.clone());\n\n    //         for (let j = 1; j < points.length; j++) {\n    //             const side = GetSideOfLine(hullPt, endPt, points[j]);\n\n    //             // in case point lies on line take the one further away.\n    //             // this fixes the collinearity problem.\n    //             if (endPt.equals(hullPt) || (side === LEFT || (side === ON && hullPt.distance(points[j]) > hullPt.distance(endPt))))\n    //                 endPt = points[j];\n    //         }\n\n    //         hullPt = endPt;\n    //     }\n    //     while (!endPt.equals(convexHull[convexHull.length - 1]));\n\n    //     return convexHull;\n    // }\n\n    //-------------ombb.js---------------------\n\n    function IntersectLines(start0, dir0, start1, dir1) {\n        const dd = dir0.x * dir1.y - dir0.y * dir1.x;\n        // dd=0 => lines are parallel. we don't care as our lines are never parallel.\n        const dx = start1.x - start0.x;\n        const dy = start1.y - start0.y;\n        const t = (dx * dir1.y - dy * dir1.x) / dd;\n        return new Vector(start0.x + t * dir0.x, start0.y + t * dir0.y);\n    }\n\n    // computes the minimum area enclosing rectangle\n    // (aka oriented minimum bounding box)\n    function CalcOmbb(convexHull) {\n        // initialize attributes\n        let BestObb;\n        let BestObbArea = Number.MAX_VALUE;\n\n        const UpdateOmbb = function(leftStart, leftDir, rightStart, rightDir, topStart, topDir, bottomStart, bottomDir)\n        {\n            var obbUpperLeft = IntersectLines(leftStart, leftDir, topStart, topDir);\n            var obbUpperRight = IntersectLines(rightStart, rightDir, topStart, topDir);\n            var obbBottomLeft = IntersectLines(bottomStart, bottomDir, leftStart, leftDir);\n            var obbBottomRight = IntersectLines(bottomStart, bottomDir, rightStart, rightDir);\n            var distLeftRight = obbUpperLeft.distance(obbUpperRight);\n            var distTopBottom = obbUpperLeft.distance(obbBottomLeft);\n            var obbArea = distLeftRight*distTopBottom;\n\n            if (obbArea !== 0 && obbArea < BestObbArea)\n            {\n                BestObb = [obbUpperLeft, obbBottomLeft, obbBottomRight, obbUpperRight];\n                BestObbArea = obbArea;\n            }\n        };\n\n\n        // compute directions of convex hull edges\n        var edgeDirs = [];\n\n        for (let i=0; i<convexHull.length; i++)\n        {\n            edgeDirs.push(convexHull[(i+1)%convexHull.length].diff(convexHull[i]));\n            edgeDirs[i].normalize();\n        }\n\n        // compute extreme points\n        var minPt = new Vector(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        var maxPt = new Vector(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n        var leftIdx, rightIdx, topIdx, bottomIdx;\n\n        for (let i = 0; i<convexHull.length; i++)\n        {\n            var pt = convexHull[i];\n\n            if (pt.x < minPt.x)\n            {\n                minPt.x = pt.x;\n                leftIdx = i;\n            }\n\n            if (pt.x > maxPt.x)\n            {\n                maxPt.x = pt.x;\n                rightIdx = i;\n            }\n\n            if (pt.y < minPt.y)\n            {\n                minPt.y = pt.y;\n                bottomIdx = i;\n            }\n\n            if (pt.y > maxPt.y)\n            {\n                maxPt.y = pt.y;\n                topIdx = i;\n            }\n        }\n\n        // initial caliper lines + directions\n        //\n        //        top\n        //      <-------\n        //      |      A\n        //      |      | right\n        // left |      |\n        //      V      |\n        //      -------\x3e\n        //       bottom\n        var leftDir = new Vector(0.0, -1);\n        var rightDir = new Vector(0, 1);\n        var topDir = new Vector(-1, 0);\n        var bottomDir = new Vector(1, 0);\n\n        // execute rotating caliper algorithm\n        for (let i = 0; i<convexHull.length; i++)\n        {\n            // of course the acos() can be optimized.\n            // but it's a JS prototype anyways, so who cares.\n            var phis = // 0=left, 1=right, 2=top, 3=bottom\n            [\n                Math.acos(leftDir.dot(edgeDirs[leftIdx])),\n                Math.acos(rightDir.dot(edgeDirs[rightIdx])),\n                Math.acos(topDir.dot(edgeDirs[topIdx])),\n                Math.acos(bottomDir.dot(edgeDirs[bottomIdx])),\n            ];\n\n            var lineWithSmallestAngle = phis.indexOf(Math.min.apply(Math, phis));\n            switch (lineWithSmallestAngle)\n            {\n            case 0: // left\n                leftDir = edgeDirs[leftIdx].clone();\n                rightDir = leftDir.clone();\n                rightDir.negate();\n                topDir = leftDir.orthogonal();\n                bottomDir = topDir.clone();\n                bottomDir.negate();\n                leftIdx = (leftIdx+1)%convexHull.length;\n                break;\n            case 1: // right\n                rightDir = edgeDirs[rightIdx].clone();\n                leftDir = rightDir.clone();\n                leftDir.negate();\n                topDir = leftDir.orthogonal();\n                bottomDir = topDir.clone();\n                bottomDir.negate();\n                rightIdx = (rightIdx+1)%convexHull.length;\n                break;\n            case 2: // top\n                topDir = edgeDirs[topIdx].clone();\n                bottomDir = topDir.clone();\n                bottomDir.negate();\n                leftDir = bottomDir.orthogonal();\n                rightDir = leftDir.clone();\n                rightDir.negate();\n                topIdx = (topIdx+1)%convexHull.length;\n                break;\n            case 3: // bottom\n                bottomDir = edgeDirs[bottomIdx].clone();\n                topDir = bottomDir.clone();\n                topDir.negate();\n                leftDir = bottomDir.orthogonal();\n                rightDir = leftDir.clone();\n                rightDir.negate();\n                bottomIdx = (bottomIdx+1)%convexHull.length;\n                break;\n            }\n\n            UpdateOmbb(convexHull[leftIdx], leftDir, convexHull[rightIdx], rightDir, convexHull[topIdx], topDir, convexHull[bottomIdx], bottomDir);\n        }\n\n        return BestObb;\n    }\n\n    const projectionCode = 'EPSG:3857';\n    const HULL = [];\n    const VERTICES = [];\n\n    function computeOMBB (vertices) {\n\n        if (isNumber$1(vertices[0] && vertices[0].x)) {\n            // 对 { x, y } 格式的坐标支持\n            const vertexes = [];\n            let t = 0;\n            for (let i = 0; i < vertices.length; i++) {\n                if (!VERTICES[t]) {\n                    VERTICES[t] = [vertices[i].x, vertices[i].y];\n                } else {\n                    VERTICES[t][0] = vertices[i].x;\n                    VERTICES[t][1] = vertices[i].y;\n                }\n                vertexes.push(VERTICES[t]);\n                t++;\n            }\n            vertices = vertexes;\n        }\n        try {\n            const hull = concaveman(vertices, Infinity);\n            let min = [Infinity, Infinity], max = [-Infinity, -Infinity];\n            for (let i = 0; i < hull.length; i++) {\n                if (hull[i][0] < min[0]) {\n                    min[0] = hull[i][0];\n                }\n                if (hull[i][0] > max[0]) {\n                    max[0] = hull[i][0];\n                }\n\n                if (hull[i][1] < min[1]) {\n                    min[1] = hull[i][1];\n                }\n                if (hull[i][1] > max[1]) {\n                    max[1] = hull[i][1];\n                }\n            }\n\n            const projectedCoord = [];\n\n            let convexHull = [];\n            let t = 0;\n            for (let i = 0; i < hull.length; i++) {\n                if (i === hull.length - 1 && hull[i][0] === hull[0][0] && hull[i][1] === hull[0][1]) {\n                    continue\n                }\n                // 用原经纬度坐标无法计算出正确的ombb，但投影坐标可以，原因未知\n                project(projectedCoord, hull[i], projectionCode);\n                if (!HULL[t]) {\n                    HULL[t] = new Vector(projectedCoord[0], projectedCoord[1]);\n                } else {\n                    HULL[t].x = projectedCoord[0];\n                    HULL[t].y = projectedCoord[1];\n                }\n                convexHull.push(HULL[t]);\n                t++;\n            }\n\n            if (PackUtil$1.calculateSignedArea(convexHull) < 0) {\n                convexHull = convexHull.reverse();\n            }\n            const ombb = CalcOmbb(convexHull); // draws OOBB candidates\n            if (!ombb || ombb.length !== 4) {\n                return null;\n            }\n            const edge0 = ombb[0].distance(ombb[1]);\n            const edge1 = ombb[1].distance(ombb[2]);\n            const box = ombb.map(v => [v.x, v.y]);\n            //宽边开始的序号，0或者1\n            box.push(+(edge1 > edge0));\n            return box;\n        } catch (e) {\n            return null;\n        }\n\n\n    }\n\n    const projectedCoord = [];\n    function projectOMBB(ombb, projectionCode) {\n        const isMultiOmbb = Array.isArray(ombb && ombb[0] && ombb[0][0]);\n        for (let i = 0; i < ombb.length; i++) {\n            if (isMultiOmbb) {\n                ombb[i] = projectOMBB(ombb[i]);\n            } else {\n                project(projectedCoord, ombb[i], projectionCode);\n                ombb[i][0] = projectedCoord[0];\n                ombb[i][1] = projectedCoord[1];\n            }\n        }\n        return ombb;\n    }\n\n    // import { project } from '../builder/projection.js';\n\n    const { PackUtil } = getVectorPacker();\n\n    class GeoJSONLayerWorker extends BaseLayerWorker {\n        /**\n         *\n         * @param {String} id - id\n         * @param {Object} options - options\n         * @param {Object} options.geojsonvt - options of geojsonvt\n         * @param {Object} [options.headers=null]  - headers of http request for remote geojson\n         * @param {Object} [options.jsonp=false]   - use jsonp to fetch remote geojson\n         * @param {*} uploader\n         * @param {*} cb\n         */\n        constructor(id, options, uploader, cache, loadings, cb) {\n            super(id, options, uploader, cache, loadings);\n            options = options || {};\n            if (!options.extent) {\n                options.extent = 8192;\n            }\n            this.setData(options.data, cb);\n        }\n\n        clearData() {\n            delete this.index;\n        }\n\n        /**\n         * Set data\n         * @param {Object} data\n         * @param {Function} cb  - callback function when finished\n         */\n        setData(data, cb) {\n            delete this.index;\n            if (isEmptyData(data)) {\n                this.empty = true;\n                cb();\n                return;\n            }\n            const options = {\n                maxZoom: 24,  // max zoom to preserve detail on; can't be higher than 24\n                tolerance: this.options.simplifyTolerance, // simplification tolerance (higher means simpler)\n                extent: this.options.extent, // tile extent (both width and height)\n                buffer: isNumber$1(this.options.tileBuffer) ? this.options.tileBuffer : 64,      // tile buffer on each side\n                hasAltitude: !!this.options.hasAltitude,\n                debug: 0,      // logging level (0 to disable, 1 or 2)\n                lineMetrics: true,\n                indexMaxZoom: 5,       // max zoom in the initial tile index\n                indexMaxPoints: 100000, // max number of points per tile in the index\n                disableFilter: true\n            };\n            if (this.options.projection) {\n                options.projection = this.options.projection;\n                if (options.projection === 'EPSG:4490') {\n                    options.projection = 'EPSG:4326';\n                }\n            }\n            if (isString(data) && data.substring(0, 1) != '{' || data.url) {\n                const url = data.url ? data.url : data;\n                Ajax.getJSON(url, data.url ? data : {}, (err, resp) => {\n                    if (err) {\n                        console.error('Failed to fetch geojson:' + url);\n                        cb(err);\n                    }\n                    if (!resp) {\n                        cb(null, { extent: null, idMap: {} });\n                        return;\n                    }\n                    let data = resp;\n                    if (this.options.convertFn) {\n                        const fn = new Function('data', this.options.convertFn + '\\nreturn convert(data)');\n                        data = fn(data);\n                    }\n                    const features = Array.isArray(data) ? data : data.features;\n                    this._genOMBB(features);\n                    // debugger\n                    const { sample1000, idMap } = this._generateId(features);\n                    this._generate(sample1000, idMap, data, options, cb);\n                });\n            } else {\n                if (typeof data === 'string') {\n                    data = JSON.parse(data);\n                }\n                const features = Array.isArray(data) ? data : data.features;\n                const length = features && features.length;\n                this._genOMBB(features);\n                let sample1000 = features;\n                if (features && length > 1000) {\n                    sample1000 = [];\n                    for (let i = 0; i < length; i++) {\n                        insertSample(features[i], sample1000, i, length);\n                    }\n                }\n                this._generate(sample1000, null, data, options, cb);\n            }\n        }\n\n        _genOMBB(features) {\n            if (!this.options.generateOMBB) {\n                return;\n            }\n            if (features) {\n                // const projectionCode = this.options.projectionCode;\n                // 大概的性能: 2023-06-24\n                // 时间   feature数量    顶点数量\n                // 84ms      2105        24621\n                // debugger\n                for (let i = 0; i < features.length; i++) {\n                    const f = features[i];\n                    if (!f || !f.geometry || !f.geometry.coordinates) {\n                        continue;\n                    }\n                    if (f.geometry.type === 'Polygon') {\n                        const shell = f.geometry.coordinates[0];\n                        if (!shell) {\n                            continue;\n                        }\n                        const ombb = computeOMBB(shell, 0, shell.length);\n                        // for (let j = 0; j < ombb.length; j++) {\n                        //     if (Array.isArray(ombb[j])) {\n                        //         project(ombb[j], ombb[j], projectionCode);\n                        //     }\n                        // }\n                        f.properties = f.properties || {};\n                        f.properties[PROP_OMBB] = ombb;\n                    } else if (f.geometry.type === 'MultiPolygon') {\n                        const polygons = f.geometry.coordinates;\n                        for (let i = 0; i < polygons.length; i++) {\n                            if (!polygons[i]) {\n                                continue;\n                            }\n                            const shell = polygons[i][0];\n                            if (!shell) {\n                                continue;\n                            }\n                            const ombb = computeOMBB(shell, 0, shell.length);\n                            // for (let j = 0; j < ombb.length; j++) {\n                            //     if (Array.isArray(ombb[j])) {\n                            //         project(ombb[j], ombb[j], projectionCode);\n                            //     }\n                            // }\n                            f.properties = f.properties || {};\n                            f.properties[PROP_OMBB] = f.properties[PROP_OMBB] || [];\n                            f.properties[PROP_OMBB][i] = ombb;\n                        }\n\n                    }\n                }\n            }\n        }\n\n        _generate(sample1000, idMap, data, options, cb) {\n            try {\n                const extent = sample1000 && sample1000.length ? bbox({ type: "FeatureCollection", features: sample1000 }) : null;\n                this.index = geojsonvt(data, this.options.geojsonvt || options);\n                cb(null, { extent, idMap });\n            } catch (err) {\n                console.warn(err);\n                cb({ error: err.message });\n            }\n        }\n\n        _generateId(data) {\n            // generate id\n            const sample1000 = [];\n            const idMap = {};\n            let uid = 0;\n            const feaIdProp = this.options.featureIdProperty;\n            function visit(f, index, length) {\n                if (!f) {\n                    return;\n                }\n                if (f.type === 'Feature' && !f.geometry) {\n                    return;\n                }\n                if (!isNumber$1(f.id)) {\n                    f.id = uid++;\n                }\n                if (feaIdProp) {\n                    let idProp = feaIdProp;\n                    if (isObject$1(feaIdProp)) {\n                        idProp = feaIdProp[f.layer || '0'];\n                    }\n                    f.id = f.properties[idProp];\n                }\n                idMap[f.id] = extend$2({}, f);\n                if (f.geometry) {\n                    idMap[f.id].geometry = extend$2({}, f.geometry);\n                    idMap[f.id].geometry.coordinates = null;\n                } else if (f.coordinates) {\n                    idMap[f.id].coordinates = null;\n                }\n\n                insertSample(f, sample1000, index, length);\n            }\n            if (data) {\n                const length = data.length;\n                data.forEach((f, index) => {\n                    visit(f, index, length);\n                });\n            }\n            return { sample1000, idMap };\n        }\n\n        getTileFeatures(context, cb) {\n            const tileInfo = context.tileInfo;\n            const features = [];\n            if (!this.index) {\n                if (this.empty) {\n                    setTimeout(function () {\n                        cb(null, features, []);\n                    }, 1);\n                    return 1;\n                }\n                setTimeout(function () {\n                    cb({ loading: true });\n                }, 1);\n                return 1;\n            }\n            const tile = this.index.getTile(tileInfo.z, tileInfo.x, tileInfo.y);\n            if (!tile || tile.features.length === 0) {\n                setTimeout(function () {\n                    cb(null, features, []);\n                }, 1);\n                return 1;\n            }\n            const layers = [];\n            for (let i = 0, l = tile.features.length; i < l; i++) {\n                const feature = tile.features[i];\n\n                let layerId = feature.layer;\n                if (layerId === undefined) {\n                    layerId = '0';\n                }\n                layers[layerId] = {\n                    types: {}\n                };\n                const types = layers[layerId].types;\n                types[feature.type] = 1;\n                feature.tags = feature.tags || {};\n                // feature.tags['$layer'] = layerId;\n                // feature.tags['$type'] = feature.type;\n                if (!feature.geometry.converted) {\n                    PackUtil.convertGeometry(feature);\n                    feature.geometry.converted = 1;\n                }\n                features.push({\n                    type: feature.type,\n                    layer: layerId,\n                    id: feature.id,\n                    geometry: feature.geometry,\n                    properties: feature.tags,\n                    extent: this.options.extent\n                });\n            }\n\n            for (const p in layers) {\n                layers[p].types = Object.keys(layers[p].types).map(t => +t);\n            }\n\n            //TODO 增加geojson-vt的多图层支持\n            setTimeout(function () {\n                cb(null, features, layers);\n            }, 1);\n\n            return 1;\n        }\n\n        onRemove() {\n            super.onRemove();\n            delete this.index;\n        }\n    }\n\n    function insertSample(feature, sample1000, i, length) {\n        const step = Math.floor(length / (1000 - 2));\n        if (i === 0 || i === length - 1) {\n            sample1000.push(feature);\n        } else if ((step === 0 || i % step === 0) && sample1000.length < 999) {\n            sample1000.push(feature);\n        }\n    }\n\n    function isEmptyData(data) {\n        if (!data) {\n            return true;\n        }\n        if (Array.isArray(data) && !data.length) {\n            return true;\n        }\n        if (data.features && !data.features.length) {\n            return true;\n        }\n        return false;\n    }\n\n    var ieee754$1 = {};\n\n    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\n    ieee754$1.read = function (buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = (nBytes * 8) - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? (nBytes - 1) : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n\n      i += d;\n\n      e = s & ((1 << (-nBits)) - 1);\n      s >>= (-nBits);\n      nBits += eLen;\n      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n      m = e & ((1 << (-nBits)) - 1);\n      e >>= (-nBits);\n      nBits += mLen;\n      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : ((s ? -1 : 1) * Infinity)\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n    };\n\n    ieee754$1.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = (nBytes * 8) - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n      var i = isLE ? 0 : (nBytes - 1);\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n      value = Math.abs(value);\n\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = ((value * c) - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n\n      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n      e = (e << mLen) | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n      buffer[offset + i - d] |= s * 128;\n    };\n\n    var pbf = Pbf;\n\n    var ieee754 = ieee754$1;\n\n    function Pbf(buf) {\n        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n        this.pos = 0;\n        this.type = 0;\n        this.length = this.buf.length;\n    }\n\n    Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\n    Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\n    Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\n    Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\n    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n        SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n    // Threshold chosen based on both benchmarking and knowledge about browser string\n    // data structures (which currently switch structure types at 12 bytes or more)\n    var TEXT_DECODER_MIN_LENGTH = 12;\n    var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');\n\n    Pbf.prototype = {\n\n        destroy: function() {\n            this.buf = null;\n        },\n\n        // === READING =================================================================\n\n        readFields: function(readField, result, end) {\n            end = end || this.length;\n\n            while (this.pos < end) {\n                var val = this.readVarint(),\n                    tag = val >> 3,\n                    startPos = this.pos;\n\n                this.type = val & 0x7;\n                readField(tag, result, this);\n\n                if (this.pos === startPos) this.skip(val);\n            }\n            return result;\n        },\n\n        readMessage: function(readField, result) {\n            return this.readFields(readField, result, this.readVarint() + this.pos);\n        },\n\n        readFixed32: function() {\n            var val = readUInt32(this.buf, this.pos);\n            this.pos += 4;\n            return val;\n        },\n\n        readSFixed32: function() {\n            var val = readInt32(this.buf, this.pos);\n            this.pos += 4;\n            return val;\n        },\n\n        // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n        readFixed64: function() {\n            var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n            this.pos += 8;\n            return val;\n        },\n\n        readSFixed64: function() {\n            var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n            this.pos += 8;\n            return val;\n        },\n\n        readFloat: function() {\n            var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n            this.pos += 4;\n            return val;\n        },\n\n        readDouble: function() {\n            var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n            this.pos += 8;\n            return val;\n        },\n\n        readVarint: function(isSigned) {\n            var buf = this.buf,\n                val, b;\n\n            b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n            b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n            b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n            b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n            b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n            return readVarintRemainder(val, isSigned, this);\n        },\n\n        readVarint64: function() { // for compatibility with v2.0.1\n            return this.readVarint(true);\n        },\n\n        readSVarint: function() {\n            var num = this.readVarint();\n            return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n        },\n\n        readBoolean: function() {\n            return Boolean(this.readVarint());\n        },\n\n        readString: function() {\n            var end = this.readVarint() + this.pos;\n            var pos = this.pos;\n            this.pos = end;\n\n            if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {\n                // longer strings are fast with the built-in browser TextDecoder API\n                return readUtf8TextDecoder(this.buf, pos, end);\n            }\n            // short strings are fast with our custom implementation\n            return readUtf8(this.buf, pos, end);\n        },\n\n        readBytes: function() {\n            var end = this.readVarint() + this.pos,\n                buffer = this.buf.subarray(this.pos, end);\n            this.pos = end;\n            return buffer;\n        },\n\n        // verbose for performance reasons; doesn't affect gzipped size\n\n        readPackedVarint: function(arr, isSigned) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readVarint(isSigned));\n            return arr;\n        },\n        readPackedSVarint: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readSVarint());\n            return arr;\n        },\n        readPackedBoolean: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readBoolean());\n            return arr;\n        },\n        readPackedFloat: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readFloat());\n            return arr;\n        },\n        readPackedDouble: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readDouble());\n            return arr;\n        },\n        readPackedFixed32: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readFixed32());\n            return arr;\n        },\n        readPackedSFixed32: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readSFixed32());\n            return arr;\n        },\n        readPackedFixed64: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readFixed64());\n            return arr;\n        },\n        readPackedSFixed64: function(arr) {\n            if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());\n            var end = readPackedEnd(this);\n            arr = arr || [];\n            while (this.pos < end) arr.push(this.readSFixed64());\n            return arr;\n        },\n\n        skip: function(val) {\n            var type = val & 0x7;\n            if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n            else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n            else if (type === Pbf.Fixed32) this.pos += 4;\n            else if (type === Pbf.Fixed64) this.pos += 8;\n            else throw new Error('Unimplemented type: ' + type);\n        },\n\n        // === WRITING =================================================================\n\n        writeTag: function(tag, type) {\n            this.writeVarint((tag << 3) | type);\n        },\n\n        realloc: function(min) {\n            var length = this.length || 16;\n\n            while (length < this.pos + min) length *= 2;\n\n            if (length !== this.length) {\n                var buf = new Uint8Array(length);\n                buf.set(this.buf);\n                this.buf = buf;\n                this.length = length;\n            }\n        },\n\n        finish: function() {\n            this.length = this.pos;\n            this.pos = 0;\n            return this.buf.subarray(0, this.length);\n        },\n\n        writeFixed32: function(val) {\n            this.realloc(4);\n            writeInt32(this.buf, val, this.pos);\n            this.pos += 4;\n        },\n\n        writeSFixed32: function(val) {\n            this.realloc(4);\n            writeInt32(this.buf, val, this.pos);\n            this.pos += 4;\n        },\n\n        writeFixed64: function(val) {\n            this.realloc(8);\n            writeInt32(this.buf, val & -1, this.pos);\n            writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n            this.pos += 8;\n        },\n\n        writeSFixed64: function(val) {\n            this.realloc(8);\n            writeInt32(this.buf, val & -1, this.pos);\n            writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n            this.pos += 8;\n        },\n\n        writeVarint: function(val) {\n            val = +val || 0;\n\n            if (val > 0xfffffff || val < 0) {\n                writeBigVarint(val, this);\n                return;\n            }\n\n            this.realloc(4);\n\n            this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n            this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n            this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n            this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n        },\n\n        writeSVarint: function(val) {\n            this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n        },\n\n        writeBoolean: function(val) {\n            this.writeVarint(Boolean(val));\n        },\n\n        writeString: function(str) {\n            str = String(str);\n            this.realloc(str.length * 4);\n\n            this.pos++; // reserve 1 byte for short string length\n\n            var startPos = this.pos;\n            // write the string directly to the buffer and see how much was written\n            this.pos = writeUtf8(this.buf, str, this.pos);\n            var len = this.pos - startPos;\n\n            if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n            // finally, write the message length in the reserved place and restore the position\n            this.pos = startPos - 1;\n            this.writeVarint(len);\n            this.pos += len;\n        },\n\n        writeFloat: function(val) {\n            this.realloc(4);\n            ieee754.write(this.buf, val, this.pos, true, 23, 4);\n            this.pos += 4;\n        },\n\n        writeDouble: function(val) {\n            this.realloc(8);\n            ieee754.write(this.buf, val, this.pos, true, 52, 8);\n            this.pos += 8;\n        },\n\n        writeBytes: function(buffer) {\n            var len = buffer.length;\n            this.writeVarint(len);\n            this.realloc(len);\n            for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n        },\n\n        writeRawMessage: function(fn, obj) {\n            this.pos++; // reserve 1 byte for short message length\n\n            // write the message directly to the buffer and see how much was written\n            var startPos = this.pos;\n            fn(obj, this);\n            var len = this.pos - startPos;\n\n            if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n            // finally, write the message length in the reserved place and restore the position\n            this.pos = startPos - 1;\n            this.writeVarint(len);\n            this.pos += len;\n        },\n\n        writeMessage: function(tag, fn, obj) {\n            this.writeTag(tag, Pbf.Bytes);\n            this.writeRawMessage(fn, obj);\n        },\n\n        writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },\n        writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },\n        writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },\n        writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },\n        writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },\n        writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },\n        writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },\n        writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },\n        writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },\n\n        writeBytesField: function(tag, buffer) {\n            this.writeTag(tag, Pbf.Bytes);\n            this.writeBytes(buffer);\n        },\n        writeFixed32Field: function(tag, val) {\n            this.writeTag(tag, Pbf.Fixed32);\n            this.writeFixed32(val);\n        },\n        writeSFixed32Field: function(tag, val) {\n            this.writeTag(tag, Pbf.Fixed32);\n            this.writeSFixed32(val);\n        },\n        writeFixed64Field: function(tag, val) {\n            this.writeTag(tag, Pbf.Fixed64);\n            this.writeFixed64(val);\n        },\n        writeSFixed64Field: function(tag, val) {\n            this.writeTag(tag, Pbf.Fixed64);\n            this.writeSFixed64(val);\n        },\n        writeVarintField: function(tag, val) {\n            this.writeTag(tag, Pbf.Varint);\n            this.writeVarint(val);\n        },\n        writeSVarintField: function(tag, val) {\n            this.writeTag(tag, Pbf.Varint);\n            this.writeSVarint(val);\n        },\n        writeStringField: function(tag, str) {\n            this.writeTag(tag, Pbf.Bytes);\n            this.writeString(str);\n        },\n        writeFloatField: function(tag, val) {\n            this.writeTag(tag, Pbf.Fixed32);\n            this.writeFloat(val);\n        },\n        writeDoubleField: function(tag, val) {\n            this.writeTag(tag, Pbf.Fixed64);\n            this.writeDouble(val);\n        },\n        writeBooleanField: function(tag, val) {\n            this.writeVarintField(tag, Boolean(val));\n        }\n    };\n\n    function readVarintRemainder(l, s, p) {\n        var buf = p.buf,\n            h, b;\n\n        b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n        b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n        b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n        b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n        b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n        b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n        throw new Error('Expected varint not more than 10 bytes');\n    }\n\n    function readPackedEnd(pbf) {\n        return pbf.type === Pbf.Bytes ?\n            pbf.readVarint() + pbf.pos : pbf.pos + 1;\n    }\n\n    function toNum(low, high, isSigned) {\n        if (isSigned) {\n            return high * 0x100000000 + (low >>> 0);\n        }\n\n        return ((high >>> 0) * 0x100000000) + (low >>> 0);\n    }\n\n    function writeBigVarint(val, pbf) {\n        var low, high;\n\n        if (val >= 0) {\n            low  = (val % 0x100000000) | 0;\n            high = (val / 0x100000000) | 0;\n        } else {\n            low  = ~(-val % 0x100000000);\n            high = ~(-val / 0x100000000);\n\n            if (low ^ 0xffffffff) {\n                low = (low + 1) | 0;\n            } else {\n                low = 0;\n                high = (high + 1) | 0;\n            }\n        }\n\n        if (val >= 0x10000000000000000 || val < -18446744073709552e3) {\n            throw new Error('Given varint doesn\\'t fit into 10 bytes');\n        }\n\n        pbf.realloc(10);\n\n        writeBigVarintLow(low, high, pbf);\n        writeBigVarintHigh(high, pbf);\n    }\n\n    function writeBigVarintLow(low, high, pbf) {\n        pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n        pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n        pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n        pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n        pbf.buf[pbf.pos]   = low & 0x7f;\n    }\n\n    function writeBigVarintHigh(high, pbf) {\n        var lsb = (high & 0x07) << 4;\n\n        pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n        pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n        pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n        pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n        pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n        pbf.buf[pbf.pos++]  = high & 0x7f;\n    }\n\n    function makeRoomForExtraLength(startPos, len, pbf) {\n        var extraLen =\n            len <= 0x3fff ? 1 :\n            len <= 0x1fffff ? 2 :\n            len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n        // if 1 byte isn't enough for encoding message length, shift the data to the right\n        pbf.realloc(extraLen);\n        for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n    }\n\n    function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\n    function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\n    function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\n    function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\n    function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\n    function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\n    function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\n    function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\n    function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n    // Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\n    function readUInt32(buf, pos) {\n        return ((buf[pos]) |\n            (buf[pos + 1] << 8) |\n            (buf[pos + 2] << 16)) +\n            (buf[pos + 3] * 0x1000000);\n    }\n\n    function writeInt32(buf, val, pos) {\n        buf[pos] = val;\n        buf[pos + 1] = (val >>> 8);\n        buf[pos + 2] = (val >>> 16);\n        buf[pos + 3] = (val >>> 24);\n    }\n\n    function readInt32(buf, pos) {\n        return ((buf[pos]) |\n            (buf[pos + 1] << 8) |\n            (buf[pos + 2] << 16)) +\n            (buf[pos + 3] << 24);\n    }\n\n    function readUtf8(buf, pos, end) {\n        var str = '';\n        var i = pos;\n\n        while (i < end) {\n            var b0 = buf[i];\n            var c = null; // codepoint\n            var bytesPerSequence =\n                b0 > 0xEF ? 4 :\n                b0 > 0xDF ? 3 :\n                b0 > 0xBF ? 2 : 1;\n\n            if (i + bytesPerSequence > end) break;\n\n            var b1, b2, b3;\n\n            if (bytesPerSequence === 1) {\n                if (b0 < 0x80) {\n                    c = b0;\n                }\n            } else if (bytesPerSequence === 2) {\n                b1 = buf[i + 1];\n                if ((b1 & 0xC0) === 0x80) {\n                    c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                    if (c <= 0x7F) {\n                        c = null;\n                    }\n                }\n            } else if (bytesPerSequence === 3) {\n                b1 = buf[i + 1];\n                b2 = buf[i + 2];\n                if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                    c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                    if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                        c = null;\n                    }\n                }\n            } else if (bytesPerSequence === 4) {\n                b1 = buf[i + 1];\n                b2 = buf[i + 2];\n                b3 = buf[i + 3];\n                if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                    c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                    if (c <= 0xFFFF || c >= 0x110000) {\n                        c = null;\n                    }\n                }\n            }\n\n            if (c === null) {\n                c = 0xFFFD;\n                bytesPerSequence = 1;\n\n            } else if (c > 0xFFFF) {\n                c -= 0x10000;\n                str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n                c = 0xDC00 | c & 0x3FF;\n            }\n\n            str += String.fromCharCode(c);\n            i += bytesPerSequence;\n        }\n\n        return str;\n    }\n\n    function readUtf8TextDecoder(buf, pos, end) {\n        return utf8TextDecoder.decode(buf.subarray(pos, end));\n    }\n\n    function writeUtf8(buf, str, pos) {\n        for (var i = 0, c, lead; i < str.length; i++) {\n            c = str.charCodeAt(i); // code point\n\n            if (c > 0xD7FF && c < 0xE000) {\n                if (lead) {\n                    if (c < 0xDC00) {\n                        buf[pos++] = 0xEF;\n                        buf[pos++] = 0xBF;\n                        buf[pos++] = 0xBD;\n                        lead = c;\n                        continue;\n                    } else {\n                        c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                        lead = null;\n                    }\n                } else {\n                    if (c > 0xDBFF || (i + 1 === str.length)) {\n                        buf[pos++] = 0xEF;\n                        buf[pos++] = 0xBF;\n                        buf[pos++] = 0xBD;\n                    } else {\n                        lead = c;\n                    }\n                    continue;\n                }\n            } else if (lead) {\n                buf[pos++] = 0xEF;\n                buf[pos++] = 0xBF;\n                buf[pos++] = 0xBD;\n                lead = null;\n            }\n\n            if (c < 0x80) {\n                buf[pos++] = c;\n            } else {\n                if (c < 0x800) {\n                    buf[pos++] = c >> 0x6 | 0xC0;\n                } else {\n                    if (c < 0x10000) {\n                        buf[pos++] = c >> 0xC | 0xE0;\n                    } else {\n                        buf[pos++] = c >> 0x12 | 0xF0;\n                        buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                    }\n                    buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n                }\n                buf[pos++] = c & 0x3F | 0x80;\n            }\n        }\n        return pos;\n    }\n\n    var pbf$1 = /*@__PURE__*/getDefaultExportFromCjs(pbf);\n\n    var pointGeometry = Point$1;\n\n    /**\n     * A standalone point geometry with useful accessor, comparison, and\n     * modification methods.\n     *\n     * @class Point\n     * @param {Number} x the x-coordinate. this could be longitude or screen\n     * pixels, or any other sort of unit.\n     * @param {Number} y the y-coordinate. this could be latitude or screen\n     * pixels, or any other sort of unit.\n     * @example\n     * var point = new Point(-77, 38);\n     */\n    function Point$1(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Point$1.prototype = {\n\n        /**\n         * Clone this point, returning a new point that can be modified\n         * without affecting the old one.\n         * @return {Point} the clone\n         */\n        clone: function() { return new Point$1(this.x, this.y); },\n\n        /**\n         * Add this point's x & y coordinates to another point,\n         * yielding a new point.\n         * @param {Point} p the other point\n         * @return {Point} output point\n         */\n        add:     function(p) { return this.clone()._add(p); },\n\n        /**\n         * Subtract this point's x & y coordinates to from point,\n         * yielding a new point.\n         * @param {Point} p the other point\n         * @return {Point} output point\n         */\n        sub:     function(p) { return this.clone()._sub(p); },\n\n        /**\n         * Multiply this point's x & y coordinates by point,\n         * yielding a new point.\n         * @param {Point} p the other point\n         * @return {Point} output point\n         */\n        multByPoint:    function(p) { return this.clone()._multByPoint(p); },\n\n        /**\n         * Divide this point's x & y coordinates by point,\n         * yielding a new point.\n         * @param {Point} p the other point\n         * @return {Point} output point\n         */\n        divByPoint:     function(p) { return this.clone()._divByPoint(p); },\n\n        /**\n         * Multiply this point's x & y coordinates by a factor,\n         * yielding a new point.\n         * @param {Point} k factor\n         * @return {Point} output point\n         */\n        mult:    function(k) { return this.clone()._mult(k); },\n\n        /**\n         * Divide this point's x & y coordinates by a factor,\n         * yielding a new point.\n         * @param {Point} k factor\n         * @return {Point} output point\n         */\n        div:     function(k) { return this.clone()._div(k); },\n\n        /**\n         * Rotate this point around the 0, 0 origin by an angle a,\n         * given in radians\n         * @param {Number} a angle to rotate around, in radians\n         * @return {Point} output point\n         */\n        rotate:  function(a) { return this.clone()._rotate(a); },\n\n        /**\n         * Rotate this point around p point by an angle a,\n         * given in radians\n         * @param {Number} a angle to rotate around, in radians\n         * @param {Point} p Point to rotate around\n         * @return {Point} output point\n         */\n        rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },\n\n        /**\n         * Multiply this point by a 4x1 transformation matrix\n         * @param {Array<Number>} m transformation matrix\n         * @return {Point} output point\n         */\n        matMult: function(m) { return this.clone()._matMult(m); },\n\n        /**\n         * Calculate this point but as a unit vector from 0, 0, meaning\n         * that the distance from the resulting point to the 0, 0\n         * coordinate will be equal to 1 and the angle from the resulting\n         * point to the 0, 0 coordinate will be the same as before.\n         * @return {Point} unit vector point\n         */\n        unit:    function() { return this.clone()._unit(); },\n\n        /**\n         * Compute a perpendicular point, where the new y coordinate\n         * is the old x coordinate and the new x coordinate is the old y\n         * coordinate multiplied by -1\n         * @return {Point} perpendicular point\n         */\n        perp:    function() { return this.clone()._perp(); },\n\n        /**\n         * Return a version of this point with the x & y coordinates\n         * rounded to integers.\n         * @return {Point} rounded point\n         */\n        round:   function() { return this.clone()._round(); },\n\n        /**\n         * Return the magitude of this point: this is the Euclidean\n         * distance from the 0, 0 coordinate to this point's x and y\n         * coordinates.\n         * @return {Number} magnitude\n         */\n        mag: function() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        },\n\n        /**\n         * Judge whether this point is equal to another point, returning\n         * true or false.\n         * @param {Point} other the other point\n         * @return {boolean} whether the points are equal\n         */\n        equals: function(other) {\n            return this.x === other.x &&\n                   this.y === other.y;\n        },\n\n        /**\n         * Calculate the distance from this point to another point\n         * @param {Point} p the other point\n         * @return {Number} distance\n         */\n        dist: function(p) {\n            return Math.sqrt(this.distSqr(p));\n        },\n\n        /**\n         * Calculate the distance from this point to another point,\n         * without the square root step. Useful if you're comparing\n         * relative distances.\n         * @param {Point} p the other point\n         * @return {Number} distance\n         */\n        distSqr: function(p) {\n            var dx = p.x - this.x,\n                dy = p.y - this.y;\n            return dx * dx + dy * dy;\n        },\n\n        /**\n         * Get the angle from the 0, 0 coordinate to this point, in radians\n         * coordinates.\n         * @return {Number} angle\n         */\n        angle: function() {\n            return Math.atan2(this.y, this.x);\n        },\n\n        /**\n         * Get the angle from this point to another point, in radians\n         * @param {Point} b the other point\n         * @return {Number} angle\n         */\n        angleTo: function(b) {\n            return Math.atan2(this.y - b.y, this.x - b.x);\n        },\n\n        /**\n         * Get the angle between this point and another point, in radians\n         * @param {Point} b the other point\n         * @return {Number} angle\n         */\n        angleWith: function(b) {\n            return this.angleWithSep(b.x, b.y);\n        },\n\n        /*\n         * Find the angle of the two vectors, solving the formula for\n         * the cross product a x b = |a||b|sin(θ) for θ.\n         * @param {Number} x the x-coordinate\n         * @param {Number} y the y-coordinate\n         * @return {Number} the angle in radians\n         */\n        angleWithSep: function(x, y) {\n            return Math.atan2(\n                this.x * y - this.y * x,\n                this.x * x + this.y * y);\n        },\n\n        _matMult: function(m) {\n            var x = m[0] * this.x + m[1] * this.y,\n                y = m[2] * this.x + m[3] * this.y;\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n\n        _add: function(p) {\n            this.x += p.x;\n            this.y += p.y;\n            return this;\n        },\n\n        _sub: function(p) {\n            this.x -= p.x;\n            this.y -= p.y;\n            return this;\n        },\n\n        _mult: function(k) {\n            this.x *= k;\n            this.y *= k;\n            return this;\n        },\n\n        _div: function(k) {\n            this.x /= k;\n            this.y /= k;\n            return this;\n        },\n\n        _multByPoint: function(p) {\n            this.x *= p.x;\n            this.y *= p.y;\n            return this;\n        },\n\n        _divByPoint: function(p) {\n            this.x /= p.x;\n            this.y /= p.y;\n            return this;\n        },\n\n        _unit: function() {\n            this._div(this.mag());\n            return this;\n        },\n\n        _perp: function() {\n            var y = this.y;\n            this.y = this.x;\n            this.x = -y;\n            return this;\n        },\n\n        _rotate: function(angle) {\n            var cos = Math.cos(angle),\n                sin = Math.sin(angle),\n                x = cos * this.x - sin * this.y,\n                y = sin * this.x + cos * this.y;\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n\n        _rotateAround: function(angle, p) {\n            var cos = Math.cos(angle),\n                sin = Math.sin(angle),\n                x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n                y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n\n        _round: function() {\n            this.x = Math.round(this.x);\n            this.y = Math.round(this.y);\n            return this;\n        }\n    };\n\n    /**\n     * Construct a point from an array if necessary, otherwise if the input\n     * is already a Point, or an unknown type, return it unchanged\n     * @param {Array<Number>|Point|*} a any kind of input value\n     * @return {Point} constructed point, or passed-through value.\n     * @example\n     * // this\n     * var point = Point.convert([0, 1]);\n     * // is equivalent to\n     * var point = new Point(0, 1);\n     */\n    Point$1.convert = function (a) {\n        if (a instanceof Point$1) {\n            return a;\n        }\n        if (Array.isArray(a)) {\n            return new Point$1(a[0], a[1]);\n        }\n        return a;\n    };\n\n    var Point = pointGeometry;\n\n    var vectortilefeature = VectorTileFeature$1;\n\n    function VectorTileFeature$1(pbf, end, extent, keys, values) {\n        // Public\n        this.properties = {};\n        this.extent = extent;\n        this.type = 0;\n\n        // Private\n        this._pbf = pbf;\n        this._geometry = -1;\n        this._keys = keys;\n        this._values = values;\n\n        pbf.readFields(readFeature, this, end);\n    }\n\n    function readFeature(tag, feature, pbf) {\n        if (tag == 1) feature.id = pbf.readVarint();\n        else if (tag == 2) readTag(pbf, feature);\n        else if (tag == 3) feature.type = pbf.readVarint();\n        else if (tag == 4) feature._geometry = pbf.pos;\n    }\n\n    function readTag(pbf, feature) {\n        var end = pbf.readVarint() + pbf.pos;\n\n        while (pbf.pos < end) {\n            var key = feature._keys[pbf.readVarint()],\n                value = feature._values[pbf.readVarint()];\n            feature.properties[key] = value;\n        }\n    }\n\n    VectorTileFeature$1.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\n    VectorTileFeature$1.prototype.loadGeometry = function() {\n        var pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        var end = pbf.readVarint() + pbf.pos,\n            cmd = 1,\n            length = 0,\n            x = 0,\n            y = 0,\n            lines = [],\n            line;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                var cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n\n                if (cmd === 1) { // moveTo\n                    if (line) lines.push(line);\n                    line = [];\n                }\n\n                line.push(new Point(x, y));\n\n            } else if (cmd === 7) {\n\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (line) {\n                    line.push(line[0].clone()); // closePolygon\n                }\n\n            } else {\n                throw new Error('unknown command ' + cmd);\n            }\n        }\n\n        if (line) lines.push(line);\n\n        return lines;\n    };\n\n    VectorTileFeature$1.prototype.bbox = function() {\n        var pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        var end = pbf.readVarint() + pbf.pos,\n            cmd = 1,\n            length = 0,\n            x = 0,\n            y = 0,\n            x1 = Infinity,\n            x2 = -Infinity,\n            y1 = Infinity,\n            y2 = -Infinity;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                var cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (x < x1) x1 = x;\n                if (x > x2) x2 = x;\n                if (y < y1) y1 = y;\n                if (y > y2) y2 = y;\n\n            } else if (cmd !== 7) {\n                throw new Error('unknown command ' + cmd);\n            }\n        }\n\n        return [x1, y1, x2, y2];\n    };\n\n    VectorTileFeature$1.prototype.toGeoJSON = function(x, y, z) {\n        var size = this.extent * Math.pow(2, z),\n            x0 = this.extent * x,\n            y0 = this.extent * y,\n            coords = this.loadGeometry(),\n            type = VectorTileFeature$1.types[this.type],\n            i, j;\n\n        function project(line) {\n            for (var j = 0; j < line.length; j++) {\n                var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;\n                line[j] = [\n                    (p.x + x0) * 360 / size - 180,\n                    360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90\n                ];\n            }\n        }\n\n        switch (this.type) {\n        case 1:\n            var points = [];\n            for (i = 0; i < coords.length; i++) {\n                points[i] = coords[i][0];\n            }\n            coords = points;\n            project(coords);\n            break;\n\n        case 2:\n            for (i = 0; i < coords.length; i++) {\n                project(coords[i]);\n            }\n            break;\n\n        case 3:\n            coords = classifyRings(coords);\n            for (i = 0; i < coords.length; i++) {\n                for (j = 0; j < coords[i].length; j++) {\n                    project(coords[i][j]);\n                }\n            }\n            break;\n        }\n\n        if (coords.length === 1) {\n            coords = coords[0];\n        } else {\n            type = 'Multi' + type;\n        }\n\n        var result = {\n            type: "Feature",\n            geometry: {\n                type: type,\n                coordinates: coords\n            },\n            properties: this.properties\n        };\n\n        if ('id' in this) {\n            result.id = this.id;\n        }\n\n        return result;\n    };\n\n    // classifies an array of rings into polygons with outer rings and holes\n\n    function classifyRings(rings) {\n        var len = rings.length;\n\n        if (len <= 1) return [rings];\n\n        var polygons = [],\n            polygon,\n            ccw;\n\n        for (var i = 0; i < len; i++) {\n            var area = signedArea(rings[i]);\n            if (area === 0) continue;\n\n            if (ccw === undefined) ccw = area < 0;\n\n            if (ccw === area < 0) {\n                if (polygon) polygons.push(polygon);\n                polygon = [rings[i]];\n\n            } else {\n                polygon.push(rings[i]);\n            }\n        }\n        if (polygon) polygons.push(polygon);\n\n        return polygons;\n    }\n\n    function signedArea(ring) {\n        var sum = 0;\n        for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n            p1 = ring[i];\n            p2 = ring[j];\n            sum += (p2.x - p1.x) * (p1.y + p2.y);\n        }\n        return sum;\n    }\n\n    var VectorTileFeature = vectortilefeature;\n\n    var vectortilelayer = VectorTileLayer$1;\n\n    function VectorTileLayer$1(pbf, end) {\n        // Public\n        this.version = 1;\n        this.name = null;\n        this.extent = 4096;\n        this.length = 0;\n\n        // Private\n        this._pbf = pbf;\n        this._keys = [];\n        this._values = [];\n        this._features = [];\n\n        pbf.readFields(readLayer, this, end);\n\n        this.length = this._features.length;\n    }\n\n    function readLayer(tag, layer, pbf) {\n        if (tag === 15) layer.version = pbf.readVarint();\n        else if (tag === 1) layer.name = pbf.readString();\n        else if (tag === 5) layer.extent = pbf.readVarint();\n        else if (tag === 2) layer._features.push(pbf.pos);\n        else if (tag === 3) layer._keys.push(pbf.readString());\n        else if (tag === 4) layer._values.push(readValueMessage(pbf));\n    }\n\n    function readValueMessage(pbf) {\n        var value = null,\n            end = pbf.readVarint() + pbf.pos;\n\n        while (pbf.pos < end) {\n            var tag = pbf.readVarint() >> 3;\n\n            value = tag === 1 ? pbf.readString() :\n                tag === 2 ? pbf.readFloat() :\n                tag === 3 ? pbf.readDouble() :\n                tag === 4 ? pbf.readVarint64() :\n                tag === 5 ? pbf.readVarint() :\n                tag === 6 ? pbf.readSVarint() :\n                tag === 7 ? pbf.readBoolean() : null;\n        }\n\n        return value;\n    }\n\n    // return feature \`i\` from this layer as a \`VectorTileFeature\`\n    VectorTileLayer$1.prototype.feature = function(i) {\n        if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n        this._pbf.pos = this._features[i];\n\n        var end = this._pbf.readVarint() + this._pbf.pos;\n        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n    };\n\n    var VectorTileLayer = vectortilelayer;\n\n    var vectortile = VectorTile$1;\n\n    function VectorTile$1(pbf, end) {\n        this.layers = pbf.readFields(readTile, {}, end);\n    }\n\n    function readTile(tag, layers, pbf) {\n        if (tag === 3) {\n            var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n            if (layer.length) layers[layer.name] = layer;\n        }\n    }\n\n    var VectorTile = vectortile;\n\n    //return MB size of arraybuffer\n    function calArrayBufferSize(buffer) {\n        if (!buffer) {\n            return 0;\n        }\n        if (!(buffer instanceof ArrayBuffer)) {\n            return 0;\n        }\n        return buffer.byteLength / 1048576;\n    }\n\n    function isNumber(val) {\n        return (typeof val === 'number') && !isNaN(val);\n    }\n\n    const ALTITUDE_ERRORS = {\n        'MISSING_ALTITUDE_ELEMENT': 2,\n    };\n\n    const textDecode = new TextDecoder('utf-8');\n\n    class VectorTileLayerWorker extends BaseLayerWorker {\n        constructor(id, options, uploader, cache, loadings, callback) {\n            super(id, options, uploader, cache, loadings);\n            options = options || {};\n            callback();\n        }\n\n        clearData() {\n            this._abortRequests();\n        }\n\n        /**\n         * Load a tile, paint and return gl directives\n         * @param {Object} tileInfo  - tileInfo, url, xyz, res, extent, etc\n         * @param {Function} cb      - callback function when finished\n         */\n        getTileFeatures(context, cb) {\n            const url = context.tileInfo.url;\n            const fetchOptions = context.fetchOptions || {};\n            const { altitudePropertyName, disableAltitudeWarning } = context;\n            const cached = this._cache.get(url);\n            if (cached && cached.cacheIndex === context.workerCacheIndex) {\n                const { err, data } = cached;\n                // setTimeout是因为该方法需要返回对象，否则BaseLayerWorker中的this.requests没有缓存，导致BaseLayerWorker不执行回调逻辑\n                return setTimeout(() => {\n                    this._readTile(url, altitudePropertyName, disableAltitudeWarning, err, data, cb);\n                }, 1);\n            }\n            //data from laodTileArray for custom\n            const { tileArrayBuffer } = context;\n            if (tileArrayBuffer) {\n                return setTimeout(() => {\n                    this._readTile(url, altitudePropertyName, disableAltitudeWarning, null, tileArrayBuffer, cb);\n                }, 1);\n            }\n            fetchOptions.referrer = context.referrer;\n            fetchOptions.errorLog = context.loadTileErrorLog;\n            const { loadTileCachMaxSize, loadTileCacheLog, } = context;\n            return Ajax.getArrayBuffer(url, fetchOptions, (err, response) => {\n                if (!this._cache) {\n                    // removed\n                    return;\n                }\n                if (err) {\n                    if (!err.loading) {\n                        this._cache.add(url, { err, data: response && response.data, cacheIndex: context.workerCacheIndex });\n                    }\n                } else if (response && response.data) {\n                    let needCache = true;\n                    if (isNumber(loadTileCachMaxSize) && loadTileCachMaxSize > 0) {\n                        const bufferSize = calArrayBufferSize(response.data);\n                        if (bufferSize > loadTileCachMaxSize) {\n                            needCache = false;\n                            if (loadTileCacheLog) {\n                                console.warn(\`url:${$D}url},loadTileCachMaxSize exceeded: ${$D}bufferSize} > ${$D}loadTileCachMaxSize},the tile will not be cached.\`);\n                            }\n                        }\n                    }\n                    if (needCache) {\n                        this._cache.add(url, { err: null, data: response.data, cacheIndex: context.workerCacheIndex });\n                    }\n                }\n\n                this._readTile(url, altitudePropertyName, disableAltitudeWarning, err, response && response.data, cb);\n            });\n        }\n\n        _readTile(url, altitudePropertyName, disableAltitudeWarning, err, data, cb) {\n            if (err) {\n                cb(err);\n                return;\n            }\n            let tile;\n            try {\n                tile = new VectorTile(new pbf$1(data));\n            } catch (err) {\n                const content = textDecode.decode(data);\n                err.message += '\\n' + url + '\\n' + content;\n                cb(err.message, [], []);\n                return;\n            }\n            const features = [];\n            if (!tile.layers) {\n                cb(null, features, []);\n                return;\n            }\n            const layers = {};\n            let feature;\n            for (const layer in tile.layers) {\n                if (hasOwn(tile.layers, layer)) {\n                    layers[layer] = {\n                        types: {}\n                    };\n                    const types = layers[layer].types;\n                    for (let i = 0, l = tile.layers[layer].length; i < l; i++) {\n                        try {\n                            feature = tile.layers[layer].feature(i);\n                            types[feature.type] = 1;\n                            // feature.properties['$layer'] = layer;\n                            // feature.properties['$type'] = feature.type;\n                            const fea = {\n                                type: feature.type,\n                                layer: layer,\n                                geometry: feature.loadGeometry(),\n                                properties: feature.properties,\n                                extent: feature.extent\n                            };\n                            if (feature.id !== undefined) {\n                                fea.id = feature.id;\n                            }\n                            let ombb = fea.properties[PROP_OMBB];\n                            if (ombb) {\n                                if (isString(ombb)) {\n                                    ombb = JSON.parse(ombb);\n                                }\n                                fea.properties[PROP_OMBB] = projectOMBB(ombb, 'EPSG:3857');\n                            }\n                            const altitudeBase64 = altitudePropertyName && fea.properties[altitudePropertyName];\n                            if (altitudeBase64) {\n                                const altitudes = decodeAltitude(altitudeBase64);\n                                const errors = [];\n                                fillAltitude(fea.geometry, altitudes, errors);\n                                if (errors.length && !disableAltitudeWarning) {\n                                    console.warn('feature.geometry is not consistent with altitude values:');\n                                    console.warn(JSON.stringify(fea, null, 2));\n                                }\n                            }\n                            features.push(fea);\n                        } catch (err) {\n                            console.warn('error when load vt geometry:', err);\n                        }\n\n                    }\n                }\n            }\n\n            for (const p in layers) {\n                layers[p].types = Object.keys(layers[p].types).map(t => +t);\n            }\n\n            cb(null, features, layers, { byteLength: data.byteLength });\n        }\n\n        abortTile(url, cb) {\n            const xhr = this.requests[url];\n            delete this.requests[url];\n            //需要先从requests中删除url，再abort，触发cancel逻辑, 否则会被当成xhr的error处理掉\n            if (xhr && xhr.abort) {\n                xhr.abort();\n            }\n            this._cancelLoadings(url);\n            cb();\n        }\n\n        onRemove() {\n            super.onRemove();\n            this._abortRequests();\n        }\n\n        _abortRequests() {\n            for (const url in this.requests) {\n                const xhr = this.requests[url];\n                if (xhr && xhr.abort) {\n                    xhr.abort();\n                }\n            }\n            this.requests = {};\n        }\n    }\n\n    function decodeAltitude(base64) {\n        const decoded = atob(base64);\n        const arr = new Uint8Array(decoded.length);\n        for (let i = 0; i < decoded.length; i++) {\n            arr[i] = decoded.charCodeAt(i);\n        }\n        return new Float32Array(arr.buffer);\n    }\n\n    function fillAltitude(geometry, altitudes, errors, iterator) {\n        if (!iterator) {\n            iterator = { index: 0 };\n        }\n        for (let i = 0; i < geometry.length; i++) {\n            if (Array.isArray(geometry[i])) {\n                fillAltitude(geometry[i], altitudes, errors, iterator);\n            } else {\n                const index = iterator.index;\n                if (isNil(altitudes[index])) {\n                    errors.push(ALTITUDE_ERRORS['MISSING_ALTITUDE_ELEMENT']);\n                } else {\n                    // meter to centimeter, reason refers to convert.js\n                    geometry[i].z = altitudes[index] * 100;\n                }\n                iterator.index++;\n            }\n        }\n    }\n\n    const { LRUCache } = getVectorPacker();\n\n\n    let callbackId = 0;\n\n    //global level 1 cache for layers sharing the same urlTemplate\n    const TILE_CACHE = new LRUCache(128);\n    // const TILE_LOADINGS = {};\n\n    class Dispatcher {\n\n        constructor(workerId) {\n            this._layers = {};\n            this._callbacks = {};\n            this.workerId = workerId;\n        }\n\n        /**\n         * Add a layer, create a layer worker\n         * @param {String} mapId    - map id\n         * @param {String} layerId  - layer id\n         * @param {String} type     - layer type, geojson or server\n         * @param {Object} options  - layer initialization options\n         * @param {Function} callback - callback function\n         */\n        addLayer({ actorId, mapId, layerId, params }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer) {\n                return;\n            }\n            const key = this._genKey(mapId, layerId);\n            const type = params.type;\n            const options = params.options;\n            const uploader = this.send.bind(this, actorId);\n            if (type === 'GeoJSONVectorTileLayer') {\n                this._layers[key] = new GeoJSONLayerWorker(layerId, options, uploader, TILE_CACHE, {}, callback);\n            } else {\n                this._layers[key] = new VectorTileLayerWorker(layerId, options, uploader, TILE_CACHE, {}, callback);\n            }\n        }\n\n        /**\n         * Remove a layer\n         * @param {String} mapId    - map id\n         * @param {String} layerId  - layer id\n         * @param {Function} callback - callback function\n         */\n        removeLayer({ mapId, layerId }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            const key = this._genKey(mapId, layerId);\n            delete this._layers[key];\n            if (layer) {\n                layer.onRemove(callback);\n                // this._resetCache();\n            }\n        }\n\n        /**\n         * Load a tile, return webgl directives\n         * @param {String} mapId    - map id\n         * @param {String} layerId  - layer id\n         * @param {Object} params   - params\n         * @param {Function} callback - callback function\n         */\n        loadTile({ mapId, layerId, params }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer) {\n                layer.loadTile(params, callback);\n            }\n        }\n\n        abortTile({ mapId, layerId, params }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer && layer.abortTile) {\n                layer.abortTile(params.url, callback);\n            }\n        }\n\n        /**\n         * Remove a tile from the worker\n         * @param {String} mapId    - map id\n         * @param {String} layerId  - layer id\n         * @param {Object} params   - params\n         * @param {Function} callback - callback function\n         */\n        removeTile({ mapId, layerId, params }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer) {\n                layer.removeTile(params, callback);\n            }\n        }\n\n        updateStyle({ mapId, layerId, params }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer) {\n                layer.updateStyle(params, callback);\n                // this._resetCache();\n            }\n        }\n\n        updateOptions({ mapId, layerId, params }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer) {\n                layer.updateOptions(params, callback);\n                // this._resetCache();\n            }\n        }\n\n        setData({ mapId, layerId, params }, callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer) {\n                layer.setData(params.data, callback);\n                // this._resetCache();\n            }\n        }\n\n        clearData({ mapId, layerId },callback) {\n            const layer = this._getLayerById(mapId, layerId);\n            if (layer) {\n                layer.clearData(callback);\n                this._resetCache();\n            }\n        }\n\n        /**\n         * Receive response from main thread and call callback\n         * @param {Object} data\n         */\n        receive(data) {\n            const id = data.callback;\n            const callback = this._callbacks[id];\n            delete this._callbacks[id];\n            if (callback && data.error) {\n                callback(new Error(data.error));\n            } else if (callback) {\n                callback(null, data.data);\n            }\n        }\n\n        /**\n         * Send a request to main thread\n         * @param {String} actorId - actor's id\n         * @param {String} command - actor's method name to call\n         * @param {Object} params - parameters\n         * @param {ArrayBuffer[]} buffers - transferable buffers\n         * @param {Function} callback - callback of main thread's reponse\n         */\n        send(actorId, command, params, buffers, callback) {\n            const id = callback ? \`${$D}actorId}-${$D}callbackId++}\` : null;\n            if (callback) this._callbacks[id] = callback;\n            postMessage({\n                type: '<request>',\n                workerId: this.workerId,\n                actorId,\n                command,\n                params,\n                callback: String(id)\n            }, buffers || []);\n        }\n\n        _genKey(mapId, layerId) {\n            return \`${$D}mapId}-${$D}layerId}\`;\n        }\n\n        _getLayerById(mapId, layerId) {\n            const key = this._genKey(mapId, layerId);\n            return this._layers[key];\n        }\n\n        _resetCache() {\n            // const keys = Object.keys(TILE_LOADINGS);\n            // for (let i = 0; i < keys.length; i++) {\n            //     delete TILE_LOADINGS[keys[i]];\n            // }\n            TILE_CACHE.reset();\n        }\n    }\n\n    const initialize = function () {\n    };\n\n    const onmessage = function (message, postResponse) {\n        const data = message.data;\n        if (!this.dispatcher) {\n            this.dispatcher = new Dispatcher(message.workerId);\n        }\n        if (message.type === '<response>') {\n            //sent request to main thread and receiving response\n            if (this.dispatcher.workerId === message.workerId) {\n                this.dispatcher.receive(message);\n            }\n        } else {\n            const command = data.command;\n            const loadTileErrorLog = (data.params || {}).loadTileErrorLog;\n            const loadTileErrorLogIgnoreCodes = (data.params || {}).loadTileErrorLogIgnoreCodes || [];\n            this.dispatcher[command]({ actorId: message.actorId, mapId: data.mapId, layerId: data.layerId, params: data.params }, (err, data, buffers) => {\n                if (loadTileErrorLog && err && !err.loading) {\n                    const status = err.status;\n                    if (isNumber$1(status) && loadTileErrorLogIgnoreCodes.indexOf(status) === -1) {\n                        console.error(command, err);\n                    }\n                }\n                // if (err && err.status !== 404 && err.status !== 204 && !err.loading) {\n                //     // err.loading 为true时，说明geojson-vt正在创建索引\n                //     console.error(command, err);\n                // }\n                postResponse(err, data, buffers);\n            });\n        }\n    };\n\n    exports.initialize = initialize;\n    exports.onmessage = onmessage;\n\n}`;function QD(i){const g=function(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0};if(g().maptalks_vt_packers)return;"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function m(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var _=b;function b(i,g){this.x=i,this.y=g}b.prototype={clone:function(){return new b(this.x,this.y)},add:function(i){return this.clone()._add(i)},sub:function(i){return this.clone()._sub(i)},multByPoint:function(i){return this.clone()._multByPoint(i)},divByPoint:function(i){return this.clone()._divByPoint(i)},mult:function(i){return this.clone()._mult(i)},div:function(i){return this.clone()._div(i)},rotate:function(i){return this.clone()._rotate(i)},rotateAround:function(i,g){return this.clone()._rotateAround(i,g)},matMult:function(i){return this.clone()._matMult(i)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(i){return this.x===i.x&&this.y===i.y},dist:function(i){return Math.sqrt(this.distSqr(i))},distSqr:function(i){var g=i.x-this.x,m=i.y-this.y;return g*g+m*m},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(i){return Math.atan2(this.y-i.y,this.x-i.x)},angleWith:function(i){return this.angleWithSep(i.x,i.y)},angleWithSep:function(i,g){return Math.atan2(this.x*g-this.y*i,this.x*i+this.y*g)},_matMult:function(i){var g=i[2]*this.x+i[3]*this.y;return this.x=i[0]*this.x+i[1]*this.y,this.y=g,this},_add:function(i){return this.x+=i.x,this.y+=i.y,this},_sub:function(i){return this.x-=i.x,this.y-=i.y,this},_mult:function(i){return this.x*=i,this.y*=i,this},_div:function(i){return this.x/=i,this.y/=i,this},_multByPoint:function(i){return this.x*=i.x,this.y*=i.y,this},_divByPoint:function(i){return this.x/=i.x,this.y/=i.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var i=this.y;return this.y=this.x,this.x=-i,this},_rotate:function(i){var g=Math.cos(i),m=Math.sin(i),_=m*this.x+g*this.y;return this.x=g*this.x-m*this.y,this.y=_,this},_rotateAround:function(i,g){var m=Math.cos(i),_=Math.sin(i),b=g.y+_*(this.x-g.x)+m*(this.y-g.y);return this.x=g.x+m*(this.x-g.x)-_*(this.y-g.y),this.y=b,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},b.convert=function(i){return i instanceof b?i:Array.isArray(i)?new b(i[0],i[1]):i};var T=m(_);const P={Point:1,LineString:2,Polygon:3,MultiPoint:4,MultiLineString:5,MultiPolygon:6};function I(i,g={}){var m=[];if("FeatureCollection"===i.type)for(var _=0;_<i.features.length;_++)H(m,i.features[_],g,_);else H(m,"Feature"===i.type?i:{geometry:i},g);return m}function H(i,g,m,_){if(g.geometry&&g.geometry.geometry){var b=g.geometry.coordinates,T=g.geometry.type,P=[],I=g.id;if(m.promoteId?I=g.properties[m.promoteId]:m.generateId&&(I=_||0),"Point"===T)W(b,P);else if("MultiPoint"===T)for(var Re=0;Re<b.length;Re++)W(b[Re],P);else if("LineString"===T)$([b],P);else if("MultiLineString"===T){if(m.lineMetrics){for(Re=0;Re<b.length;Re++)q(b[Re],P=[]),i.push(ye(I,"LineString",P,g.properties));return}$(b,P)}else if("Polygon"===T)$(b,P);else{if("MultiPolygon"!==T){if("GeometryCollection"===T){for(Re=0;Re<g.geometry.geometries.length;Re++)H(i,{id:I,geometry:g.geometry.geometries[Re],properties:g.properties},m,_);return}return void console.warn(`Input data type(${T}) is not a valid GeoJSON geometry type.`)}for(Re=0;Re<b.length;Re++){var Be=[];$(b[Re],Be),P.push(Be)}}i.push(ye(I,T,P,g.properties))}}function W(i,g){const m=new T(i[0],i[1]);m.z=100*(i[2]||0),g.push([m])}function q(i,g){for(let m=0;m<i.length;m++){const _=new T(i[m][0],i[m][1]);_.z=100*(i[m][2]||0),g.push(_)}}function $(i,g,m,_){for(var b=0;b<i.length;b++){var T=[];q(i[b],T),g.push(T)}}function ye(i,g,m,_){return{id:void 0===i?null:i,type:P[g],geometry:m,properties:_}}function Re(i,g,m){m=m||{},this.w=i||64,this.h=g||64,this.autoResize=!!m.autoResize,this.shelves=[],this.freebins=[],this.stats={},this.bins={},this.maxId=0}function Be(i,g,m){this.x=0,this.y=i,this.w=this.free=g,this.h=m}function Ge(i,g,m,_,b,T,P){this.id=i,this.x=g,this.y=m,this.w=_,this.h=b,this.maxw=T||_,this.maxh=P||b,this.refcount=0}
/*!
  	 * Codes from mapbox-gl-js
  	 * github.com/mapbox/mapbox-gl-js
  	 * MIT License
  	 */function je(i,{width:g,height:m},_,b){if(b){if(b.length!==g*m*_)throw new RangeError("mismatched image size")}else b=new Uint8Array(g*m*_);return i.width=g,i.height=m,i.data=b,i}function Xe(i,{width:g,height:m},_){if(g===i.width&&m===i.height)return;const b=je({},{width:g,height:m},_);Ze(i,b,{x:0,y:0},{x:0,y:0},{width:Math.min(i.width,g),height:Math.min(i.height,m)},_),i.width=g,i.height=m,i.data=b.data}function Ze(i,g,m,_,b,T){if(0===b.width||0===b.height)return g;if(b.width>i.width||b.height>i.height||m.x>i.width-b.width||m.y>i.height-b.height)throw new RangeError("out of range source coordinates for image copy");if(b.width>g.width||b.height>g.height||_.x>g.width-b.width||_.y>g.height-b.height)throw new RangeError("out of range destination coordinates for image copy");const P=i.data,I=g.data;if(P===I)return g;for(let H=0;H<b.height;H++){const W=((m.y+H)*i.width+m.x)*T,q=((_.y+H)*g.width+_.x)*T;for(let i=0;i<b.width*T;i++)I[q+i]=P[W+i]}return g}Re.prototype.pack=function(i,g){i=[].concat(i),g=g||{};for(var m,_,b,T=[],P=0;P<i.length;P++)if(_=i[P].h||i[P].height,(m=i[P].w||i[P].width)&&_){if(!(b=this.packOne(m,_,i[P].id)))continue;g.inPlace&&(i[P].x=b.x,i[P].y=b.y,i[P].id=b.id),T.push(b)}return this.shrink(),T},Re.prototype.packOne=function(i,g,m){var _,b,T,P,I,H,W,q,$={freebin:-1,shelf:-1,waste:1/0},ye=0;if("string"==typeof m||"number"==typeof m){if(_=this.getBin(m))return this.ref(_),_;"number"==typeof m&&(this.maxId=Math.max(m,this.maxId))}else m=++this.maxId;for(P=0;P<this.freebins.length;P++){if(g===(_=this.freebins[P]).maxh&&i===_.maxw)return this.allocFreebin(P,i,g,m);g>_.maxh||i>_.maxw||g<=_.maxh&&i<=_.maxw&&(T=_.maxw*_.maxh-i*g)<$.waste&&($.waste=T,$.freebin=P)}for(P=0;P<this.shelves.length;P++)if(ye+=(b=this.shelves[P]).h,!(i>b.free)){if(g===b.h)return this.allocShelf(P,i,g,m);g>b.h||g<b.h&&(T=(b.h-g)*i)<$.waste&&($.freebin=-1,$.waste=T,$.shelf=P)}return-1!==$.freebin?this.allocFreebin($.freebin,i,g,m):-1!==$.shelf?this.allocShelf($.shelf,i,g,m):g<=this.h-ye&&i<=this.w?(b=new Be(ye,this.w,g),this.allocShelf(this.shelves.push(b)-1,i,g,m)):this.autoResize?(I=H=this.h,((W=q=this.w)<=I||i>W)&&(q=2*Math.max(i,W)),(I<W||g>I)&&(H=2*Math.max(g,I)),this.resize(q,H),this.packOne(i,g,m)):null},Re.prototype.allocFreebin=function(i,g,m,_){var b=this.freebins.splice(i,1)[0];return b.id=_,b.w=g,b.h=m,b.refcount=0,this.bins[_]=b,this.ref(b),b},Re.prototype.allocShelf=function(i,g,m,_){var b=this.shelves[i].alloc(g,m,_);return this.bins[_]=b,this.ref(b),b},Re.prototype.shrink=function(){if(this.shelves.length>0){for(var i=0,g=0,m=0;m<this.shelves.length;m++){var _=this.shelves[m];g+=_.h,i=Math.max(_.w-_.free,i)}this.resize(i,g)}},Re.prototype.getBin=function(i){return this.bins[i]},Re.prototype.ref=function(i){if(1===++i.refcount){var g=i.h;this.stats[g]=1+(0|this.stats[g])}return i.refcount},Re.prototype.unref=function(i){return 0===i.refcount?0:(0===--i.refcount&&(this.stats[i.h]--,delete this.bins[i.id],this.freebins.push(i)),i.refcount)},Re.prototype.clear=function(){this.shelves=[],this.freebins=[],this.stats={},this.bins={},this.maxId=0},Re.prototype.resize=function(i,g){this.w=i,this.h=g;for(var m=0;m<this.shelves.length;m++)this.shelves[m].resize(i);return!0},Be.prototype.alloc=function(i,g,m){if(i>this.free||g>this.h)return null;var _=this.x;return this.x+=i,this.free-=i,new Ge(m,_,this.y,i,g,i,this.h)},Be.prototype.resize=function(i){return this.free+=i-this.w,this.w=i,!0};class AlphaImage{constructor(i,g){je(this,i,1,g)}resize(i){Xe(this,i,1)}clone(){return new AlphaImage({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(i,g,m,_,b){Ze(i,g,m,_,b,1)}}class RGBAImage{constructor(i,g){je(this,i,4,g)}resize(i){Xe(this,i,4)}clone(){return new RGBAImage({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(i,g,m,_,b){Ze(i,g,m,_,b,4)}}function Ye(i){let g=0;for(let m,_,b=0,T=i.length,P=T-1;b<T;P=b++)if(m=i[b],_=i[P],void 0!==m.x)g+=(_.x-m.x)*(m.y+_.y);else{if(m[2]||_[2])return 1;g+=(_[0]-m[0])*(m[1]+_[1])}return g}function Qe(i,g,m,_,b){const T=i[g*_],P=i[g*_+1],I=i[m*_],H=i[m*_+1];return T===I&&(T<0||T>b)&&P!==H||P===H&&(P<0||P>b)&&T!==I}function Je(i,g,m){let _=m;return g&&i&&(_=+i[g]),isNaN(_)&&(_=m||0),100*_}function Ke(i,g,m,_,b,T,P){g||0===g||(g=1);const I=Je(i.properties,m,_),H=I*g;let W=(T?100*T:0)||I;return b?W=Je(i.properties,b,T):P&&(W=I-Je(i.properties,P,T)),W*=g,{altitude:H,height:W}}function et(i,g){return g<1/0&&(i.x<0||i.x>g||i.y<0||i.y>g)}function tt(i){return null==i}function at(i,g,m){if(i===m||i===g)return i;const _=m-g;return((i-g)%_+_)%_+g}function ht(i,g){if(!g)return null;const m=new Map;for(let _=0;_<g.length;_++){const b=g[_],T=i[b];let P=m.get(T);P||(P=[],m.set(T,P)),P.push(b)}return m}function gt(i){return!(i&i-1)&&0!==i}
/*!
  	 * Codes from mapbox-gl-js
  	 * github.com/mapbox/mapbox-gl-js
  	 * MIT License
  	 */class ImagePosition{constructor(i,g,{pixelRatio:m}){this.paddedRect=i,this.pixelRatio=m||1,this.padding=g}get tl(){return[this.paddedRect.x+this.padding,this.paddedRect.y+this.padding]}get br(){return[this.paddedRect.x+this.paddedRect.w-this.padding,this.paddedRect.y+this.paddedRect.h-this.padding]}get displaySize(){return[(this.paddedRect.w-2*this.padding)/this.pixelRatio,(this.paddedRect.h-2*this.padding)/this.pixelRatio]}}class IconAtlas{constructor(i,g){this.iconMap=i,this.options=g||{},this.build()}build(){const i=this.iconMap,g=Object.keys(i).length,m={},_=new Re(0,0,{autoResize:!0}),b=[],T=g>1?1:0;for(const g in i){const _=i[g],P={x:0,y:0,w:_.data.width+2*T,h:_.data.height+2*T};b.push(P),m[g]=new ImagePosition(P,T,_)}_.pack(b,{inPlace:!0});if(!(this.options.nonPowerOfTwo||gt(_.w)&&gt(_.h))){const i=yt(_.w),g=yt(_.h);_.resize(i,g)}const P=new RGBAImage({width:_.w,height:_.h});for(const g in i){const _=i[g],b=m[g].paddedRect;RGBAImage.copy(_.data,P,{x:0,y:0},{x:b.x+T,y:b.y+T},_.data)}this.image=P,this.positions=m}}function yt(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}
/*!
  	 * Codes from mapbox-gl-js
  	 * github.com/mapbox/mapbox-gl-js
  	 * MIT License
  	 * TODO 升级为potpack
  	 */class GlyphAtlas{constructor(i){this.glyphMap=i,this.build()}build(){const i=this.glyphMap,g={},m=new Re(0,0,{autoResize:!0}),_=[];for(const m in i){const b=i[m],T=g[m]={};for(const i in b){const g=b[+i];if(!g||0===g.bitmap.width||0===g.bitmap.height)continue;const m={x:0,y:0,w:g.bitmap.width+2,h:g.bitmap.height+2};_.push(m),T[i]={rect:m,metrics:g.metrics}}}m.pack(_,{inPlace:!0});const b=new AlphaImage({width:m.w,height:m.h});for(const m in i){const _=i[m];for(const i in _){const T=_[+i];if(!T||0===T.bitmap.width||0===T.bitmap.height)continue;const P=g[m][i].rect;AlphaImage.copy(T.bitmap,b,{x:0,y:0},{x:P.x+1,y:P.y+1},T.bitmap)}}this.image=b,this.positions=g}}function vt(i){return i<65536?Uint16Array:Uint32Array}function xt(i){return(i=Math.abs(i))<32768?Int16Array:(Math.pow(2,24),Float32Array)}function bt(i){return i<65536?Uint16Array:Float32Array}function Tt(i,g){const m=i.getLength?i.getLength():i.length;if(i instanceof g)return i.slice(0,m);const _=new g(m);i=i._origin||i;for(let g=0;g<m;g++)_[g]=i[g]||0;return _}function Mt(i){const g=i.type,m=[];if(1===g||4===g)for(let g=0;g<i.geometry.length;g++)W(i.geometry[g],m);else if(2===g)$(i.geometry,m);else if(3===g)$(i.geometry,m);else if(5===g)$(i.geometry,m);else if(6===g)for(let g=0;g<i.geometry.length;g++){const _=[];$(i.geometry[g],_),m.push(_)}return i.geometry=m,i}let Pt;const It={width:100,height:10};let Et=!1;try{const i=new OffscreenCanvas(1,1);i.getContext("2d").fillText("hello",0,0),Et=!0}catch(i){Et=!1}function Lt(){if(!Pt){const{width:i,height:g}=It;Et?Pt=new OffscreenCanvas(i,g):(Pt=document.createElement("canvas"),Pt.width=i,Pt.height=g)}return Pt}class ColorIn{constructor(i,g={}){if(!Array.isArray(i))return void console.error("colors is not array");if(i.length<2)return void console.error("colors.length should >1");this.colors=i;let m=1/0,_=-1/0;for(let g=0,b=i.length;g<b;g++){const b=i[g][0];m=Math.min(b,m),_=Math.max(b,_)}this.min=m,this.max=_,this.valueOffset=this.max-this.min,this.options=Object.assign({},It,g),this._initImgData()}getImageData(){return this.imgData}_initImgData(){const i=Lt(),{width:g,height:m}=this.options;i.width=g,i.height=m;const _=i.getContext("2d");_.clearRect(0,0,i.width,i.height);const b=_.createLinearGradient(0,0,i.width,0),{colors:T,valueOffset:P}=this;for(let i=0,g=T.length;i<g;i++){const[g,m]=T[i];b.addColorStop((g-this.min)/P,m)}_.fillStyle=b,_.fillRect(0,0,i.width,i.height),this.imgData=_.getImageData(0,0,i.width,i.height)}getColor(i){i=Math.max(this.min,i),i=Math.min(i,this.max);let g=Math.round((i-this.min)/this.valueOffset*this.imgData.width);g=Math.min(g,this.imgData.width-1);const m=4*g;return[this.imgData.data[m],this.imgData.data[m+1],this.imgData.data[m+2],this.imgData.data[m+3]]}}var Dt;function Ft(i){return null==i}function Ht(i){return!Ft(i)}function Bt(i){return""===i}function zt(i,g){var m,_,b;if(Yt(i)){var T,P=i.stops&&"object"==typeof i.stops[0][0],I=P||Ht(i.property),H=P||!I,W=i.type||g||"exponential";if("exponential"===W)T=Gt;else if("interval"===W)T=Ut;else if("categorical"===W)T=Vt;else if("identity"===W)T=qt;else if("color-interpolate"===W)T=Wt;else{if("calculate-expression"!==W)throw new Error('Unknown function type "'+W+'"');T=Xt}if(P){var q={},$=[];for(let g=0;g<i.stops.length;g++){var ye=i.stops[g];void 0===q[ye[0].zoom]&&(q[ye[0].zoom]={zoom:ye[0].zoom,type:i.type,property:i.property,default:i.default,stops:[]}),q[ye[0].zoom].stops.push([ye[0].value,ye[1]])}for(let i in q)$.push([q[i].zoom,zt(q[i])]);m=function(g,m){const _=Gt({stops:$,base:i.base},g)(g,m);return"function"==typeof _?_(g,m):_},_=!1,b=!1}else H?(m=function(g){const m=T(i,g);return"function"==typeof m?m(g):m},_=!0,b=!1):(m=function(g,m){const _=T(i,m?m[i.property]:null);return"function"==typeof _?_(g,m):_},_=!1,b=!0)}else m=function(){return i},_=!0,b=!0;return m.isZoomConstant=b,m.isFeatureConstant=_,m}function Vt(i,g){for(let m=0;m<i.stops.length;m++)if(g===i.stops[m][0])return i.stops[m][1];return i.default}function Ut(i,g){for(var m=0;m<i.stops.length&&!(g<i.stops[m][0]);m++);return i.stops[Math.max(m-1,0)][1]}function Gt(i,g){for(var m=Ht(i.base)&&!Bt(i.base)?i.base:1,_=0;!(_>=i.stops.length||g<=i.stops[_][0]);)_++;return 0===_?i.stops[_][1]:_===i.stops.length?i.stops[_-1][1]:Zt(g,m,i.stops[_-1][0],i.stops[_][0],i.stops[_-1][1],i.stops[_][1])}"function"==typeof Map&&(Dt=new Map);const jt={width:100,height:1};function Wt(i,g){const m=i.stops;if(m&&m.length>1){let i;if(Dt){const g=JSON.stringify(m);if(!Dt.has(g)){const i=new ColorIn(m,jt);Dt.set(g,i)}i=Dt.get(g)}else i=new ColorIn(m,jt);const[_,b,T,P]=i.getColor(g);return[_/255,b/255,T/255,P/255]}return m&&1===m.length?m[0][1]:null}function qt(i,g){return function(i,g,m){return Ht(i)?i:Ht(g)?g:Ht(m)?m:null}(g,i.default)}function Xt(i,g){const m=String(i.property),_=i.expression,b=g;function T(g){return Ft(g)||Bt(g)||isNaN(g)?i.default:g}if(!Ht(g)||Bt(g)||isNaN(g)||g<0)return T(i.default);{const g=function i(g,m,_){const b=Number(_),T=String(m);return Array.isArray(g)?g.map((g=>i(g,T,b))):g===T?b:g}(_,m,b);return T(function g(m){if(!Array.isArray(m)){if("number"==typeof m)return m;throw new Error("Invalid expression format")}{const _=m[0];if(!["+","-","*","/"].includes(_))throw new Error(`Unknown operator: ${_}`);const b=m.slice(1).map((i=>g(i)));switch(_){case"+":return b.reduce(((i,g)=>i+g),0);case"-":return b.reduce(((i,g)=>i-g));case"*":return b.reduce(((i,g)=>i*g),1);case"/":return b.some((i=>0===i))?i.default:b.reduce(((i,g)=>i/g));default:throw new Error(`Unsupported operator: ${_}`)}}}(g))}}function Zt(i,g,m,_,b,T){return"function"==typeof b?function(){var P=b.apply(void 0,arguments),I=T.apply(void 0,arguments);return Zt(i,g,m,_,P,I)}:b.length?function(i,g,m,_,b,T){var P=[];for(let I=0;I<b.length;I++)P[I]=$t(i,g,m,_,b[I],T[I]);return P}(i,g,m,_,b,T):$t(i,g,m,_,b,T)}function $t(i,g,m,_,b,T){var P,I=_-m,H=i-m;return b*(1-(P=1===g?H/I:(Math.pow(g,H)-1)/(Math.pow(g,I)-1)))+T*P}function Yt(i){return i&&"object"==typeof i&&(i.stops||i.property&&"identity"===i.type||i.expression&&"calculate-expression"===i.type)}function Qt(i){return en(i,"exponential")}function Jt(i){return en(i,"interval")}function Kt(i,g){if(!i)return null;var m=!1;if(Array.isArray(i)){var _,b=[];for(let T=0;T<i.length;T++)(_=Kt(i[T],g))?(b.push(_),m=!0):b.push(i[T]);return m?b:i}var T,P={__fn_types_loaded:!0},I=[];for(T in i)i.hasOwnProperty(T)&&I.push(T);const H=function(i){Object.defineProperty(P,i,{get:function(){return this["__fn_"+i]||(this["__fn_"+i]=Qt(this["_"+i])),this["__fn_"+i].apply(this,g())},set:function(g){this["_"+i]=g},configurable:!0,enumerable:!0})};for(let g=0,_=I.length;g<_;g++)Yt(i[T=I[g]])?(m=!0,P["_"+T]=i[T],H(T)):P[T]=i[T];return m?P:i}function en(i,g){if(!Yt(i))return function(){return i};let m=!0,_=!0;const b=(i=JSON.parse(JSON.stringify(i))).stops;if(b)for(let i=0;i<b.length;i++)if(Yt(b[i][1])){const T=en(b[i][1],g);m=m&&T.isZoomConstant,_=_&&T.isFeatureConstant,b[i]=[b[i][0],T]}const T=zt(i,g);return T.isZoomConstant=m&&T.isZoomConstant,T.isFeatureConstant=_&&T.isFeatureConstant,T}var tn={exports:{}},nn={exports:{}},rn=function(i){return!(!i||"string"==typeof i)&&(i instanceof Array||Array.isArray(i)||i.length>=0&&(i.splice instanceof Function||Object.getOwnPropertyDescriptor(i,i.length-1)&&"String"!==i.constructor.name))},on=Array.prototype.concat,sn=Array.prototype.slice,an=nn.exports=function(i){for(var g=[],m=0,_=i.length;m<_;m++){var b=i[m];rn(b)?g=on.call(g,sn.call(b)):g.push(b)}return g};an.wrap=function(i){return function(){return i(an(arguments))}};var ln={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},hn=nn.exports,cn=Object.hasOwnProperty,un=Object.create(null);for(var fn in ln)cn.call(ln,fn)&&(un[ln[fn]]=fn);var dn=tn.exports={to:{},get:{}};function pn(i,g,m){return Math.min(Math.max(g,i),m)}function gn(i){var g=Math.round(i).toString(16).toUpperCase();return g.length<2?"0"+g:g}dn.get=function(i){var g,m;switch(i.substring(0,3).toLowerCase()){case"hsl":g=dn.get.hsl(i),m="hsl";break;case"hwb":g=dn.get.hwb(i),m="hwb";break;default:g=dn.get.rgb(i),m="rgb"}return g?{model:m,value:g}:null},dn.get.rgb=function(i){if(!i)return null;var g,m,_,b=[0,0,0,1];if(g=i.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(_=g[2],g=g[1],m=0;m<3;m++){var T=2*m;b[m]=parseInt(g.slice(T,T+2),16)}_&&(b[3]=parseInt(_,16)/255)}else if(g=i.match(/^#([a-f0-9]{3,4})$/i)){for(_=(g=g[1])[3],m=0;m<3;m++)b[m]=parseInt(g[m]+g[m],16);_&&(b[3]=parseInt(_+_,16)/255)}else if(g=i.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)){for(m=0;m<3;m++)b[m]=parseInt(g[m+1],0);g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}else{if(!(g=i.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)))return(g=i.match(/^(\w+)$/))?"transparent"===g[1]?[0,0,0,0]:cn.call(ln,g[1])?((b=ln[g[1]])[3]=1,b):null:null;for(m=0;m<3;m++)b[m]=Math.round(2.55*parseFloat(g[m+1]));g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}for(m=0;m<3;m++)b[m]=pn(b[m],0,255);return b[3]=pn(b[3],0,1),b},dn.get.hsl=function(i){if(!i)return null;var g=i.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,pn(parseFloat(g[2]),0,100),pn(parseFloat(g[3]),0,100),pn(isNaN(m)?1:m,0,1)]}return null},dn.get.hwb=function(i){if(!i)return null;var g=i.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,pn(parseFloat(g[2]),0,100),pn(parseFloat(g[3]),0,100),pn(isNaN(m)?1:m,0,1)]}return null},dn.to.hex=function(){var i=hn(arguments);return"#"+gn(i[0])+gn(i[1])+gn(i[2])+(i[3]<1?gn(Math.round(255*i[3])):"")},dn.to.rgb=function(){var i=hn(arguments);return i.length<4||1===i[3]?"rgb("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+")":"rgba("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+", "+i[3]+")"},dn.to.rgb.percent=function(){var i=hn(arguments),g=Math.round(i[0]/255*100),m=Math.round(i[1]/255*100),_=Math.round(i[2]/255*100);return i.length<4||1===i[3]?"rgb("+g+"%, "+m+"%, "+_+"%)":"rgba("+g+"%, "+m+"%, "+_+"%, "+i[3]+")"},dn.to.hsl=function(){var i=hn(arguments);return i.length<4||1===i[3]?"hsl("+i[0]+", "+i[1]+"%, "+i[2]+"%)":"hsla("+i[0]+", "+i[1]+"%, "+i[2]+"%, "+i[3]+")"},dn.to.hwb=function(){var i=hn(arguments),g="";return i.length>=4&&1!==i[3]&&(g=", "+i[3]),"hwb("+i[0]+", "+i[1]+"%, "+i[2]+"%"+g+")"},dn.to.keyword=function(i){return un[i.slice(0,3)]};var mn=tn.exports,An={exports:{}},yn={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},_n={};for(var xn in yn)yn.hasOwnProperty(xn)&&(_n[yn[xn]]=xn);var bn=An.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var wn in bn)if(bn.hasOwnProperty(wn)){if(!("channels"in bn[wn]))throw new Error("missing channels property: "+wn);if(!("labels"in bn[wn]))throw new Error("missing channel labels property: "+wn);if(bn[wn].labels.length!==bn[wn].channels)throw new Error("channel and label counts mismatch: "+wn);var Sn=bn[wn].channels,Mn=bn[wn].labels;delete bn[wn].channels,delete bn[wn].labels,Object.defineProperty(bn[wn],"channels",{value:Sn}),Object.defineProperty(bn[wn],"labels",{value:Mn})}function Cn(i,g){return Math.pow(i[0]-g[0],2)+Math.pow(i[1]-g[1],2)+Math.pow(i[2]-g[2],2)}bn.rgb.hsl=function(i){var g,m,_=i[0]/255,b=i[1]/255,T=i[2]/255,P=Math.min(_,b,T),I=Math.max(_,b,T),H=I-P;return I===P?g=0:_===I?g=(b-T)/H:b===I?g=2+(T-_)/H:T===I&&(g=4+(_-b)/H),(g=Math.min(60*g,360))<0&&(g+=360),m=(P+I)/2,[g,100*(I===P?0:m<=.5?H/(I+P):H/(2-I-P)),100*m]},bn.rgb.hsv=function(i){var g,m,_,b,T,P=i[0]/255,I=i[1]/255,H=i[2]/255,W=Math.max(P,I,H),q=W-Math.min(P,I,H),$=function(i){return(W-i)/6/q+.5};return 0===q?b=T=0:(T=q/W,g=$(P),m=$(I),_=$(H),P===W?b=_-m:I===W?b=1/3+g-_:H===W&&(b=2/3+m-g),b<0?b+=1:b>1&&(b-=1)),[360*b,100*T,100*W]},bn.rgb.hwb=function(i){var g=i[0],m=i[1],_=i[2];return[bn.rgb.hsl(i)[0],100*(1/255*Math.min(g,Math.min(m,_))),100*(_=1-1/255*Math.max(g,Math.max(m,_)))]},bn.rgb.cmyk=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255;return[100*((1-m-(g=Math.min(1-m,1-_,1-b)))/(1-g)||0),100*((1-_-g)/(1-g)||0),100*((1-b-g)/(1-g)||0),100*g]},bn.rgb.keyword=function(i){var g=_n[i];if(g)return g;var m,_=1/0;for(var b in yn)if(yn.hasOwnProperty(b)){var T=Cn(i,yn[b]);T<_&&(_=T,m=b)}return m},bn.keyword.rgb=function(i){return yn[i]},bn.rgb.xyz=function(i){var g=i[0]/255,m=i[1]/255,_=i[2]/255;return[100*(.4124*(g=g>.04045?Math.pow((g+.055)/1.055,2.4):g/12.92)+.3576*(m=m>.04045?Math.pow((m+.055)/1.055,2.4):m/12.92)+.1805*(_=_>.04045?Math.pow((_+.055)/1.055,2.4):_/12.92)),100*(.2126*g+.7152*m+.0722*_),100*(.0193*g+.1192*m+.9505*_)]},bn.rgb.lab=function(i){var g=bn.rgb.xyz(i),m=g[0],_=g[1],b=g[2];return _/=100,b/=108.883,m=(m/=95.047)>.008856?Math.pow(m,1/3):7.787*m+16/116,[116*(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116)-16,500*(m-_),200*(_-(b=b>.008856?Math.pow(b,1/3):7.787*b+16/116))]},bn.hsl.rgb=function(i){var g,m,_,b,T,P=i[0]/360,I=i[1]/100,H=i[2]/100;if(0===I)return[T=255*H,T,T];g=2*H-(m=H<.5?H*(1+I):H+I-H*I),b=[0,0,0];for(var W=0;W<3;W++)(_=P+1/3*-(W-1))<0&&_++,_>1&&_--,b[W]=255*(T=6*_<1?g+6*(m-g)*_:2*_<1?m:3*_<2?g+(m-g)*(2/3-_)*6:g);return b},bn.hsl.hsv=function(i){var g=i[0],m=i[1]/100,_=i[2]/100,b=m,T=Math.max(_,.01);return m*=(_*=2)<=1?_:2-_,b*=T<=1?T:2-T,[g,100*(0===_?2*b/(T+b):2*m/(_+m)),100*((_+m)/2)]},bn.hsv.rgb=function(i){var g=i[0]/60,m=i[1]/100,_=i[2]/100,b=Math.floor(g)%6,T=g-Math.floor(g),P=255*_*(1-m),I=255*_*(1-m*T),H=255*_*(1-m*(1-T));switch(_*=255,b){case 0:return[_,H,P];case 1:return[I,_,P];case 2:return[P,_,H];case 3:return[P,I,_];case 4:return[H,P,_];case 5:return[_,P,I]}},bn.hsv.hsl=function(i){var g,m,_,b=i[0],T=i[1]/100,P=i[2]/100,I=Math.max(P,.01);return _=(2-T)*P,m=T*I,[b,100*(m=(m/=(g=(2-T)*I)<=1?g:2-g)||0),100*(_/=2)]},bn.hwb.rgb=function(i){var g,m,_,b,T,P,I,H=i[0]/360,W=i[1]/100,q=i[2]/100,$=W+q;switch($>1&&(W/=$,q/=$),_=6*H-(g=Math.floor(6*H)),1&g&&(_=1-_),b=W+_*((m=1-q)-W),g){default:case 6:case 0:T=m,P=b,I=W;break;case 1:T=b,P=m,I=W;break;case 2:T=W,P=m,I=b;break;case 3:T=W,P=b,I=m;break;case 4:T=b,P=W,I=m;break;case 5:T=m,P=W,I=b}return[255*T,255*P,255*I]},bn.cmyk.rgb=function(i){var g=i[1]/100,m=i[2]/100,_=i[3]/100;return[255*(1-Math.min(1,i[0]/100*(1-_)+_)),255*(1-Math.min(1,g*(1-_)+_)),255*(1-Math.min(1,m*(1-_)+_))]},bn.xyz.rgb=function(i){var g,m,_,b=i[0]/100,T=i[1]/100,P=i[2]/100;return m=-.9689*b+1.8758*T+.0415*P,_=.0557*b+-.204*T+1.057*P,g=(g=3.2406*b+-1.5372*T+-.4986*P)>.0031308?1.055*Math.pow(g,1/2.4)-.055:12.92*g,m=m>.0031308?1.055*Math.pow(m,1/2.4)-.055:12.92*m,_=_>.0031308?1.055*Math.pow(_,1/2.4)-.055:12.92*_,[255*(g=Math.min(Math.max(0,g),1)),255*(m=Math.min(Math.max(0,m),1)),255*(_=Math.min(Math.max(0,_),1))]},bn.xyz.lab=function(i){var g=i[0],m=i[1],_=i[2];return m/=100,_/=108.883,g=(g/=95.047)>.008856?Math.pow(g,1/3):7.787*g+16/116,[116*(m=m>.008856?Math.pow(m,1/3):7.787*m+16/116)-16,500*(g-m),200*(m-(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116))]},bn.lab.xyz=function(i){var g,m,_;g=i[1]/500+(m=(i[0]+16)/116),_=m-i[2]/200;var b=Math.pow(m,3),T=Math.pow(g,3),P=Math.pow(_,3);return m=b>.008856?b:(m-16/116)/7.787,g=T>.008856?T:(g-16/116)/7.787,_=P>.008856?P:(_-16/116)/7.787,[g*=95.047,m*=100,_*=108.883]},bn.lab.lch=function(i){var g,m=i[0],_=i[1],b=i[2];return(g=360*Math.atan2(b,_)/2/Math.PI)<0&&(g+=360),[m,Math.sqrt(_*_+b*b),g]},bn.lch.lab=function(i){var g,m=i[1];return g=i[2]/360*2*Math.PI,[i[0],m*Math.cos(g),m*Math.sin(g)]},bn.rgb.ansi16=function(i){var g=i[0],m=i[1],_=i[2],b=1 in arguments?arguments[1]:bn.rgb.hsv(i)[2];if(0===(b=Math.round(b/50)))return 30;var T=30+(Math.round(_/255)<<2|Math.round(m/255)<<1|Math.round(g/255));return 2===b&&(T+=60),T},bn.hsv.ansi16=function(i){return bn.rgb.ansi16(bn.hsv.rgb(i),i[2])},bn.rgb.ansi256=function(i){var g=i[0],m=i[1],_=i[2];return g===m&&m===_?g<8?16:g>248?231:Math.round((g-8)/247*24)+232:16+36*Math.round(g/255*5)+6*Math.round(m/255*5)+Math.round(_/255*5)},bn.ansi16.rgb=function(i){var g=i%10;if(0===g||7===g)return i>50&&(g+=3.5),[g=g/10.5*255,g,g];var m=.5*(1+~~(i>50));return[(1&g)*m*255,(g>>1&1)*m*255,(g>>2&1)*m*255]},bn.ansi256.rgb=function(i){if(i>=232){var g=10*(i-232)+8;return[g,g,g]}var m;return i-=16,[Math.floor(i/36)/5*255,Math.floor((m=i%36)/6)/5*255,m%6/5*255]},bn.rgb.hex=function(i){var g=(((255&Math.round(i[0]))<<16)+((255&Math.round(i[1]))<<8)+(255&Math.round(i[2]))).toString(16).toUpperCase();return"000000".substring(g.length)+g},bn.hex.rgb=function(i){var g=i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!g)return[0,0,0];var m=g[0];3===g[0].length&&(m=m.split("").map((function(i){return i+i})).join(""));var _=parseInt(m,16);return[_>>16&255,_>>8&255,255&_]},bn.rgb.hcg=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255,T=Math.max(Math.max(m,_),b),P=Math.min(Math.min(m,_),b),I=T-P;return g=I<=0?0:T===m?(_-b)/I%6:T===_?2+(b-m)/I:4+(m-_)/I+4,g/=6,[360*(g%=1),100*I,100*(I<1?P/(1-I):0)]},bn.hsl.hcg=function(i){var g=i[1]/100,m=i[2]/100,_=1,b=0;return(_=m<.5?2*g*m:2*g*(1-m))<1&&(b=(m-.5*_)/(1-_)),[i[0],100*_,100*b]},bn.hsv.hcg=function(i){var g=i[2]/100,m=i[1]/100*g,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},bn.hcg.rgb=function(i){var g=i[1]/100,m=i[2]/100;if(0===g)return[255*m,255*m,255*m];var _,b=[0,0,0],T=i[0]/360%1*6,P=T%1,I=1-P;switch(Math.floor(T)){case 0:b[0]=1,b[1]=P,b[2]=0;break;case 1:b[0]=I,b[1]=1,b[2]=0;break;case 2:b[0]=0,b[1]=1,b[2]=P;break;case 3:b[0]=0,b[1]=I,b[2]=1;break;case 4:b[0]=P,b[1]=0,b[2]=1;break;default:b[0]=1,b[1]=0,b[2]=I}return[255*(g*b[0]+(_=(1-g)*m)),255*(g*b[1]+_),255*(g*b[2]+_)]},bn.hcg.hsv=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g),_=0;return m>0&&(_=g/m),[i[0],100*_,100*m]},bn.hcg.hsl=function(i){var g=i[1]/100,m=i[2]/100*(1-g)+.5*g,_=0;return m>0&&m<.5?_=g/(2*m):m>=.5&&m<1&&(_=g/(2*(1-m))),[i[0],100*_,100*m]},bn.hcg.hwb=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g);return[i[0],100*(m-g),100*(1-m)]},bn.hwb.hcg=function(i){var g=1-i[2]/100,m=g-i[1]/100,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},bn.apple.rgb=function(i){return[i[0]/65535*255,i[1]/65535*255,i[2]/65535*255]},bn.rgb.apple=function(i){return[i[0]/255*65535,i[1]/255*65535,i[2]/255*65535]},bn.gray.rgb=function(i){return[i[0]/100*255,i[0]/100*255,i[0]/100*255]},bn.gray.hsl=bn.gray.hsv=function(i){return[0,0,i[0]]},bn.gray.hwb=function(i){return[0,100,i[0]]},bn.gray.cmyk=function(i){return[0,0,0,i[0]]},bn.gray.lab=function(i){return[i[0],0,0]},bn.gray.hex=function(i){var g=255&Math.round(i[0]/100*255),m=((g<<16)+(g<<8)+g).toString(16).toUpperCase();return"000000".substring(m.length)+m},bn.rgb.gray=function(i){return[(i[0]+i[1]+i[2])/3/255*100]};var Pn=An.exports,kn=Pn;function On(i){var g=function(){for(var i={},g=Object.keys(kn),m=g.length,_=0;_<m;_++)i[g[_]]={distance:-1,parent:null};return i}(),m=[i];for(g[i].distance=0;m.length;)for(var _=m.pop(),b=Object.keys(kn[_]),T=b.length,P=0;P<T;P++){var I=b[P],H=g[I];-1===H.distance&&(H.distance=g[_].distance+1,H.parent=_,m.unshift(I))}return g}function En(i,g){return function(m){return g(i(m))}}function Rn(i,g){for(var m=[g[i].parent,i],_=kn[g[i].parent][i],b=g[i].parent;g[b].parent;)m.unshift(g[b].parent),_=En(kn[g[b].parent][b],_),b=g[b].parent;return _.conversion=m,_}var Ln=Pn,Dn=function(i){for(var g=On(i),m={},_=Object.keys(g),b=_.length,T=0;T<b;T++){var P=_[T];null!==g[P].parent&&(m[P]=Rn(P,g))}return m},Fn={};Object.keys(Ln).forEach((function(i){Fn[i]={},Object.defineProperty(Fn[i],"channels",{value:Ln[i].channels}),Object.defineProperty(Fn[i],"labels",{value:Ln[i].labels});var g=Dn(i);Object.keys(g).forEach((function(m){var _=g[m];Fn[i][m]=function(i){var g=function(g){if(null==g)return g;arguments.length>1&&(g=Array.prototype.slice.call(arguments));var m=i(g);if("object"==typeof m)for(var _=m.length,b=0;b<_;b++)m[b]=Math.round(m[b]);return m};return"conversion"in i&&(g.conversion=i.conversion),g}(_),Fn[i][m].raw=function(i){var g=function(g){return null==g?g:(arguments.length>1&&(g=Array.prototype.slice.call(arguments)),i(g))};return"conversion"in i&&(g.conversion=i.conversion),g}(_)}))}));var Nn=mn,Hn=Fn,Bn=[].slice,Vn=["keyword","gray","hex"],Un={};Object.keys(Hn).forEach((function(i){Un[Bn.call(Hn[i].labels).sort().join("")]=i}));var Gn={};function jn(i,g){if(!(this instanceof jn))return new jn(i,g);if(g&&g in Vn&&(g=null),g&&!(g in Hn))throw new Error("Unknown model: "+g);var m,_;if(null==i)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(i instanceof jn)this.model=i.model,this.color=i.color.slice(),this.valpha=i.valpha;else if("string"==typeof i){var b=Nn.get(i);if(null===b)throw new Error("Unable to parse color from string: "+i);this.model=b.model,this.color=b.value.slice(0,_=Hn[this.model].channels),this.valpha="number"==typeof b.value[_]?b.value[_]:1}else if(i.length){this.model=g||"rgb";var T=Bn.call(i,0,_=Hn[this.model].channels);this.color=Zn(T,_),this.valpha="number"==typeof i[_]?i[_]:1}else if("number"==typeof i)i&=16777215,this.model="rgb",this.color=[i>>16&255,i>>8&255,255&i],this.valpha=1;else{this.valpha=1;var P=Object.keys(i);"alpha"in i&&(P.splice(P.indexOf("alpha"),1),this.valpha="number"==typeof i.alpha?i.alpha:0);var I=P.sort().join("");if(!(I in Un))throw new Error("Unable to parse color from object: "+JSON.stringify(i));this.model=Un[I];var H=Hn[this.model].labels,W=[];for(m=0;m<H.length;m++)W.push(i[H[m]]);this.color=Zn(W)}if(Gn[this.model])for(_=Hn[this.model].channels,m=0;m<_;m++){var q=Gn[this.model][m];q&&(this.color[m]=q(this.color[m]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}function Wn(i,g,m){return(i=Array.isArray(i)?i:[i]).forEach((function(i){(Gn[i]||(Gn[i]=[]))[g]=m})),i=i[0],function(_){var b;return arguments.length?(m&&(_=m(_)),(b=this[i]()).color[g]=_,b):(b=this[i]().color[g],m&&(b=m(b)),b)}}function qn(i){return function(g){return Math.max(0,Math.min(i,g))}}function Zn(i,g){for(var m=0;m<g;m++)"number"!=typeof i[m]&&(i[m]=0);return i}jn.prototype={toString:function(){return this.string()},toJSON:function(){return this[this.model]()},string:function(i){var g=this.model in Nn.to?this:this.rgb(),m=1===(g=g.round("number"==typeof i?i:1)).valpha?g.color:g.color.concat(this.valpha);return Nn.to[g.model](m)},percentString:function(i){var g=this.rgb().round("number"==typeof i?i:1),m=1===g.valpha?g.color:g.color.concat(this.valpha);return Nn.to.rgb.percent(m)},array:function(){return 1===this.valpha?this.color.slice():this.color.concat(this.valpha)},object:function(){for(var i={},g=Hn[this.model].channels,m=Hn[this.model].labels,_=0;_<g;_++)i[m[_]]=this.color[_];return 1!==this.valpha&&(i.alpha=this.valpha),i},unitArray:function(){var i=this.rgb().color;return i[0]/=255,i[1]/=255,i[2]/=255,1!==this.valpha&&i.push(this.valpha),i},unitObject:function(){var i=this.rgb().object();return i.r/=255,i.g/=255,i.b/=255,1!==this.valpha&&(i.alpha=this.valpha),i},round:function(i){return i=Math.max(i||0,0),new jn(this.color.map(function(i){return function(g){return function(i,g){return Number(i.toFixed(g))}(g,i)}}(i)).concat(this.valpha),this.model)},alpha:function(i){return arguments.length?new jn(this.color.concat(Math.max(0,Math.min(1,i))),this.model):this.valpha},red:Wn("rgb",0,qn(255)),green:Wn("rgb",1,qn(255)),blue:Wn("rgb",2,qn(255)),hue:Wn(["hsl","hsv","hsl","hwb","hcg"],0,(function(i){return(i%360+360)%360})),saturationl:Wn("hsl",1,qn(100)),lightness:Wn("hsl",2,qn(100)),saturationv:Wn("hsv",1,qn(100)),value:Wn("hsv",2,qn(100)),chroma:Wn("hcg",1,qn(100)),gray:Wn("hcg",2,qn(100)),white:Wn("hwb",1,qn(100)),wblack:Wn("hwb",2,qn(100)),cyan:Wn("cmyk",0,qn(100)),magenta:Wn("cmyk",1,qn(100)),yellow:Wn("cmyk",2,qn(100)),black:Wn("cmyk",3,qn(100)),x:Wn("xyz",0,qn(100)),y:Wn("xyz",1,qn(100)),z:Wn("xyz",2,qn(100)),l:Wn("lab",0,qn(100)),a:Wn("lab",1),b:Wn("lab",2),keyword:function(i){return arguments.length?new jn(i):Hn[this.model].keyword(this.color)},hex:function(i){return arguments.length?new jn(i):Nn.to.hex(this.rgb().round().color)},rgbNumber:function(){var i=this.rgb().color;return(255&i[0])<<16|(255&i[1])<<8|255&i[2]},luminosity:function(){for(var i=this.rgb().color,g=[],m=0;m<i.length;m++){var _=i[m]/255;g[m]=_<=.03928?_/12.92:Math.pow((_+.055)/1.055,2.4)}return.2126*g[0]+.7152*g[1]+.0722*g[2]},contrast:function(i){var g=this.luminosity(),m=i.luminosity();return g>m?(g+.05)/(m+.05):(m+.05)/(g+.05)},level:function(i){var g=this.contrast(i);return g>=7.1?"AAA":g>=4.5?"AA":""},isDark:function(){var i=this.rgb().color;return(299*i[0]+587*i[1]+114*i[2])/1e3<128},isLight:function(){return!this.isDark()},negate:function(){for(var i=this.rgb(),g=0;g<3;g++)i.color[g]=255-i.color[g];return i},lighten:function(i){var g=this.hsl();return g.color[2]+=g.color[2]*i,g},darken:function(i){var g=this.hsl();return g.color[2]-=g.color[2]*i,g},saturate:function(i){var g=this.hsl();return g.color[1]+=g.color[1]*i,g},desaturate:function(i){var g=this.hsl();return g.color[1]-=g.color[1]*i,g},whiten:function(i){var g=this.hwb();return g.color[1]+=g.color[1]*i,g},blacken:function(i){var g=this.hwb();return g.color[2]+=g.color[2]*i,g},grayscale:function(){var i=this.rgb().color,g=.3*i[0]+.59*i[1]+.11*i[2];return jn.rgb(g,g,g)},fade:function(i){return this.alpha(this.valpha-this.valpha*i)},opaquer:function(i){return this.alpha(this.valpha+this.valpha*i)},rotate:function(i){var g=this.hsl(),m=g.color[0];return g.color[0]=m=(m=(m+i)%360)<0?360+m:m,g},mix:function(i,g){if(!i||!i.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof i);var m=i.rgb(),_=this.rgb(),b=void 0===g?.5:g,T=2*b-1,P=m.alpha()-_.alpha(),I=((T*P===-1?T:(T+P)/(1+T*P))+1)/2,H=1-I;return jn.rgb(I*m.red()+H*_.red(),I*m.green()+H*_.green(),I*m.blue()+H*_.blue(),m.alpha()*b+_.alpha()*(1-b))}},Object.keys(Hn).forEach((function(i){if(-1===Vn.indexOf(i)){var g=Hn[i].channels;jn.prototype[i]=function(){if(this.model===i)return new jn(this);if(arguments.length)return new jn(arguments,i);var m,_="number"==typeof arguments[g]?g:this.valpha;return new jn((m=Hn[this.model][i].raw(this.color),Array.isArray(m)?m:[m]).concat(_),i)},jn[i]=function(m){return"number"==typeof m&&(m=Zn(Bn.call(arguments),g)),new jn(m,i)}}}));var $n=m(jn);function Yn(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}function Qn(i){return null==i}function Jn(i){return"number"==typeof i&&!isNaN(i)}function Kn(i){return"object"==typeof i&&!!i}function er(i){return!Qn(i)&&("string"==typeof i||null!==i.constructor&&i.constructor===String)}function tr(i){return!Qn(i)&&("function"==typeof i||null!==i.constructor&&i.constructor===Function)}const nr=Object.prototype.hasOwnProperty;function rr(i,g){return nr.call(i,g)}const ir=Math.PI/180;function or(i){return i&&Yt(i)&&i.property}function sr(i){const{verticalCentimeterToPoint:g,tileRatio:m}=i;return g*m}function lr(i){return"centimeter"===i||"cm"===i?1:"millimeter"===i||"mm"===i?.1:100}const hr={};function cr(i,g){if(!Array.isArray(g)){if(g&&void 0!==g.r&&void 0!==g.g&&void 0!==g.b)return i[0]=255*g.r,i[1]=255*g.g,i[2]=255*g.b,i[3]=void 0!==g.a?255*g.a:255,i;g=hr[g]=hr[g]||$n(g).unitArray()}for(let m=0;m<g.length;m++)i[m]=255*g[m];return 3===g.length&&(i[3]=255),i}const ur={textFill:1,textSize:1,textOpacity:1,textDx:1,textDy:1,markerWidth:1,markerHeight:1,markerOpacity:1,markerDx:1,markerDy:1,lineWidth:1,lineColor:1,lineOpacity:1,polygonFill:1,polygonOpacity:1,polygonPatternFileWidth:1,polygonPatternFileOrigin:1,rotationX:1,rotationY:1,rotationZ:1,scaleX:1,scaleY:1,scaleZ:1,translationX:1,translationY:1,translationZ:1};const fr={textName:1,markerTextFitPadding:1,markerTextFit:1,lineGradientProperty:1};var dr=Object.freeze({__proto__:null,checkIfIdentityZoomDependent:function(i,g,m){if(Array.isArray(m)||(m=Object.values(m)),!m||!m.length)return!1;if(!ur[i])return!1;for(let i=0;i<m.length;i++){const _=m[i]&&(m[i].feature||m[i]);if(!_)continue;const b=_.properties&&_.properties[g];if(b&&(Yt(b)&&!Qt(b).isZoomConstant))return!0}return!1},checkIfZoomFnTypeSymbol:function(i){return!!ur[i]||!!fr[i]},evaluate:function(i,g,m){return tr(i)?i(void 0!==m?m:null,g):i},extend:Yn,getAltitudeToLocal:sr,getTubeSizeScale:lr,hasOwn:rr,isFnTypeSymbol:or,isFunction:tr,isInteger:function(i){return(0|i)===i},isNil:Qn,isNumber:Jn,isObject:Kn,isString:er,join:function(i,g){return i.join?i.join(g||","):Array.prototype.join.call(i,g||",")},normalizeColor:cr,now:function(){return Date.now()},toDegree:function(i){return i/ir},toRadian:function(i){return i*ir}});class StyledVector{constructor(i,g,m,_){this.feature=i,this.symbol=g,this.fnTypes=m,this.options=_}getPolygonResource(){let i=this.symbol.polygonPatternFile;const{polygonPatternFileFn:g}=this.fnTypes;return this._getResource(i,g)}getLineResource(){let i=this.symbol.linePatternFile;const{linePatternFileFn:g}=this.fnTypes;return this._getResource(i,g)}_getResource(i,g){if(g){i=g(this.options.zoom,this.feature.properties)}return i}}function pr(i,g,m,_){const b=Math.abs(_)>>15,T=b>>1,P=b%2;let I=_%Math.pow(2,15);const H=g+(T<<14)*Math.sign(g),W=m+(P<<14)*Math.sign(m);return i[0]=H,i[1]=W,I=Math.round(I),i[2]=0===I?_<0?-1:0:I,i}const gr=Math.pow(2,14),mr=Math.pow(2,15);
/*!
  	    Feature Filter by

  	    (c) mapbox 2016 and maptalks 2018
  	    www.mapbox.com | www.maptalks.org
  	    License: MIT, header required.
  	*/
const Ar=["Unknown","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection"];function yr(i){if(!0===i||!1===i)return!0;if(!Array.isArray(i)||0===i.length)return!1;switch(i[0]){case"has":case"!has":return 2===i.length&&("string"==typeof i[1]||i[1].property&&i[1].op);case"in":case"!in":return i.length>=2&&("string"==typeof i[1]||i[1].property&&i[1].op);case"==":case"!=":case">":case">=":case"<":case"<=":return 3===i.length&&("string"==typeof i[1]||i[1].property&&i[1].op);case"none":case"any":case"all":for(const g of i.slice(1))if(!yr(g)&&"boolean"!=typeof g)return!1;return!0;case"contains":return!0;default:return!1}}function _r(i){if(!i)return"true";const g=i[0];if(i.length<=1)return"any"===g?"false":"true";const m="=="===g?xr(i[1],i[2],"===",!1):"!="===g?xr(i[1],i[2],"!==",!1):"<"===g||">"===g||"<="===g||">="===g?xr(i[1],i[2],g,!0):"any"===g?wr(i.slice(1),"||"):"all"===g?wr(i.slice(1),"&&"):"none"===g?Mr(wr(i.slice(1),"||")):"in"===g?Tr(i[1],i.slice(2)):"!in"===g?Mr(Tr(i[1],i.slice(2))):"has"===g?Sr(i[1]):"!has"===g?Mr(Sr(i[1])):"contains"===g?function(i,g,m){const _=vr(i);return void 0!==m?`(${_} + '').indexOf("${g}") === ${m}`:`(${_} + '').indexOf("${g}") >= 0`}(i[1],i[2],i[3]):"true";return`(${m})`}function vr(i){return"$"===i[0]?"f."+i.substring(1):"p["+JSON.stringify(i)+"]"}function xr(i,g,m,_){if("object"==typeof(b=i)&&b&&i.op)return function(i,g,m,_){const b=i.property,T=i.op;let P=vr(b);return"length"!==T?(console.error(`not support ${T} op`),"false"):(P=`((${P}+='').length)`,br(P,b,g,m,_))}(i,g,m,_);var b;return br(vr(i),i,g,m,_)}function br(i,g,m,_,b){const T="$type"===g?Ar.indexOf(m):JSON.stringify(m);return(b?`typeof ${i}=== typeof ${T}&&`:"")+i+_+T}function wr(i,g){return i.map(_r).join(g)}function Tr(i,g){"$type"===i&&(g=g.map((i=>Ar.indexOf(i))));const m=JSON.stringify(g.sort(Cr)),_=vr(i);return g.length<=200?`${m}.indexOf(${_}) !== -1`:`function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(${_}, ${m},0,${g.length-1})`}function Sr(i){return"$id"===i?'"id" in f':`${JSON.stringify(i)} in p`}function Mr(i){return`!(${i})`}function Cr(i,g){return i<g?-1:i>g?1:0}
/*!
  	 * a compact version of mapbox-gl-style-spec
  	 * based on mapbox-gl-style-spec@13.28.0
  	 * https://github.com/mapbox/mapbox-gl-js/tree/main/src/style-spec
  	 * LICENSE : ISC
  	 */var Pr="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},Ir={exports:{}};
/*! https://mths.be/punycode v1.3.2 by @mathias */
!function(i,g){!function(m){var _=g&&!g.nodeType&&g,b=i&&!i.nodeType&&i,T="object"==typeof Pr&&Pr;T.global!==T&&T.window!==T&&T.self!==T||(m=T);var P,I,H=2147483647,W=36,q=/^xn--/,$=/[^\x20-\x7E]/,ye=/[\x2E\u3002\uFF0E\uFF61]/g,Re={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},Be=Math.floor,Ge=String.fromCharCode;function je(i){throw RangeError(Re[i])}function Xe(i,g){for(var m=i.length,_=[];m--;)_[m]=g(i[m]);return _}function Ze(i,g){var m=i.split("@"),_="";return m.length>1&&(_=m[0]+"@",i=m[1]),_+Xe((i=i.replace(ye,".")).split("."),g).join(".")}function Ye(i){for(var g,m,_=[],b=0,T=i.length;b<T;)(g=i.charCodeAt(b++))>=55296&&g<=56319&&b<T?56320==(64512&(m=i.charCodeAt(b++)))?_.push(((1023&g)<<10)+(1023&m)+65536):(_.push(g),b--):_.push(g);return _}function Qe(i){return Xe(i,(function(i){var g="";return i>65535&&(g+=Ge((i-=65536)>>>10&1023|55296),i=56320|1023&i),g+=Ge(i)})).join("")}function Je(i,g){return i+22+75*(i<26)-((0!=g)<<5)}function Ke(i,g,m){var _=0;for(i=m?Be(i/700):i>>1,i+=Be(i/g);i>455;_+=W)i=Be(i/35);return Be(_+36*i/(i+38))}function et(i){var g,m,_,b,T,P,I,q,$,ye,Re,Ge=[],Xe=i.length,Ze=0,Ye=128,Je=72;for((m=i.lastIndexOf("-"))<0&&(m=0),_=0;_<m;++_)i.charCodeAt(_)>=128&&je("not-basic"),Ge.push(i.charCodeAt(_));for(b=m>0?m+1:0;b<Xe;){for(T=Ze,P=1,I=W;b>=Xe&&je("invalid-input"),((q=(Re=i.charCodeAt(b++))-48<10?Re-22:Re-65<26?Re-65:Re-97<26?Re-97:W)>=W||q>Be((H-Ze)/P))&&je("overflow"),Ze+=q*P,!(q<($=I<=Je?1:I>=Je+26?26:I-Je));I+=W)P>Be(H/(ye=W-$))&&je("overflow"),P*=ye;Je=Ke(Ze-T,g=Ge.length+1,0==T),Be(Ze/g)>H-Ye&&je("overflow"),Ye+=Be(Ze/g),Ze%=g,Ge.splice(Ze++,0,Ye)}return Qe(Ge)}function tt(i){var g,m,_,b,T,P,I,q,$,ye,Re,Xe,Ze,Qe,et,tt=[];for(Xe=(i=Ye(i)).length,g=128,m=0,T=72,P=0;P<Xe;++P)(Re=i[P])<128&&tt.push(Ge(Re));for(_=b=tt.length,b&&tt.push("-");_<Xe;){for(I=H,P=0;P<Xe;++P)(Re=i[P])>=g&&Re<I&&(I=Re);for(I-g>Be((H-m)/(Ze=_+1))&&je("overflow"),m+=(I-g)*Ze,g=I,P=0;P<Xe;++P)if((Re=i[P])<g&&++m>H&&je("overflow"),Re==g){for(q=m,$=W;!(q<(ye=$<=T?1:$>=T+26?26:$-T));$+=W)tt.push(Ge(Je(ye+(et=q-ye)%(Qe=W-ye),0))),q=Be(et/Qe);tt.push(Ge(Je(q,0))),T=Ke(m,Ze,_==b),m=0,++_}++m,++g}return tt.join("")}if(P={version:"1.3.2",ucs2:{decode:Ye,encode:Qe},decode:et,encode:tt,toASCII:function(i){return Ze(i,(function(i){return $.test(i)?"xn--"+tt(i):i}))},toUnicode:function(i){return Ze(i,(function(i){return q.test(i)?et(i.slice(4).toLowerCase()):i}))}},_&&b)if(i.exports==_)b.exports=P;else for(I in P)P.hasOwnProperty(I)&&(_[I]=P[I]);else m.punycode=P}(Pr)}(Ir,Ir.exports);class ParsingError$1 extends Error{constructor(i,g){super(g),this.message=g,this.key=i}}var kr=ParsingError$1;class Scope{constructor(i,g=[]){this.parent=i,this.bindings={};for(const[i,m]of g)this.bindings[i]=m}concat(i){return new Scope(this,i)}get(i){if(this.bindings[i])return this.bindings[i];if(this.parent)return this.parent.get(i);throw new Error(`${i} not found in scope.`)}has(i){return!!this.bindings[i]||!!this.parent&&this.parent.has(i)}}var Or=Scope;const Er={kind:"null"},Rr={kind:"number"},Lr={kind:"string"},Dr={kind:"boolean"},Fr={kind:"color"},Nr={kind:"object"},Hr={kind:"value"},Br={kind:"collator"},zr={kind:"formatted"},Vr={kind:"resolvedImage"};function Ur(i,g){return{kind:"array",itemType:i,N:g}}function Gr(i){if("array"===i.kind){const g=Gr(i.itemType);return"number"==typeof i.N?`array<${g}, ${i.N}>`:"value"===i.itemType.kind?"array":`array<${g}>`}return i.kind}const jr=[Er,Rr,Lr,Dr,Fr,zr,Nr,Ur(Hr),Vr];function Wr(i,g){if("error"===g.kind)return null;if("array"===i.kind){if("array"===g.kind&&(0===g.N&&"value"===g.itemType.kind||!Wr(i.itemType,g.itemType))&&("number"!=typeof i.N||i.N===g.N))return null}else{if(i.kind===g.kind)return null;if("value"===i.kind)for(const i of jr)if(!Wr(i,g))return null}return`Expected ${Gr(i)} but found ${Gr(g)} instead.`}function qr(i,g){return g.some((g=>g.kind===i.kind))}function Xr(i,g){return g.some((g=>"null"===g?null===i:"array"===g?Array.isArray(i):"object"===g?i&&!Array.isArray(i)&&"object"==typeof i:g===typeof i))}var Zr,$r={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};function Yr(i){return(i=Math.round(i))<0?0:i>255?255:i}function Qr(i){return i<0?0:i>1?1:i}function Jr(i){return Yr("%"===i[i.length-1]?parseFloat(i)/100*255:parseInt(i))}function Kr(i){return Qr("%"===i[i.length-1]?parseFloat(i)/100:parseFloat(i))}function ei(i,g,m){return m<0?m+=1:m>1&&(m-=1),6*m<1?i+(g-i)*m*6:2*m<1?g:3*m<2?i+(g-i)*(2/3-m)*6:i}try{Zr={}.parseCSSColor=function(i){var g,m=i.replace(/ /g,"").toLowerCase();if(m in $r)return $r[m].slice();if("#"===m[0])return 4===m.length?(g=parseInt(m.substr(1),16))>=0&&g<=4095?[(3840&g)>>4|(3840&g)>>8,240&g|(240&g)>>4,15&g|(15&g)<<4,1]:null:7===m.length&&(g=parseInt(m.substr(1),16))>=0&&g<=16777215?[(16711680&g)>>16,(65280&g)>>8,255&g,1]:null;var _=m.indexOf("("),b=m.indexOf(")");if(-1!==_&&b+1===m.length){var T=m.substr(0,_),P=m.substr(_+1,b-(_+1)).split(","),I=1;switch(T){case"rgba":if(4!==P.length)return null;I=Kr(P.pop());case"rgb":return 3!==P.length?null:[Jr(P[0]),Jr(P[1]),Jr(P[2]),I];case"hsla":if(4!==P.length)return null;I=Kr(P.pop());case"hsl":if(3!==P.length)return null;var H=(parseFloat(P[0])%360+360)%360/360,W=Kr(P[1]),q=Kr(P[2]),$=q<=.5?q*(W+1):q+W-q*W,ye=2*q-$;return[Yr(255*ei(ye,$,H+1/3)),Yr(255*ei(ye,$,H)),Yr(255*ei(ye,$,H-1/3)),I];default:return null}}return null}}catch(i){}class Color{constructor(i,g,m,_=1){this.r=i,this.g=g,this.b=m,this.a=_}static parse(i){if(!i)return;if(i instanceof Color)return i;if("string"!=typeof i)return;const g=Zr(i);return g?new Color(g[0]/255*g[3],g[1]/255*g[3],g[2]/255*g[3],g[3]):void 0}toString(){const[i,g,m,_]=this.toArray();return`rgba(${Math.round(i)},${Math.round(g)},${Math.round(m)},${_})`}toArray(){const{r:i,g,b:m,a:_}=this;return 0===_?[0,0,0,0]:[255*i/_,255*g/_,255*m/_,_]}toArray01(){const{r:i,g,b:m,a:_}=this;return 0===_?[0,0,0,0]:[i/_,g/_,m/_,_]}toArray01PremultipliedAlpha(){const{r:i,g,b:m,a:_}=this;return[i,g,m,_]}}Color.black=new Color(0,0,0,1),Color.white=new Color(1,1,1,1),Color.transparent=new Color(0,0,0,0),Color.red=new Color(1,0,0,1),Color.blue=new Color(0,0,1,1);var ti=Color;class Collator{constructor(i,g,m){this.sensitivity=i?g?"variant":"case":g?"accent":"base",this.locale=m,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(i,g){return this.collator.compare(i,g)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}}class FormattedSection{constructor(i,g,m,_,b){this.text=i.normalize?i.normalize():i,this.image=g,this.scale=m,this.fontStack=_,this.textColor=b}}class Formatted{constructor(i){this.sections=i}static fromString(i){return new Formatted([new FormattedSection(i,null,null,null,null)])}isEmpty(){return 0===this.sections.length||!this.sections.some((i=>0!==i.text.length||i.image&&0!==i.image.name.length))}static factory(i){return i instanceof Formatted?i:Formatted.fromString(i)}toString(){return 0===this.sections.length?"":this.sections.map((i=>i.text)).join("")}serialize(){const i=["format"];for(const g of this.sections){if(g.image){i.push(["image",g.image.name]);continue}i.push(g.text);const m={};g.fontStack&&(m["text-font"]=["literal",g.fontStack.split(",")]),g.scale&&(m["font-scale"]=g.scale),g.textColor&&(m["text-color"]=["rgba"].concat(g.textColor.toArray())),i.push(m)}return i}}class ResolvedImage{constructor(i){this.name=i.name,this.available=i.available}toString(){return this.name}static fromString(i){return i?new ResolvedImage({name:i,available:!1}):null}serialize(){return["image",this.name]}}function ni(i,g,m,_){if(!("number"==typeof i&&i>=0&&i<=255&&"number"==typeof g&&g>=0&&g<=255&&"number"==typeof m&&m>=0&&m<=255)){return`Invalid rgba value [${("number"==typeof _?[i,g,m,_]:[i,g,m]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`}return void 0===_||"number"==typeof _&&_>=0&&_<=1?null:`Invalid rgba value [${[i,g,m,_].join(", ")}]: 'a' must be between 0 and 1.`}function ri(i){if(null===i)return!0;if("string"==typeof i)return!0;if("boolean"==typeof i)return!0;if("number"==typeof i)return!0;if(i instanceof ti)return!0;if(i instanceof Collator)return!0;if(i instanceof Formatted)return!0;if(i instanceof ResolvedImage)return!0;if(Array.isArray(i)){for(const g of i)if(!ri(g))return!1;return!0}if("object"==typeof i){for(const g in i)if(!ri(i[g]))return!1;return!0}return!1}function ii(i){if(null===i)return Er;if("string"==typeof i)return Lr;if("boolean"==typeof i)return Dr;if("number"==typeof i)return Rr;if(i instanceof ti)return Fr;if(i instanceof Collator)return Br;if(i instanceof Formatted)return zr;if(i instanceof ResolvedImage)return Vr;if(Array.isArray(i)){const g=i.length;let m;for(const g of i){const i=ii(g);if(m){if(m===i)continue;m=Hr;break}m=i}return Ur(m||Hr,g)}return Nr}function oi(i){const g=typeof i;return null===i?"":"string"===g||"number"===g||"boolean"===g?String(i):i instanceof ti||i instanceof Formatted||i instanceof ResolvedImage?i.toString():JSON.stringify(i)}class Literal{constructor(i,g){this.type=i,this.value=g}static parse(i,g){if(2!==i.length)return g.error(`'literal' expression requires exactly one argument, but found ${i.length-1} instead.`);if(!ri(i[1]))return g.error("invalid value");const m=i[1];let _=ii(m);const b=g.expectedType;return"array"!==_.kind||0!==_.N||!b||"array"!==b.kind||"number"==typeof b.N&&0!==b.N||(_=b),new Literal(_,m)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}serialize(){return"array"===this.type.kind||"object"===this.type.kind?["literal",this.value]:this.value instanceof ti?["rgba"].concat(this.value.toArray()):this.value instanceof Formatted?this.value.serialize():this.value}}var si=Literal;var ai=class RuntimeError{constructor(i){this.name="ExpressionEvaluationError",this.message=i}toJSON(){return this.message}};const li={string:Lr,number:Rr,boolean:Dr,object:Nr};class Assertion{constructor(i,g){this.type=i,this.args=g}static parse(i,g){if(i.length<2)return g.error("Expected at least one argument.");let m,_=1;const b=i[0];if("array"===b){let b,T;if(i.length>2){const m=i[1];if("string"!=typeof m||!(m in li)||"object"===m)return g.error('The item type argument of "array" must be one of string, number, boolean',1);b=li[m],_++}else b=Hr;if(i.length>3){if(null!==i[2]&&("number"!=typeof i[2]||i[2]<0||i[2]!==Math.floor(i[2])))return g.error('The length argument to "array" must be a positive integer literal',2);T=i[2],_++}m=Ur(b,T)}else m=li[b];const T=[];for(;_<i.length;_++){const m=g.parse(i[_],_,Hr);if(!m)return null;T.push(m)}return new Assertion(m,T)}evaluate(i){for(let g=0;g<this.args.length;g++){const m=this.args[g].evaluate(i);if(!Wr(this.type,ii(m)))return m;if(g===this.args.length-1)throw new ai(`Expected value to be of type ${Gr(this.type)}, but found ${Gr(ii(m))} instead.`)}return null}eachChild(i){this.args.forEach(i)}outputDefined(){return this.args.every((i=>i.outputDefined()))}serialize(){const i=this.type,g=[i.kind];if("array"===i.kind){const m=i.itemType;if("string"===m.kind||"number"===m.kind||"boolean"===m.kind){g.push(m.kind);const _=i.N;("number"==typeof _||this.args.length>1)&&g.push(_)}}return g.concat(this.args.map((i=>i.serialize())))}}var hi=Assertion;class FormatExpression{constructor(i){this.type=zr,this.sections=i}static parse(i,g){if(i.length<2)return g.error("Expected at least one argument.");const m=i[1];if(!Array.isArray(m)&&"object"==typeof m)return g.error("First argument must be an image or text section.");const _=[];let b=!1;for(let m=1;m<=i.length-1;++m){const T=i[m];if(b&&"object"==typeof T&&!Array.isArray(T)){b=!1;let i=null;if(T["font-scale"]&&(i=g.parse(T["font-scale"],1,Rr),!i))return null;let m=null;if(T["text-font"]&&(m=g.parse(T["text-font"],1,Ur(Lr)),!m))return null;let P=null;if(T["text-color"]&&(P=g.parse(T["text-color"],1,Fr),!P))return null;const I=_[_.length-1];I.scale=i,I.font=m,I.textColor=P}else{const T=g.parse(i[m],1,Hr);if(!T)return null;const P=T.type.kind;if("string"!==P&&"value"!==P&&"null"!==P&&"resolvedImage"!==P)return g.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");b=!0,_.push({content:T,scale:null,font:null,textColor:null})}}return new FormatExpression(_)}evaluate(i){return new Formatted(this.sections.map((g=>{const m=g.content.evaluate(i);return ii(m)===Vr?new FormattedSection("",m,null,null,null):new FormattedSection(oi(m),null,g.scale?g.scale.evaluate(i):null,g.font?g.font.evaluate(i).join(","):null,g.textColor?g.textColor.evaluate(i):null)})))}eachChild(i){for(const g of this.sections)i(g.content),g.scale&&i(g.scale),g.font&&i(g.font),g.textColor&&i(g.textColor)}outputDefined(){return!1}serialize(){const i=["format"];for(const g of this.sections){i.push(g.content.serialize());const m={};g.scale&&(m["font-scale"]=g.scale.serialize()),g.font&&(m["text-font"]=g.font.serialize()),g.textColor&&(m["text-color"]=g.textColor.serialize()),i.push(m)}return i}}class ImageExpression{constructor(i){this.type=Vr,this.input=i}static parse(i,g){if(2!==i.length)return g.error("Expected two arguments.");const m=g.parse(i[1],1,Lr);return m?new ImageExpression(m):g.error("No image name provided.")}evaluate(i){const g=this.input.evaluate(i),m=ResolvedImage.fromString(g);return m&&i.availableImages&&(m.available=i.availableImages.indexOf(g)>-1),m}eachChild(i){i(this.input)}outputDefined(){return!1}serialize(){return["image",this.input.serialize()]}}const ci={"to-boolean":Dr,"to-color":Fr,"to-number":Rr,"to-string":Lr};class Coercion{constructor(i,g){this.type=i,this.args=g}static parse(i,g){if(i.length<2)return g.error("Expected at least one argument.");const m=i[0];if(("to-boolean"===m||"to-string"===m)&&2!==i.length)return g.error("Expected one argument.");const _=ci[m],b=[];for(let m=1;m<i.length;m++){const _=g.parse(i[m],m,Hr);if(!_)return null;b.push(_)}return new Coercion(_,b)}evaluate(i){if("boolean"===this.type.kind)return Boolean(this.args[0].evaluate(i));if("color"===this.type.kind){let g,m;for(const _ of this.args){if(g=_.evaluate(i),m=null,g instanceof ti)return g;if("string"==typeof g){const m=i.parseColor(g);if(m)return m}else if(Array.isArray(g)&&(m=g.length<3||g.length>4?`Invalid rbga value ${JSON.stringify(g)}: expected an array containing either three or four numeric values.`:ni(g[0],g[1],g[2],g[3]),!m))return new ti(g[0]/255,g[1]/255,g[2]/255,g[3])}throw new ai(m||`Could not parse color from value '${"string"==typeof g?g:String(JSON.stringify(g))}'`)}if("number"===this.type.kind){let g=null;for(const m of this.args){if(g=m.evaluate(i),null===g)return 0;const _=Number(g);if(!isNaN(_))return _}throw new ai(`Could not convert ${JSON.stringify(g)} to number.`)}return"formatted"===this.type.kind?Formatted.fromString(oi(this.args[0].evaluate(i))):"resolvedImage"===this.type.kind?ResolvedImage.fromString(oi(this.args[0].evaluate(i))):oi(this.args[0].evaluate(i))}eachChild(i){this.args.forEach(i)}outputDefined(){return this.args.every((i=>i.outputDefined()))}serialize(){if("formatted"===this.type.kind)return new FormatExpression([{content:this.args[0],scale:null,font:null,textColor:null}]).serialize();if("resolvedImage"===this.type.kind)return new ImageExpression(this.args[0]).serialize();const i=[`to-${this.type.kind}`];return this.eachChild((g=>{i.push(g.serialize())})),i}}var ui=Coercion;const fi=["Unknown","Point","LineString","Polygon"];var di=class EvaluationContext{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null,this.featureTileCoord=null,this.featureDistanceData=null}id(){return this.feature&&void 0!==this.feature.id?this.feature.id:null}geometryType(){return this.feature?"number"==typeof this.feature.type?fi[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}distanceFromCenter(){if(this.featureTileCoord&&this.featureDistanceData){const i=this.featureDistanceData.center,g=this.featureDistanceData.scale,{x:m,y:_}=this.featureTileCoord;return this.featureDistanceData.bearing[0]*(m*g-i[0])+this.featureDistanceData.bearing[1]*(_*g-i[1])}return 0}parseColor(i){let g=this._parseColorCache[i];return g||(g=this._parseColorCache[i]=ti.parse(i)),g}};class CompoundExpression{constructor(i,g,m,_){this.name=i,this.type=g,this._evaluate=m,this.args=_}evaluate(i){return this._evaluate(i,this.args)}eachChild(i){this.args.forEach(i)}outputDefined(){return!1}serialize(){return[this.name].concat(this.args.map((i=>i.serialize())))}static parse(i,g){const m=i[0],_=CompoundExpression.definitions[m];if(!_)return g.error(`Unknown expression "${m}". If you wanted a literal array, use ["literal", [...]].`,0);const b=Array.isArray(_)?_[0]:_.type,T=Array.isArray(_)?[[_[1],_[2]]]:_.overloads,P=T.filter((([g])=>!Array.isArray(g)||g.length===i.length-1));let I=null;for(const[_,T]of P){I=new Ni(g.registry,g.path,null,g.scope);const P=[];let H=!1;for(let g=1;g<i.length;g++){const m=i[g],b=Array.isArray(_)?_[g-1]:_.type,T=I.parse(m,1+P.length,b);if(!T){H=!0;break}P.push(T)}if(!H)if(Array.isArray(_)&&_.length!==P.length)I.error(`Expected ${_.length} arguments, but found ${P.length} instead.`);else{for(let i=0;i<P.length;i++){const g=Array.isArray(_)?_[i]:_.type,m=P[i];I.concat(i+1).checkSubtype(g,m.type)}if(0===I.errors.length)return new CompoundExpression(m,b,T,P)}}if(1===P.length)g.errors.push(...I.errors);else{const m=(P.length?P:T).map((([i])=>{return g=i,Array.isArray(g)?`(${g.map(Gr).join(", ")})`:`(${Gr(g.type)}...)`;var g})).join(" | "),_=[];for(let m=1;m<i.length;m++){const b=g.parse(i[m],1+_.length);if(!b)return null;_.push(Gr(b.type))}g.error(`Expected arguments of type ${m}, but found (${_.join(", ")}) instead.`)}return null}static register(i,g){CompoundExpression.definitions=g;for(const m in g)i[m]=CompoundExpression}}var pi=CompoundExpression;class CollatorExpression{constructor(i,g,m){this.type=Br,this.locale=m,this.caseSensitive=i,this.diacriticSensitive=g}static parse(i,g){if(2!==i.length)return g.error("Expected one argument.");const m=i[1];if("object"!=typeof m||Array.isArray(m))return g.error("Collator options argument must be an object.");const _=g.parse(void 0!==m["case-sensitive"]&&m["case-sensitive"],1,Dr);if(!_)return null;const b=g.parse(void 0!==m["diacritic-sensitive"]&&m["diacritic-sensitive"],1,Dr);if(!b)return null;let T=null;return m.locale&&(T=g.parse(m.locale,1,Lr),!T)?null:new CollatorExpression(_,b,T)}evaluate(i){return new Collator(this.caseSensitive.evaluate(i),this.diacriticSensitive.evaluate(i),this.locale?this.locale.evaluate(i):null)}eachChild(i){i(this.caseSensitive),i(this.diacriticSensitive),this.locale&&i(this.locale)}outputDefined(){return!1}serialize(){const i={};return i["case-sensitive"]=this.caseSensitive.serialize(),i["diacritic-sensitive"]=this.diacriticSensitive.serialize(),this.locale&&(i.locale=this.locale.serialize()),["collator",i]}}const gi=8192;function mi(i,g){i[0]=Math.min(i[0],g[0]),i[1]=Math.min(i[1],g[1]),i[2]=Math.max(i[2],g[0]),i[3]=Math.max(i[3],g[1])}function Ai(i,g){return!(i[0]<=g[0])&&(!(i[2]>=g[2])&&(!(i[1]<=g[1])&&!(i[3]>=g[3])))}function yi(i,g){const m=(180+i[0])/360;const _=(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+i[1]*Math.PI/360)))/360;const b=Math.pow(2,g.z);return[Math.round(m*b*gi),Math.round(_*b*gi)]}function _i(i,g,m){const _=i[0]-g[0],b=i[1]-g[1],T=i[0]-m[0],P=i[1]-m[1];return _*P-T*b===0&&_*T<=0&&b*P<=0}function vi(i,g,m){return g[1]>i[1]!=m[1]>i[1]&&i[0]<(m[0]-g[0])*(i[1]-g[1])/(m[1]-g[1])+g[0]}function xi(i,g){let m=!1;for(let _=0,b=g.length;_<b;_++){const b=g[_];for(let g=0,_=b.length;g<_-1;g++){if(_i(i,b[g],b[g+1]))return!1;vi(i,b[g],b[g+1])&&(m=!m)}}return m}function bi(i,g){for(let m=0;m<g.length;m++)if(xi(i,g[m]))return!0;return!1}function wi(i,g,m,_){const b=_[0]-m[0],T=_[1]-m[1],P=(i[0]-m[0])*T-b*(i[1]-m[1]),I=(g[0]-m[0])*T-b*(g[1]-m[1]);return P>0&&I<0||P<0&&I>0}function Ti(i,g,m,_){return 0!==function(i,g){return i[0]*g[1]-i[1]*g[0]}([_[0]-m[0],_[1]-m[1]],[g[0]-i[0],g[1]-i[1]])&&!(!wi(i,g,m,_)||!wi(m,_,i,g))}function Si(i,g,m){for(const _ of m)for(let m=0;m<_.length-1;++m)if(Ti(i,g,_[m],_[m+1]))return!0;return!1}function Mi(i,g){for(let m=0;m<i.length;++m)if(!xi(i[m],g))return!1;for(let m=0;m<i.length-1;++m)if(Si(i[m],i[m+1],g))return!1;return!0}function Ci(i,g){for(let m=0;m<g.length;m++)if(Mi(i,g[m]))return!0;return!1}function Pi(i,g,m){const _=[];for(let b=0;b<i.length;b++){const T=[];for(let _=0;_<i[b].length;_++){const P=yi(i[b][_],m);mi(g,P),T.push(P)}_.push(T)}return _}function Ii(i,g,m){const _=[];for(let b=0;b<i.length;b++){const T=Pi(i[b],g,m);_.push(T)}return _}function ki(i,g,m,_){if(i[0]<m[0]||i[0]>m[2]){const g=.5*_;let b=i[0]-m[0]>g?-_:m[0]-i[0]>g?_:0;0===b&&(b=i[0]-m[2]>g?-_:m[2]-i[0]>g?_:0),i[0]+=b}mi(g,i)}function Oi(i,g,m,_){const b=Math.pow(2,_.z)*gi,T=[_.x*gi,_.y*gi],P=[];if(!i)return P;for(const _ of i)for(const i of _){const _=[i.x+T[0],i.y+T[1]];ki(_,g,m,b),P.push(_)}return P}function Ei(i,g,m,_){const b=Math.pow(2,_.z)*gi,T=[_.x*gi,_.y*gi],P=[];if(!i)return P;for(const m of i){const i=[];for(const _ of m){const m=[_.x+T[0],_.y+T[1]];mi(g,m),i.push(m)}P.push(i)}if(g[2]-g[0]<=b/2){!function(i){i[0]=i[1]=1/0,i[2]=i[3]=-1/0}(g);for(const i of P)for(const _ of i)ki(_,g,m,b)}return P}class Within{constructor(i,g){this.type=Dr,this.geojson=i,this.geometries=g}static parse(i,g){if(2!==i.length)return g.error(`'within' expression requires exactly one argument, but found ${i.length-1} instead.`);if(ri(i[1])){const g=i[1];if("FeatureCollection"===g.type)for(let i=0;i<g.features.length;++i){const m=g.features[i].geometry.type;if("Polygon"===m||"MultiPolygon"===m)return new Within(g,g.features[i].geometry)}else if("Feature"===g.type){const i=g.geometry.type;if("Polygon"===i||"MultiPolygon"===i)return new Within(g,g.geometry)}else if("Polygon"===g.type||"MultiPolygon"===g.type)return new Within(g,g)}return g.error("'within' expression requires valid geojson object that contains polygon geometry type.")}evaluate(i){if(null!=i.geometry()&&null!=i.canonicalID()){if("Point"===i.geometryType())return function(i,g){const m=[1/0,1/0,-1/0,-1/0],_=[1/0,1/0,-1/0,-1/0],b=i.canonicalID();if(!b)return!1;if("Polygon"===g.type){const T=Pi(g.coordinates,_,b),P=Oi(i.geometry(),m,_,b);if(!Ai(m,_))return!1;for(const i of P)if(!xi(i,T))return!1}if("MultiPolygon"===g.type){const T=Ii(g.coordinates,_,b),P=Oi(i.geometry(),m,_,b);if(!Ai(m,_))return!1;for(const i of P)if(!bi(i,T))return!1}return!0}(i,this.geometries);if("LineString"===i.geometryType())return function(i,g){const m=[1/0,1/0,-1/0,-1/0],_=[1/0,1/0,-1/0,-1/0],b=i.canonicalID();if(!b)return!1;if("Polygon"===g.type){const T=Pi(g.coordinates,_,b),P=Ei(i.geometry(),m,_,b);if(!Ai(m,_))return!1;for(const i of P)if(!Mi(i,T))return!1}if("MultiPolygon"===g.type){const T=Ii(g.coordinates,_,b),P=Ei(i.geometry(),m,_,b);if(!Ai(m,_))return!1;for(const i of P)if(!Ci(i,T))return!1}return!0}(i,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}serialize(){return["within",this.geojson]}}var Ri=Within;function Li(i){if(i instanceof pi){if("get"===i.name&&1===i.args.length)return!1;if("feature-state"===i.name)return!1;if("has"===i.name&&1===i.args.length)return!1;if("properties"===i.name||"geometry-type"===i.name||"id"===i.name)return!1;if(/^filter-/.test(i.name))return!1}if(i instanceof Ri)return!1;let g=!0;return i.eachChild((i=>{g&&!Li(i)&&(g=!1)})),g}function Di(i,g){if(i instanceof pi&&g.indexOf(i.name)>=0)return!1;let m=!0;return i.eachChild((i=>{m&&!Di(i,g)&&(m=!1)})),m}class Var{constructor(i,g){this.type=g.type,this.name=i,this.boundExpression=g}static parse(i,g){if(2!==i.length||"string"!=typeof i[1])return g.error("'var' expression requires exactly one string literal argument.");const m=i[1];return g.scope.has(m)?new Var(m,g.scope.get(m)):g.error(`Unknown variable "${m}". Make sure "${m}" has been bound in an enclosing "let" expression before using it.`,1)}evaluate(i){return this.boundExpression.evaluate(i)}eachChild(){}outputDefined(){return!1}serialize(){return["var",this.name]}}var Fi=Var;class ParsingContext{constructor(i,g=[],m,_=new Or,b=[]){this.registry=i,this.path=g,this.key=g.map((i=>`[${i}]`)).join(""),this.scope=_,this.errors=b,this.expectedType=m}parse(i,g,m,_,b={}){return g?this.concat(g,m,_)._parse(i,b):this._parse(i,b)}_parse(i,g){function m(i,g,m){return"assert"===m?new hi(g,[i]):"coerce"===m?new ui(g,[i]):i}if(null!==i&&"string"!=typeof i&&"boolean"!=typeof i&&"number"!=typeof i||(i=["literal",i]),Array.isArray(i)){if(0===i.length)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');const _=i[0];if("string"!=typeof _)return this.error(`Expression name must be a string, but found ${typeof _} instead. If you wanted a literal array, use ["literal", [...]].`,0),null;const b=this.registry[_];if(b){let _=b.parse(i,this);if(!_)return null;if(this.expectedType){const i=this.expectedType,b=_.type;if("string"!==i.kind&&"number"!==i.kind&&"boolean"!==i.kind&&"object"!==i.kind&&"array"!==i.kind||"value"!==b.kind)if("color"!==i.kind&&"formatted"!==i.kind&&"resolvedImage"!==i.kind||"value"!==b.kind&&"string"!==b.kind){if(this.checkSubtype(i,b))return null}else _=m(_,i,g.typeAnnotation||"coerce");else _=m(_,i,g.typeAnnotation||"assert")}if(!(_ instanceof si)&&"resolvedImage"!==_.type.kind&&Hi(_)){const i=new di;try{_=new si(_.type,_.evaluate(i))}catch(i){return this.error(i.message),null}}return _}return this.error(`Unknown expression "${_}". If you wanted a literal array, use ["literal", [...]].`,0)}return this.error(void 0===i?"'undefined' value invalid. Use null instead.":"object"==typeof i?'Bare objects invalid. Use ["literal", {...}] instead.':`Expected an array, but found ${typeof i} instead.`)}concat(i,g,m){const _="number"==typeof i?this.path.concat(i):this.path,b=m?this.scope.concat(m):this.scope;return new ParsingContext(this.registry,_,g||null,b,this.errors)}error(i,...g){const m=`${this.key}${g.map((i=>`[${i}]`)).join("")}`;this.errors.push(new kr(m,i))}checkSubtype(i,g){const m=Wr(i,g);return m&&this.error(m),m}}var Ni=ParsingContext;function Hi(i){if(i instanceof Fi)return Hi(i.boundExpression);if(i instanceof pi&&"error"===i.name)return!1;if(i instanceof CollatorExpression)return!1;if(i instanceof Ri)return!1;const g=i instanceof ui||i instanceof hi;let m=!0;return i.eachChild((i=>{m=g?m&&Hi(i):m&&i instanceof si})),!!m&&(Li(i)&&Di(i,["zoom","heatmap-density","line-progress","sky-radial-progress","accumulated","is-supported-script","pitch","distance-from-center"]))}function Bi(i,g){const m=i.length-1;let _,b,T=0,P=m,I=0;for(;T<=P;)if(I=Math.floor((T+P)/2),_=i[I],b=i[I+1],_<=g){if(I===m||g<b)return I;T=I+1}else{if(!(_>g))throw new ai("Input is not a number.");P=I-1}return 0}class Step{constructor(i,g,m){this.type=i,this.input=g,this.labels=[],this.outputs=[];for(const[i,g]of m)this.labels.push(i),this.outputs.push(g)}static parse(i,g){if(i.length-1<4)return g.error(`Expected at least 4 arguments, but found only ${i.length-1}.`);if((i.length-1)%2!=0)return g.error("Expected an even number of arguments.");const m=g.parse(i[1],1,Rr);if(!m)return null;const _=[];let b=null;g.expectedType&&"value"!==g.expectedType.kind&&(b=g.expectedType);for(let m=1;m<i.length;m+=2){const T=1===m?-1/0:i[m],P=i[m+1],I=m,H=m+1;if("number"!=typeof T)return g.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',I);if(_.length&&_[_.length-1][0]>=T)return g.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',I);const W=g.parse(P,H,b);if(!W)return null;b=b||W.type,_.push([T,W])}return new Step(b,m,_)}evaluate(i){const g=this.labels,m=this.outputs;if(1===g.length)return m[0].evaluate(i);const _=this.input.evaluate(i);if(_<=g[0])return m[0].evaluate(i);const b=g.length;if(_>=g[b-1])return m[b-1].evaluate(i);return m[Bi(g,_)].evaluate(i)}eachChild(i){i(this.input);for(const g of this.outputs)i(g)}outputDefined(){return this.outputs.every((i=>i.outputDefined()))}serialize(){const i=["step",this.input.serialize()];for(let g=0;g<this.labels.length;g++)g>0&&i.push(this.labels[g]),i.push(this.outputs[g].serialize());return i}}var zi=Step,Vi=Ui;function Ui(i,g,m,_){this.cx=3*i,this.bx=3*(m-i)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*g,this.by=3*(_-g)-this.cy,this.ay=1-this.cy-this.by,this.p1x=i,this.p1y=g,this.p2x=m,this.p2y=_}function Gi(i,g,m){return i*(1-m)+g*m}Ui.prototype={sampleCurveX:function(i){return((this.ax*i+this.bx)*i+this.cx)*i},sampleCurveY:function(i){return((this.ay*i+this.by)*i+this.cy)*i},sampleCurveDerivativeX:function(i){return(3*this.ax*i+2*this.bx)*i+this.cx},solveCurveX:function(i,g){if(void 0===g&&(g=1e-6),i<0)return 0;if(i>1)return 1;for(var m=i,_=0;_<8;_++){var b=this.sampleCurveX(m)-i;if(Math.abs(b)<g)return m;var T=this.sampleCurveDerivativeX(m);if(Math.abs(T)<1e-6)break;m-=b/T}var P=0,I=1;for(m=i,_=0;_<20&&(b=this.sampleCurveX(m),!(Math.abs(b-i)<g));_++)i>b?P=m:I=m,m=.5*(I-P)+P;return m},solve:function(i,g){return this.sampleCurveY(this.solveCurveX(i,g))}};var ji=Object.freeze({__proto__:null,number:Gi,color:function(i,g,m){return new ti(Gi(i.r,g.r,m),Gi(i.g,g.g,m),Gi(i.b,g.b,m),Gi(i.a,g.a,m))},array:function(i,g,m){return i.map(((i,_)=>Gi(i,g[_],m)))}});const Wi=.95047,qi=1.08883,Xi=4/29,Zi=6/29,$i=3*Zi*Zi,Yi=Zi*Zi*Zi,Qi=Math.PI/180,Ji=180/Math.PI;function Ki(i){return i>Yi?Math.pow(i,1/3):i/$i+Xi}function to(i){return i>Zi?i*i*i:$i*(i-Xi)}function no(i){return 255*(i<=.0031308?12.92*i:1.055*Math.pow(i,1/2.4)-.055)}function ro(i){return(i/=255)<=.04045?i/12.92:Math.pow((i+.055)/1.055,2.4)}function io(i){const g=ro(i.r),m=ro(i.g),_=ro(i.b),b=Ki((.4124564*g+.3575761*m+.1804375*_)/Wi),T=Ki((.2126729*g+.7151522*m+.072175*_)/1);return{l:116*T-16,a:500*(b-T),b:200*(T-Ki((.0193339*g+.119192*m+.9503041*_)/qi)),alpha:i.a}}function oo(i){let g=(i.l+16)/116,m=isNaN(i.a)?g:g+i.a/500,_=isNaN(i.b)?g:g-i.b/200;return g=1*to(g),m=Wi*to(m),_=qi*to(_),new ti(no(3.2404542*m-1.5371385*g-.4985314*_),no(-.969266*m+1.8760108*g+.041556*_),no(.0556434*m-.2040259*g+1.0572252*_),i.alpha)}function so(i,g,m){const _=g-i;return i+m*(_>180||_<-180?_-360*Math.round(_/360):_)}const ao={forward:io,reverse:oo,interpolate:function(i,g,m){return{l:Gi(i.l,g.l,m),a:Gi(i.a,g.a,m),b:Gi(i.b,g.b,m),alpha:Gi(i.alpha,g.alpha,m)}}},lo={forward:function(i){const{l:g,a:m,b:_}=io(i),b=Math.atan2(_,m)*Ji;return{h:b<0?b+360:b,c:Math.sqrt(m*m+_*_),l:g,alpha:i.a}},reverse:function(i){const g=i.h*Qi,m=i.c;return oo({l:i.l,a:Math.cos(g)*m,b:Math.sin(g)*m,alpha:i.alpha})},interpolate:function(i,g,m){return{h:so(i.h,g.h,m),c:Gi(i.c,g.c,m),l:Gi(i.l,g.l,m),alpha:Gi(i.alpha,g.alpha,m)}}};class Interpolate{constructor(i,g,m,_,b){this.type=i,this.operator=g,this.interpolation=m,this.input=_,this.labels=[],this.outputs=[];for(const[i,g]of b)this.labels.push(i),this.outputs.push(g)}static interpolationFactor(i,g,m,_){let b=0;if("exponential"===i.name)b=ho(g,i.base,m,_);else if("linear"===i.name)b=ho(g,1,m,_);else if("cubic-bezier"===i.name){const T=i.controlPoints;b=new Vi(T[0],T[1],T[2],T[3]).solve(ho(g,1,m,_))}return b}static parse(i,g){let[m,_,b,...T]=i;if(!Array.isArray(_)||0===_.length)return g.error("Expected an interpolation type expression.",1);if("linear"===_[0])_={name:"linear"};else if("exponential"===_[0]){const i=_[1];if("number"!=typeof i)return g.error("Exponential interpolation requires a numeric base.",1,1);_={name:"exponential",base:i}}else{if("cubic-bezier"!==_[0])return g.error(`Unknown interpolation type ${String(_[0])}`,1,0);{const i=_.slice(1);if(4!==i.length||i.some((i=>"number"!=typeof i||i<0||i>1)))return g.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);_={name:"cubic-bezier",controlPoints:i}}}if(i.length-1<4)return g.error(`Expected at least 4 arguments, but found only ${i.length-1}.`);if((i.length-1)%2!=0)return g.error("Expected an even number of arguments.");if(b=g.parse(b,2,Rr),!b)return null;const P=[];let I=null;"interpolate-hcl"===m||"interpolate-lab"===m?I=Fr:g.expectedType&&"value"!==g.expectedType.kind&&(I=g.expectedType);for(let i=0;i<T.length;i+=2){const m=T[i],_=T[i+1],b=i+3,H=i+4;if("number"!=typeof m)return g.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',b);if(P.length&&P[P.length-1][0]>=m)return g.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',b);const W=g.parse(_,H,I);if(!W)return null;I=I||W.type,P.push([m,W])}return"number"===I.kind||"color"===I.kind||"array"===I.kind&&"number"===I.itemType.kind&&"number"==typeof I.N?new Interpolate(I,m,_,b,P):g.error(`Type ${Gr(I)} is not interpolatable.`)}evaluate(i){const g=this.labels,m=this.outputs;if(1===g.length)return m[0].evaluate(i);const _=this.input.evaluate(i);if(_<=g[0])return m[0].evaluate(i);const b=g.length;if(_>=g[b-1])return m[b-1].evaluate(i);const T=Bi(g,_),P=Interpolate.interpolationFactor(this.interpolation,_,g[T],g[T+1]),I=m[T].evaluate(i),H=m[T+1].evaluate(i);return"interpolate"===this.operator?ji[this.type.kind.toLowerCase()](I,H,P):"interpolate-hcl"===this.operator?lo.reverse(lo.interpolate(lo.forward(I),lo.forward(H),P)):ao.reverse(ao.interpolate(ao.forward(I),ao.forward(H),P))}eachChild(i){i(this.input);for(const g of this.outputs)i(g)}outputDefined(){return this.outputs.every((i=>i.outputDefined()))}serialize(){let i;i="linear"===this.interpolation.name?["linear"]:"exponential"===this.interpolation.name?1===this.interpolation.base?["linear"]:["exponential",this.interpolation.base]:["cubic-bezier"].concat(this.interpolation.controlPoints);const g=[this.operator,i,this.input.serialize()];for(let i=0;i<this.labels.length;i++)g.push(this.labels[i],this.outputs[i].serialize());return g}}function ho(i,g,m,_){const b=_-m,T=i-m;return 0===b?0:1===g?T/b:(Math.pow(g,T)-1)/(Math.pow(g,b)-1)}var co=Interpolate;class Coalesce{constructor(i,g){this.type=i,this.args=g}static parse(i,g){if(i.length<2)return g.error("Expectected at least one argument.");let m=null;const _=g.expectedType;_&&"value"!==_.kind&&(m=_);const b=[];for(const _ of i.slice(1)){const i=g.parse(_,1+b.length,m,void 0,{typeAnnotation:"omit"});if(!i)return null;m=m||i.type,b.push(i)}const T=_&&b.some((i=>Wr(_,i.type)));return new Coalesce(T?Hr:m,b)}evaluate(i){let g,m=null,_=0;for(const b of this.args){if(_++,m=b.evaluate(i),m&&m instanceof ResolvedImage&&!m.available&&(g||(g=m),m=null,_===this.args.length))return g;if(null!==m)break}return m}eachChild(i){this.args.forEach(i)}outputDefined(){return this.args.every((i=>i.outputDefined()))}serialize(){const i=["coalesce"];return this.eachChild((g=>{i.push(g.serialize())})),i}}var uo=Coalesce;class Let{constructor(i,g){this.type=g.type,this.bindings=[].concat(i),this.result=g}evaluate(i){return this.result.evaluate(i)}eachChild(i){for(const g of this.bindings)i(g[1]);i(this.result)}static parse(i,g){if(i.length<4)return g.error(`Expected at least 3 arguments, but found ${i.length-1} instead.`);const m=[];for(let _=1;_<i.length-1;_+=2){const b=i[_];if("string"!=typeof b)return g.error(`Expected string, but found ${typeof b} instead.`,_);if(/[^a-zA-Z0-9_]/.test(b))return g.error("Variable names must contain only alphanumeric characters or '_'.",_);const T=g.parse(i[_+1],_+1);if(!T)return null;m.push([b,T])}const _=g.parse(i[i.length-1],i.length-1,g.expectedType,m);return _?new Let(m,_):null}outputDefined(){return this.result.outputDefined()}serialize(){const i=["let"];for(const[g,m]of this.bindings)i.push(g,m.serialize());return i.push(this.result.serialize()),i}}var fo=Let;class At{constructor(i,g,m){this.type=i,this.index=g,this.input=m}static parse(i,g){if(3!==i.length)return g.error(`Expected 2 arguments, but found ${i.length-1} instead.`);const m=g.parse(i[1],1,Rr),_=g.parse(i[2],2,Ur(g.expectedType||Hr));if(!m||!_)return null;return new At(_.type.itemType,m,_)}evaluate(i){const g=this.index.evaluate(i),m=this.input.evaluate(i);if(g<0)throw new ai(`Array index out of bounds: ${g} < 0.`);if(g>=m.length)throw new ai(`Array index out of bounds: ${g} > ${m.length-1}.`);if(g!==Math.floor(g))throw new ai(`Array index must be an integer, but found ${g} instead.`);return m[g]}eachChild(i){i(this.index),i(this.input)}outputDefined(){return!1}serialize(){return["at",this.index.serialize(),this.input.serialize()]}}var go=At;class In{constructor(i,g){this.type=Dr,this.needle=i,this.haystack=g}static parse(i,g){if(3!==i.length)return g.error(`Expected 2 arguments, but found ${i.length-1} instead.`);const m=g.parse(i[1],1,Hr),_=g.parse(i[2],2,Hr);return m&&_?qr(m.type,[Dr,Lr,Rr,Er,Hr])?new In(m,_):g.error(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(m.type)} instead`):null}evaluate(i){const g=this.needle.evaluate(i),m=this.haystack.evaluate(i);if(null==m)return!1;if(!Xr(g,["boolean","string","number","null"]))throw new ai(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(ii(g))} instead.`);if(!Xr(m,["string","array"]))throw new ai(`Expected second argument to be of type array or string, but found ${Gr(ii(m))} instead.`);return m.indexOf(g)>=0}eachChild(i){i(this.needle),i(this.haystack)}outputDefined(){return!0}serialize(){return["in",this.needle.serialize(),this.haystack.serialize()]}}var mo=In;class IndexOf{constructor(i,g,m){this.type=Rr,this.needle=i,this.haystack=g,this.fromIndex=m}static parse(i,g){if(i.length<=2||i.length>=5)return g.error(`Expected 3 or 4 arguments, but found ${i.length-1} instead.`);const m=g.parse(i[1],1,Hr),_=g.parse(i[2],2,Hr);if(!m||!_)return null;if(!qr(m.type,[Dr,Lr,Rr,Er,Hr]))return g.error(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(m.type)} instead`);if(4===i.length){const b=g.parse(i[3],3,Rr);return b?new IndexOf(m,_,b):null}return new IndexOf(m,_)}evaluate(i){const g=this.needle.evaluate(i),m=this.haystack.evaluate(i);if(!Xr(g,["boolean","string","number","null"]))throw new ai(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(ii(g))} instead.`);if(!Xr(m,["string","array"]))throw new ai(`Expected second argument to be of type array or string, but found ${Gr(ii(m))} instead.`);if(this.fromIndex){const _=this.fromIndex.evaluate(i);return m.indexOf(g,_)}return m.indexOf(g)}eachChild(i){i(this.needle),i(this.haystack),this.fromIndex&&i(this.fromIndex)}outputDefined(){return!1}serialize(){if(null!=this.fromIndex&&void 0!==this.fromIndex){const i=this.fromIndex.serialize();return["index-of",this.needle.serialize(),this.haystack.serialize(),i]}return["index-of",this.needle.serialize(),this.haystack.serialize()]}}var Ao=IndexOf;class Match{constructor(i,g,m,_,b,T){this.inputType=i,this.type=g,this.input=m,this.cases=_,this.outputs=b,this.otherwise=T}static parse(i,g){if(i.length<5)return g.error(`Expected at least 4 arguments, but found only ${i.length-1}.`);if(i.length%2!=1)return g.error("Expected an even number of arguments.");let m,_;g.expectedType&&"value"!==g.expectedType.kind&&(_=g.expectedType);const b={},T=[];for(let P=2;P<i.length-1;P+=2){let I=i[P];const H=i[P+1];Array.isArray(I)||(I=[I]);const W=g.concat(P);if(0===I.length)return W.error("Expected at least one branch label.");for(const i of I){if("number"!=typeof i&&"string"!=typeof i)return W.error("Branch labels must be numbers or strings.");if("number"==typeof i&&Math.abs(i)>Number.MAX_SAFE_INTEGER)return W.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);if("number"==typeof i&&Math.floor(i)!==i)return W.error("Numeric branch labels must be integer values.");if(m){if(W.checkSubtype(m,ii(i)))return null}else m=ii(i);if(void 0!==b[String(i)])return W.error("Branch labels must be unique.");b[String(i)]=T.length}const q=g.parse(H,P,_);if(!q)return null;_=_||q.type,T.push(q)}const P=g.parse(i[1],1,Hr);if(!P)return null;const I=g.parse(i[i.length-1],i.length-1,_);return I?"value"!==P.type.kind&&g.concat(1).checkSubtype(m,P.type)?null:new Match(m,_,P,b,T,I):null}evaluate(i){const g=this.input.evaluate(i);return(ii(g)===this.inputType&&this.outputs[this.cases[g]]||this.otherwise).evaluate(i)}eachChild(i){i(this.input),this.outputs.forEach(i),i(this.otherwise)}outputDefined(){return this.outputs.every((i=>i.outputDefined()))&&this.otherwise.outputDefined()}serialize(){const i=["match",this.input.serialize()],g=Object.keys(this.cases).sort(),m=[],_={};for(const i of g){const g=_[this.cases[i]];void 0===g?(_[this.cases[i]]=m.length,m.push([this.cases[i],[i]])):m[g][1].push(i)}const b=i=>"number"===this.inputType.kind?Number(i):i;for(const[g,_]of m)i.push(1===_.length?b(_[0]):_.map(b)),i.push(this.outputs[g].serialize());return i.push(this.otherwise.serialize()),i}}var yo=Match;class Case{constructor(i,g,m){this.type=i,this.branches=g,this.otherwise=m}static parse(i,g){if(i.length<4)return g.error(`Expected at least 3 arguments, but found only ${i.length-1}.`);if(i.length%2!=0)return g.error("Expected an odd number of arguments.");let m;g.expectedType&&"value"!==g.expectedType.kind&&(m=g.expectedType);const _=[];for(let b=1;b<i.length-1;b+=2){const T=g.parse(i[b],b,Dr);if(!T)return null;const P=g.parse(i[b+1],b+1,m);if(!P)return null;_.push([T,P]),m=m||P.type}const b=g.parse(i[i.length-1],i.length-1,m);return b?new Case(m,_,b):null}evaluate(i){for(const[g,m]of this.branches)if(g.evaluate(i))return m.evaluate(i);return this.otherwise.evaluate(i)}eachChild(i){for(const[g,m]of this.branches)i(g),i(m);i(this.otherwise)}outputDefined(){return this.branches.every((([i,g])=>g.outputDefined()))&&this.otherwise.outputDefined()}serialize(){const i=["case"];return this.eachChild((g=>{i.push(g.serialize())})),i}}var _o=Case;class Slice{constructor(i,g,m,_){this.type=i,this.input=g,this.beginIndex=m,this.endIndex=_}static parse(i,g){if(i.length<=2||i.length>=5)return g.error(`Expected 3 or 4 arguments, but found ${i.length-1} instead.`);const m=g.parse(i[1],1,Hr),_=g.parse(i[2],2,Rr);if(!m||!_)return null;if(!qr(m.type,[Ur(Hr),Lr,Hr]))return g.error(`Expected first argument to be of type array or string, but found ${Gr(m.type)} instead`);if(4===i.length){const b=g.parse(i[3],3,Rr);return b?new Slice(m.type,m,_,b):null}return new Slice(m.type,m,_)}evaluate(i){const g=this.input.evaluate(i),m=this.beginIndex.evaluate(i);if(!Xr(g,["string","array"]))throw new ai(`Expected first argument to be of type array or string, but found ${Gr(ii(g))} instead.`);if(this.endIndex){const _=this.endIndex.evaluate(i);return g.slice(m,_)}return g.slice(m)}eachChild(i){i(this.input),i(this.beginIndex),this.endIndex&&i(this.endIndex)}outputDefined(){return!1}serialize(){if(null!=this.endIndex&&void 0!==this.endIndex){const i=this.endIndex.serialize();return["slice",this.input.serialize(),this.beginIndex.serialize(),i]}return["slice",this.input.serialize(),this.beginIndex.serialize()]}}var vo=Slice;function xo(i,g){return"=="===i||"!="===i?"boolean"===g.kind||"string"===g.kind||"number"===g.kind||"null"===g.kind||"value"===g.kind:"string"===g.kind||"number"===g.kind||"value"===g.kind}function bo(i,g,m,_){return 0===_.compare(g,m)}function wo(i,g,m){const _="=="!==i&&"!="!==i;return class Comparison{constructor(i,g,m){this.type=Dr,this.lhs=i,this.rhs=g,this.collator=m,this.hasUntypedArgument="value"===i.type.kind||"value"===g.type.kind}static parse(i,g){if(3!==i.length&&4!==i.length)return g.error("Expected two or three arguments.");const m=i[0];let b=g.parse(i[1],1,Hr);if(!b)return null;if(!xo(m,b.type))return g.concat(1).error(`"${m}" comparisons are not supported for type '${Gr(b.type)}'.`);let T=g.parse(i[2],2,Hr);if(!T)return null;if(!xo(m,T.type))return g.concat(2).error(`"${m}" comparisons are not supported for type '${Gr(T.type)}'.`);if(b.type.kind!==T.type.kind&&"value"!==b.type.kind&&"value"!==T.type.kind)return g.error(`Cannot compare types '${Gr(b.type)}' and '${Gr(T.type)}'.`);_&&("value"===b.type.kind&&"value"!==T.type.kind?b=new hi(T.type,[b]):"value"!==b.type.kind&&"value"===T.type.kind&&(T=new hi(b.type,[T])));let P=null;if(4===i.length){if("string"!==b.type.kind&&"string"!==T.type.kind&&"value"!==b.type.kind&&"value"!==T.type.kind)return g.error("Cannot use collator to compare non-string types.");if(P=g.parse(i[3],3,Br),!P)return null}return new Comparison(b,T,P)}evaluate(b){const T=this.lhs.evaluate(b),P=this.rhs.evaluate(b);if(_&&this.hasUntypedArgument){const g=ii(T),m=ii(P);if(g.kind!==m.kind||"string"!==g.kind&&"number"!==g.kind)throw new ai(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${g.kind}, ${m.kind}) instead.`)}if(this.collator&&!_&&this.hasUntypedArgument){const i=ii(T),m=ii(P);if("string"!==i.kind||"string"!==m.kind)return g(b,T,P)}return this.collator?m(b,T,P,this.collator.evaluate(b)):g(b,T,P)}eachChild(i){i(this.lhs),i(this.rhs),this.collator&&i(this.collator)}outputDefined(){return!0}serialize(){const g=[i];return this.eachChild((i=>{g.push(i.serialize())})),g}}}const To=wo("==",(function(i,g,m){return g===m}),bo),So=wo("!=",(function(i,g,m){return g!==m}),(function(i,g,m,_){return!bo(0,g,m,_)})),Mo=wo("<",(function(i,g,m){return g<m}),(function(i,g,m,_){return _.compare(g,m)<0})),Co=wo(">",(function(i,g,m){return g>m}),(function(i,g,m,_){return _.compare(g,m)>0})),Po=wo("<=",(function(i,g,m){return g<=m}),(function(i,g,m,_){return _.compare(g,m)<=0})),Io=wo(">=",(function(i,g,m){return g>=m}),(function(i,g,m,_){return _.compare(g,m)>=0}));class NumberFormat{constructor(i,g,m,_,b,T){this.type=Lr,this.number=i,this.locale=g,this.currency=m,this.unit=_,this.minFractionDigits=b,this.maxFractionDigits=T}static parse(i,g){if(3!==i.length)return g.error("Expected two arguments.");const m=g.parse(i[1],1,Rr);if(!m)return null;const _=i[2];if("object"!=typeof _||Array.isArray(_))return g.error("NumberFormat options argument must be an object.");let b=null;if(_.locale&&(b=g.parse(_.locale,1,Lr),!b))return null;let T=null;if(_.currency&&(T=g.parse(_.currency,1,Lr),!T))return null;let P=null;if(_.unit&&(P=g.parse(_.unit,1,Lr),!P))return null;let I=null;if(_["min-fraction-digits"]&&(I=g.parse(_["min-fraction-digits"],1,Rr),!I))return null;let H=null;return _["max-fraction-digits"]&&(H=g.parse(_["max-fraction-digits"],1,Rr),!H)?null:new NumberFormat(m,b,T,P,I,H)}evaluate(i){return new Intl.NumberFormat(this.locale?this.locale.evaluate(i):[],{style:(this.currency?"currency":this.unit&&"unit")||"decimal",currency:this.currency?this.currency.evaluate(i):void 0,unit:this.unit?this.unit.evaluate(i):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(i):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(i):void 0}).format(this.number.evaluate(i))}eachChild(i){i(this.number),this.locale&&i(this.locale),this.currency&&i(this.currency),this.unit&&i(this.unit),this.minFractionDigits&&i(this.minFractionDigits),this.maxFractionDigits&&i(this.maxFractionDigits)}outputDefined(){return!1}serialize(){const i={};return this.locale&&(i.locale=this.locale.serialize()),this.currency&&(i.currency=this.currency.serialize()),this.unit&&(i.unit=this.unit.serialize()),this.minFractionDigits&&(i["min-fraction-digits"]=this.minFractionDigits.serialize()),this.maxFractionDigits&&(i["max-fraction-digits"]=this.maxFractionDigits.serialize()),["number-format",this.number.serialize(),i]}}class Length{constructor(i){this.type=Rr,this.input=i}static parse(i,g){if(2!==i.length)return g.error(`Expected 1 argument, but found ${i.length-1} instead.`);const m=g.parse(i[1],1);return m?"array"!==m.type.kind&&"string"!==m.type.kind&&"value"!==m.type.kind?g.error(`Expected argument of type string or array, but found ${Gr(m.type)} instead.`):new Length(m):null}evaluate(i){const g=this.input.evaluate(i);if("string"==typeof g)return g.length;if(Array.isArray(g))return g.length;throw new ai(`Expected value to be of type string or array, but found ${Gr(ii(g))} instead.`)}eachChild(i){i(this.input)}outputDefined(){return!1}serialize(){const i=["length"];return this.eachChild((g=>{i.push(g.serialize())})),i}}const ko={"==":To,"!=":So,">":Co,"<":Mo,">=":Io,"<=":Po,array:hi,at:go,boolean:hi,case:_o,coalesce:uo,collator:CollatorExpression,format:FormatExpression,image:ImageExpression,in:mo,"index-of":Ao,interpolate:co,"interpolate-hcl":co,"interpolate-lab":co,length:Length,let:fo,literal:si,match:yo,number:hi,"number-format":NumberFormat,object:hi,slice:vo,step:zi,string:hi,"to-boolean":ui,"to-color":ui,"to-number":ui,"to-string":ui,var:Fi,within:Ri};function Oo(i,[g,m,_,b]){g=g.evaluate(i),m=m.evaluate(i),_=_.evaluate(i);const T=b?b.evaluate(i):1,P=ni(g,m,_,T);if(P)throw new ai(P);return new ti(g/255*T,m/255*T,_/255*T,T)}function Eo(i,g){return i in g}function Ro(i,g){const m=g[i];return void 0===m?null:m}function Lo(i){return{type:i}}pi.register(ko,{error:[{kind:"error"},[Lr],(i,[g])=>{throw new ai(g.evaluate(i))}],typeof:[Lr,[Hr],(i,[g])=>Gr(ii(g.evaluate(i)))],"to-rgba":[Ur(Rr,4),[Fr],(i,[g])=>g.evaluate(i).toArray()],rgb:[Fr,[Rr,Rr,Rr],Oo],rgba:[Fr,[Rr,Rr,Rr,Rr],Oo],has:{type:Dr,overloads:[[[Lr],(i,[g])=>Eo(g.evaluate(i),i.properties())],[[Lr,Nr],(i,[g,m])=>Eo(g.evaluate(i),m.evaluate(i))]]},get:{type:Hr,overloads:[[[Lr],(i,[g])=>Ro(g.evaluate(i),i.properties())],[[Lr,Nr],(i,[g,m])=>Ro(g.evaluate(i),m.evaluate(i))]]},"feature-state":[Hr,[Lr],(i,[g])=>Ro(g.evaluate(i),i.featureState||{})],properties:[Nr,[],i=>i.properties()],"geometry-type":[Lr,[],i=>i.geometryType()],id:[Hr,[],i=>i.id()],zoom:[Rr,[],i=>i.globals.zoom],pitch:[Rr,[],i=>i.globals.pitch||0],"distance-from-center":[Rr,[],i=>i.distanceFromCenter()],"heatmap-density":[Rr,[],i=>i.globals.heatmapDensity||0],"line-progress":[Rr,[],i=>i.globals.lineProgress||0],"sky-radial-progress":[Rr,[],i=>i.globals.skyRadialProgress||0],accumulated:[Hr,[],i=>void 0===i.globals.accumulated?null:i.globals.accumulated],"+":[Rr,Lo(Rr),(i,g)=>{let m=0;for(const _ of g)m+=_.evaluate(i);return m}],"*":[Rr,Lo(Rr),(i,g)=>{let m=1;for(const _ of g)m*=_.evaluate(i);return m}],"-":{type:Rr,overloads:[[[Rr,Rr],(i,[g,m])=>g.evaluate(i)-m.evaluate(i)],[[Rr],(i,[g])=>-g.evaluate(i)]]},"/":[Rr,[Rr,Rr],(i,[g,m])=>g.evaluate(i)/m.evaluate(i)],"%":[Rr,[Rr,Rr],(i,[g,m])=>g.evaluate(i)%m.evaluate(i)],ln2:[Rr,[],()=>Math.LN2],pi:[Rr,[],()=>Math.PI],e:[Rr,[],()=>Math.E],"^":[Rr,[Rr,Rr],(i,[g,m])=>Math.pow(g.evaluate(i),m.evaluate(i))],sqrt:[Rr,[Rr],(i,[g])=>Math.sqrt(g.evaluate(i))],log10:[Rr,[Rr],(i,[g])=>Math.log(g.evaluate(i))/Math.LN10],ln:[Rr,[Rr],(i,[g])=>Math.log(g.evaluate(i))],log2:[Rr,[Rr],(i,[g])=>Math.log(g.evaluate(i))/Math.LN2],sin:[Rr,[Rr],(i,[g])=>Math.sin(g.evaluate(i))],cos:[Rr,[Rr],(i,[g])=>Math.cos(g.evaluate(i))],tan:[Rr,[Rr],(i,[g])=>Math.tan(g.evaluate(i))],asin:[Rr,[Rr],(i,[g])=>Math.asin(g.evaluate(i))],acos:[Rr,[Rr],(i,[g])=>Math.acos(g.evaluate(i))],atan:[Rr,[Rr],(i,[g])=>Math.atan(g.evaluate(i))],min:[Rr,Lo(Rr),(i,g)=>Math.min(...g.map((g=>g.evaluate(i))))],max:[Rr,Lo(Rr),(i,g)=>Math.max(...g.map((g=>g.evaluate(i))))],abs:[Rr,[Rr],(i,[g])=>Math.abs(g.evaluate(i))],round:[Rr,[Rr],(i,[g])=>{const m=g.evaluate(i);return m<0?-Math.round(-m):Math.round(m)}],floor:[Rr,[Rr],(i,[g])=>Math.floor(g.evaluate(i))],ceil:[Rr,[Rr],(i,[g])=>Math.ceil(g.evaluate(i))],"filter-==":[Dr,[Lr,Hr],(i,[g,m])=>i.properties()[g.value]===m.value],"filter-id-==":[Dr,[Hr],(i,[g])=>i.id()===g.value],"filter-type-==":[Dr,[Lr],(i,[g])=>i.geometryType()===g.value],"filter-<":[Dr,[Lr,Hr],(i,[g,m])=>{const _=i.properties()[g.value],b=m.value;return typeof _==typeof b&&_<b}],"filter-id-<":[Dr,[Hr],(i,[g])=>{const m=i.id(),_=g.value;return typeof m==typeof _&&m<_}],"filter->":[Dr,[Lr,Hr],(i,[g,m])=>{const _=i.properties()[g.value],b=m.value;return typeof _==typeof b&&_>b}],"filter-id->":[Dr,[Hr],(i,[g])=>{const m=i.id(),_=g.value;return typeof m==typeof _&&m>_}],"filter-<=":[Dr,[Lr,Hr],(i,[g,m])=>{const _=i.properties()[g.value],b=m.value;return typeof _==typeof b&&_<=b}],"filter-id-<=":[Dr,[Hr],(i,[g])=>{const m=i.id(),_=g.value;return typeof m==typeof _&&m<=_}],"filter->=":[Dr,[Lr,Hr],(i,[g,m])=>{const _=i.properties()[g.value],b=m.value;return typeof _==typeof b&&_>=b}],"filter-id->=":[Dr,[Hr],(i,[g])=>{const m=i.id(),_=g.value;return typeof m==typeof _&&m>=_}],"filter-has":[Dr,[Hr],(i,[g])=>g.value in i.properties()],"filter-has-id":[Dr,[],i=>null!==i.id()&&void 0!==i.id()],"filter-type-in":[Dr,[Ur(Lr)],(i,[g])=>g.value.indexOf(i.geometryType())>=0],"filter-id-in":[Dr,[Ur(Hr)],(i,[g])=>g.value.indexOf(i.id())>=0],"filter-in-small":[Dr,[Lr,Ur(Hr)],(i,[g,m])=>m.value.indexOf(i.properties()[g.value])>=0],"filter-in-large":[Dr,[Lr,Ur(Hr)],(i,[g,m])=>function(i,g,m,_){for(;m<=_;){const b=m+_>>1;if(g[b]===i)return!0;g[b]>i?_=b-1:m=b+1}return!1}(i.properties()[g.value],m.value,0,m.value.length-1)],all:{type:Dr,overloads:[[[Dr,Dr],(i,[g,m])=>g.evaluate(i)&&m.evaluate(i)],[Lo(Dr),(i,g)=>{for(const m of g)if(!m.evaluate(i))return!1;return!0}]]},any:{type:Dr,overloads:[[[Dr,Dr],(i,[g,m])=>g.evaluate(i)||m.evaluate(i)],[Lo(Dr),(i,g)=>{for(const m of g)if(m.evaluate(i))return!0;return!1}]]},"!":[Dr,[Dr],(i,[g])=>!g.evaluate(i)],"is-supported-script":[Dr,[Lr],(i,[g])=>{const m=i.globals&&i.globals.isSupportedScript;return!m||m(g.evaluate(i))}],upcase:[Lr,[Lr],(i,[g])=>g.evaluate(i).toUpperCase()],downcase:[Lr,[Lr],(i,[g])=>g.evaluate(i).toLowerCase()],concat:[Lr,Lo(Hr),(i,g)=>g.map((g=>oi(g.evaluate(i)))).join("")],"resolved-locale":[Lr,[Br],(i,[g])=>g.evaluate(i).resolvedLocale()]});var Do=ko;class StyleExpression{constructor(i,g){this.expression=i,this._warningHistory={},this._evaluator=new di,this._defaultValue=g?function(i){return"color"===i.type&&(g=i.default,"object"==typeof g&&null!==g&&!Array.isArray(g)||Array.isArray(i.default))?new ti(0,0,0,0):"color"===i.type?ti.parse(i.default)||null:void 0===i.default?null:i.default;var g}(g):null,this._enumValues=g&&"enum"===g.type?g.values:null}evaluateWithoutErrorHandling(i,g,m,_,b,T,P,I){return this._evaluator.globals=i,this._evaluator.feature=g,this._evaluator.featureState=m,this._evaluator.canonical=_||null,this._evaluator.availableImages=b||null,this._evaluator.formattedSection=T,this._evaluator.featureTileCoord=P||null,this._evaluator.featureDistanceData=I||null,this.expression.evaluate(this._evaluator)}evaluate(i,g,m,_,b,T,P,I){this._evaluator.globals=i,this._evaluator.feature=g||null,this._evaluator.featureState=m||null,this._evaluator.canonical=_||null,this._evaluator.availableImages=b||null,this._evaluator.formattedSection=T||null,this._evaluator.featureTileCoord=P||null,this._evaluator.featureDistanceData=I||null;try{const i=this.expression.evaluate(this._evaluator);if(null==i||"number"==typeof i&&i!=i)return this._defaultValue;if(this._enumValues&&!(i in this._enumValues))throw new ai(`Expected value to be one of ${Object.keys(this._enumValues).map((i=>JSON.stringify(i))).join(", ")}, but found ${JSON.stringify(i)} instead.`);return i}catch(i){return this._warningHistory[i.message]||(this._warningHistory[i.message]=!0,"undefined"!=typeof console&&console.warn(i.message)),this._defaultValue}}}function Fo(i,g){const m=new Ni(Do,[],g?function(i){const g={color:Fr,string:Lr,number:Rr,enum:Lr,boolean:Dr,formatted:zr,resolvedImage:Vr};if("array"===i.type)return Ur(g[i.value]||Hr,i.length);return g[i.type]}(g):void 0),_=m.parse(i,void 0,void 0,void 0,g&&"string"===g.type?{typeAnnotation:"coerce"}:void 0);return _?function(i){return{result:"success",value:i}}(new StyleExpression(_,g)):{result:"error",value:m.errors}}function No(i){if(Array.isArray(i))return i.map(No);if(i instanceof Object&&!(i instanceof Number||i instanceof String||i instanceof Boolean)){const g={};for(const m in i)g[m]=No(i[m]);return g}return function(i){return i instanceof Number||i instanceof String||i instanceof Boolean?i.valueOf():i}(i)}function Ho(i,g="fill"){if(null==i)return{filter:()=>!0,needGeometry:!1,needFeature:!1};const m=i;let _=!0;try{_=function(i){if(!Uo(i))return i;let g=No(i);return zo(g),g=Bo(g),g}(m)}catch(i){console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(m,null,2)}\n        `)}const b=Fo(_,null);let T=null;if("error"===b.result)throw new Error(b.value.map((i=>`${i.key}: ${i.message}`)).join(", "));T=(i,g,m)=>b.value.evaluate(i,g,{},m);let P=null,I=null;if(_!==m){const i=Fo(m,null);if("error"===i.result)throw new Error(i.value.map((i=>`${i.key}: ${i.message}`)).join(", "));P=(g,m,_,b,T)=>i.value.evaluate(g,m,{},_,void 0,void 0,b,T),I=!Li(i.value.expression)}return{filter:T,dynamicFilter:P||void 0,needGeometry:jo(_),needFeature:!!I}}function Bo(i){if(!Array.isArray(i))return i;const g=function(i){if(Go.has(i[0]))for(let g=1;g<i.length;g++){if(Uo(i[g]))return!0}return i}(i);return!0===g?g:g.map((i=>Bo(i)))}function zo(i){let g=!1;const m=[];if("case"===i[0]){for(let _=1;_<i.length-1;_+=2)g=g||Uo(i[_]),m.push(i[_+1]);m.push(i[i.length-1])}else if("match"===i[0]){g=g||Uo(i[1]);for(let g=2;g<i.length-1;g+=2)m.push(i[g+1]);m.push(i[i.length-1])}else if("step"===i[0]){g=g||Uo(i[1]);for(let g=1;g<i.length-1;g+=2)m.push(i[g+1])}g&&(i.length=0,i.push("any",...m));for(let g=1;g<i.length;g++)zo(i[g])}function Uo(i){if(!Array.isArray(i))return!1;if(function(i){return"pitch"===i||"distance-from-center"===i}(i[0]))return!0;for(let g=1;g<i.length;g++){if(Uo(i[g]))return!0}return!1}const Go=new Set(["in","==","!=",">",">=","<","<=","to-boolean"]);function jo(i){if(!Array.isArray(i))return!1;if("within"===i[0])return!0;for(let g=1;g<i.length;g++)if(jo(i[g]))return!0;return!1}const Wo={isExpression:function(i){return Array.isArray(i)&&i.length>0&&"string"==typeof i[0]&&i[0]in Do},createExpression:Fo},{isExpression:qo,createExpression:Xo}=Wo;const Zo={};function $o(i){if(!Array.isArray(i))return $o([i]);const g=[];for(let m=0;m<i.length;m++){let _;_=!0===i[m].filter?function(){return!0}:Yo(i[m].filter),g.push(Yn({},i[m],{filter:_}))}return g}function Yo(i){if(!0===i)return function(){return!0};if(i&&i.condition){if("any"===i.type){const g=i.condition,m=[];for(let i=0;i<g.length;i++)m.push(Yo(g[i]));return(i,g)=>{for(let _=0;_<m.length;_++)if(m[_](i,g))return!0;return!1}}const g=Yo(i.condition);if(Qn(i.layer))return g;const m=g=>g.layer===i.layer;return(i,_)=>m(i)&&g(i,_)}if(yr(i))return new Function("f",`var p = (f && f.properties || {}); return ${_r(i)}`);{let g=Ho(i);g=g&&g.filter;const m=(i,m)=>(Zo.zoom=m,g&&g(Zo,i));return m}}const Qo={type:"number","property-type":"data-driven",expression:{parameters:["zoom","feature"]}};function Jo(i,g){Qo.type=g||"number";const m=Xo(i,Qo);if("success"!==m.result)throw new Error(`Invalid maplibre spec expression: ${JSON.stringify(i)} (${m.value})`);return m.value}function Ko(i){return qo(i)}const es={lineWidth:1,lineStrokeWidth:1,lineDx:1,lineDy:1,lineOpacity:1,linePatternAnimSpeed:1,markerWidth:1,markerHeight:1,markerDx:1,markerDy:1,markerSpacing:1,markerOpacity:1,markerRotation:1,textWrapWidth:1,textSpacing:1,textSize:1,textHaloRadius:1,textHaloOpacity:1,textDx:1,textDy:1,textOpacity:1,textRotation:1,polygonOpacity:1};function ts(i){return es[i]}const rs={markerPlacement:1,markerFile:1,mergeOnProperty:1,markerTextFit:1,markerType:1,markerHorizontalAlignment:1,markerVerticalAlignment:1,markerRotationAlignment:1,markerPitchAlignment:1,markerFillPatternFile:1,markerLinePatternFile:1,textName:1,textPlacement:1,textFaceName:1,textStyle:1,textHorizontalAlignment:1,textVerticalAlignment:1,textRotationAlignment:1,textPitchAlignment:1,lineJoin:1,lineCap:1,linePatternFile:1,polygonPatternFile:1},is={lineDasharray:1,markerLineDasharray:1,uvScale:1,uvOffset:1};function os(i){return rs[i]?"string":ts(i)?"number":is[i]?"array":"color"}var ss=Object.freeze({__proto__:null,compileFilter:Yo,compileStyle:function(i=[]){return i=i.map((i=>{const g=Yn({},i);return g.filter&&g.filter.value&&(g.filter=g.filter.value),g})),$o(i)},createExpression:Jo,getExpressionType:os,isExpression:Ko,isInterpolated:ts});const ls="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,hs=function(i){return class extends i{pushIn(...i){const g=i.length;for(let m=0;m<g;m++)this[this.currentIndex++]=i[m]}fill(i,g,m){super.fill(i,g,m),m>this.currentIndex&&(this.currentIndex=m)}set(i,g){i>=this.currentIndex&&(this.currentIndex=i+1),this[i]=g}getLength(){return this.currentIndex}setLength(i){this.currentIndex=i,super.length<i&&(super.length=i)}trySetLength(i){i>this.currentIndex&&this.setLength(i)}reset(){this.currentIndex=0}slice(i,g){const m=super.slice(i,g);return m.currentIndex=g-i,m}}},cs=hs(Array),fs={get:function(i,g){return"length"===g?i.getLength():i[g]}};class MainThreadArrayItem extends Array{setLength(i){this.length=i,this.currentIndex=i}trySetLength(i){this.length=i,this.currentIndex=i}getLength(){return this.length}}let ds;class ArrayPool{static createTypedArray(i,g){return Tt(i,g)}static getInstance(){return ds}static ensureCapacity(i,g){if(!i.BYTES_PER_ELEMENT)return i;if(i.length>=g)return i;const m=new i.constructor(g+Math.ceil(.5*g)),_=i.getLength();for(let g=0;g<_;g++)m[g]=i[g];return m.currentIndex=i.currentIndex,m}static getArray(i){let g;if(i){const m=hs(i);g=new m(1048576/m.BYTES_PER_ELEMENT)}else g=new cs;return g.push=(...i)=>{g.pushIn(...i)},g}static getProxyArray(){const i=new cs,g=new Proxy(i,fs);return g.push=(...g)=>{i.pushIn(...g)},g._origin=i,g}constructor(){this._arrays=[],this._index=0,this._proxiedArrays=[],this._proxiedIndex=0,this._typedArrays={}}getProxy(){if(!ls){const i=new MainThreadArrayItem;return i.currentIndex=0,i}const i=this._proxiedArrays[this._proxiedIndex]=this._proxiedArrays[this._proxiedIndex]||ArrayPool.getProxyArray();return i.reset(),this._proxiedIndex++,i}get(i){if(!ls){const i=new MainThreadArrayItem;return i.currentIndex=0,i}if(i){const g=i.name;let m=this._typedArrays[g];m||(m=this._typedArrays[g]={arrays:[],index:0});const _=m.index,b=m.arrays[_]=m.arrays[_]||ArrayPool.getArray(i);return b.reset(),m.index++,b}const g=this._arrays[this._index]=this._arrays[this._index]||ArrayPool.getArray();return g.reset(),this._index++,g}reset(){this._index=0,this._proxiedIndex=0;for(const i in this._typedArrays)this._typedArrays[i].index=0}}ds=new ArrayPool;const ps="__fea_idx",ms=[],As={},ys={},_s={},vs=[],xs=ArrayPool.getInstance();let bs=!1;const ws=Math.pow(2,17);class VectorPack{static isAtlasLoaded(i,g={}){const{iconAtlas:m}=g;return!!(!i||m&&m.positions[i])}static genFnTypes(i){const g={};for(const m in i)if(Ko(i[m])){const _=(m+"_Fn_0").trim(),b=(m+"Fn").trim(),T=os(m);g[_]=Jo(i[m],T),g[b]=(i,m)=>{let b;As.zoom=i,ys.properties=m;try{b=g[_].evaluateWithoutErrorHandling(As,ys,_s,null,vs)}catch(i){return null}return b}}else if(or(i[m])){const _=(m+"_Fn_0").trim(),b=(m+"Fn").trim();ts(m)?(g[_]=Qt(i[m]),g[b]=(i,m)=>{const b=g[_](i,m);return or(b)?Qt(b)(i,m):b}):(g[_]=Jt(i[m]),g[b]=(i,m)=>{const b=g[_](i,m);return or(b)?Jt(b)(i,m):b})}return g}constructor(i,g,m){this.options=m;const _=[];this.symbolDef=g,this.symbol=Kt(g,(()=>(_[0]=m.zoom,_))),this.styledVectors=[],this.properties={},this._fnTypes=m.fnTypes||VectorPack.genFnTypes(this.symbolDef),or(this.symbolDef.visible)&&(this._visibleFn=Qt(this.symbolDef.visible)),m.atlas&&(this.iconAtlas=m.atlas.iconAtlas,this.glyphAtlas=m.atlas.glyphAtlas),this.maxAltitude=0,this.features=this._check(i)}needAltitudeAttribute(){const i=Math.max(Math.abs(this.maxPosZ),Math.abs(this.minPosZ));return this.options.forceAltitudeAttribute||i>=ws||this.options.positionType===Float32Array}getPositionFormat(){return this.needAltitudeAttribute()?[{type:Int16Array,width:2,name:"aPosition"},{type:Float32Array,width:1,name:"aAltitude"}]:[{type:Float32Array,width:3,name:"aPosition"}]}fillPosition(i,g,m,_){if(g<this._minX&&(this._minX=g),g>this._maxX&&(this._maxX=g),m<this._minY&&(this._minY=m),m>this._maxY&&(this._maxY=m),this.needAltitudeAttribute()){let b=i.aPosition.currentIndex;i.aPosition[b++]=g,i.aPosition[b++]=m,i.aPosition.currentIndex=b,b=i.aAltitude.currentIndex,i.aAltitude[b++]=_,i.aAltitude.currentIndex=b}else{pr(ms,g,m,_);let b=i.aPosition.currentIndex;i.aPosition[b++]=ms[0],i.aPosition[b++]=ms[1],i.aPosition[b++]=ms[2],i.aPosition.currentIndex=b}}_check(i){if(!i.length)return i;const g=(ps+"").trim();let m,_=0,b=i[_];for(;!b.geometry;)_++,b=i[_];if(Array.isArray(b.geometry)&&b.properties){let g=b.geometry[0];for(;Array.isArray(g);)g=g[0];g&&!Qn(g.x)&&(m=i)}if(!m)if(m=[],Array.isArray(b.geometry))for(let g=0;g<i.length;g++){const _=Yn({},i[g]);m.push(Mt(_))}else for(let _=0;_<i.length;_++){const b=i[_],T=I(b);for(let i=0;i<T.length;i++){const _=T[i];_[g]=b[g],m.push(_)}}if(this.options.altitudeProperty)for(let i=0;i<m.length;i++){const g=m[i];if(!g||!g.geometry||1!==g.type&&4!==g.type)continue;const _=this.getAltitude(g.properties);if(_)for(let i=0;i<g.geometry.length;i++){const m=g.geometry[i];if(m&&m.length)for(let i=0;i<m.length;i++)m[i].z=(m[i].z||0)+_}}if(this.maxPosZ=0,this.minPosZ=0,!this.options.forceAltitudeAttribute){const i="line"===this.symbolDef.textPlacement;let g=-1/0,_=1/0,b=!1;const{textPitchAlignmentFn:T}=this._fnTypes;!T&&i&&"map"===this.symbolDef.textPitchAlignment&&(b=!0);const P=[];for(let I=0;I<m.length;I++){const[H,W]=Ss(P,m[I]&&m[I].geometry);if(W>g&&(g=W),H<_&&(_=H),i&&!b&&T&&m[I].properties){const i=T(null,m[I].properties);"map"===i&&(b=i)}}this.hasMapPitchAlign=b,this.maxPosZ=g===-1/0?0:g,this.minPosZ=_===1/0?0:_}const T=this.options.order;if(T){const i=[];for(let g=0;g<T.length;g++)T[g]&&i.push(Yo(T[g]));m=m.sort(((g,m)=>{const _=i.length;let b=-1,T=-1;for(let P=0;P<_&&(i[P](g)&&(b=P),i[P](m)&&(T=P),!(b>=0&&b<_&&T>=0&&T<_));P++);return b-T}))}return m}load(i=1){const g=(ps+"").trim(),m="_debug_info".trim(),_=this._fnTypes,b=this.styledVectors;this.count=0;const T=this.features;if(!T||!T.length)return Promise.resolve(null);const P={},I={},H={zoom:this.options.zoom,isVector3D:!!this.options.center,defaultMarkerVerticalAlignment:this.options.defaultMarkerVerticalAlignment},W=[],q=Kt(this.symbolDef,(()=>(W[0]=H.zoom,W)));let $=0,ye=T.length;const Re=this.options.debugIndex;try{for(;$<ye;$++){const i=T[$];if(!i||!i.geometry)continue;if(Jn(Re)&&i[m].index!==Re)continue;i.properties||(i.properties={}),i.properties.$layer=i.layer,i.properties.$type=i.type;const W=this.createStyledVector(i,q,_,H,P,I);W&&W.feature.geometry&&(W.featureIdx=void 0===i[g]?$:i[g],this.count++,b.push(W))}}catch(i){return Promise.reject(i)}return this.options.atlas?Promise.resolve(this.pack(i)):this.loadAtlas(P,I).then((()=>this.pack(i)))}loadAtlas(i,g){return new Promise(((m,_)=>{this.fetchAtlas(i,g,((i,g)=>{if(i)_(i);else{if(g){const{icons:i,glyphs:m}=g;if(i&&Object.keys(i).length){for(const g in i){const m=i[g],{width:_,height:b,data:T}=m.data;m.data=new RGBAImage({width:_,height:b},T)}this.iconAtlas=new IconAtlas(i,{nonPowerOfTwo:!this.options.isWebGL1})}if(m&&Object.keys(m).length){for(const i in m){const g=m[i];for(const i in g){const m=g[i],{width:_,height:b,data:T}=m.bitmap;m.bitmap=new AlphaImage({width:_,height:b},T)}}this.glyphAtlas=new GlyphAtlas(m)}}m({glyphAtlas:this.glyphAtlas,iconAtlas:this.iconAtlas})}}))}))}fetchAtlas(i,g,m){Object.keys(i).length>0||Object.keys(g).length>0?this.options.requestor(i,g,m):m()}pack(i){if(!this.count)return null;if(null==i)throw new Error("layout scale is undefined");const g=this.createDataPack(this.styledVectors,i);if(!g)return null;this.properties.minAltitude=this.minPosZ/100,this.properties.maxAltitude=this.maxPosZ/100,g.properties=this.properties,this.empty&&(g.empty=!0);const m=g.buffers;delete g.buffers;const _={data:g,buffers:m};if(this.iconAtlas){const i=_.data.iconAtlas=Ts(this.iconAtlas);if(i.glyphMap)for(const g in i.glyphMap){m.push(i.glyphMap[g].data.data.buffer)}m.push(_.data.iconAtlas.image.data.buffer)}return this.glyphAtlas&&(_.data.glyphAtlas=Ts(this.glyphAtlas),m.push(_.data.glyphAtlas.image.data.buffer)),_}createStyledVector(i,g,m,_){return new StyledVector(i,g,m,_)}createDataPack(i,g){if(!i||!i.length)return null;this.maxIndex=0,this.maxPos=0,this._minX=this._minY=1/0,this._maxX=this._maxY=-1/0,this.dynamicAttrs={};const m=this.data={};this._arrayPool=xs,xs.reset();let _=this.elements=xs.get();const b=this._dataFormat=this.getFormat(Array.isArray(i[0])?i[0][0].symbol:i[0].symbol),T=this.needAltitudeAttribute()?2:3;for(let i=0;i<b.length;i++)m[b[i].name]=xs.get(b[i].type);let P=xs.get(),I=0;const H=xs.get();let W=0,q=!1,$=!0;const ye=new Set;for(let _=0,b=i.length;_<b;_++){if(!i[_].feature.geometry)continue;const b=Array.isArray(i[_])?i[_][0].feature.id:i[_].feature.id;$&&(void 0!==ys.id?ye&&(ye.has(ys.id)?$=!1:ye.add(ys.id)):$=!1),Jn(b)&&(Math.abs(b)>W&&(W=Math.abs(b)),b<0&&(q=!0));const Re=this.data.aPosition.getLength();if(Array.isArray(i[_]))for(let m=0;m<i[_].length;m++)this._placeVector(i[_][m],g);else this._placeVector(i[_],g);const Be=(m.aPosition.getLength()-Re)/T;for(let g=0;g<Be;g++)P.push(i[_].featureIdx),Jn(b)&&H.push(b);I=Math.max(I,i[_].featureIdx)}if(this.countOutOfAngle>0&&!bs&&(bs=!0,console.warn("text anchor along line is ignored as anchor's line angle is bigger than textMaxAngle.")),this.hasElements()&&!_.getLength())return null;const Re=!!this.options.center?Float32Array:bt(I);P=ArrayPool.createTypedArray(P,Re),b[0].type=this.options.positionType?this.options.positionType:xt(this.maxPos);const Be=this.options.center;if(Be&&(Be[0]||Be[1])){const i=m.aPosition,g=i.getLength();for(let m=0;m<g;m+=T)i[m]-=Be[0],i[m+1]-=Be[1]}const Ge=function(i,g){const m={};for(let _=0;_<i.length;_++){const b=i[_],T=b.type,P=b.name;m[P]=T===Array?g[P]:Tt(g[P],T)}return m}(b,m);Ge.aPickingId=P;const je=[];for(const i in Ge)je.push(Ge[i].buffer);const Xe=vt(this.maxIndex);_=ArrayPool.createTypedArray(_,Xe),je.push(_.buffer);const Ze={data:Ge,isIdUnique:$,is2D:0===this.maxPosZ&&0===this.minPosZ,indices:this.hasElements()?_:null,positionSize:T,positionBounding:[this._minX,this._minY,this._maxX,this._maxY],buffers:je,symbolIndex:this.symbolDef.index||{index:0},dynamicAttributes:this.dynamicAttrs};if(this._packMarkerPlacement&&(Ze.markerPlacement=this._packMarkerPlacement),this._packTextPlacement&&(Ze.textPlacement=this._packTextPlacement),H.getLength()){const i=q?xt(W):bt(W);Ze.featureIds=ArrayPool.createTypedArray(H,i),je.push(Ze.featureIds.buffer)}else Ze.featureIds=[];return Ze.pickingIdIndiceMap=ht(P,Ze.indices),Ze}_placeVector(i,g){this._visibleFn&&!this._visibleFn(this.options.zoom,i.feature.properties)||this.placeVector(i,g,this.formatWidth)}addElements(i,g,m){this.maxIndex=Math.max(this.maxIndex,i,g,m);let _=this.elements.currentIndex;this.elements[_++]=i,this.elements[_++]=g,this.elements[_++]=m,this.elements.currentIndex=_}hasElements(){return!0}getAltitude(i){const{altitudeProperty:g,defaultAltitude:m,altitudeScale:_}=this.options;let b=Je(i,g,m);return _&&(b*=_),this.maxAltitude=Math.max(this.maxAltitude,Math.abs(b)),b}getIconAtlasMaxValue(){const i=this.iconAtlas.positions;let g=0;for(const m in i)if(rr(i,m)){const{tl:_,displaySize:b}=i[m],T=Math.max(_[0],_[1],b[0]-1,b[1]-1);T>g&&(g=T)}return g}ensureDataCapacity(i,g){const m=this._dataFormat;for(let _=0;_<m.length;_++){const b=this.data[m[_].name];if(!b)continue;const T=m[_].width*i,P=b.getLength();this.data[m[_].name]=ArrayPool.ensureCapacity(b,P+T*g)}}}function Ts(i){let g=i.positions,m=i.image&&i.image.format||"alpha";if(i instanceof IconAtlas){g={};for(const m in i.positions){const _=i.positions[m];g[m]={paddedRect:_.paddedRect,pixelRatio:_.pixelRatio,tl:_.tl,br:_.br,displaySize:_.displaySize}}m="rgba"}const _=i.image;return{image:{width:_.width,height:_.height,data:_.data,format:m},glyphMap:i.glyphMap,positions:g}}function Ss(i,g){if(!g)return 0;let m=-1/0,_=1/0;const b=[];if(Array.isArray(g))for(let i=0;i<g.length;i++)if(Array.isArray(g[i])){const[T,P]=Ss(b,g[i]);P>m&&(m=P),T<_&&(_=T)}else{const b=Math.abs(g[i].z||0);b>m&&(m=b),b<_&&(_=b)}else{const i=Math.abs(g.z||0);i>m&&(m=i),i<_&&(_=i)}return i[0]=_,i[1]=m,i}const Ms="___fn_in_stops";function Cs(i,g,m,_){const b="__fn_textSize".trim();let T=i.textSize;if(Qn(g.textSize))return[16,16];i[b]&&(T=i[b]);const P=[];if(P[0]=tr(T)?T(_,m):T,Yt(P[0])){const g=P[0].__fn_key=P[0].__fn_key||JSON.stringify(P[0]);i[Ms]||(i[Ms]={}),i[Ms][g]||(i[Ms][g]=Qt(P[0]));P[0]=(0,i[Ms][g])(_,m)}return P[1]=P[0],P}function Ps(i){const g=i.stops;let m=-1/0;for(let i=0;i<g.length;i++){let _=g[i][1];Kn(g[i][1])&&(_=Ps(g[i][1])),_>m&&(m=_)}return m}const Is=["{","}"],ks="";function Os(i){return i||"Open Sans Regular"}const Es=/\{[\w-]+(?:\|[\w-]+)*\}/g;function Rs(i,g){if(!er(i))return i;function m(i){if(!g)return ks;const m=g[i];return Qn(m)?ks:Array.isArray(m)?m.join():m}const[_,b]=Is,T=Ls(i);for(let g=0,P=T.length;g<P;g++){const P=T[g],I=`${_}${P}${b}`;if(P.indexOf("|")>0){const g=P.split("|");let _=!1;for(let b=0;b<g.length;b++){const T=m(g[b]);if(T!==ks){i=Ds(i,I,T),_=!0;break}}_||(i=Ds(i,I,ks))}else{i=Ds(i,I,m(P))}}return i}function Ls(i){i+=ks;const[g,m]=Is,_=[];let b=!1,T=ks;for(let P=0,I=i.length;P<I;P++){const I=i[P];b||I!==g||(b=!0),I===g&&b&&(T=ks),b&&I!==g&&I!==m&&(T+=I),I===m&&T&&(b=!1,_.push(T),T=ks)}return _}function Ds(i,g,m){if(!i)return i;if(i.replaceAll)return i.replaceAll(g,m);for(;i.indexOf(g)>-1;)i=i.replace(g,m);return i}var Fs=Object.freeze({__proto__:null,EMPTY_STRING:ks,getSDFFont:Os,replaceAll:Ds,resolveExpVarNames:function i(g,m){if(2!==m.length||"get"!==m[0])for(let _=0;_<m.length;_++)2===m[_].length&&"get"===m[_][0]?g.push(m[_][1]):Array.isArray(m[_])&&i(g,m[_]);else g.push(m[1])},resolveText:Rs,resolveText_bak:function(i,g){return er(i)?i.replace(Es,(function(i){if(!g)return"";if((i=i.substring(1,i.length-1)).indexOf("|")>0){const m=i.split("|");for(let i=0;i<m.length;i++){const _=g[m[i]];if(!Qn(_))return _}return""}const m=g[i];return Qn(m)?"":Array.isArray(m)?m.join():m})):i},resolveVarNames:function(i){return i.match(Es)},templateKeys:Ls});const Ns=i=>i>=128&&i<=255,Hs=i=>i>=1536&&i<=1791,Bs=i=>i>=1872&&i<=1919,zs=i=>i>=2208&&i<=2303,Vs=i=>i>=4352&&i<=4607,Us=i=>i>=5120&&i<=5759,Gs=i=>i>=6320&&i<=6399,js=i=>i>=8192&&i<=8303,Ws=i=>i>=8448&&i<=8527,qs=i=>i>=8528&&i<=8591,Xs=i=>i>=8960&&i<=9215,Zs=i=>i>=9216&&i<=9279,$s=i=>i>=9280&&i<=9311,Ys=i=>i>=9312&&i<=9471,Qs=i=>i>=9632&&i<=9727,Js=i=>i>=9728&&i<=9983,Ks=i=>i>=11008&&i<=11263,ea=i=>i>=11904&&i<=12031,ta=i=>i>=12032&&i<=12255,na=i=>i>=12272&&i<=12287,ra=i=>i>=12288&&i<=12351,ia=i=>i>=12352&&i<=12447,oa=i=>i>=12448&&i<=12543,sa=i=>i>=12544&&i<=12591,aa=i=>i>=12592&&i<=12687,la=i=>i>=12688&&i<=12703,ha=i=>i>=12704&&i<=12735,ca=i=>i>=12736&&i<=12783,ua=i=>i>=12784&&i<=12799,fa=i=>i>=12800&&i<=13055,da=i=>i>=13056&&i<=13311,pa=i=>i>=13312&&i<=19903,ga=i=>i>=19904&&i<=19967,ma=i=>i>=19968&&i<=40959,Aa=i=>i>=40960&&i<=42127,ya=i=>i>=42128&&i<=42191,_a=i=>i>=43360&&i<=43391,va=i=>i>=44032&&i<=55215,xa=i=>i>=55216&&i<=55295,ba=i=>i>=57344&&i<=63743,wa=i=>i>=63744&&i<=64255,Ta=i=>i>=64336&&i<=65023,Sa=i=>i>=65040&&i<=65055,Ma=i=>i>=65072&&i<=65103,Ca=i=>i>=65104&&i<=65135,Pa=i=>i>=65136&&i<=65279,Ia=i=>i>=65280&&i<=65519;function ka(i){return!Hs(i)&&(!Bs(i)&&(!zs(i)&&(!Ta(i)&&!Pa(i))))}function Oa(i){return!(i<11904)&&(!!ha(i)||(!!sa(i)||(!!Ma(i)||(!!wa(i)||(!!da(i)||(!!ea(i)||(!!ca(i)||(!!ra(i)||(!!pa(i)||(!!ma(i)||(!!fa(i)||(!!Ia(i)||(!!ia(i)||(!!na(i)||(!!ta(i)||(!!ua(i)||(!!oa(i)||(!!Sa(i)||(!!ya(i)||!!Aa(i))))))))))))))))))))}function Ea(i){return 746===i||747===i||!(i<4352)&&(!!ha(i)||(!!sa(i)||(!(!Ma(i)||i>=65097&&i<=65103)||(!!wa(i)||(!!da(i)||(!!ea(i)||(!!ca(i)||(!(!ra(i)||i>=12296&&i<=12305||i>=12308&&i<=12319||12336===i)||(!!pa(i)||(!!ma(i)||(!!fa(i)||(!!aa(i)||(!!_a(i)||(!!xa(i)||(!!Vs(i)||(!!va(i)||(!!ia(i)||(!!na(i)||(!!la(i)||(!!ta(i)||(!!ua(i)||(!(!oa(i)||12540===i)||(!(!Ia(i)||65288===i||65289===i||65293===i||i>=65306&&i<=65310||65339===i||65341===i||65343===i||i>=65371&&i<=65503||65507===i||i>=65512&&i<=65519)||(!(!Ca(i)||i>=65112&&i<=65118||i>=65123&&i<=65126)||(!!Us(i)||(!!Gs(i)||(!!Sa(i)||(!!ga(i)||(!!Aa(i)||!!ya(i))))))))))))))))))))))))))))))}function Ra(i){return!(Ea(i)||function(i){return!!(Ns(i)&&(167===i||169===i||174===i||177===i||188===i||189===i||190===i||215===i||247===i)||js(i)&&(8214===i||8224===i||8225===i||8240===i||8241===i||8251===i||8252===i||8258===i||8263===i||8264===i||8265===i||8273===i)||Ws(i)||qs(i)||Xs(i)&&(i>=8960&&i<=8967||i>=8972&&i<=8991||i>=8996&&i<=9e3||9003===i||i>=9085&&i<=9114||i>=9150&&i<=9165||9167===i||i>=9169&&i<=9179||i>=9186&&i<=9215)||Zs(i)&&9251!==i||$s(i)||Ys(i)||Qs(i)||Js(i)&&!(i>=9754&&i<=9759)||Ks(i)&&(i>=11026&&i<=11055||i>=11088&&i<=11097||i>=11192&&i<=11243)||ra(i)||oa(i)||ba(i)||Ma(i)||Ca(i)||Ia(i)||8734===i||8756===i||8757===i||i>=9984&&i<=10087||i>=10102&&i<=10131||65532===i||65533===i)}(i))}function La(i){return i>=1424&&i<=2303||Ta(i)||Pa(i)}const Da=[[9,9],[32,32],[5760,5760],[8192,8198],[8200,8202],[8287,12288],[6158,6158],[8203,8205]];function Fa(i){for(const g of Da)if(i>=g[0]&&i<=g[1])return!0;return!1}const Na={"!":"︕","#":"＃",$:"＄","%":"％","&":"＆","(":"︵",")":"︶","*":"＊","+":"＋",",":"︐","-":"︲",".":"・","/":"／",":":"︓",";":"︔","<":"︿","=":"＝",">":"﹀","?":"︖","@":"＠","[":"﹇","\\":"＼","]":"﹈","^":"＾",_:"︳","`":"｀","{":"︷","|":"―","}":"︸","~":"～","¢":"￠","£":"￡","¥":"￥","¦":"￤","¬":"￢","¯":"￣","–":"︲","—":"︱","‘":"﹃","’":"﹄","“":"﹁","”":"﹂","…":"︙","‧":"・","₩":"￦","、":"︑","。":"︒","〈":"︿","〉":"﹀","《":"︽","》":"︾","「":"﹁","」":"﹂","『":"﹃","』":"﹄","【":"︻","】":"︼","〔":"︹","〕":"︺","〖":"︗","〗":"︘","！":"︕","（":"︵","）":"︶","，":"︐","－":"︲","．":"・","：":"︓","；":"︔","＜":"︿","＞":"﹀","？":"︖","［":"﹇","］":"﹈","＿":"︳","｛":"︷","｜":"―","｝":"︸","｟":"︵","｠":"︶","｡":"︒","｢":"﹁","｣":"﹂"};const Ha=1,Ba=2;function za(i,g,m,_,b,T,P,I,H,W){let q=i.trim();W===Ba&&(q=function(i){let g="";const m=Array.from(i);for(let i=0;i<m.length;i++){const _=m[i+1].codePointAt(0)||null,b=m[i-1].codePointAt(0)||null;g+=_&&Ra(_)&&!Na[m[i+1]]||b&&Ra(b)&&!Na[m[i-1]]||!Na[m[i]]?m[i]:Na[m[i]]}return g}(q));const $=[],ye={positionedGlyphs:$,text:q,top:I[1],bottom:I[1],left:I[0],right:I[0],writingMode:W};let Re;return Re=function(i,g){const m=[];let _=0;for(let b=0;b<g.length;b++){const T=g[b];m.push(i.substring(_,T)),_=T}return _<i.length&&m.push(i.substring(_,i.length)),m}(q,function(i,g,m,_){if(!m)return[];if(!i)return[];const b=[],T=function(i,g,m,_){let b=0;for(let m=0;m<i.length;m++){const T=_[i.codePointAt(m)];T&&(b+=T.metrics.advance+g)}const T=Math.max(1,Math.ceil(b/m));return b/T}(i,g,m,_);let P=0;for(let m=0;m<i.length;m++){const I=i.codePointAt(m),H=_[I];H&&(H&&!Va[I]&&(P+=H.metrics.advance+g),m<i.length-1&&(Ua[I]||Oa(I))&&b.push(Wa(m+1,P,T,b,ja(I,i.codePointAt(m+1)),!1)))}return qa(Wa(i.length,P,T,b,0,!0))}(q,P,m,g)),function(i,g,m,_,b,T,P,I,H,W){let q=0,$=0,ye=0;const Re=i.positionedGlyphs,Be=.5;for(let i=0;i<m.length;i++){let b=m[i];if(b=b.trim(),!b.length){$-=_;continue}const T=Re.length;for(let i=0;i<b.length;i++){const m=b.codePointAt(i),_=g[m];_&&(Ea(m)&&P!==Ha?(32!==m&&Re.push({glyph:m,x:q,y:0,vertical:!0}),q+=H+I):(32!==m&&Re.push({glyph:m,x:q,y:$,vertical:!1}),q+=_.metrics.advance+I))}if(Re.length!==T){ye=Math.max(q-I,ye),Za(Re,g,T,Re.length-1,Be)}q=0,$-=_}const{horizontalAlign:Ge,verticalAlign:je}=Xa(b,W);!function(i,g,m,_,b,T,P){const I=(g-m)*b,H=-(-_*P+.5)*T;if(!I&&!H)return;for(let g=0;g<i.length;g++)i[g].x+=I,i[g].y+=H}(Re,Be,Ge,je,ye,_,m.length);const Xe=m.length*_;i.top+=-je*Xe,i.bottom=i.top+Xe,i.left+=-Ge*ye,i.right=i.left+ye}(ye,g,Re,_,b,0,W,P,H),!!$.length&&ye}const Va={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},Ua={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function Ga(i,g,m,_){const b=Math.pow(i-g,2);return _?i<g?b/2:2*b:b+Math.abs(m)*m}function ja(i,g){let m=0;return 10===i&&(m-=1e4),40!==i&&65288!==i||(m+=50),41!==g&&65289!==g||(m+=50),m}function Wa(i,g,m,_,b,T){let P=null,I=Ga(g,m,b,T);for(let i=0;i<_.length;i++){const H=_[i],W=Ga(g-H.x,m,b,T)+H.badness;W<=I&&(P=H,I=W)}return{index:i,x:g,priorBreak:P,badness:I}}function qa(i){return i?qa(i.priorBreak).concat(i.index):[]}function Xa(i,g){let m=.5,_=.5;switch(i){case"right":case"top-right":case"bottom-right":m=g?1:0;break;case"left":case"top-left":case"bottom-left":m=g?0:1}switch(i){case"bottom":case"bottom-right":case"bottom-left":_=g?1:0;break;case"top":case"top-right":case"top-left":_=g?0:1}return{horizontalAlign:m,verticalAlign:_}}function Za(i,g,m,_,b){const T=g[i[_].glyph];if(T){const g=(i[_].x+T.metrics.advance)*b;if(!g)return;for(let b=m;b<=_;b++)i[b].x-=g}}function $a(i){if(!function(i){for(const g of i)if(La(g.charCodeAt(0)))return!0;return!1}(i))return i;const g=[],m=[],_=[];let b=0,T=0,P=1,I=1;for(const H of i){const i=H.codePointAt(0);Fa(i)?(_.push(H),b++):(P=La(i)?-1:1,I!==P?(T=b,m.length&&(I>0&&m.reverse(),g.push(...m)),_.length&&(g.splice(T,0,..._),_.length=0),I=P,m.length=0):_.length&&(m.push(..._),_.length=0),m.push(H),b++)}return _.length&&m.push(..._),m.length&&(I>0&&m.reverse(),g.push(...m)),g.reverse().join("")}const Ya=/\{ *([\w_]+) *\}/g,Qa={ellipse:"middle",cross:"middle",x:"middle",triangle:"middle",square:"middle",diamond:"middle",bar:"top",pie:"top",pin:"top",rectangle:"bottom"};class StyledPoint{constructor(i,g,m,_,b){this.feature=i,this.symbolDef=g,this.symbol=m,this.options=b,this._thisReplacer=this._replacer.bind(this),this._fnTypes=_}_replacer(i,g){return this.feature.properties[g]||""}getShape(i,g){if(this._shape)return this._shape;const{markerTypeFn:m,textHorizontalAlignmentFn:_,textVerticalAlignmentFn:b,markerHorizontalAlignmentFn:T,markerVerticalAlignmentFn:P,textWrapWidthFn:I}=this._fnTypes,H={},W=this.symbol,q=this.getIconAndGlyph(),$=this.feature.properties,ye=m?m(null,$):W.markerType;if(q&&q.glyph){const{font:i,text:m}=q.glyph;if(""===m)return null;const T=this.textSize[0]/24,P=24,ye=W.textKeepUpright,Re="map"===W.textRotationAlignment&&"line"===W.textPlacement&&!W.isIconText,Be=g.glyphMap[i],Ge=Ja(_?_(null,$):W.textHorizontalAlignment,b?b(null,$):W.textVerticalAlignment),je=1.2*P,Xe=function(i){for(let g=0;g<i.length;g++)if(!ka(i.charAt(g).charCodeAt(0)))return!1;return!0}(m),Ze=Xe&&W.textLetterSpacing/T||0,Ye=[W.textDx/T||0,W.textDy/T||0],Qe=((I?I(null,$):W.textWrapWidth)||10*P)/T,Je={};Je.horizontal=za(m,Be,Qe,je,Ge,0,Ze,Ye,P,Ha),Xe&&Re&&ye&&(Je.vertical=za(m,Be,Qe,je,Ge,0,Ze,Ye,P,Ba)),H.textShape=Je}if(q&&q.icon){if(!i||!i.positions[q.icon.url])return null;const g=T?T(null,$):W.markerHorizontalAlignment;let m=P?P(null,$):W.markerVerticalAlignment;!m&&ye&&(m=Qa[ye]),m=m||this.options.defaultMarkerVerticalAlignment;const _=Ja(g,m),b=function(i,g,m){let{horizontalAlign:_,verticalAlign:b}=Xa(g,m);m?_=1-_:b=1-b;const T=-2048*_,P=-2048*b;return{image:i,top:P,bottom:P+2048,left:T,right:T+2048}}(i.positions[q.icon.url],_,this.options.isVector3D);this.iconSize||(this.iconSize=b.image.displaySize),H.iconShape=b}return this._shape=H,H}getIconAndGlyph(){if(this.iconGlyph)return this.iconGlyph;const{markerFileFn:i,markerTypeFn:g,markerPathFn:m,markerWidthFn:_,markerHeightFn:b,markerFillFn:T,markerFillPatternFileFn:P,markerFillOpacityFn:I,markerTextFitFn:H,markerTextFitPaddingFn:W,markerLineColorFn:q,markerLineWidthFn:$,markerLineOpacityFn:ye,markerLineDasharrayFn:Re,markerLinePatternFileFn:Be,markerPathWidthFn:Ge,markerPathHeightFn:je,textNameFn:Xe,textFaceNameFn:Ze}=this._fnTypes,{zoom:Ye}=this.options,Qe={},Je=this.symbol,Ke=this.symbolDef,et=this.feature.properties,tt=i?i(null,et):Je.markerFile,at=g?g(null,et):Je.markerType,ht=tt||at||Je.markerPath,gt=!Qn(this.symbolDef.textName);let yt,vt;if(ht){yt=function(i,g,m,_,b,T){if(Qn(g.markerWidth)&&Qn(g.markerHeight))return null;const P="__fn_markerWidth".trim(),I="__fn_markerHeight".trim();let H=g.markerWidth||0,W=g.markerHeight||0;return Kn(H)&&("identity"!==H.type?H=Ps(H):(H=i.markerWidth,i[P]&&(H=i[P](_,m)),Kn(H)&&(H="identity"===H.type?b(_,m):Ps(H)))),Kn(W)&&("identity"!==W.type?W=Ps(W):(W=i.markerHeight,i[I]&&(W=i[I](_,m)),Kn(W)&&(W="identity"===W.type?T(_,m):Ps(W)))),[H,W]}(Je,this.symbolDef,et,Ye,_,b)||[0,0];let i=Je.markerTextFit;if(H&&(i=H(Ye,et)),i&&Ke.textName&&"none"!==i){const g=Ke.textSize;let m=Ke.textName;Yt(m)&&(m=Qt(m)(Ye,et));const _=Rs(m,et);if(_){const m="__fn_textSize".trim(),b="__fn_textSize_0".trim();Yt(g)&&!Ke[m]&&(Ke[b]=Qt(g),Ke[m]=(i,g)=>{const m=Ke[b](i,g);return Yt(m)?Qt(m)(i,g):m});const T=Cs(Ke,Ke,et,Ye);if("width"!==i&&"both"!==i||(yt[0]=T[0]*_.length),"height"!==i&&"both"!==i||(yt[1]=T[1]),T[0]&&T[1]){let i=Je.markerTextFitPadding||[0,0,0,0];W&&(i=W(Ye,et)),yt[0]+=i[1]+i[3],yt[1]+=i[0]+i[2]}}else yt[0]=yt[1]=-1}}if(gt&&(vt=Cs(Je,this.symbolDef,et,Ye)),!vt&&!yt)return Qe;if(yt&&(yt[0]=Math.ceil(yt[0]),yt[1]=Math.ceil(yt[1])),vt&&(vt[0]=Math.ceil(vt[0]),vt[1]=Math.ceil(vt[1])),this.iconSize=yt,this.textSize=vt,ht&&yt[0]>=0&&yt[1]>=0){let i;if(at){const g={};if(g.markerType=at,"path"===at&&(g.markerPath=m?m(null,et):Je.markerPath,g.markerPathWidth=Ge?Ge(null,et):Je.markerPathWidth,g.markerPathHeight=je?je(null,et):Je.markerPathHeight),_){const i=_(null,et);Qn(i)||(g.markerWidth=i)}else Je.markerWidth>=0&&(g.markerWidth=Je.markerWidth);if(b){const i=b(null,et);Qn(i)||(g.markerHeight=i)}else Je.markerHeight>=0&&(g.markerHeight=Je.markerHeight);if(T){const i=T(null,et);Qn(i)||(g.markerFill=i)}else Je.markerFill&&(g.markerFill=Je.markerFill);if(P){const i=P(null,et);Qn(i)||(g.markerFillPatternFile=i)}else Je.markerFillPatternFile&&(g.markerFillPatternFile=Je.markerFillPatternFile);if(I){const i=I(null,et);Qn(i)||(g.markerFillOpacity=i)}else Je.markerFillOpacity>=0&&(g.markerFillOpacity=Je.markerFillOpacity);if(q){const i=q(null,et);Qn(i)||(g.markerLineColor=i)}else Je.markerLineColor&&(g.markerLineColor=Je.markerLineColor);if($){const i=$(null,et);Qn(i)||(g.markerLineWidth=i)}else Je.markerLineWidth>=0&&(g.markerLineWidth=Je.markerLineWidth);if(ye){const i=ye(null,et);Qn(i)||(g.markerLineOpacity=i)}else Je.markerLineOpacity>=0&&(g.markerLineOpacity=Je.markerLineOpacity);if(Re){const i=Re(null,et);Qn(i)||(g.markerLineDasharray=i)}else Je.markerLineDasharray&&(g.markerLineDasharray=Je.markerLineDasharray);if(Be){const i=Be(null,et);Qn(i)||(g.markerLinePatternFile=i)}else Je.markerLinePatternFile&&(g.markerLinePatternFile=Je.markerLinePatternFile);i="vector://"+JSON.stringify(g)}else i=tt?tt.replace(Ya,this._thisReplacer):Je.markerPath?function(i,g,m){if(!i.markerPath)return null;let _=1;const b=function(i){const g={stroke:{stroke:i.markerLineColor,"stroke-width":i.markerLineWidth,"stroke-opacity":i.markerLineOpacity,"stroke-dasharray":null,"stroke-linecap":"butt","stroke-linejoin":"round"},fill:{fill:i.markerFill,"fill-opacity":i.markerFillOpacity}};return 0===g.stroke["stroke-width"]&&(g.stroke["stroke-opacity"]=0),g}(i);Jn(i.markerOpacity)&&(_=i.markerOpacity),Jn(i.opacity)&&(_*=i.opacity);const T={};if(b){for(const i in b.stroke)rr(b.stroke,i)&&(Qn(b.stroke[i])||(T[i]=b.stroke[i]));for(const i in b.fill)rr(b.fill,i)&&(Qn(b.fill[i])||(T[i]=b.fill[i]))}const P=Array.isArray(i.markerPath)?i.markerPath:[i.markerPath];let I;const H=[];for(let i=0;i<P.length;i++)I=er(P[i])?{path:P[i]}:P[i],I=Yn({},I,T),I.d=I.path,delete I.path,H.push(I);const W=['<svg version="1.1"','xmlns="http://www.w3.org/2000/svg"'];_<1&&W.push('opacity="'+_+'"'),i.markerPathWidth&&i.markerPathHeight&&W.push('viewBox="0 0 '+i.markerPathWidth+" "+i.markerPathHeight+'"'),W.push('preserveAspectRatio="none"'),g&&W.push('width="'+g+'"'),m&&W.push('height="'+m+'"'),W.push("><defs></defs>");for(let i=0;i<H.length;i++){let g="<path ";for(const m in H[i])rr(H[i],m)&&(g+=" "+m+'="'+H[i][m]+'"');g+="></path>",W.push(g)}return W.push("</svg>"),"data:image/svg+xml;base64,"+btoa(W.join(" "))}(Je,yt[0],yt[1]):null;Qe.icon={url:i,iconSize:yt,textSize:vt}}if(gt){const i=Xe?Xe(this.options.zoom,et):Je.textName;if(i||0===i){const g=Os(Ze?Ze(null,et):Je.textFaceName);let m=Rs(i,et);m&&m.length&&(m=$a(m),Qe.glyph={font:g,text:m})}}return this.iconGlyph=Qe,Qe}}function Ja(i,g){g&&"middle"!==g||(g="center"),i&&"middle"!==i||(i="center");let m="center"!==g?g:"";return m+="center"!==i?(m.length?"-":"")+i:"",m}
/*!
  	 * From mapbox-gl-js
  	 * MIT License
  	 * https://github.com/mapbox/mapbox-gl-js
  	 */function Ka(i,g,m,_,b){const P=[];let I;for(let H=0;H<i.length;H++){const W=i[H];let q,$=!1;for(let i=0;i<W.length-1;i++){let H=W[i],ye=W[i+1];H.x<g&&ye.x<g||(H.x<g?(I=H,H=new T(g,H.y+(g-H.x)/(ye.x-H.x)*(ye.y-H.y))._round(),H.z=I.z+(g-I.x)/(ye.x-I.x)*(ye.z-I.z),$=!0):ye.x<g&&(I=ye,ye=new T(g,H.y+(g-H.x)/(ye.x-H.x)*(ye.y-H.y))._round(),ye.z=H.z+(g-H.x)/(I.x-H.x)*(I.z-H.z),$=!0),H.y<m&&ye.y<m||(H.y<m?(I=H,H=new T(H.x+(m-H.y)/(ye.y-H.y)*(ye.x-H.x),m)._round(),H.z=I.z+(m-I.y)/(ye.y-I.y)*(ye.z-I.z),$=!0):ye.y<m&&(I=ye,ye=new T(H.x+(m-H.y)/(ye.y-H.y)*(ye.x-H.x),m)._round(),ye.z=H.z+(m-H.y)/(I.y-H.y)*(I.z-H.z),$=!0),H.x>=_&&ye.x>=_||(H.x>=_?(I=H,H=new T(_,H.y+(_-H.x)/(ye.x-H.x)*(ye.y-H.y))._round(),H.z=I.z+(_-I.x)/(ye.x-I.x)*(ye.z-I.z),$=!0):ye.x>=_&&(I=ye,ye=new T(_,H.y+(_-H.x)/(ye.x-H.x)*(ye.y-H.y))._round(),ye.z=H.z+(_-H.x)/(I.x-H.x)*(I.z-H.z),$=!0),H.y>=b&&ye.y>=b||(H.y>=b?(I=H,H=new T(H.x+(b-H.y)/(ye.y-H.y)*(ye.x-H.x),b)._round(),H.z=I.z+(b-I.y)/(ye.y-I.y)*(ye.z-I.z),$=!0):ye.y>=b&&(I=ye,ye=new T(H.x+(b-H.y)/(ye.y-H.y)*(ye.x-H.x),b)._round(),ye.z=H.z+(b-H.y)/(I.y-H.y)*(I.z-H.z),$=!0),q&&H.equals(q[q.length-1])||(q=[H],P.push(q)),$&&(q.clipped=!0),q.push(ye)))))}}return P}class Anchor extends T{constructor(i,g,m,_){super(i,g),this.angle=m,void 0!==_&&(this.segment=_)}clone(){return new Anchor(this.x,this.y,this.angle,this.segment)}}
/*!
  	 * From mapbox-gl-js
  	 * MIT License
  	 * https://github.com/mapbox/mapbox-gl-js
  	 */function el(i,g,m,_,b){if(void 0===g.segment)return!0;let T=g,P=g.segment+1,I=0;for(;I>-m/2;){if(P--,P<0)return!1;I-=i[P].dist(T),T=i[P]}I+=i[P].dist(i[P+1]),P++;const H=[];let W=0;for(;I<m/2;){const g=i[P],m=i[P+1];if(!m)return!1;let T=i[P-1].angleTo(g)-g.angleTo(m);for(T=Math.abs((T+3*Math.PI)%(2*Math.PI)-Math.PI),H.push({distance:I,angleDelta:T}),W+=T;I-H[0].distance>_;)W-=H.shift().angleDelta;if(W>b)return!1;P++,I+=g.dist(m)}return!0}function tl(i,g,m,_,b,T,P,I,H,W,q){const $=function(i,g,m){return i?.6*g*m:0}(_,T,P),ye=function(i){return Math.max(i?i.right-i.left:0,0)}(_),Re=0===i[0].x||i[0].x===H||0===i[0].y||i[0].y===H;g-ye*P<g/4&&(g=ye*P+g/4);return nl(i,Re?g/2*I%g:(ye/2+2*T)*P*I%g,g,$,m,ye*P,Re,!1,H,W,q)}function nl(i,g,m,_,b,T,P,I,H,W,q){let $=0;const ye=T/2,Re=function(i){let g=0;for(let m=0;m<i.length-1;m++)g+=i[m].dist(i[m+1]);return g}(i);let Be=0,Ge=g-m,je=[];for(let g=0;g<i.length-1;g++){const P=i[g],I=i[g+1],Xe=P.dist(I),Ze=I.angleTo(P);for(;Ge+m<Be+Xe;){Ge+=m;const Ye=(Ge-Be)/Xe,Qe=rl(P.x,I.x,Ye),Je=rl(P.y,I.y,Ye),Ke=rl(P.z||0,I.z||0,Ye);if(Qe>=0&&Qe<H&&Je>=0&&Je<H&&Ge-ye>=0&&Ge+ye<=Re){const m=new Anchor(Qe,Je,Ze,g);m.z=Ke,W&&(m.axis=[P.y-Je,Qe-P.x],m.angleR=Ke===(P.z||0)?0:Math.atan(.9*(Ke-(P.z||0))*q/P.dist(m))),m.line=i,m._round(),!_||el(i,m,T,_,b)?je.push(m):_&&$++}}Be+=Xe}return I||je.length||P||(je=nl(i,Be/2,m,_,b,T,P,!0,H,W,q)),je.countOutOfAngle=$,je}function rl(i,g,m){return i*(1-m)+g*m}var il={exports:{}};!function(i){i.exports=function(){function i(i,m,b,T,P){g(i,m,b||0,T||i.length-1,P||_)}function g(i,_,b,T,P){for(;T>b;){if(T-b>600){var I=T-b+1,H=_-b+1,W=Math.log(I),q=.5*Math.exp(2*W/3),$=.5*Math.sqrt(W*q*(I-q)/I)*(H-I/2<0?-1:1);g(i,_,Math.max(b,Math.floor(_-H*q/I+$)),Math.min(T,Math.floor(_+(I-H)*q/I+$)),P)}var ye=i[_],Re=b,Be=T;for(m(i,b,_),P(i[T],ye)>0&&m(i,b,T);Re<Be;){for(m(i,Re,Be),Re++,Be--;P(i[Re],ye)<0;)Re++;for(;P(i[Be],ye)>0;)Be--}0===P(i[b],ye)?m(i,b,Be):m(i,++Be,T),Be<=_&&(b=Be+1),_<=Be&&(T=Be-1)}}function m(i,g,m){var _=i[g];i[g]=i[m],i[m]=_}function _(i,g){return i<g?-1:i>g?1:0}return i}()}(il);var ol=m(il.exports);function sl(i,g){const m=i.length;if(m<=1)return[i];const _=[];let b,T;for(let g=0;g<m;g++){const m=Ye(i[g]);0!==m&&(i[g].area=Math.abs(m),void 0===T&&(T=m<0),T===m<0?(b&&_.push(b),b=[i[g]]):b.push(i[g]))}if(b&&_.push(b),g>1)for(let i=0;i<_.length;i++)_[i].length<=g||(ol(_[i],g,1,_[i].length-1,al),_[i]=_[i].slice(0,g));return _}function al(i,g){return g.area-i.area}class TinyQueue{constructor(i=[],g=ll){if(this.data=i,this.length=this.data.length,this.compare=g,this.length>0)for(let i=(this.length>>1)-1;i>=0;i--)this._down(i)}push(i){this.data.push(i),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const i=this.data[0],g=this.data.pop();return this.length--,this.length>0&&(this.data[0]=g,this._down(0)),i}peek(){return this.data[0]}_up(i){const{data:g,compare:m}=this,_=g[i];for(;i>0;){const b=i-1>>1,T=g[b];if(m(_,T)>=0)break;g[i]=T,i=b}g[i]=_}_down(i){const{data:g,compare:m}=this,_=this.length>>1,b=g[i];for(;i<_;){let _=1+(i<<1),T=g[_];const P=_+1;if(P<this.length&&m(g[P],T)<0&&(_=P,T=g[P]),m(T,b)>=0)break;g[i]=T,i=_}g[i]=b}}function ll(i,g){return i<g?-1:i>g?1:0}function hl(i,g,m){const _=g.distSqr(m);if(0===_)return i.distSqr(g);const b=((i.x-g.x)*(m.x-g.x)+(i.y-g.y)*(m.y-g.y))/_;return i.distSqr(b<0?g:b>1?m:m.sub(g)._mult(b)._add(g))}function cl(i,g=1,m=!1){let _=1/0,b=1/0,P=-1/0,I=-1/0;const H=i[0];for(let i=0;i<H.length;i++){const g=H[i];(!i||g.x<_)&&(_=g.x),(!i||g.y<b)&&(b=g.y),(!i||g.x>P)&&(P=g.x),(!i||g.y>I)&&(I=g.y)}const W=Math.min(P-_,I-b);let q=W/2;const $=new TinyQueue([],ul);if(0===W)return new T(_,b);for(let g=_;g<P;g+=W)for(let m=b;m<I;m+=W)$.push(new fl(g+q,m+q,q,i));let ye=function(i){let g=0,m=0,_=0;const b=i[0];for(let i=0,T=b.length,P=T-1;i<T;P=i++){const T=b[i],I=b[P],H=T.x*I.y-I.x*T.y;m+=(T.x+I.x)*H,_+=(T.y+I.y)*H,g+=3*H}return new fl(m/g,_/g,0,i)}(i),Re=$.length;for(;$.length;){const _=$.pop();(_.d>ye.d||!ye.d)&&(ye=_,m&&console.log("found best %d after %d probes",Math.round(1e4*_.d)/1e4,Re)),_.max-ye.d<=g||(q=_.h/2,$.push(new fl(_.p.x-q,_.p.y-q,q,i)),$.push(new fl(_.p.x+q,_.p.y-q,q,i)),$.push(new fl(_.p.x-q,_.p.y+q,q,i)),$.push(new fl(_.p.x+q,_.p.y+q,q,i)),Re+=4)}return m&&(console.log(`num probes: ${Re}`),console.log(`best distance: ${ye.d}`)),ye.p}function ul(i,g){return g.max-i.max}function fl(i,g,m,_){this.p=new T(i,g),this.h=m,this.d=function(i,g){let m=!1,_=1/0;for(let b=0;b<g.length;b++){const T=g[b];for(let g=0,b=T.length,P=b-1;g<b;P=g++){const b=T[g],I=T[P];b.y>i.y!=I.y>i.y&&i.x<(I.x-b.x)*(i.y-b.y)/(I.y-b.y)+b.x&&(m=!m),_=Math.min(_,hl(i,b,I))}}return(m?1:-1)*Math.sqrt(_)}(this.p,_),this.max=this.d+this.h*Math.SQRT2}function dl(i,g,m,_,b,T,P,I,H,W){const{feature:q,iconSize:$,textSize:ye,symbol:Re}=i,Be=$||ye?24:0,Ge=b*(ye?ye[0]/Be:1);if("line"===P){const i=[];i.countOutOfAngle=0;let b=q.geometry;T&&(b=Ka(q.geometry,0,0,T,T));for(let P=0;P<b.length;P++){const q=tl(b[P],I,m,Re.isIconText?null:_&&_.vertical||_&&_.horizontal||_,0,Be,Re.isIconText?1:Ge,1,T||1/0,H,W);if(Re.textPlacement&&!Re.isIconText)for(let i=0;i<q.length;i++)q[i].startIndex=g.length/3;if(i.push.apply(i,q),Re.textPlacement&&!Re.isIconText)for(let i=0;i<b[P].length;i++)g.push(b[P][i].x,b[P][i].y,b[P][i].z||0);i.countOutOfAngle+=q.countOutOfAngle||0}return i}return pl(q,P,T)}function pl(i,g,m,_,b){const T=[];if(3===i.type){const P=sl(i.geometry,0);for(let i=0;i<P.length;i++){const I=P[i];if("vertex"===g)for(let i=0;i<I.length;i++){const g=I[i];for(let P=0;P<g.length;P++)et(g[P],m)||(T.push(g[P]),_&&(0===P?gl(g[P],g[P],g[i+1],b):gl(g[P],g[P-1],g[P],b)))}else if("vertex-first"===g){const i=I[0];i&&i[0]&&!et(i[0],m)&&(T.push(i[0]),_&&gl(i[0],i[0],i[1],b))}else if("vertex-last"===g||"vertex-firstlast"===g){const i=I[0];if("vertex-firstlast"===g&&i&&i[0]&&!et(i[0],m)&&(T.push(i[0]),_&&gl(i[0],i[0],i[1],b)),i&&i[i.length-1]&&!et(i[i.length-1],m)){const g=i.length-1;T.push(i[g]),_&&gl(i[g],i[g-1],i[g],b)}}else{const i=cl(I,16);et(i,m)||T.push(i)}}}else if(2===i.type)for(let P=0;P<i.geometry.length;P++){const I=i.geometry[P];if("vertex"===g)for(let i=0;i<I.length;i++)et(I[i],m)||(T.push(I[i]),_&&(0===i?gl(I[i],I[i],I[i+1],b):gl(I[i],I[i-1],I[i],b)));else if("vertex-last"===g||"vertex-firstlast"===g){if("vertex-firstlast"!==g||et(I[0],m)||(T.push(I[0]),_&&gl(I[0],I[0],I[1],b)),I&&I[I.length-1]&&!et(I[I.length-1],m)){const i=I.length-1;T.push(I[i]),_&&gl(I[i],I[i-1],I[i],b)}}else et(I[0],m)||(T.push(I[0]),_&&gl(I[0],I[0],I[1],b))}else if(1===i.type)for(let g=0;g<i.geometry.length;g++){const b=i.geometry[g];for(let i=0;i<b.length;i++){const g=b[i];et(g,m)||(_&&(g.xRotation=0,g.yRotation=0,g.zRotation=0),T.push(g))}}return T}function gl(i,g,m,_){if(i.xRotation||i.yRotation||i.zRotation)return i;const b=m.x-g.x,T=g.y-m.y,P=(m.z-g.z)*_,I=Math.atan2(T,b);i.zRotation=I;const H=Math.atan2(P,Math.sqrt(b*b+T*T));return i.xyRotation=H,i}function ml(i,g){const m={},_={},b=[];let T=0;function P(g){b.push(i[g]),T++}function I(i,g,m){const T=_[i];return delete _[i],_[g]=T,b[T].geometry[0].pop(),b[T].geometry[0]=b[T].geometry[0].concat(m[0]),T}function H(i,g,_){const T=m[g];return delete m[g],m[i]=T,b[T].geometry[0].shift(),b[T].geometry[0]=_[0].concat(b[T].geometry[0]),T}function W(i,g,m){const _=m?g[0][g[0].length-1]:g[0][0];return`${i}:${_.x}:${_.y}`}for(let q=0;q<i.length;q++){const $=i[q],ye=$.geometry;if(!ye)continue;const Re=$.properties[g]?$.properties[g].toString():null;if(!Re){P(q);continue}const Be=W(Re,ye),Ge=W(Re,ye,!0);if(Be in _&&Ge in m&&_[Be]!==m[Ge]){const i=H(Be,Ge,ye),g=I(Be,Ge,b[i].geometry);delete m[Be],delete _[Ge],_[W(Re,b[g].geometry,!0)]=g,b[i].geometry=null}else Be in _?I(Be,Ge,ye):Ge in m?H(Be,Ge,ye):(P(q),m[Be]=T-1,_[Ge]=T-1)}return b.filter((i=>i.geometry))}const Al="__index";function yl(i,g,m,_){const b=(Al+"").trim(),T=function(i,g,m,_){const b=(Al+"").trim(),{mergeOnPropertyFn:T}=m;if(!g.mergeOnProperty)return[];if(P=g.mergeOnProperty,!tt(P)&&("string"==typeof P||null!==P.constructor&&P.constructor===String))return[{features:i,property:g.mergeOnProperty}];var P;const I=[],H={},W=[];for(let m=0;m<i.length;m++){i[m][b]=m;const P=i[m].properties=i[m].properties||{};P.$layer=i[m].layer,P.$type=i[m].type;const q=T?T(_,P):g.mergeOnProperty;tt(q)?W.push(i[m]):(void 0===H[q]&&(H[q]=I.length,I.push({features:[],property:q})),I[H[q]].features.push(i[m]))}W.length&&I.push({features:W});return I}(i,g,m,_);if(T.length){const i=[];for(let g=0;g<T.length;g++)i.push(T[g].property?ml(T[g].features,T[g].property):T[g].features);if(1===i.length)return i[0];{let g=[];for(let m=0;m<i.length;m++)g=g.concat(i[m]);return g.sort(((i,g)=>i[b]-g[b])),g}}return[]}const _l=14;class PointPack extends VectorPack{static needMerge(i,g,m){if(!i)return!1;let _="line"===i.textPlacement||"line"===i.markerPlacement;return _||(g.textPlacementFn&&(_="line"===g.textPlacementFn(m)),g.markerPlacementFn&&(_="line"===g.markerPlacementFn(m))),i.mergeOnProperty&&_}static mergeLineFeatures(i,g,m,_){let b=g.textPlacement,T=g.markerPlacement;return m.textPlacementFn&&(b=m.textPlacementFn(_)),m.markerPlacementFn&&(T=m.markerPlacementFn(_)),"line"!==b&&"line"!==T?i:yl(i,g,m,_)}static splitPointSymbol(i,g=0){const m=[];if(Array.isArray(i)){const g=i;for(let i=0;i<g.length;i++)g[i]&&m.push(...PointPack.splitPointSymbol(g[i],i));return m}let _=null,b=null;for(const g in i)0===g.indexOf("marker")?(_=_||{},_[g]=i[g]):0===g.indexOf("text")&&(b=b||{},b[g]=i[g]);return _&&(_.isIconText=!0,i.mergeOnProperty&&(_.mergeOnProperty=i.mergeOnProperty),m.push(_)),b&&(_&&(b.textPlacement=_.markerPlacement,b.textSpacing=_.markerSpacing,b.isIconText=!0),i.mergeOnProperty&&(b.mergeOnProperty=i.mergeOnProperty),m.push(b)),void 0!==i.visible&&(_&&(_.visible=i.visible),b&&(b.visible=i.visible)),_&&(_.markerTextFit&&b&&(_.text={},_.text.textName=b.textName,_.text.textSize=b.textSize),_.index={index:g,type:0}),b&&(b.index={index:g,type:1}),m}static isAtlasLoaded(i,g){const{icon:m,glyph:_}=i,{iconAtlas:b,glyphAtlas:T}=g;if(m&&(!b||!b.positions[m.url]))return!1;if(_){if(!T||!T.positions[_.font])return!1;const i=T.positions[_.font],{text:g}=_;for(const m of g)if(!i[m.codePointAt(0)])return!1}return!0}constructor(i,g,m){super(i,g,m),this._textPlacement=g.textPlacement,this._fnTypes.textPlacementFn&&(this._textPlacement=this._fnTypes.textPlacementFn(this.options.zoom))}createStyledVector(i,g,m,_,b,T){const P=new StyledPoint(i,this.symbolDef,g,m,_),I=P.getIconAndGlyph();if(I.icon&&!this.options.atlas){const{url:i,iconSize:g}=I.icon;b[i]||(b[i]=I.icon.iconSize),b[i][0]<g[0]&&(b[i][0]=g[0]),b[i][1]<g[1]&&(b[i][1]=g[1])}if(I.glyph&&!this.options.atlas){const{font:i,text:g}=I.glyph,m=T[i]=T[i]||{};for(const i of g)m[i.codePointAt(0)]=1;"line"===this._textPlacement&&(T.options={isCharsCompact:!1})}return this.options.allowEmptyPack||I.icon||I.glyph?P:null}getFormat(i){const g="text"===this.options.pluginType,m="line"===this._textPlacement&&!i.isIconText,_=this.getPackSDFFormat(i);_.push(...this._getTextFnTypeFormats()),m||_.push(...this._getMarkerFnTypeFormats());const{markerOpacityFn:b,textOpacityFn:T,markerPitchAlignmentFn:P,textPitchAlignmentFn:I,markerRotationAlignmentFn:H,textRotationAlignmentFn:W,markerRotationFn:q,textRotationFn:$,markerAllowOverlapFn:ye,textAllowOverlapFn:Re,markerIgnorePlacementFn:Be,textIgnorePlacementFn:Ge}=this._fnTypes;return b?_.push({type:Uint8Array,width:2,name:"aColorOpacity"}):T&&_.push({type:Uint8Array,width:1,name:"aColorOpacity"}),(P||I)&&_.push({type:Uint8Array,width:g?1:2,name:"aPitchAlign"}),(H||W)&&_.push({type:Uint8Array,width:g?1:2,name:"aRotationAlign"}),(q||$)&&_.push({type:Uint16Array,width:g?1:2,name:"aRotation"}),(ye||Re||Be||Ge)&&_.push({type:Uint8Array,width:1,name:"aOverlap"}),_}_is3DPitchText(){return this.hasMapPitchAlign}_getTextFnTypeFormats(){const{textFillFn:i,textSizeFn:g,textHaloFillFn:m,textHaloRadiusFn:_,textHaloOpacityFn:b,textDxFn:T,textDyFn:P}=this._fnTypes,I=[];return i&&I.push({type:Uint8Array,width:4,name:"aTextFill"}),g&&I.push({type:Uint8Array,width:1,name:"aTextSize"}),m&&I.push({type:Uint8Array,width:4,name:"aTextHaloFill"}),(_||b)&&I.push({type:Uint8Array,width:2,name:"aTextHalo"}),T&&I.push({type:Int8Array,width:1,name:"aTextDx"}),P&&I.push({type:Int8Array,width:1,name:"aTextDy"}),I}_getMarkerFnTypeFormats(){const{markerWidthFn:i,markerHeightFn:g,markerDxFn:m,markerDyFn:_,textDxFn:b,textDyFn:T}=this._fnTypes,P=[];return i&&P.push({type:this.options.markerWidthType||Uint8Array,width:1,name:"aMarkerWidth"}),g&&P.push({type:this.options.markerHeightType||Uint8Array,width:1,name:"aMarkerHeight"}),(m||b)&&P.push({type:Int8Array,width:1,name:"aMarkerDx"}),(_||T)&&P.push({type:Int8Array,width:1,name:"aMarkerDy"}),P}_prepareFnTypes(){this.iconAtlas||(this._fnTypes.markerWidthFn=this._fnTypes.markerHeightFn=this._fnTypes.markerDxFn=this._fnTypes.markerDyFn=this._fnTypes.markerPitchAlignmentFn=this._fnTypes.markerRotationAlignmentFn=this._fnTypes.markerRotationFn=this._fnTypes.markerAllowOverlapFn=this._fnTypes.markerIgnorePlacementFn=this._fnTypes.markerOpacityFn=null),this.glyphAtlas||(this._fnTypes.textFillFn=this._fnTypes.textSizeFn=this._fnTypes.textHaloFillFn=this._fnTypes.textHaloRadiusFn=this._fnTypes.textHaloOpacityFn=this._fnTypes.textDxFn=this._fnTypes.textDyFn=this._fnTypes.textPitchAlignmentFn=this._fnTypes.textRotationAlignmentFn=this._fnTypes.textRotationFn=this._fnTypes.textAllowOverlapFn=this._fnTypes.textIgnorePlacementFn=this._fnTypes.textOpacityFn=null)}createDataPack(){if(!this.iconAtlas&&!this.glyphAtlas){if(!this.options.allowEmptyPack)return null;this.empty=!0}this._prepareFnTypes(),this.countOutOfAngle=0,this.lineVertex=[];const i=super.createDataPack.apply(this,arguments);return i?(i.lineVertex=new Int16Array(this.lineVertex),i.buffers.push(i.lineVertex.buffer),i):null}placeVector(i,g){const m=i.getShape(this.iconAtlas,this.glyphAtlas);if(!m)return;const{iconShape:_,textShape:b}=m,P=!_||!_.image,I=!b||!b.horizontal&&!b.vertical;if(!this.options.allowEmptyPack&&P&&I)return;const H=this._getAnchors(i,b||_,g);this.countOutOfAngle+=H.countOutOfAngle||0;if(0===H.length)return;const W=this.data,q=this.needAltitudeAttribute()?2:3;let $=this.data.aPosition.getLength()/q;const ye=i.feature.properties,Re="line"===this._textPlacement&&!i.symbol.isIconText,Be=!I,Ge=!P,je=Be&&Re&&function(i){let g=0;for(let m=0;m<i.length;m++)if(Ea(i.charAt(m).charCodeAt(0)))g=0;else if(g++,g>=1)return!1;return!0}(i.getIconAndGlyph().glyph.text)?1:0,{textFillFn:Xe,textSizeFn:Ze,textHaloFillFn:Ye,textHaloRadiusFn:Qe,textHaloOpacityFn:Je,textDxFn:ht,textDyFn:gt,textPitchAlignmentFn:yt,textRotationAlignmentFn:vt,textRotationFn:xt,textAllowOverlapFn:bt,textIgnorePlacementFn:Tt,textOpacityFn:Mt,markerWidthFn:Pt,markerHeightFn:It,markerDxFn:Et,markerDyFn:Lt,markerPitchAlignmentFn:Dt,markerRotationAlignmentFn:Ft,markerRotationFn:Ht,markerAllowOverlapFn:Bt,markerIgnorePlacementFn:zt,markerOpacityFn:Vt}=this._fnTypes;let Ut,Gt,jt,Wt,qt=[0,0,0,0],Xt=_l,Zt=[0,0,0,0],$t=0,Qt=0,Jt=0,Kt=0,en=0,tn=0,nn=0,rn=0,on=0,sn=0,an=0,ln=0,hn=0,cn=0;if(Be){const g=i.getIconAndGlyph().glyph.font;jt=function(i,g,m){const _=i.positionedGlyphs,b=[];for(let P=0;P<_.length;P++){const I=_[P],H=m[I.glyph];if(!H)continue;const W=H.rect;if(!W)continue;const q=4,$=H.metrics.advance/2,ye=H.metrics.height/2,Re=g?[I.x+$,0]:[0,0],Be=g?[0,I.y-ye]:[I.x+$,I.y-ye],Ge=H.metrics.left-q-$+Be[0],je=H.metrics.top-q+Be[1],Xe=Ge+W.w,Ze=je+W.h,Ye=new T(Ge,je),Qe=new T(Xe,je),Je=new T(Ge,Ze),Ke=new T(Xe,Ze);if(g&&I.vertical){const i=new T(-$,$),g=-Math.PI/2,m=new T(5,0);Ye._rotateAround(g,i)._add(m),Qe._rotateAround(g,i)._add(m),Je._rotateAround(g,i)._add(m),Ke._rotateAround(g,i)._add(m)}b.push({tl:Ye,tr:Qe,bl:Je,br:Ke,tex:W,writingMode:i.writingMode,glyphOffset:Re})}return b}(b.horizontal,Re,this.glyphAtlas.positions[g]),Xe&&(qt=Xe(null,ye),Yt(qt)?this.dynamicAttrs.aTextFill=1:qt=cr([],qt)),Ze&&(Xt=Ze(this.options.zoom,ye),tt(Xt)&&(Xt=_l)),Ye&&(Zt=Ye(null,ye),Yt(Zt)?this.dynamicAttrs.aTextHaloFill=1:Zt=cr([],Zt)),Qe&&($t=Qe(null,ye)),Je&&(Qt=255*Je(null,ye)),ht&&(Jt=ht(null,ye)||0),gt&&(Kt=gt(null,ye)||0),yt&&(sn=+("map"===yt(null,ye))),vt&&(ln=+("map"===vt(null,ye))),xt&&(cn=at(xt(null,ye),0,360)*Math.PI/180)}Ge&&(Wt=_?function(i){const g=i.image,m=i.top-1/g.pixelRatio,_=i.left-1/g.pixelRatio,b=i.bottom+1/g.pixelRatio,P=i.right+1/g.pixelRatio;let I,H,W,q;return I=new T(_,m),H=new T(P,m),W=new T(P,b),q=new T(_,b),[{tl:I,tr:H,bl:q,br:W,tex:{x:g.tl[0],y:g.tl[1],w:g.displaySize[0],h:g.displaySize[1]},writingMode:void 0,glyphOffset:[0,0]}]}(_):function(){const i=new T(0,0),g=new T(0,0),m=new T(0,0);return[{tl:i,tr:g,bl:new T(0,0),br:m,tex:{x:0,y:0,w:0,h:0},writingMode:void 0,glyphOffset:[0,0]}]}(),Pt&&(en=Pt(null,ye)),tt(en)&&(en=Wt[0].tex.w),It&&(tn=It(null,ye)),tt(tn)&&(tn=Wt[0].tex.h),Et&&(nn=Et(null,ye)),Lt&&(rn=Lt(null,ye)),Dt&&(on=+("map"===Dt(null,ye))),Ft&&(an=+("map"===Ft(null,ye))),Ht&&(hn=at(Ht(null,ye),0,360)*Math.PI/180)),Yt(Xt)&&(this.dynamicAttrs.aTextSize=1),(Yt($t)||Yt(Qt))&&(this.dynamicAttrs.aTextHalo=1),Yt(en)&&(this.dynamicAttrs.aMarkerWidth=1),Yt(tn)&&(this.dynamicAttrs.aMarkerHeight=1),(Yt(nn)||Yt(Jt))&&(this.dynamicAttrs.aDxDy=1),(Yt(rn)||Yt(Jt))&&(this.dynamicAttrs.aDxDy=1),(Yt(on)||Yt(sn))&&(this.dynamicAttrs.aPitchAlign=1),(Yt(an)||Yt(ln))&&(this.dynamicAttrs.aRotationAlign=1),(Yt(hn)||Yt(cn))&&(this.dynamicAttrs.aRotation=1);(Bt||bt)&&(Bt&&(Ut=Bt(null,ye)||0),!Ut&&bt&&(Ut=bt(null,ye)||0));let un;(zt||Tt)&&(zt&&(Gt=zt(null,ye)||0),!Gt&&Tt&&(Gt=Tt(null,ye)||0));Vt&&(un=255*(Vt(this.options.zoom,ye)||0));let fn=0;Mt&&(fn=255*(Mt(this.options.zoom,ye)||0));const dn=jt&&jt.length||0;this.ensureDataCapacity(4*(dn+(Wt&&Wt.length||0)),H.length);const pn=this.options.EXTENT,{altitudeScale:gn,altitudeProperty:mn,defaultAltitude:An}=this.options,{altitude:yn}=Ke(i.feature,gn,mn,An),_n=this.needAltitudeAttribute(),xn=(i,g,m,_,b,T,P)=>{if(!g)return;const I=i?dn:1;for(let H=0;H<g.length;H++){const q=g[H],{tl:ye,tr:Be,bl:Ge,br:Xe,tex:Ze}=q;let Ye;this._fillPos(W,m,_,b,10*ye.x,10*ye.y,Ze.x,Ze.y+Ze.h,i,P),this._fillTextData(W,Re,I,q.glyphOffset,T,je,T.axis,T.angleR),this._fillFnTypeData(W,qt,Xt,Zt,$t,Qt,Jt,Kt,en,tn,nn,rn,un,fn,on,sn,an,ln,hn,cn,Ut,Gt),this._fillPos(W,m,_,b,10*Be.x,10*Be.y,Ze.x+Ze.w,Ze.y+Ze.h,i,P),this._fillTextData(W,Re,I,q.glyphOffset,T,je,T.axis,T.angleR),this._fillFnTypeData(W,qt,Xt,Zt,$t,Qt,Jt,Kt,en,tn,nn,rn,un,fn,on,sn,an,ln,hn,cn,Ut,Gt),this._fillPos(W,m,_,b,10*Ge.x,10*Ge.y,Ze.x,Ze.y,i,P),this._fillTextData(W,Re,I,q.glyphOffset,T,je,T.axis,T.angleR),this._fillFnTypeData(W,qt,Xt,Zt,$t,Qt,Jt,Kt,en,tn,nn,rn,un,fn,on,sn,an,ln,hn,cn,Ut,Gt),this._fillPos(W,m,_,b,10*Xe.x,10*Xe.y,Ze.x+Ze.w,Ze.y,i,P),this._fillTextData(W,Re,I,q.glyphOffset,T,je,T.axis,T.angleR),this._fillFnTypeData(W,qt,Xt,Zt,$t,Qt,Jt,Kt,en,tn,nn,rn,un,fn,on,sn,an,ln,hn,cn,Ut,Gt),this.addElements($,$+1,$+2),this.addElements($+1,$+2,$+3),$+=4,Ye=_n?Math.max(Math.abs(m),Math.abs(_)):Math.max(Math.abs(m),Math.abs(_),Math.abs(b)),Ye>this.maxPos&&(this.maxPos=Ye)}},bn="text"===this.options.pluginType;for(let i=0;i<H.length;i++){const g=H[i],m=g.z||yn||0;if(pn!==1/0&&et(g,pn))continue;const _=g.x,b=g.y;Ge&&xn(!1,Wt,_,b,m,g),Be&&(bn||xn(!0,jt,_,b,m,g,!0),xn(!0,jt,_,b,m,g,!1))}}_fillPos(i,g,m,_,b,T,P,I,H,W){this.fillPosition(i,g,m,_);let q=i.aShape.currentIndex;i.aShape[q++]=b,i.aShape[q++]=T,i.aShape.currentIndex=q,i.aTexCoord?(q=i.aTexCoord.currentIndex,i.aTexCoord[q++]=P,i.aTexCoord[q++]=I,i.aTexCoord.currentIndex=q):(q=i.aShape.currentIndex,"text"!==this.options.pluginType?(i.aShape[q++]=+!!H+(P<<1),i.aShape[q++]=+!!W+(I<<1)):(i.aShape[q++]=P,i.aShape[q++]=I),i.aShape.currentIndex=q)}_fillTextData(i,g,m,_,b,T,P,I){let H=i.aCount.currentIndex;if(i.aCount[H++]=m,i.aCount.currentIndex=H,g){H=i.aGlyphOffset.currentIndex,i.aGlyphOffset[H++]=_[0],i.aGlyphOffset[H++]=_[1],i.aGlyphOffset.currentIndex=H,this._is3DPitchText()&&(H=i.aPitchRotation.currentIndex,i.aPitchRotation[H++]=P[0],i.aPitchRotation[H++]=P[1],i.aPitchRotation[H++]=I,i.aPitchRotation.currentIndex=H);const g=b.startIndex;H=i.aSegment.currentIndex,i.aSegment[H++]=b.segment+g,i.aSegment[H++]=g,i.aSegment[H++]=b.line.length,i.aSegment.currentIndex=H,H=i.aVertical.currentIndex,i.aVertical[H++]=T,i.aVertical.currentIndex=H}}_fillFnTypeData(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be,Ge,je,Xe,Ze,Ye,Qe,Je){const{textFillFn:Ke,textSizeFn:et,textHaloFillFn:at,textHaloRadiusFn:ht,textDxFn:gt,textDyFn:yt,textPitchAlignmentFn:vt,textRotationAlignmentFn:xt,textRotationFn:bt,textAllowOverlapFn:Tt,textIgnorePlacementFn:Mt,textOpacityFn:Pt,textHaloOpacityFn:It,markerWidthFn:Et,markerHeightFn:Lt,markerDxFn:Dt,markerDyFn:Ft,markerPitchAlignmentFn:Ht,markerRotationAlignmentFn:Bt,markerRotationFn:zt,markerAllowOverlapFn:Vt,markerIgnorePlacementFn:Ut,markerOpacityFn:Gt}=this._fnTypes;if(Ke){let m=i.aTextFill.currentIndex;i.aTextFill[m++]=g[0],i.aTextFill[m++]=g[1],i.aTextFill[m++]=g[2],i.aTextFill[m++]=g[3],i.aTextFill.currentIndex=m}if(et){let g=i.aTextSize.currentIndex;i.aTextSize[g++]=m,i.aTextSize.currentIndex=g}if(at){let g=i.aTextHaloFill.currentIndex;i.aTextHaloFill[g++]=_[0],i.aTextHaloFill[g++]=_[1],i.aTextHaloFill[g++]=_[2],i.aTextHaloFill[g++]=_[3],i.aTextHaloFill.currentIndex=g}if(ht||It){let g=i.aTextHalo.currentIndex;i.aTextHalo[g++]=b||0,i.aTextHalo.currentIndex=g,g=i.aTextHalo.currentIndex,i.aTextHalo[g++]=255*(tt(T)?1:T),i.aTextHalo.currentIndex=g}if(gt){let g=i.aTextDx.currentIndex;i.aTextDx[g++]=P,i.aTextDx.currentIndex=g}if(yt){let g=i.aTextDy.currentIndex;i.aTextDy[g++]=I,i.aTextDy.currentIndex=g}if(Et){let g=i.aMarkerWidth.currentIndex;i.aMarkerWidth[g++]=H,i.aMarkerWidth.currentIndex=g}if(Lt){let g=i.aMarkerHeight.currentIndex;i.aMarkerHeight[g++]=W,i.aMarkerHeight.currentIndex=g}if(Dt){let g=i.aMarkerDx.currentIndex;i.aMarkerDx[g++]=q,i.aMarkerDx.currentIndex=g}if(Ft){let g=i.aMarkerDy.currentIndex;i.aMarkerDy[g++]=$,i.aMarkerDy.currentIndex=g}const jt="text"===this.options.pluginType;if(!jt&&(Gt||Pt)){Gt||(ye=255);let g=i.aColorOpacity.currentIndex;i.aColorOpacity[g++]=ye,i.aColorOpacity.currentIndex=g,g=i.aColorOpacity.currentIndex,i.aColorOpacity[g++]=ye=Pt?Re:255,i.aColorOpacity.currentIndex=g}if(jt&&Pt){let g=i.aColorOpacity.currentIndex;i.aColorOpacity[g++]=Re,i.aColorOpacity.currentIndex=g}if(vt||Ht)if(jt){let g=i.aPitchAlign.currentIndex;i.aPitchAlign[g++]=Ge,i.aPitchAlign.currentIndex=g}else{let g=i.aPitchAlign.currentIndex;i.aPitchAlign[g++]=Be,i.aPitchAlign.currentIndex=g,g=i.aPitchAlign.currentIndex,i.aPitchAlign[g++]=Ge,i.aPitchAlign.currentIndex=g}if(Bt||xt)if(jt){let g=i.aRotationAlign.currentIndex;i.aRotationAlign[g++]=Xe,i.aRotationAlign.currentIndex=g}else{let g=i.aRotationAlign.currentIndex;i.aRotationAlign[g++]=je,i.aRotationAlign.currentIndex=g,g=i.aRotationAlign.currentIndex,i.aRotationAlign[g++]=Xe,i.aRotationAlign.currentIndex=g}if(zt||bt)if(jt){let g=i.aRotation.currentIndex;i.aRotation[g++]=9362*Ye,i.aRotation.currentIndex=g}else{let g=i.aRotation.currentIndex;i.aRotation[g++]=9362*Ze,i.aRotation.currentIndex=g,g=i.aRotation.currentIndex,i.aRotation[g++]=9362*Ye,i.aRotation.currentIndex=g}const Wt=Vt||Tt,qt=Ut||Mt;if(Wt||qt){let g=i.aOverlap.currentIndex;i.aOverlap[g++]=(Wt?8:0)+4*Qe+((qt?2:0)+Je),i.aOverlap.currentIndex=g}b>0&&(this.properties.hasHalo=1)}_getAnchors(i,g,m){const{feature:_,symbol:b}=i,T=this._getPlacement(i,b),P=_.properties,{markerSpacingFn:I,textSpacingFn:H,textMaxAngleFn:W}=this._fnTypes,q=((I?I(null,P):b.markerSpacing)||(H?H(null,P):b.textSpacing)||250)*m;let $=W?W(this.options.zoom,P):b.textMaxAngle;tt($)&&($=80),$*=Math.PI/180;const ye=this.options.EXTENT,Re=this.options.altitudeToTileScale,Be=this._is3DPitchText();return dl(i,this.lineVertex,$,g,m,ye,T,q,Be,Re)}_getPlacement(i,g){let m;return m=this._fnTypes.markerPlacementFn?this._fnTypes.markerPlacementFn(this.options.zoom,i.feature.properties):g.markerPlacement||this._textPlacement,this._packMarkerPlacement||!g.markerPlacement&&!g.isIconText||(this._packMarkerPlacement=m),!this._textPlacement||g.isIconText||this._packTextPlacement||(this._packTextPlacement=m),m}getPackSDFFormat(i){if("line"!==this._textPlacement||i.isIconText)return[...this.getPositionFormat(),{type:Int16Array,width:4,name:"aShape"},{type:Uint8Array,width:1,name:"aCount"}];{const i=[...this.getPositionFormat(),{type:Int16Array,width:2,name:"aShape"},{type:Uint16Array,width:2,name:"aTexCoord"},{type:Uint8Array,width:1,name:"aCount"},{type:Int16Array,width:2,name:"aGlyphOffset"},{type:Uint16Array,width:3,name:"aSegment"},{type:Uint8Array,width:1,name:"aVertical"}];return this._is3DPitchText()&&i.push({type:Float32Array,width:3,name:"aPitchRotation"}),i}}}class Point3{constructor(i){this.x=i.x,this.y=i.y,this.z=i.z||0}clone(){return new Point3(this)}_unit(){return this._div(this.mag()),this}_div(i){return this.x/=i,this.y/=i,this.z/=i,this}_perp(){var i=this.y;return this.y=this.x,this.x=-i,this}mag(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}add(i){return this.clone()._add(i)}sub(i){return this.clone()._sub(i)}_add(i){return this.x+=i.x,this.y+=i.y,this.z+=i.z,this}_sub(i){return this.x-=i.x,this.y-=i.y,this.z-=i.z,this}equals(i){return this.x===i.x&&this.y===i.y&&this.z===i.z}mult(i){return this.clone()._mult(i)}_mult(i){return this.x*=i,this.y*=i,this.z*=i,this}dist(i){return Math.sqrt(this.distSqr(i))}distSqr(i){var g=i.x-this.x,m=i.y-this.y,_=i.z-this.z;return g*g+m*m+_*_}_round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}angleTo(i){return Math.atan2(this.y-i.y,this.x-i.x)}}var vl="undefined"!=typeof Float32Array?Float32Array:Array;function xl(i,g,m,_){return i[0]=g,i[1]=m,i[2]=_,i}function bl(i,g){var m=g[0],_=g[1],b=g[2],T=m*m+_*_+b*b;return T>0&&(T=1/Math.sqrt(T)),i[0]=g[0]*T,i[1]=g[1]*T,i[2]=g[2]*T,i}function wl(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[0],I=m[1],H=m[2];return i[0]=b*H-T*I,i[1]=T*P-_*H,i[2]=_*I-b*P,i}function Tl(i,g,m,_,b){return i[0]=g,i[1]=m,i[2]=_,i[3]=b,i}function Sl(i,g,m){return i[0]=g[0]*m,i[1]=g[1]*m,i[2]=g[2]*m,i[3]=g[3]*m,i}function Ml(i,g,m){return i[0]=g,i[1]=m,i}Math.hypot||(Math.hypot=function(){for(var i=0,g=arguments.length;g--;)i+=arguments[g]*arguments[g];return Math.sqrt(i)}),function(){var i,g=(i=new vl(3),vl!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i)}(),function(){var i,g=(i=new vl(4),vl!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0),i)}();var Cl=function(i){return Math.hypot(i[0],i[1])};!function(){var i,g=(i=new vl(2),vl!=Float32Array&&(i[0]=0,i[1]=0),i)}();const Pl=63,Il=Math.cos(Math.PI/180*37.5),kl=Math.pow(2,16)/1,Ol=new T,El=new T,Rl=new T;class LinePack extends VectorPack{static mergeLineFeatures(i,g,m,_){return yl(i,g,m,_)}constructor(i,g,m){super(i,g,m);let _=!1;const{lineDasharrayFn:b,lineDashColorFn:T}=this._fnTypes;this.hasGradient=this.symbol.lineGradientProperty,b&&(_=function(i,g,m){for(let _=0;_<i.length;_++){if(m(g,i[_].properties))return!0}return!1}(i,this.options.zoom,b),_&&(this.dasharrayFn=b)),this.hasDasharray=Fl(this.symbol.lineDasharray)||_,this.hasDasharray&&T&&(this.dashColorFn=T)}createStyledVector(i,g,m,_,b){const T=new StyledVector(i,g,m,_),P=T.getLineResource();return!this.options.atlas&&P&&(b[P]=[0,0]),T}getFormat(){const{lineWidthFn:i,lineStrokeWidthFn:g,lineStrokeColorFn:m,lineColorFn:_,lineOpacityFn:b,lineDxFn:T,lineDyFn:P,linePatternAnimSpeedFn:I,linePatternGapFn:H}=this._fnTypes,W=[...this.getPositionFormat()];if(W.push(this.iconAtlas||this.hasDasharray?{type:Int8Array,width:3,name:"aExtrude"}:{type:Int8Array,width:2,name:"aExtrude"}),W.push({type:this.options.positionType||Uint16Array,width:1,name:"aLinesofar"}),i&&W.push({type:Uint8Array,width:1,name:"aLineWidth"}),g&&W.push({type:Uint8Array,width:1,name:"aLineStrokeWidth"}),_&&W.push({type:Uint8Array,width:4,name:"aColor"}),m&&W.push({type:Uint8Array,width:4,name:"aStrokeColor"}),b&&W.push({type:Uint8Array,width:1,name:"aOpacity"}),this.dasharrayFn&&W.push({type:Uint8Array,width:4,name:"aDasharray"}),this.dashColorFn&&W.push({type:Uint8Array,width:4,name:"aDashColor"}),this.iconAtlas){const i=this.getIconAtlasMaxValue();W.push({type:i>255?Uint16Array:Uint8Array,width:4,name:"aTexInfo"})}return(T||P)&&W.push({type:Int8Array,width:2,name:"aLineDxDy"}),(I||H)&&W.push({type:Int8Array,width:2,name:"aLinePattern"}),W}placeVector(i){const{lineJoinFn:g,lineCapFn:m,lineWidthFn:_,lineHeightFn:b,lineStrokeWidthFn:T,lineStrokeColorFn:P,lineColorFn:I,lineOpacityFn:H,lineDxFn:W,lineDyFn:q,linePatternAnimSpeedFn:$,linePatternGapFn:ye}=this._fnTypes,Re=this.symbol,Be=i.feature,Ge=Be.properties;let je=Re.lineJoin||"miter",Xe=Re.lineCap||"butt";if(g&&(je=g(this.options.zoom,Ge)||"miter"),m&&(Xe=m(this.options.zoom,Ge)||"butt"),_){let i=_(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aLineWidth=1,i=4),Qn(i)&&(i=4),this.feaLineWidth=+i}else this.feaLineWidth=+Re.lineWidth;if(b){let i=b(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aLineHeight=1),Qn(i)&&(i=this.feaLineWidth),this.feaLineHeight=+i}else this.feaLineHeight=+Re.lineHeight||this.feaLineWidth;if(T){let i=T(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aLineStrokeWidth=1,i=0),Qn(i)&&(i=0),this.feaLineStrokeWidth=i}else this.feaLineStrokeWidth=Re.lineStrokeWidth||0;if(I&&(this.feaColor=I(this.options.zoom,Ge)||[255,255,255,255],Yt(this.feaColor)?(this.dynamicAttrs.aColor=1,this.feaColor=[0,0,0,0]):this.feaColor=cr([],this.feaColor)),P&&(this.feaStrokeColor=P(this.options.zoom,Ge)||[0,0,0,255],Yt(this.feaStrokeColor)?(this.dynamicAttrs.aStrokeColor=1,this.feaStrokeColor=[0,0,0,0]):this.feaStrokeColor=cr([],this.feaStrokeColor)),H){let i=H(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aOpacity=1,i=1),Qn(i)&&(i=1),this.feaOpacity=255*i}if(this.dasharrayFn){let i=this.dasharrayFn(this.options.zoom,Ge)||[0,0,0,0];if(Yt(i)&&(this.dynamicAttrs.aDasharray=1,i=[0,0,0,0]),i.length<4){const g=i;1===i.length?i=[g[0],g[0],g[0],g[0]]:2===i.length?i=[g[0],g[1],g[0],g[1]]:3===i.length&&(i=[g[0],g[1],g[2],g[2]])}this.feaDash=i}if(this.dashColorFn){let i=(this.dashColorFn?this.dashColorFn(this.options.zoom,Ge):this.symbol.lineDashColor)||[0,0,0,0];Yt(i)&&(this.dynamicAttrs.aDashColor=1,i=[0,0,0,0]),i=cr([],i),this.feaDashColor=i}if(this.iconAtlas){const g=i.getLineResource(),m=this.iconAtlas.iconMap[g];if(this.feaTexInfo=this.feaTexInfo||[0,0,0,0],m){const{tl:i,displaySize:m}=this.iconAtlas.positions[g];this.feaTexInfo[0]=i[0]+1,this.feaTexInfo[1]=i[1]+1,this.feaTexInfo[2]=m[0]-3,this.feaTexInfo[3]=m[1]-3}else this.feaTexInfo[0]=this.feaTexInfo[1]=this.feaTexInfo[2]=this.feaTexInfo[3]=0}if(W){let i=W(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aLineDxDy=1,i=0),Qn(i)&&(i=0),this.feaLineDx=i}if(q){let i=q(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aLineDxDy=1,i=0),Qn(i)&&(i=0),this.feaLineDy=i}if($){let i=$(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aLinePatternAnimSpeed=1,i=0),Qn(i)&&(i=0),0!==i&&(this.properties.hasPatternAnim=1),this.feaPatternAnimSpeed=i}if(ye){let i=ye(this.options.zoom,Ge);Yt(i)&&(this.dynamicAttrs.aLinePatternGap=1,i=0),Qn(i)&&(i=0),this.feaLinePatternGap=i}const Ze=this.options.EXTENT;let Ye=Be.geometry;if(Ze!==1/0){Ye=[];const i=[];for(let g=0;g<Be.geometry.length;g++){i[0]=Be.geometry[g];const m=Ka(i,-1,-1,Ze+1,Ze+1);if(3===Be.type&&m.length>1){const i=m[0],g=m[m.length-1];zl(i[0],g[g.length-1])&&(m[0]=g.concat(i.slice(1)),m.length=m.length-1)}Ye.push(...m)}}const Qe=this.needAltitudeAttribute()?2:3;for(let i=0;i<Ye.length;i++){this.offset=this.data.aPosition.getLength()/Qe;this._addLine(Ye[i],Be,je,Xe,2,1.05)}}_hasPattern(){return this.iconAtlas&&this.feaTexInfo[2]&&this.feaTexInfo[3]}_addLine(i,g,m,_,b,T){const P=this._hasPattern()||Fl(this.feaDash)||Fl(this.symbol.lineDasharray),I=this.options.isTube;I&&(i=i.map((i=>new Point3(i)))),this.overscaling=1;const H=this.options.EXTENT;if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.prevVertex=null,this.symbol.lineGradientProperty&&g.properties&&Jn(g.properties.mapbox_clip_start)&&Jn(g.properties.mapbox_clip_end)){this.clipStart=+g.properties.mapbox_clip_start,this.clipEnd=+g.properties.mapbox_clip_end;for(let g=0;g<i.length-1;g++)this.totalDistance+=i[g].dist(i[g+1]);this.updateScaledDistance()}const W=3===g.type&&!i.clipped;let q=i.length;for(;q>=2&&zl(i[q-1],i[q-2]);)q--;let $=0;for(;$<q-1&&zl(i[$],i[$+1]);)$++;if(q<(W?3:2))return;"bevel"===m&&(b=1.05);const ye=this.overscaling<=16?15*H/(512*this.overscaling):0,Re={vertexLength:0,primitiveLength:0,currentNormal:null};let Be,Ge,je,Xe,Ze;this.e1=this.e2=-1,W&&(Be=i[q-2],Ze=i[$].sub(Be)._unit()._perp()),this.ensureDataCapacity(m,q,360,2);for(let g=$;g<q;g++){if(je=g===q-1?W?i[$+1]:void 0:i[g+1],je&&zl(i[g],je))continue;Ze&&(Xe=Ze),Be&&(Ge=Be),Be=i[g],je&&Be.x===je.x&&Be.y===je.y&&(Be.x+=1e-4),Ze=je?je.sub(Be)._unit()._perp():Xe,Re.dir=Ge?Be.sub(Ge)._unit():je.sub(Be)._unit(),Xe=Xe||Ze,Re.currentNormal=Xe;let H=Xe.add(Ze);0===H.x&&0===H.y||H._unit();const Ye=Xe.x*Ze.x+Xe.y*Ze.y,Qe=H.x*Ze.x+H.y*Ze.y,Je=0!==Qe?1/Qe:1/0,Ke=2*Math.sqrt(2-2*Qe),et=Qe<Il&&Ge&&je,tt=Xe.x*Ze.y-Xe.y*Ze.x>0;if(!I&&et&&g>$){const i=Be.dist(Ge);if(i>2*ye){const g=Be.sub(Be.sub(Ge)._mult(ye/i)._round());g.z=Be.z,this.updateDistance(Ge,g),this.addCurrentVertex(g,Xe,0,0,Re),Ge=g}}const at=Ge&&je;Re.middleVertex=at;let ht=at?m:W?"butt":_;if(at&&"round"===ht&&(Je<T?ht="miter":Je<=2&&(ht="fakeround")),"miter"===ht&&Je>b&&!I&&(ht="bevel"),"bevel"===ht&&(Je>2&&(ht="flipbevel"),Je<b&&(ht="miter")),Ge&&this.updateDistance(Ge,Be),"miter"===ht)I?(this.addCurrentVertex(Be,Xe,0,0,Re),Re.dir=je.sub(Be)._unit(),this.addCurrentVertex(Be,Ze,0,0,Re)):(H._mult(Je),this.addCurrentVertex(Be,H,0,0,Re),P&&(Re.currentNormal=Ze,Re.dir=je.sub(Be)._unit(),this.addCurrentVertex(Be,H,0,0,Re)));else if("flipbevel"===ht){if(Je>100)H=Ze.mult(-1);else{const i=Je*Xe.add(Ze).mag()/Xe.sub(Ze).mag();H._perp()._mult(i*(tt?-1:1))}this.addCurrentVertex(Be,H,0,0,Re),this.addCurrentVertex(Be,H.mult(-1),0,0,Re)}else if("bevel"===ht||"fakeround"===ht){const i=-Math.sqrt(Je*Je-1),g=tt?i:0,m=tt?0:i;if(Ge&&this.addCurrentVertex(Be,Xe,g,m,Re),"fakeround"===ht){const i=Math.round(180*Ke/Math.PI/20);for(let g=1;g<i;g++){let m=g/i;if(.5!==m){const i=m-.5;m+=m*i*(m-1)*((1.0904+Ye*(Ye*(3.55645-1.43519*Ye)-3.2452))*i*i+(.848013+Ye*(.215638*Ye-1.06021)))}const _=Ze.sub(Xe)._mult(m)._add(Xe)._unit()._mult(tt?-1:1);this.addHalfVertex(Be,_.x,_.y,!1,tt,0,Re)}}je&&(Re.currentNormal=Ze,Re.dir=je.sub(Be)._unit(),this.addCurrentVertex(Be,Ze,-g,-m,Re))}else if("butt"===ht)this.addCurrentVertex(Be,H,0,0,Re);else if("square"===ht){const i=Ge?1:-1;this.addCurrentVertex(Be,H,i,i,Re)}else"round"===ht&&(Ge&&(this.addCurrentVertex(Be,Xe,0,0,Re),this.addCurrentVertex(Be,Xe,1,1,Re,!0)),je&&(this.addCurrentVertex(Be,Ze,-1,-1,Re,!0),this.addCurrentVertex(Be,Ze,0,0,Re)));if(!I&&et&&g<q-1){const i=Be.dist(je);if(i>2*ye){const g=Be.add(je.sub(Be)._mult(ye/i)._round());g.z=Be.z,this.updateDistance(Be,g),this.addCurrentVertex(g,Ze,0,0,Re),Be=g}}}}ensureDataCapacity(i,g,m,_){const b="round"===i?Math.round(m/20)-1:0;super.ensureDataCapacity((6+b)*_,g)}addCurrentVertex(i,g,m,_,b,T=!1){const P=g.x+g.y*m,I=g.y-g.x*m,H=g.y*_-g.x,W=-g.y-g.x*_;let q=0,$=0;if(b.middleVertex){Ol.x=P,Ol.y=I;const i=b.currentNormal;if(q=Bl(i,Ol,b.dir),0===m&&0===_)$=-q;else{const g=El;g.x=i.x,g.y=i.y,g._mult(-1),Rl.x=H,Rl.y=W,$=Bl(g,Rl,b.dir)}}this.addHalfVertex(i,P,I,T,!1,m,b,q),this.addHalfVertex(i,H,W,T,!0,-_,b,$),this.prevVertex&&zl(i,this.prevVertex)||(this.prevVertex=i),this.distance>kl/2&&0===this.totalDistance&&(this.distance=0,this.updateScaledDistance(),this.addCurrentVertex(i,g,m,_,b,T))}addHalfVertex({x:i,y:g,z:m},_,b,T,P,I,H,W){this.fillData(this.data,i,g,m||0,_,b,T,P,1*this.scaledDistance,W);const q=H.vertexLength++;this.e1>=0&&this.e2>=0&&(this.addElements(this.e1,this.e2,q),H.primitiveLength++),P?this.e2=q:this.e1=q}fillData(i,g,m,_,b,T,P,I,H,W){const{lineWidthFn:q,lineStrokeWidthFn:$,lineStrokeColorFn:ye,lineColorFn:Re,lineOpacityFn:Be,lineDxFn:Ge,lineDyFn:je,linePatternAnimSpeedFn:Xe,linePatternGapFn:Ze}=this._fnTypes;this.fillPosition(i,g,m,_);let Ye=Pl*b;Ye=(Math.sign(Ye)||1)*((Math.floor(Math.abs(Ye))>>1<<1)+ +P);let Qe=Pl*T;Qe=(Math.sign(Qe)||1)*((Math.floor(Math.abs(Qe))>>1<<1)+ +I);let Je=i.aExtrude.currentIndex;i.aExtrude[Je++]=Ye,i.aExtrude[Je++]=Qe,(this.iconAtlas||this.hasDasharray)&&(i.aExtrude[Je++]=Pl*W),i.aExtrude.currentIndex=Je,Je=i.aLinesofar.currentIndex,i.aLinesofar[Je++]=H,i.aLinesofar.currentIndex=Je,q&&(Je=i.aLineWidth.currentIndex,i.aLineWidth[Je++]=Math.round(2*this.feaLineWidth),i.aLineWidth.currentIndex=Je),$&&(Je=i.aLineStrokeWidth.currentIndex,i.aLineStrokeWidth[Je++]=Math.round(2*this.feaLineStrokeWidth),i.aLineStrokeWidth.currentIndex=Je),Re&&(Je=i.aColor.currentIndex,i.aColor[Je++]=this.feaColor[0],i.aColor[Je++]=this.feaColor[1],i.aColor[Je++]=this.feaColor[2],i.aColor[Je++]=this.feaColor[3],i.aColor.currentIndex=Je),ye&&(Je=i.aStrokeColor.currentIndex,i.aStrokeColor[Je++]=this.feaStrokeColor[0],i.aStrokeColor[Je++]=this.feaStrokeColor[1],i.aStrokeColor[Je++]=this.feaStrokeColor[2],i.aStrokeColor[Je++]=this.feaStrokeColor[3],i.aStrokeColor.currentIndex=Je),Be&&(Je=i.aOpacity.currentIndex,i.aOpacity[Je++]=this.feaOpacity,i.aOpacity.currentIndex=Je),this.dasharrayFn&&(Je=i.aDasharray.currentIndex,i.aDasharray[Je++]=this.feaDash[0],i.aDasharray[Je++]=this.feaDash[1],i.aDasharray[Je++]=this.feaDash[2],i.aDasharray[Je++]=this.feaDash[3],i.aDasharray.currentIndex=Je),this.dashColorFn&&(Je=i.aDashColor.currentIndex,i.aDashColor[Je++]=this.feaDashColor[0],i.aDashColor[Je++]=this.feaDashColor[1],i.aDashColor[Je++]=this.feaDashColor[2],i.aDashColor[Je++]=this.feaDashColor[3],i.aDashColor.currentIndex=Je),this.iconAtlas&&(Je=i.aTexInfo.currentIndex,i.aTexInfo[Je++]=this.feaTexInfo[0],i.aTexInfo[Je++]=this.feaTexInfo[1],i.aTexInfo[Je++]=this.feaTexInfo[2],i.aTexInfo[Je++]=this.feaTexInfo[3],i.aTexInfo.currentIndex=Je),(Ge||je)&&(Je=i.aLineDxDy.currentIndex,i.aLineDxDy[Je++]=this.feaLineDx||0,i.aLineDxDy[Je++]=this.feaLineDy||0,i.aLineDxDy.currentIndex=Je),(Xe||Ze)&&(Je=i.aLinePattern.currentIndex,i.aLinePattern[Je++]=127*(this.feaPatternAnimSpeed||0),i.aLinePattern[Je++]=10*(this.feaLinePatternGap||0),i.aLinePattern.currentIndex=Je),this.maxPos=Math.max(this.maxPos,Math.abs(g)+1,Math.abs(m)+1)}addElements(i,g,m){super.addElements(this.offset+i,this.offset+g,this.offset+m)}_filterPolygonEdges(i){const g=this.options.EXTENT,m=this.elements;for(let _=0;_<m.length;_+=3)if(g===1/0||!Dl(this.data.aPosition,m[_],m[_+1],3,g)&&!Dl(this.data.aPosition,m[_+1],m[_+2],3,g)){let g=i.currentIndex;i[g++]=m[_],i[g++]=m[_+1],i[g++]=m[_+2],i.currentIndex=g}}_filterLine(i){if(i.length<=1)return i;const g=[],m=this.options.EXTENT;let _,b=!0;for(_=0;_<i.length-1;_++){const T=Ll(i[_],i[_+1],m);T&&b||(g.push(i[_]),b=T)}return b||g.push(i[_]),g}updateDistance(i,g){if(this.options.isTube){const m=i.dist(g),_=sr(this.options)*(g.z-i.z);this.distance+=Math.sqrt(m*m+_*_)}else this.distance+=i.dist(g);this.updateScaledDistance()}updateScaledDistance(){this.scaledDistance=this.totalDistance>0?(this.clipStart+(this.clipEnd-this.clipStart)*this.distance/this.totalDistance)*(kl-1):this.distance}}function Ll(i,g,m){return m!==1/0&&(i.x<0&&g.x<0||i.x>m&&g.x>m||i.y<0&&g.y<0||i.y>m&&g.y>m)}function Dl(i,g,m,_,b){if(b===1/0)return!1;const T=Math.floor(.5*i[g*_]),P=Math.floor(.5*i[g*_+1]),I=Math.floor(.5*i[m*_]),H=Math.floor(.5*i[m*_+1]);return T===I&&(T<0||T>b)&&P!==H||P===H&&(P<0||P>b)&&T!==I}function Fl(i){if(!Array.isArray(i))return!1;for(let g=0;g<i.length;g++)if(i[g])return!0;return!1}const Nl=[],Hl=[];function Bl(i,g,m){const _=i.mag(),b=g.mag();Ml(Nl,m.x,m.y),Ml(Hl,g.x,g.y);const T=function(i,g){return i[0]*g[0]+i[1]*g[1]}(Nl,Hl);return-Math.sign(T)*Math.sqrt(b*b-_*_)}function zl(i,g){return i.equals(g)&&i.z===g.z}var Vl="undefined"!=typeof Float32Array?Float32Array:Array;function Ul(i,g,m,_){return i[0]=g,i[1]=m,i[2]=_,i}var Gl=function(i,g,m){return i[0]=g[0]-m[0],i[1]=g[1]-m[1],i[2]=g[2]-m[2],i};!function(){var i,g=(i=new Vl(3),Vl!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0),i)}();const jl=[];const Wl=[],ql=[],Xl=[],Zl=[],$l=[],Yl=[],Ql=[];function Jl(i,g,m,_,b,T){Ul(Zl,i[3*g],i[3*g+1],i[3*g+2]),Ul($l,i[3*m],i[3*m+1],i[3*m+2]),Ul(Yl,i[3*_],i[3*_+1],i[3*_+2]);const P=Gl(Wl,Yl,$l),I=Gl(ql,Zl,$l),H=function(i,g,m){var _=g[0],b=g[1],T=g[2],P=m[0],I=m[1],H=m[2];return i[0]=b*H-T*I,i[1]=T*P-_*H,i[2]=_*I-b*P,i}(Xl,P,I);!function(i,g){var m=g[0],_=g[1],b=g[2],T=m*m+_*_+b*b;T>0&&(T=1/Math.sqrt(T),i[0]=g[0]*T,i[1]=g[1]*T,i[2]=g[2]*T)}(Ql,H),b[3*g]=b[3*g]||0,b[3*m]=b[3*m]||0,b[3*_]=b[3*_]||0,b[3*g+1]=b[3*g+1]||0,b[3*m+1]=b[3*m+1]||0,b[3*_+1]=b[3*_+1]||0,b[3*g+2]=b[3*g+2]||0,b[3*m+2]=b[3*m+2]||0,b[3*_+2]=b[3*_+2]||0,b[3*g]+=Ql[0],b[3*m]+=Ql[0],b[3*_]+=Ql[0],b[3*g+1]+=Ql[1],b[3*m+1]+=Ql[1],b[3*_+1]+=Ql[1],b[3*g+2]+=Ql[2],b[3*m+2]+=Ql[2],b[3*_+2]+=Ql[2],T[g]+=1,T[m]+=1,T[_]+=1}const Kl=Math.pow(2,16)/1;const eh=45*Math.PI/100;function th(i,g,m=2){const _=g&&g.length,b=_?g[0]*m:i.length;let T=nh(i,0,b,m,!0);const P=[];if(!T||T.next===T.prev)return P;let I,H,W;if(_&&(T=function(i,g,m,_){const b=[];for(let m=0,T=g.length;m<T;m++){const P=nh(i,g[m]*_,m<T-1?g[m+1]*_:i.length,_,!1);P===P.next&&(P.steiner=!0),b.push(dh(P))}b.sort(hh);for(let i=0;i<b.length;i++)m=ch(b[i],m);return m}(i,g,T,m)),i.length>80*m){I=1/0,H=1/0;let g=-1/0,_=-1/0;for(let T=m;T<b;T+=m){const m=i[T],b=i[T+1];m<I&&(I=m),b<H&&(H=b),m>g&&(g=m),b>_&&(_=b)}W=Math.max(g-I,_-H),W=0!==W?32767/W:0}return ih(T,P,m,I,H,W,0),P}function nh(i,g,m,_,b){let T;if(b===function(i,g,m,_){let b=0;for(let T=g,P=m-_;T<m;T+=_)b+=(i[P]-i[T])*(i[T+1]+i[P+1]),P=T;return b}
/*!
  	 * from @turf/bboxClip
  	 * https://github.com/Turfjs/turf
  	 * MIT LICENSE
  	 */(i,g,m,_)>0)for(let b=g;b<m;b+=_)T=Th(b/_|0,i[b],i[b+1],T);else for(let b=m-_;b>=g;b-=_)T=Th(b/_|0,i[b],i[b+1],T);return T&&yh(T,T.next)&&(Sh(T),T=T.next),T}function rh(i,g){if(!i)return i;g||(g=i);let m,_=i;do{if(m=!1,_.steiner||!yh(_,_.next)&&0!==Ah(_.prev,_,_.next))_=_.next;else{if(Sh(_),_=g=_.prev,_===_.next)break;m=!0}}while(m||_!==g);return g}function ih(i,g,m,_,b,T,P){if(!i)return;!P&&T&&function(i,g,m,_){let b=i;do{0===b.z&&(b.z=fh(b.x,b.y,g,m,_)),b.prevZ=b.prev,b.nextZ=b.next,b=b.next}while(b!==i);b.prevZ.nextZ=null,b.prevZ=null,function(i){let g,m=1;do{let _,b=i;i=null;let T=null;for(g=0;b;){g++;let P=b,I=0;for(let i=0;i<m&&(I++,P=P.nextZ,P);i++);let H=m;for(;I>0||H>0&&P;)0!==I&&(0===H||!P||b.z<=P.z)?(_=b,b=b.nextZ,I--):(_=P,P=P.nextZ,H--),T?T.nextZ=_:i=_,_.prevZ=T,T=_;b=P}T.nextZ=null,m*=2}while(g>1)}(b)}(i,_,b,T);let I=i;for(;i.prev!==i.next;){const H=i.prev,W=i.next;if(T?sh(i,_,b,T):oh(i))g.push(H.i,i.i,W.i),Sh(i),i=W.next,I=W.next;else if((i=W)===I){P?1===P?ih(i=ah(rh(i),g),g,m,_,b,T,2):2===P&&lh(i,g,m,_,b,T):ih(rh(i),g,m,_,b,T,1);break}}}function oh(i){const g=i.prev,m=i,_=i.next;if(Ah(g,m,_)>=0)return!1;const b=g.x,T=m.x,P=_.x,I=g.y,H=m.y,W=_.y,q=Math.min(b,T,P),$=Math.min(I,H,W),ye=Math.max(b,T,P),Re=Math.max(I,H,W);let Be=_.next;for(;Be!==g;){if(Be.x>=q&&Be.x<=ye&&Be.y>=$&&Be.y<=Re&&gh(b,I,T,H,P,W,Be.x,Be.y)&&Ah(Be.prev,Be,Be.next)>=0)return!1;Be=Be.next}return!0}function sh(i,g,m,_){const b=i.prev,T=i,P=i.next;if(Ah(b,T,P)>=0)return!1;const I=b.x,H=T.x,W=P.x,q=b.y,$=T.y,ye=P.y,Re=Math.min(I,H,W),Be=Math.min(q,$,ye),Ge=Math.max(I,H,W),je=Math.max(q,$,ye),Xe=fh(Re,Be,g,m,_),Ze=fh(Ge,je,g,m,_);let Ye=i.prevZ,Qe=i.nextZ;for(;Ye&&Ye.z>=Xe&&Qe&&Qe.z<=Ze;){if(Ye.x>=Re&&Ye.x<=Ge&&Ye.y>=Be&&Ye.y<=je&&Ye!==b&&Ye!==P&&gh(I,q,H,$,W,ye,Ye.x,Ye.y)&&Ah(Ye.prev,Ye,Ye.next)>=0)return!1;if(Ye=Ye.prevZ,Qe.x>=Re&&Qe.x<=Ge&&Qe.y>=Be&&Qe.y<=je&&Qe!==b&&Qe!==P&&gh(I,q,H,$,W,ye,Qe.x,Qe.y)&&Ah(Qe.prev,Qe,Qe.next)>=0)return!1;Qe=Qe.nextZ}for(;Ye&&Ye.z>=Xe;){if(Ye.x>=Re&&Ye.x<=Ge&&Ye.y>=Be&&Ye.y<=je&&Ye!==b&&Ye!==P&&gh(I,q,H,$,W,ye,Ye.x,Ye.y)&&Ah(Ye.prev,Ye,Ye.next)>=0)return!1;Ye=Ye.prevZ}for(;Qe&&Qe.z<=Ze;){if(Qe.x>=Re&&Qe.x<=Ge&&Qe.y>=Be&&Qe.y<=je&&Qe!==b&&Qe!==P&&gh(I,q,H,$,W,ye,Qe.x,Qe.y)&&Ah(Qe.prev,Qe,Qe.next)>=0)return!1;Qe=Qe.nextZ}return!0}function ah(i,g){let m=i;do{const _=m.prev,b=m.next.next;!yh(_,b)&&_h(_,m,m.next,b)&&bh(_,b)&&bh(b,_)&&(g.push(_.i,m.i,b.i),Sh(m),Sh(m.next),m=i=b),m=m.next}while(m!==i);return rh(m)}function lh(i,g,m,_,b,T){let P=i;do{let i=P.next.next;for(;i!==P.prev;){if(P.i!==i.i&&mh(P,i)){let I=wh(P,i);return P=rh(P,P.next),I=rh(I,I.next),ih(P,g,m,_,b,T,0),void ih(I,g,m,_,b,T,0)}i=i.next}P=P.next}while(P!==i)}function hh(i,g){let m=i.x-g.x;if(0===m&&(m=i.y-g.y,0===m)){m=(i.next.y-i.y)/(i.next.x-i.x)-(g.next.y-g.y)/(g.next.x-g.x)}return m}function ch(i,g){const m=function(i,g){let m=g;const _=i.x,b=i.y;let T,P=-1/0;if(yh(i,m))return m;do{if(yh(i,m.next))return m.next;if(b<=m.y&&b>=m.next.y&&m.next.y!==m.y){const i=m.x+(b-m.y)*(m.next.x-m.x)/(m.next.y-m.y);if(i<=_&&i>P&&(P=i,T=m.x<m.next.x?m:m.next,i===_))return T}m=m.next}while(m!==g);if(!T)return null;const I=T,H=T.x,W=T.y;let q=1/0;m=T;do{if(_>=m.x&&m.x>=H&&_!==m.x&&ph(b<W?_:P,b,H,W,b<W?P:_,b,m.x,m.y)){const g=Math.abs(b-m.y)/(_-m.x);bh(m,i)&&(g<q||g===q&&(m.x>T.x||m.x===T.x&&uh(T,m)))&&(T=m,q=g)}m=m.next}while(m!==I);return T}(i,g);if(!m)return g;const _=wh(m,i);return rh(_,_.next),rh(m,m.next)}function uh(i,g){return Ah(i.prev,i,g.prev)<0&&Ah(g.next,i,i.next)<0}function fh(i,g,m,_,b){return(i=1431655765&((i=858993459&((i=252645135&((i=16711935&((i=(i-m)*b|0)|i<<8))|i<<4))|i<<2))|i<<1))|(g=1431655765&((g=858993459&((g=252645135&((g=16711935&((g=(g-_)*b|0)|g<<8))|g<<4))|g<<2))|g<<1))<<1}function dh(i){let g=i,m=i;do{(g.x<m.x||g.x===m.x&&g.y<m.y)&&(m=g),g=g.next}while(g!==i);return m}function ph(i,g,m,_,b,T,P,I){return(b-P)*(g-I)>=(i-P)*(T-I)&&(i-P)*(_-I)>=(m-P)*(g-I)&&(m-P)*(T-I)>=(b-P)*(_-I)}function gh(i,g,m,_,b,T,P,I){return!(i===P&&g===I)&&ph(i,g,m,_,b,T,P,I)}function mh(i,g){return i.next.i!==g.i&&i.prev.i!==g.i&&!function(i,g){let m=i;do{if(m.i!==i.i&&m.next.i!==i.i&&m.i!==g.i&&m.next.i!==g.i&&_h(m,m.next,i,g))return!0;m=m.next}while(m!==i);return!1}(i,g)&&(bh(i,g)&&bh(g,i)&&function(i,g){let m=i,_=!1;const b=(i.x+g.x)/2,T=(i.y+g.y)/2;do{m.y>T!=m.next.y>T&&m.next.y!==m.y&&b<(m.next.x-m.x)*(T-m.y)/(m.next.y-m.y)+m.x&&(_=!_),m=m.next}while(m!==i);return _}(i,g)&&(Ah(i.prev,i,g.prev)||Ah(i,g.prev,g))||yh(i,g)&&Ah(i.prev,i,i.next)>0&&Ah(g.prev,g,g.next)>0)}function Ah(i,g,m){return(g.y-i.y)*(m.x-g.x)-(g.x-i.x)*(m.y-g.y)}function yh(i,g){return i.x===g.x&&i.y===g.y}function _h(i,g,m,_){const b=xh(Ah(i,g,m)),T=xh(Ah(i,g,_)),P=xh(Ah(m,_,i)),I=xh(Ah(m,_,g));return b!==T&&P!==I||(!(0!==b||!vh(i,m,g))||(!(0!==T||!vh(i,_,g))||(!(0!==P||!vh(m,i,_))||!(0!==I||!vh(m,g,_)))))}function vh(i,g,m){return g.x<=Math.max(i.x,m.x)&&g.x>=Math.min(i.x,m.x)&&g.y<=Math.max(i.y,m.y)&&g.y>=Math.min(i.y,m.y)}function xh(i){return i>0?1:i<0?-1:0}function bh(i,g){return Ah(i.prev,i,i.next)<0?Ah(i,g,i.next)>=0&&Ah(i,i.prev,g)>=0:Ah(i,g,i.prev)<0||Ah(i,i.next,g)<0}function wh(i,g){const m=Mh(i.i,i.x,i.y),_=Mh(g.i,g.x,g.y),b=i.next,T=g.prev;return i.next=g,g.prev=i,m.next=b,b.prev=m,_.next=m,m.prev=_,T.next=_,_.prev=T,_}function Th(i,g,m,_){const b=Mh(i,g,m);return _?(b.next=_.next,b.prev=_,_.next.prev=b,_.next=b):(b.prev=b,b.next=b),b}function Sh(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function Mh(i,g,m){return{i,x:g,y:m,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}const Ch=[],Ph=[];function Ih(i,g){var m,_,b,P,I,H,W;for(_=1;_<=8;_*=2){for(m=[],P=!(Oh(b=i[i.length-1],g)&_),I=0;I<i.length;I++){if((W=!(Oh(H=i[I],g)&_))!==P){const i=kh(b,H,_,g);m.push(void 0!==H.x?new T(i[0],i[1]):i)}W&&m.push(H),b=H,P=W}if(!(i=m).length)break}return m}function kh(i,g,m,_){return Ch[0]=void 0===i.x?i[0]:i.x,Ch[1]=void 0===i.y?i[1]:i.y,i=Ch,Ph[0]=void 0===g.x?g[0]:g.x,Ph[1]=void 0===g.y?g[1]:g.y,g=Ph,8&m?[i[0]+(g[0]-i[0])*(_[3]-i[1])/(g[1]-i[1]),_[3]]:4&m?[i[0]+(g[0]-i[0])*(_[1]-i[1])/(g[1]-i[1]),_[1]]:2&m?[_[2],i[1]+(g[1]-i[1])*(_[2]-i[0])/(g[0]-i[0])]:1&m?[_[0],i[1]+(g[1]-i[1])*(_[0]-i[0])/(g[0]-i[0])]:null}function Oh(i,g){Ch[0]=void 0===i.x?i[0]:i.x,Ch[1]=void 0===i.y?i[1]:i.y;var m=0;return(i=Ch)[0]<g[0]?m|=1:i[0]>g[2]&&(m|=2),i[1]<g[1]?m|=4:i[1]>g[3]&&(m|=8),m}const Eh=[0,0,0,0],Rh=-9999999;const Lh=[{type:Int16Array,width:3,name:"aPosition"}];class RoundTubePack extends LinePack{constructor(i,g,m){(g=Yn({},g)).lineJoin="miter",g.lineCap="butt",super(i,g,m),this.options.radialSegments%2==1&&this.options.radialSegments--}getFormat(){const{lineWidthFn:i,lineColorFn:g,lineOpacityFn:m,linePatternAnimSpeedFn:_,linePatternGapFn:b}=this._fnTypes,T=[...this.getPositionFormat(),{type:Int8Array,width:4,name:"aTubeNormal"},{type:this.options.positionType||Uint16Array,width:1,name:"aLinesofar"}];if(this.iconAtlas){T.push({type:Int8Array,width:1,name:"aNormalDistance"});const i=this.getIconAtlasMaxValue();T.push({type:i>255?Uint16Array:Uint8Array,width:4,name:"aTexInfo"})}return i&&T.push({type:Uint16Array,width:1,name:"aLineWidth"}),g&&T.push({type:Uint8Array,width:4,name:"aColor"}),m&&T.push({type:Uint8Array,width:1,name:"aOpacity"}),_&&T.push({type:Int8Array,width:1,name:"aLinePatternAnimSpeed"}),b&&T.push({type:Int8Array,width:1,name:"aLinePatternGap"}),T}ensureDataCapacity(i,g,m,_){return super.ensureDataCapacity(i,g,m,_*(this.options.radialSegments/2))}addHalfVertex(i,g,m,_,b,T,P,I){const{x:H,y:W,z:q}=i,$=1*this.scaledDistance,ye=this.options.radialSegments/2,{x:Re,y:Be,z:Ge}=P.dir,je=function(i,g,m,_,b,T,P,I){xl(Dh,m,_,b),xl(Fh,T,P,0),wl(Nh,Dh,Fh),bl(Fh,Fh),bl(Nh,Nh),Hh[g]||(Hh[g]=[]);const H=Hh[g];for(var W=0;W<g;W++){const m=Math.PI*W/g,_=1-Math.abs(m-0)/(Math.PI/2);H[W]=H[W]||[],Bh(Fh,Nh,H[W],i,m,_*(I?-1:1))}return H}(1,ye,Re,Be,Ge,g,m,b);this.prevVertex&&this.fillTubeElements(b),this.fillData(this.data,H,W,q||0,je,b,$,I)}fillTubeElements(i){const g=this.options.radialSegments/2,m=this.needAltitudeAttribute()?2:3,_=this.data.aPosition.getLength()/m;for(let m=0;m<g;m++){const b=m+_-2*g;let T,P;m===g-1&&i?(T=m+_-2*g+1,P=m+_-2*g-2*g+1):(T=m+_+1,P=m+_+1-2*g),super.addElements(m+_-this.offset,T-this.offset,b-this.offset),super.addElements(b-this.offset,T-this.offset,P-this.offset)}}fillData(i,g,m,_,b,T,P,I){const{lineWidthFn:H,lineColorFn:W,lineOpacityFn:q,linePatternAnimSpeedFn:$,linePatternGapFn:ye}=this._fnTypes,Re=b.length;for(let T=0;T<Re;T++){this.fillPosition(i,g,m,_),Sl(b[T],b[T],Pl);let Re=i.aTubeNormal.currentIndex;for(let g=0;g<b[T].length;g++)i.aTubeNormal[Re++]=b[T][g];if(i.aTubeNormal.currentIndex=Re,Re=i.aLinesofar.currentIndex,i.aLinesofar[Re++]=P,i.aLinesofar.currentIndex=Re,this.iconAtlas&&(Re=i.aNormalDistance.currentIndex,i.aNormalDistance[Re++]=Pl*I,i.aNormalDistance.currentIndex=Re,Re=i.aTexInfo.currentIndex,i.aTexInfo[Re++]=this.feaTexInfo[0],i.aTexInfo[Re++]=this.feaTexInfo[1],i.aTexInfo[Re++]=this.feaTexInfo[2],i.aTexInfo[Re++]=this.feaTexInfo[3],i.aTexInfo.currentIndex=Re),H){const g=lr(this.options.metric);let m=this.feaLineWidth*g;isNaN(m)&&(m=0),Re=i.aLineWidth.currentIndex,i.aLineWidth[Re++]=Math.round(m),i.aLineWidth.currentIndex=Re}W&&(Re=i.aColor.currentIndex,i.aColor[Re++]=this.feaColor[0],i.aColor[Re++]=this.feaColor[1],i.aColor[Re++]=this.feaColor[2],i.aColor[Re++]=this.feaColor[3],i.aColor.currentIndex=Re),q&&(Re=i.aOpacity.currentIndex,i.aOpacity[Re++]=this.feaOpacity,i.aOpacity.currentIndex=Re),$&&(Re=i.aLinePatternAnimSpeed.currentIndex,i.aLinePatternAnimSpeed[Re++]=127*(this.feaPatternAnimSpeed||0),i.aLinePatternAnimSpeed.currentIndex=Re),ye&&(Re=i.aLinePatternGap.currentIndex,i.aLinePatternGap[Re++]=10*(this.feaLinePatternGap||0),i.aLinePatternGap.currentIndex=Re)}this.maxPos=Math.max(this.maxPos,Math.abs(g)+1,Math.abs(m)+1)}createDataPack(i,g){const m=super.createDataPack(i,g);return m&&(m.is2D=!1),m}}const Dh=[],Fh=[],Nh=[],Hh={};function Bh(i,g,m,_,b,T){return Tl(m,_*(Math.cos(b)*i[0]+Math.sin(b)*g[0]),_*(Math.cos(b)*i[1]+Math.sin(b)*g[1]),_*(Math.cos(b)*i[2]+Math.sin(b)*g[2]),T),m}const zh=[],Vh=[],Uh=[],Gh=[],jh=[];function Wh(i,g,m,_,b,T,P,I){xl(Vh,m,_,b),xl(Uh,T,P,0),wl(Gh,Vh,Uh),bl(Uh,Uh),bl(Gh,Gh),Ml(zh,i,g);const H=Cl(zh)/i,W=Math.atan(g/i);let q=Math.PI/2+(Math.PI/2-W);return jh[0]||(jh[0]=[]),Bh(Uh,Gh,jh[0],H,q,I?1:-1),q+=2*W,jh[1]||(jh[1]=[]),Bh(Uh,Gh,jh[1],H,q,I?1:-1),jh}class LRUCache{constructor(i){this.max=i,this.reset()}reset(){return this.data={},this.order=[],this}clear(){this.reset()}add(i,g){return this.has(i)?(this.order.splice(this.order.indexOf(i),1),this.data[i]=g,this.order.push(i)):(this.data[i]=g,this.order.push(i),this.order.length>this.max&&this.getAndRemove(this.order[0])),this}has(i){return i in this.data}keys(){return this.order}getAndRemove(i){if(!this.has(i))return null;const g=this.data[i];return delete this.data[i],this.order.splice(this.order.indexOf(i),1),g}get(i){if(!this.has(i))return null;return this.data[i]}remove(i){return this.has(i)?(delete this.data[i],this.order.splice(this.order.indexOf(i),1),this):this}setMaxSize(i){for(this.max=i;this.order.length>this.max;)this.getAndRemove(this.order[0]);return this}}
/*!
  	 * based on @mapbox/tiny-sdf
  	 * https://github.com/mapbox/tiny-sdf
  	 * @License BSD 2-Clause
  	 */var qh=1e20;function Xh(i,g,m,_,b,T,P){this.fontSize=i||24,this.buffer=void 0===g?3:g,this.cutoff=_||.25,this.fontFamily=b||"sans-serif",this.fontWeight=T||"normal",this.fontStyle=P||"normal",this.radius=m||8;var I=this.size=this.fontSize+2*this.buffer;this.canvas="undefined"==typeof document?new OffscreenCanvas(I,I):document.createElement("canvas"),this.canvas.width=this.canvas.height=I,this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),this.ctx.font=this.fontStyle+" "+this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(I*I),this.gridInner=new Float64Array(I*I),this.f=new Float64Array(I),this.z=new Float64Array(I+1),this.v=new Uint16Array(I),this.middle=Math.round(I/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}function Zh(i,g,m,_,b,T){for(var P=0;P<g;P++)$h(i,P,g,m,_,b,T);for(var I=0;I<m;I++)$h(i,I*g,1,g,_,b,T)}function $h(i,g,m,_,b,T,P){var I,H,W,q;for(T[0]=0,P[0]=-1e20,P[1]=qh,I=0;I<_;I++)b[I]=i[g+I*m];for(I=1,H=0,W=0;I<_;I++){do{W=(b[I]-b[q=T[H]]+I*I-q*q)/(I-q)/2}while(W<=P[H]&&--H>-1);T[++H]=I,P[H]=W,P[H+1]=qh}for(I=0,H=0;I<_;I++){for(;P[H+1]<I;)H++;i[g+I*m]=b[q=T[H]]+(I-q)*(I-q)}}Xh.prototype.draw=function(i,g,m){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.textBaseline="top",this.ctx.fillText(i,this.buffer,this.buffer);for(var _=this.ctx.getImageData(0,0,g,m),b=new Uint8ClampedArray(g*m),T=0;T<g*m;T++){var P=_.data[4*T+3]/255;this.gridOuter[T]=1===P?0:0===P?qh:Math.pow(Math.max(0,.5-P),2),this.gridInner[T]=1===P?qh:0===P?0:Math.pow(Math.max(0,P-.5),2)}for(Zh(this.gridOuter,g,m,this.f,this.v,this.z),Zh(this.gridInner,g,m,this.f,this.v,this.z),T=0;T<g*m;T++){var I=Math.sqrt(this.gridOuter[T])-Math.sqrt(this.gridInner[T]);b[T]=Math.round(255-255*(I/this.radius+this.cutoff))}return b};let Yh=0;function Qh(i){const g={width:i.bitmap.width,height:i.bitmap.height,data:new Uint8ClampedArray(i.bitmap.data)};return{charCode:i.charCode,bitmap:g,metrics:Yn({},i.metrics)}}var Jh=Object.freeze({__proto__:null,calculateSignedArea:Ye,clipPolygon:Ih,convertGeometry:Mt,convertRTLText:$a,generatePickingIndiceIndex:ht,getFeaAltitudeAndHeight:Ke,getIndexArrayType:vt,getPosArrayType:xt,getUnsignedArrayType:bt,packPosition:pr,unpackPosition:function(i,g,m,_){const b=(Math.sign(g)||1)*(Math.abs(g)%gr),T=(Math.sign(m)||1)*(Math.abs(m)%gr),P=Math.floor(Math.abs(g)/gr),I=Math.floor(Math.abs(m)/gr);return i[0]=b,i[1]=T,i[2]=Math.sign(_+1e-5)*(2*P+I)*mr+_,i}});const Kh={},ec={},tc=[];var nc=Object.freeze({__proto__:null,loadSymbolFnTypes:function i(g,m){if(!g)return null;var _=!1;if(Array.isArray(g)){var b,T=[];for(let P=0;P<g.length;P++)(b=i(g[P],m))?(T.push(b),_=!0):T.push(g[P]);return _?T:g}var P={__fn_types_loaded:!0};const I=[];for(const i in g)rr(g,i)&&I.push(i);const H=function(i){Object.defineProperty(P,i,{get:function(){return this["__fn_"+i]||(this["__fn_"+i]=Qt(this["_"+i])),this["__fn_"+i].apply(this,m())},set:function(g){this["_"+i]=g},configurable:!0,enumerable:!0})},W={},q=function(i,g){Object.defineProperty(P,i,{get:function(){this["__fn_"+i]||(this["__fn_"+i]=Jo(this["_"+i],g));const _=m()[0];W.zoom=_;try{return this["__fn_"+i].evaluateWithoutErrorHandling(W,Kh,ec,null,tc)}catch(i){return null}},set:function(g){this["_"+i]=g},configurable:!0,enumerable:!0})};for(let i=0,m=I.length;i<m;i++){const m=I[i];if(Yt(g[m]))_=!0,P["_"+m]=g[m],H(m);else if(Ko(g[m])){_=!0;const i=os(m);P["_"+m]=g[m],q(m,i)}else P[m]=g[m]}return _?P:g}});const rc={polygonPatternFile:1,markerFile:1,markerPlacement:1,markerSpacing:1,textName:1,textFaceName:1,textPlacement:1,textSpacing:1,lineJoin:1,lineCap:1,linePatternFile:1},ic={textHorizontalAlignment:1,textVerticalAlignment:1,textWrapWidth:1,markerHorizontalAlignment:1,markerVerticalAlignment:1},oc={lineDasharray:1,topPolygonFill:1,bottomPolygonFill:1};Object.assign(ic,rc),Object.assign(oc,rc),i.ArrayPool=ArrayPool,i.CirclePack=class CirclePack extends VectorPack{getFormat(){return Lh}placeVector(i,g){const m=this._getAnchors(i,g);if(0===m.length)return;const _=this.data,b=this.getAltitude(i.feature.properties);let T=_.aPosition.getLength()/Lh[0].width;for(let i=0;i<m.length;i++){const g=m[i];_.aPosition.push(2*g.x+0,2*g.y+0,b),_.aPosition.push(2*g.x+1,2*g.y+0,b),_.aPosition.push(2*g.x+1,2*g.y+1,b),_.aPosition.push(2*g.x+0,2*g.y+1,b),this.addElements(T,T+1,T+2),this.addElements(T,T+2,T+3),T+=4;const P=Math.max(Math.abs(2*g.x+1),Math.abs(2*g.y+1));P>this.maxPos&&(this.maxPos=P)}}_getAnchors(i,g){const{feature:m,symbol:_}=i,b=this._getPlacement(i,_),T=m.properties,{markerSpacingFn:P}=this._fnTypes,I=((P?P(null,T):_.markerSpacing)||250)*g;return dl(i,null,null,g,this.options.EXTENT,b,I)}_getPlacement(i,g){return this._fnTypes.markerPlacementFn?this._fnTypes.markerPlacementFn(this.options.zoom,i.feature.properties):g.markerPlacement}},i.DEFAULT_TEX_WIDTH=23.25,i.FilterUtil=ss,i.FuncTypeUtil=nc,i.GlyphAtlas=GlyphAtlas,i.GlyphRequestor=class GlyphRequestor{constructor(i,g=15,m,_){this.entries={},this._cachedFont={},this._cache=new LRUCache(2048,(function(){})),this._framer=i,this._limit=g,this._isCompactChars=m,this._sdfURL=_}_isValidSDFURL(i){return i&&i.indexOf("{stack}")>=0&&i.indexOf("{range}")>0}getGlyphs(i,g){if(!i||!Object.keys(i).length)return void g(null,{glyphs:null});if(this._isValidSDFURL(this._sdfURL))return void this._requestRemoteSDF(i,g);const m=this.entries,_=i.options;let b=!0;_&&(b=!1!==_.isCharsCompact),b=b||this._isCompactChars;const T=(_,T,I)=>{let H=0,W=0;for(const g in i)if("options"!==g){m[g]=m[g]||{},T[g]=T[g]||{};for(const q in i[g]){if(W++,W<=_)continue;const i=b&&!Ea(+q),$=g+":"+q+":"+i;let ye;if(this._cache.has($)?ye=this._cache.get($):(ye=this._tinySDF(m[g],g,q,i),this._cache.add($,ye),H++),ye=Qh(ye),T[g][q]=ye,I.push(ye.bitmap.data.buffer),this._framer&&H>this._limit)return void this._framer(P(W,T,I))}}g(null,{glyphs:T,buffers:I})};function P(i,g,m){return()=>{T(i,g,m)}}T(0,{},[])}_requestRemoteSDF(i,g){const m=[];for(const g in i)for(const _ of i[g])m.push(this._requestGlyph(g,_));Promise.all(m).then((i=>{g(null,i)}))}_requestGlyph(){return Promise.resolve(null)}_tinySDF(i,g,m,_){const b=g;let T=i.tinySDF;const P=_?-1:2;if(!T){let g="400";/bolder/i.test(b)?g="1000":/bold/i.test(b)?g="900":/medium/i.test(b)?g="500":/light/i.test(b)&&(g="200"),T=i.tinySDF=new Xh(24,2,8,.25,b,g)}const I=String.fromCodePoint(m),H=T.ctx.measureText(I),W=Math.round(H.width),q=T.draw(I,W+4,28);if(Yh<4){const i="undefined"!=typeof document&&document.getElementById("sdf-debug-"+Yh++);if(i){i.width=W+4,i.height=T.canvas.height;i.getContext("2d").drawImage(T.canvas,0,0)}}return{charCode:m,bitmap:{width:W+4,height:28,data:q},metrics:{width:W,height:24,left:1,top:-2,advance:W+2+P}}}},i.INVALID_TEX_COORD=Rh,i.IconAtlas=IconAtlas,i.LRUCache=LRUCache,i.LineExtrusionPack=class LineExtrusionPack extends LinePack{constructor(i,g,m){super(i,g,m),this._hasALineHeight=m.altitudeProperty}getFormat(){const{lineColorFn:i,lineWidthFn:g}=this._fnTypes,m=[{type:Math.max(Math.abs(this.maxPosZ),Math.abs(this.minPosZ))>=Math.pow(2,15)?Float32Array:Int16Array,width:3,name:"aPosition"},{type:Uint16Array,width:1,name:"aLinesofar"},{type:Uint8Array,width:1,name:"aUp"},{type:Int16Array,width:3,name:"aExtrudedPosition"},{type:Int8Array,width:2,name:"aExtrude"}];return i&&m.push({type:Uint8Array,width:4,name:"aColor"}),g&&m.push({type:Uint8Array,width:1,name:"aLineWidth"}),this._hasALineHeight&&m.push({type:Float32Array,width:1,name:"aLineHeight"}),m}placeVector(i){const g=i.feature;if(this._hasALineHeight){const{altitudeScale:i,altitudeProperty:m,defaultAltitude:_,heightProperty:b,defaultHeight:T,minHeightProperty:P}=this.options,{altitude:I,height:H}=Ke(g,i,m,_,b,T,P);this.feaAltitude=I,this.feaMinHeight=(I-H)/I*32767,I>this.maxAltitude&&(this.maxAltitude=I)}return super.placeVector(i)}needAltitudeAttribute(){return!1}_addLine(i,g,m,_,b,T){const P=this.data.aPosition.getLength()/3;super._addLine(i,g,m,_,b,T);const I=this.data.aPosition.getLength()/3,H=this.data.aPosition.getLength()/3-this.offset;if(!(3===g.type)&&H>0&&!1!==this.options.side){const i=!1!==this.options.top?1:0,g=i+4;let m=this.data.aPosition.getLength()/3;for(const i in this.data){const g=this.data[i],_=g.getLength()/m;let b=g.currentIndex;for(let i=0;i<_;i++)g[b++]=g[P*_+3*_+i];g.currentIndex=b}m=this.data.aPosition.getLength()/3;for(const i in this.data){const _=this.data[i],b=_.getLength()/m;let T=_.currentIndex;for(let i=0;i<b;i++)_[T++]=_[P*b+b*g+i];_.currentIndex=T}m=this.data.aPosition.getLength()/3;for(const i in this.data){const _=this.data[i],b=_.getLength()/m;let T=_.currentIndex;for(let i=0;i<b;i++)_[T++]=_[P*b+b*(g+3)+i];_.currentIndex=T}super.addElements(i+1,H+1,H),super.addElements(H,H+1,H+2);const _=this.data.aPosition.getLength()/3-this.offset;m=this.data.aPosition.getLength()/3;for(const i in this.data){const g=this.data[i],_=g.getLength()/m;let b=g.currentIndex;for(let i=0;i<_;i++)g[b++]=g[I*_-_+i];g.currentIndex=b}m=this.data.aPosition.getLength()/3;for(const i in this.data){const _=this.data[i],b=_.getLength()/m;let T=_.currentIndex;for(let i=0;i<b;i++)_[T++]=_[I*b-g*b-b+i];_.currentIndex=T}m=this.data.aPosition.getLength()/3;for(const i in this.data){const _=this.data[i],b=_.getLength()/m;let T=_.currentIndex;for(let i=0;i<b;i++)_[T++]=_[I*b-g*b-3*b+i];_.currentIndex=T}super.addElements(_,H-3,_+1),super.addElements(H-3,_+2,_+1)}}fillData(i,g,m,_,b,T,P,I,H){const W=!1!==this.options.top,q=!1!==this.options.side,$=this.feaLineWidth||this.symbol.lineWidth/2*(this.options.EXTENT/this.options.tileSize),ye=Pl*b,Re=Pl*T,Be=$*b+g,Ge=$*T+m;this._fillTop(i,g,m,b,T,P,I,H,Be,Ge,ye,Re),q&&(W&&this._fillTop(i,g,m,b,T,P,I,H,Be,Ge,ye,Re),this._fillTop(i,g,m,b,T,P,I,H,Be,Ge,ye,Re),this._fillBottom(i,g,m,b,T,P,I,H,Be,Ge,ye,Re),this._fillBottom(i,g,m,b,T,P,I,H,Be,Ge,ye,Re)),this.maxPos=Math.max(this.maxPos,Math.abs(g),Math.abs(m))}_fillTop(i,g,m,_,b,T,P,I,H,W,q,$){const{lineColorFn:ye,lineWidthFn:Re}=this._fnTypes;let Be=i.aPosition.currentIndex;i.aPosition[Be++]=g,i.aPosition[Be++]=m,i.aPosition[Be++]=32767,i.aPosition.currentIndex=Be,Be=i.aLinesofar.currentIndex,i.aLinesofar[Be++]=I,i.aLinesofar.currentIndex=Be,Be=i.aUp.currentIndex,i.aUp[Be++]=+P,i.aUp.currentIndex=Be,Be=i.aExtrudedPosition.currentIndex,i.aExtrudedPosition[Be++]=H,i.aExtrudedPosition[Be++]=W,i.aExtrudedPosition[Be++]=1,i.aExtrudedPosition.currentIndex=Be,Be=i.aExtrude.currentIndex,i.aExtrude[Be++]=q,i.aExtrude[Be++]=$,i.aExtrude.push(q,$),ye&&(Be=i.aColor.currentIndex,i.aColor[Be++]=this.feaColor[0],i.aColor[Be++]=this.feaColor[1],i.aColor[Be++]=this.feaColor[2],i.aColor[Be++]=this.feaColor[3],i.aColor.currentIndex=Be),Re&&(Be=i.aLineWidth.currentIndex,i.aLineWidth[Be++]=Math.round(2*this.feaLineWidth),i.aLineWidth.currentIndex=Be),this._hasALineHeight&&(Be=i.aLineHeight.currentIndex,i.aLineHeight[Be++]=this.feaAltitude,i.aLineHeight.currentIndex=Be)}_fillBottom(i,g,m,_,b,T,P,I,H,W,q,$){const{lineColorFn:ye,lineWidthFn:Re}=this._fnTypes;let Be=i.aPosition.currentIndex;i.aPosition[Be++]=g,i.aPosition[Be++]=m,i.aPosition[Be++]=this.feaMinHeight||0,i.aPosition.currentIndex=Be,Be=i.aLinesofar.currentIndex,i.aLinesofar[Be++]=I,i.aLinesofar.currentIndex=Be,Be=i.aUp.currentIndex,i.aUp[Be++]=+P,i.aUp.currentIndex=Be,Be=i.aExtrudedPosition.currentIndex,i.aExtrudedPosition[Be++]=H,i.aExtrudedPosition[Be++]=W,i.aExtrudedPosition[Be++]=1,i.aExtrudedPosition.currentIndex=Be,Be=i.aExtrude.currentIndex,i.aExtrude[Be++]=q,i.aExtrude[Be++]=$,i.aExtrude.push(q,$),ye&&(Be=i.aColor.currentIndex,i.aColor[Be++]=this.feaColor[0],i.aColor[Be++]=this.feaColor[1],i.aColor[Be++]=this.feaColor[2],i.aColor[Be++]=this.feaColor[3],i.aColor.currentIndex=Be),Re&&(Be=i.aLineWidth.currentIndex,i.aLineWidth[Be++]=Math.round(2*this.feaLineWidth),i.aLineWidth.currentIndex=Be),this._hasALineHeight&&(Be=i.aLineHeight.currentIndex,i.aLineHeight[Be++]=this.feaAltitude,i.aLineHeight.currentIndex=Be)}addElements(i,g,m){const _=!1!==this.options.top,b=!1!==this.options.side,T=(_?1:0)+(b?4:0);i*=T,g*=T;if(this.data.aUp[this.offset+(m*=T)+4]){if(_&&super.addElements(g,i,m),b){const i=_?1:0;super.addElements(g+i,m+i,m+i+2),super.addElements(g+i+1,m+i+1+2,g+i+1+2)}}else if(_&&super.addElements(i,m,g),b){const g=_?1:0;super.addElements(i+g,i+g+2,m+g),super.addElements(i+g+1+2,m+g+1+2,m+g+1)}}createDataPack(i,g){this.maxAltitude=0;const m=super.createDataPack(i,g);if(!m)return m;const{data:_,indices:b}=m;this.getFormat().reduce(((i,g)=>(i[g.name]={size:g.width},i)),{}).aPickingId={size:1};const{aExtrudedPosition:T,aPosition:P,aLinesofar:I,aUp:H,aExtrude:W,aColor:q,aLineHeight:$,aLineWidth:ye}=_,Re={},Be=function(i,g){const m=[];m.setLength&&m.setLength(i.length);const _=jl;_.length<i.length/3&&(_.length=i.length/3),_.fill(0,0,i.length/3);const b=void 0===g.length?g:g.length;for(let T=0;T<b/3;T++)void 0===g.length?Jl(i,3*T,3*T+1,3*T+2,m,_):Jl(i,g[3*T],g[3*T+1],g[3*T+2],m,_);for(let i=0;i<m.length;i+=3){const g=_[i/3];0!==g?(m[i]/=g,m[i+1]/=g,m[i+2]/=g):(m[i]=0,m[i+1]=0,m[i+2]=0)}return m}(T,b);let Ge,je=!0;for(let i=0;i<Be.length;i++)Be[i]=-Be[i],Be[i]%1!=0&&(je=!1);if(!1!==this.options.top&&this.symbol.material&&function(i){for(const g in i)if(g.indexOf("Texture")>=0&&i[g])return!0;return!1}(this.symbol.material)&&(Ge=function(i,g,m){const _=256,b=[];for(let T=0;T<i.length;T+=3){const i=g[T/3];b.push(i/_,m[T/3]?1:0)}return b}(T,I,H)),Re.aPosition=P,Ge&&(Re.aTexCoord0=new Float32Array(Ge)),Re.aNormal=je?new Int8Array(Be):new Float32Array(Be),Re.aPickingId=_.aPickingId,Re.aExtrude=W,q&&(Re.aColor=q),ye&&(Re.aLineWidth=ye),$){const i=xt(this.maxAltitude);Re.aLineHeight=new i($)}const Xe=[];for(const i in Re)Xe.push(Re[i].buffer);return m.data=Re,m.buffers=Xe,m}},i.LinePack=LinePack,i.NativeLinePack=class NativeLinePack extends VectorPack{getFormat(){return[...this.getPositionFormat()]}placeVector(i){const g=i.feature,m=3===g.type,_=g.geometry,b=this.elements;m&&(this.elements=this._arrayPool.get());const T=this.needAltitudeAttribute()?2:3;for(let i=0;i<_.length;i++)this.offset=this.data.aPosition.getLength()/T,this._addLine(_[i],g),m&&(this._filterPolygonEdges(b),this.elements=this._arrayPool.get());m&&(this.elements=b)}_addLine(i,g){const m=3===g.type;let _=i.length;for(;_>=2&&i[_-1].equals(i[_-2]);)_--;let b,T,P,I=0;for(;I<_-1&&i[I].equals(i[I+1]);)I++;if(!(_<(m?3:2))){this.distance=0,this.vertexLength=0,this.primitiveLength=0,this.e1=this.e2=this.e3=-1,m&&(b=i[_-2]);for(let g=I;g<_;g++)P=m&&g===_-1?i[I+1]:i[g+1],P&&i[g].equals(P)||(b&&(T=b),b=i[g],T&&(this.distance+=b.dist(T)),this.addCurrentVertex(b,this.distance))}}addCurrentVertex(i,g){const m=this.vertexLength++;this.addLineVertex(this.data,i,g),m>=1&&this.addElements(m-1,m),g>Kl&&(this.distance=0,this.addCurrentVertex(i,this.distance))}addLineVertex(i,g){const m=this.needAltitudeAttribute();this.fillPosition(i,g.x,g.y,g.z||0),this.maxPos=m?Math.max(this.maxPos,Math.abs(g.x),Math.abs(g.y)):Math.max(this.maxPos,Math.abs(g.x),Math.abs(g.y),Math.abs(g.z||0))}addElements(i,g){this.maxIndex=Math.max(this.maxIndex,this.offset+i,this.offset+g);let m=this.elements.currentIndex;this.elements[m++]=this.offset+i,this.elements[m++]=this.offset+g,this.elements.currentIndex=m}_filterPolygonEdges(i){const g=this.options.EXTENT,m=this.elements,_=m.getLength();for(let b=0;b<_;b+=2)if(!Qe(this.data.aPosition,m[b],m[b+1],3,g)){let g=i.currentIndex;i[g++]=m[b],i[g++]=m[b+1],i.currentIndex=g}}},i.NativePointPack=class NativePointPack extends VectorPack{getFormat(){const{markerFillFn:i}=this._fnTypes;let g;return g="line"===this.symbol.markerRotationAlignment?[...this.getPositionFormat(),{type:Float32Array,width:1,name:"aXYRotation"},{type:Float32Array,width:1,name:"aZRotation"}]:[...this.getPositionFormat()],i&&g.push({type:Uint8Array,width:4,name:"aColor"}),g}placeVector(i){const g=i.feature.properties,{markerFillFn:m}=this._fnTypes;let _;m&&(_=m(this.options.zoom,g)||[255,255,255,255],Yt(_)?(this.dynamicAttrs.aColor=1,_=[0,0,0,0]):_=cr([],_));const b=this.data,T="line"===this.symbol.markerRotationAlignment,P=this._getAnchors(i,this.symbol.markerSpacing||250,this.symbol.markerPlacement||"point",T),I=this.needAltitudeAttribute();for(let i=0;i<P.length;i++){const g=P[i];if(this.fillPosition(this.data,g.x,g.y,g.z),T){let i=b.aXYRotation.currentIndex;b.aXYRotation[i++]=g.xyRotation||0,b.aXYRotation.currentIndex=i,i=b.aZRotation.currentIndex,b.aZRotation[i++]=g.zRotation||0,b.aZRotation.currentIndex=i}if(_){let i=b.aColor.currentIndex;b.aColor[i++]=_[0],b.aColor[i++]=_[1],b.aColor[i++]=_[2],b.aColor[i++]=_[3],b.aColor.currentIndex=i}let m;m=I?Math.max(Math.abs(g.x),Math.abs(g.y)):Math.max(Math.abs(g.x),Math.abs(g.y),Math.abs(g.z||0)),m>this.maxPos&&(this.maxPos=m)}}_getAnchors(i,g,m,_){const b=i.feature,T=this.options.EXTENT;if("line"===m){const i=[];let m=b.geometry;T&&(m=Ka(b.geometry,0,0,T,T));for(let _=0;_<m.length;_++){const b=tl(m[_],g,eh,null,0,24,1,1,T||1/0);i.push.apply(i,b)}return i}return pl(b,m,T,_,this.options.altitudeToTileScale)}hasElements(){return!1}},i.PackUtil=Jh,i.PointPack=PointPack,i.PolygonPack=class PolygonPack extends VectorPack{constructor(...i){super(...i),this.lineElements=[]}createStyledVector(i,g,m,_,b){const T=new StyledVector(i,g,m,_),P=T.getPolygonResource();return!this.options.atlas&&P&&(b[P]=[0,0]),T}getFormat(){const i=[...this.getPositionFormat()],{polygonFillFn:g,polygonOpacityFn:m,uvScaleFn:_,uvOffsetFn:b,polygonPatternUVFn:T}=this._fnTypes;if(this.iconAtlas){const g=this.getIconAtlasMaxValue();i.push({type:g>255?Uint16Array:Uint8Array,width:4,name:"aTexInfo"})}return g&&i.push({type:Uint8Array,width:4,name:"aColor"}),m&&i.push({type:Uint8Array,width:1,name:"aOpacity"}),_&&i.push({type:Uint16Array,width:2,name:"aUVScale"}),b&&i.push({type:Uint8Array,width:2,name:"aUVOffset"}),T&&i.push({type:Float32Array,width:2,name:"aTexCoord"}),i}placeVector(i,g){const m=i.feature;this._addPolygon(m.geometry,m,g)}_addPolygon(i,g){let m,_,b,T;const{polygonFillFn:P,polygonOpacityFn:I,uvScaleFn:H,uvOffsetFn:W,uvOffsetInMeterFn:q,polygonPatternUVFn:$}=this._fnTypes,ye=g.properties;P&&(m=P(this.options.zoom,ye)||Tl([],255,255,255,255),Yt(m)?(this.dynamicAttrs.aColor=1,m=Eh):m=cr([],m)),I&&(_=I(this.options.zoom,ye),Yt(_)?(this.dynamicAttrs.aOpacity=1,_=255):(Qn(_)&&(_=1),_*=255)),H&&(b=H(this.options.zoom,ye),Yt(b)?(b=[255,255],this.dynamicAttrs.aUVScale=1):(Qn(b)&&(b=[1,1]),b=[255*b[0],255*b[1]])),W&&(q&&q(null,ye)?T=[0,0]:(T=W(this.options.zoom,ye),Yt(T)?(T=[0,0],this.dynamicAttrs.aUVOffset=1):(Qn(T)&&(T=[0,0]),T=[255*T[0],255*T[1]])));const Re=!!this.iconAtlas,Be=sl(i,500),Ge=[0,0],je=[0,0];if(Re){const{polygonPatternFileFn:i}=this._fnTypes,g=i?i(null,ye):this.symbol.polygonPatternFile;if(this.iconAtlas.iconMap[g]){const i=this.iconAtlas.positions[g],m=!gt(i.displaySize[0])||!gt(i.displaySize[1]);Ge[0]=i.tl[0]+(m?1:0),Ge[1]=i.tl[1]+(m?1:0),je[0]=i.displaySize[0]-1-(m?2:0),je[1]=i.displaySize[1]-1-(m?2:0)}}let Xe,Ze=0;$&&(Xe=$(this.options.zoom,ye));const Ye=this.needAltitudeAttribute()?2:3,Qe=[-1,-1,g.extent+1,g.extent+1],Je=this._flattened=this._flattened||this._arrayPool.getProxy(),Ke=this._holeIndices=this._holeIndices||this._arrayPool.getProxy();for(let i=0;i<Be.length;i++){const g=Be[i],P=this.data.aPosition.getLength()/Ye;Je.setLength(0),Ke.setLength(0);for(let i=0;i<g.length;i++){let P=g[i];if(this.options.EXTENT!==1/0&&0===this.maxPosZ&&0===this.minPosZ&&(P=Ih(P,Qe)),0===P.length)continue;0!==i&&Ke.push(Je.length/3),this.ensureDataCapacity(P.length);const I=this.data;for(let i=0;i<P.length;i++){const g=P[i].x,H=P[i].y,W=P[i].z||0;if(this.fillPosition(this.data,g,H,W),Re){let i=I.aTexInfo.currentIndex;I.aTexInfo[i++]=Ge[0],I.aTexInfo[i++]=Ge[1],I.aTexInfo[i++]=je[0],I.aTexInfo[i++]=je[1],I.aTexInfo.currentIndex=i}if(void 0!==m){let i=I.aColor.currentIndex;I.aColor[i++]=m[0],I.aColor[i++]=m[1],I.aColor[i++]=m[2],I.aColor[i++]=m[3],I.aColor.currentIndex=i}if(void 0!==_){let i=I.aOpacity.currentIndex;I.aOpacity[i++]=_,I.aOpacity.currentIndex=i}if(void 0!==b){let i=I.aUVScale.currentIndex;I.aUVScale[i++]=b[0],I.aUVScale[i++]=b[1],I.aUVScale.currentIndex=i}if(void 0!==T){let i=I.aUVOffset.currentIndex;I.aUVOffset[i++]=T[0],I.aUVOffset[i++]=T[1],I.aUVOffset.currentIndex=i}if($){let i=I.aTexCoord.currentIndex;if(Xe){const g=Qn(Xe[2*Ze])?Xe[0]:Xe[2*Ze],m=Qn(Xe[2*Ze]+1)?Xe[1]:Xe[2*Ze+1];I.aTexCoord[i++]=g,I.aTexCoord[i++]=m}else I.aTexCoord[i++]=Rh,I.aTexCoord[i++]=Rh;I.aTexCoord.currentIndex=i,Ze++}const q=Math.abs(g),ye=Math.abs(H);q>this.maxPos&&(this.maxPos=q),ye>this.maxPos&&(this.maxPos=ye),Je.push(g,H,W)}}let I=th(Je,Ke,3);if(Je.length&&!I.length){const i=[];for(let g=0;g<Je.length;g+=3)i[g]=Je[g],i[g+1]=Je[g+2],i[g+2]=Je[g+1];if(I=th(i,Ke,3),!I.length){for(let g=0;g<Je.length;g+=3)i[g]=Je[g+1],i[g+1]=Je[g+2],i[g+2]=Je[g];I=th(i,Ke,3)}}for(let i=0;i<I.length;i+=3)this.addElements(P+I[i],P+I[i+1],P+I[i+2])}}ensureDataCapacity(i){super.ensureDataCapacity(1,i)}},i.RGBAImage=RGBAImage,i.RoundTubePack=RoundTubePack,i.SYMBOLS_NEED_REBUILD_IN_VECTOR=oc,i.SYMBOLS_NEED_REBUILD_IN_VT=ic,i.SquareTubePack=class SquareTubePack extends RoundTubePack{addHalfVertex(i,g,m,_,b,T,P,I){const{x:H,y:W,z:q}=i,$=1*this.scaledDistance,{x:ye,y:Re,z:Be}=P.dir,Ge=Wh(this.feaLineWidth,this.feaLineHeight,ye,Re,Be,g,m,b);this.prevVertex&&this.fillTubeElements(b),this.fillData(this.data,H,W,q||0,Ge,b,$,I)}ensureDataCapacity(i,g,m,_){return super.ensureDataCapacity(i,g,m,2*_)}},i.StyleUtil=dr,i.StyledPoint=StyledPoint,i.StyledVector=StyledVector,i.TEXT_MAX_ANGLE=80,i.TextUtil=Fs,i.VectorPack=VectorPack,g().maptalks_vt_packers=i}QD({});function JD(){return function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}().maptalks_vt_packers}var KD={vert:"\nstruct VTPUniforms {\n    minAltitude: f32,\n};\n\n@group(0) @binding($b) var<uniform> vtUniforms: VTPUniforms;\n\n#ifdef HAS_ALTITUDE\n    fn unpackVTPosition(vertexInput: VertexInput) -> vec3f {\n        var altitude: f32 = vertexInput.aAltitude;\n        #ifdef HAS_TERRAIN_ALTITUDE\n            // aTerrainAltitude的单位是米，在vt中需要转换为厘米\n            altitude += vertexInput.aTerrainAltitude * 100.0;\n        #endif\n        altitude += vtUniforms.minAltitude * 100.0;\n        return vec3f(vec2f(vertexInput.aPosition), altitude);\n    }\n#else\n    // 16384 is pow(2.0, 14.0)\n    const position_modValue: f32 = 16384.0;\n    const position_delta: f32 = 0.00001;\n\n    fn unpackVTPosition(vertexInput: VertexInput) -> vec3f {\n        let aPosition: vec3f = vec3f(vertexInput.aPosition.xyz);\n        let z: f32 = aPosition.z;\n        let pos: vec2f = sign(aPosition.xy + position_delta) * (abs(aPosition.xy) % position_modValue);\n        let highs: vec2f = floor(abs(aPosition.xy) / position_modValue);\n\n        var altitude: f32 = sign(z + position_delta) * (highs.x * 2.0 + highs.y) * pow(2.0, 15.0) + z;\n        #ifdef HAS_TERRAIN_ALTITUDE\n            // aTerrainAltitude的单位是米，在vt中需要转换为厘米\n            altitude += vertexInput.aTerrainAltitude * 100.0;\n        #endif\n        altitude += vtUniforms.minAltitude * 100.0;\n        return vec3f(pos, altitude);\n    }\n#endif\n",attributes:[{defines:["HAS_TERRAIN_ALTITUDE"],name:"aTerrainAltitude",type:"f32"}]};var eF={frag:"\n#define HAS_HIGHLIGHT_COLOR_POINT 1\n#define SDF_PX 8.0\n#define DEVICE_PIXEL_RATIO 1.0\n// 0.105 / DEVICE_PIXEL_RATIO\n#define EDGE_GAMMA 0.105 / 1.0\n\nstruct TextRenderShaderUniforms {\n    gammaScale: f32\n}\n\nstruct TextRenderUniforms {\n    textOpacity: f32,\n    isHalo: f32,\n    textHaloBlur: f32,\n    #ifndef HAS_TEXT_HALO_OPACITY\n        textHaloOpacity: f32,\n    #endif\n    #ifndef HAS_TEXT_HALO_RADIUS\n        textHaloRadius: f32,\n    #endif\n    #ifndef HAS_TEXT_FILL\n        textFill: vec4f,\n    #endif\n    #ifndef HAS_TEXT_HALO_FILL\n        textHaloFill: vec4f,\n    #endif\n};\n\n@group(0) @binding($b) var<uniform> textRenderUniforms: TextRenderUniforms;\n@group(0) @binding($b) var<uniform> textRenderShaderUniforms: TextRenderShaderUniforms;\n@group(0) @binding($b) var glyphTex: texture_2d<f32>;\n@group(0) @binding($b) var glyphTexSampler: sampler;\n\n\nfn renderText(input: VertexOutput) -> vec4f {\n    #ifdef HAS_TEXT_FILL\n        var myTextFill = input.vTextFill;\n    #else\n        var myTextFill = textRenderUniforms.textFill;\n    #endif\n    let gammaScale = textRenderShaderUniforms.gammaScale;\n    let fontScale = input.vTextSize / 24.0;\n    var color = myTextFill;\n    var gamma = EDGE_GAMMA / (fontScale * gammaScale);\n    let buff = 185.0 / 256.0; // (256.0 - 64.0) / 256.0\n\n    var isHaloText: bool;\n    #ifdef HAS_HALO_ATTR\n        // text halo in icon\n        isHaloText = input.vHalo > 0.5;\n    #else\n        isHaloText = textRenderUniforms.isHalo == 1.0;\n    #endif\n\n    if (isHaloText) {\n        #ifdef HAS_TEXT_HALO_FILL\n            var haloFill = input.vTextHaloFill;\n        #else\n            var haloFill = textRenderUniforms.textHaloFill;\n        #endif\n\n        #ifdef HAS_TEXT_HALO_RADIUS\n            let haloRadius = input.vTextHalo.x;\n        #else\n            let haloRadius = textRenderUniforms.textHaloRadius;\n        #endif\n\n        if (haloRadius == 0.0) {\n            discard;\n        }\n\n        color = haloFill;\n        gamma = (textRenderUniforms.textHaloBlur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * gammaScale);\n        let buff = (6.0 - haloRadius / fontScale) / SDF_PX;\n\n        #ifdef HAS_TEXT_HALO_OPACITY\n            let haloOpacity = input.vTextHalo.y / 255.0;\n        #else\n            let haloOpacity = textRenderUniforms.textHaloOpacity;\n        #endif\n\n        color *= haloOpacity * 1.25;\n    }\n\n    let dist = textureSampleLevel(glyphTex, glyphTexSampler, input.vTexCoord, 0.0).r;\n    let gammaScaled = gamma * input.vGammaScale * 0.7;\n\n    let alpha = clamp(smoothstep(buff - gammaScaled, buff + gammaScaled, dist), 0.0, 1.0);\n    return color * (alpha * textRenderUniforms.textOpacity);\n}\n"};let tF=0;function nF(){return tF++}const rF="function"==typeof Object.assign;function iF(i,...g){if(rF)return Object.assign(i,...g),i;for(let m=0;m<g.length;m++){const _=g[m];for(const g in _)i[g]=_[g]}return i}function oF(i){return!hF(i)&&("string"==typeof i||null!==i.constructor&&i.constructor===String)}function sF(i){return"number"==typeof i&&!isNaN(i)}function aF(i){return!hF(i)&&("function"==typeof i||null!==i.constructor&&i.constructor===Function)}function lF(i){return!Array.isArray(i)&&"object"==typeof i&&!!i}function hF(i){return null==i}function cF(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];if(m)for(let g=0,_=m.length;g<_;g++)i.push(m[g])}return i.length}function uF(i){return wL(i)&&i.property}function fF(i,g){return Object.prototype.hasOwnProperty.call(i,g)}function dF(i,g){return g.altitudeToPoint(100,i)/100/100}function pF(i,g,m){for(let _=0;_<i.length;_++){const b=i[_],T=iF({},b),{renderPlugin:P}=b,I=iF({},P);I.sceneConfig&&!Object.keys(I.sceneConfig).length&&delete I.sceneConfig;let H=-1;for(let i=m.length-1;i>=0;i--)if(jv(I,m[i])){H=i;break}H<0&&(H=m.length,m.push(I)),T.renderPlugin=H,g.push(T)}}const gF="function"==typeof fetch&&"function"==typeof AbortController,mF={jsonp:function(i,g){const m="_maptalks_jsonp_"+nF();i.match(/\?/)?i+="&callback="+m:i+="?callback="+m;let _=document.createElement("script");return _.type="text/javascript",_.src=i,window[m]=function(i){g(null,i),document.getElementsByTagName("head")[0].removeChild(_),_=null,delete window[m]},document.getElementsByTagName("head")[0].appendChild(_),this},get:function(i,g,m){if(aF(g)){const i=m;m=g,g=i}let _=(g=g||{}).errorLog;hF(_)&&(_=!0),g.method&&(g.method=g.method.toUpperCase());const b="POST"===g.method;if(gF){const b=new AbortController,T=g;T.signal=b.signal,T.referrerPolicy=T.referrerPolicy||"origin",T.method=T.method||"GET";const P=new Request(i,T);return g.returnJSON&&P.headers.set("Accept","application/json"),fetch(P).then((b=>{const T=this._parseResponse(b,g.returnJSON,g.responseType);T.message?(T.url=i,m(T)):T.then((i=>{m(null,"arraybuffer"===g.responseType?{data:i,cacheControl:b.headers.get("Cache-Control"),expires:b.headers.get("Expires"),contentType:b.headers.get("Content-Type")}:i)})).catch((g=>{g.code&&g.code===DOMException.ABORT_ERR||(_&&console.error("Fetch error:",i,g),m(g))}))})).catch((g=>{g.code&&g.code===DOMException.ABORT_ERR||(_&&console.error("Fetch error:",i,g),m(g))})),b}{const _=mF._getClient(m);if(_.open(g.method||"GET",i,!0),g){for(const i in g.headers)_.setRequestHeader(i,g.headers[i]);_.withCredentials="include"===g.credentials,g.responseType&&(_.responseType=g.responseType)}return _.send(b?g.body:null),_}},_parseResponse:(i,g,m)=>200!==i.status?{status:i.status,statusText:i.statusText,message:`incorrect http request with status code(${i.status}): ${i.statusText}`}:"arraybuffer"===m?i.arrayBuffer():g?i.json():i.text(),_wrapCallback:function(i,g){return function(){if(4===i.readyState)if(200===i.status)if("arraybuffer"===i.responseType){0===i.response.byteLength?g({status:200,statusText:i.statusText,message:"http status 200 returned without content."}):g(null,{data:i.response,cacheControl:i.getResponseHeader("Cache-Control"),expires:i.getResponseHeader("Expires"),contentType:i.getResponseHeader("Content-Type")})}else g(null,i.responseText);else g({status:i.status,statusText:i.statusText,message:`incorrect http request with status code(${i.status}): ${i.statusText}`})}},_getClient:function(i){let g;try{g=new XMLHttpRequest}catch(i){try{g=new ActiveXObject("Msxml2.XMLHTTP")}catch(i){try{g=new ActiveXObject("Microsoft.XMLHTTP")}catch(i){}}}return g.onreadystatechange=mF._wrapCallback(g,i),g},getArrayBuffer(i,g,m){if(aF(g)){const i=m;m=g,g=i}return g||(g={}),g.responseType="arraybuffer",mF.get(i,g,m)},getJSON:function(i,g,m){if(aF(g)){const i=m;m=g,g=i}const _=function(i,g){const _="string"==typeof g?JSON.parse(g):g||null;m(i,_)};return g&&g.jsonp?mF.jsonp(i,_):((g=g||{}).returnJSON=!0,mF.get(i,g,_))}};class LRUCache{constructor(i){this.max=i,this.reset()}reset(){return this.data={},this.order=[],this}clear(){this.reset()}add(i,g){return this.has(i)?(this.order.splice(this.order.indexOf(i),1),this.data[i]=g,this.order.push(i)):(this.data[i]=g,this.order.push(i),this.order.length>this.max&&this.getAndRemove(this.order[0])),this}has(i){return i in this.data}keys(){return this.order}getAndRemove(i){if(!this.has(i))return null;const g=this.data[i];return delete this.data[i],this.order.splice(this.order.indexOf(i),1),g}get(i){if(!this.has(i))return null;return this.data[i]}remove(i){return this.has(i)?(delete this.data[i],this.order.splice(this.order.indexOf(i),1),this):this}setMaxSize(i){for(this.max=i;this.order.length>this.max;)this.getAndRemove(this.order[0]);return this}}class IconRequestor{constructor(i){this.options=i||{},this._requesting={},this._cache=new LRUCache(256,(function(){}));const g=document.createElement("canvas");this.ctx=g.getContext("2d",{willReadFrequently:!0})}getIcons(i,g){if(!i||!Object.keys(i).length)return void g(null,{icons:null});const m=Object.keys(i),_={},b=[];let T=0,P=0;const I=this;function H(i,m){_[i]=I._getCache(i,m),_[i]&&"error"!==_[i]?b.push(_[i].data.data.buffer):delete _[i],P++,P===T&&g(null,{icons:_,buffers:b})}function W(i){const g=I._requesting[i.url];for(let m=0;m<g.length;m++)g[m].call(i,i.url,i.size);delete I._requesting[i.url]}function q(){const i=I.ctx;let g,m;try{g=this.width,m=this.height,this.size[0]=g,this.size[1]=m,I._ensureMaxSize(null,this.size),g=this.size[0],m=this.size[1];const _=i.canvas;_.width=g,_.height=m,i.imageSmoothingEnabled=!1,i.drawImage(this,0,0,g,m);const b=i.getImageData(0,0,_.width,_.height).data;I._addCache(this.url,b,_.width,_.height)}catch(i){console.warn(i)}W(this)}function $(i){console.warn(`failed loading icon(${this.index}) at "${this.url}"`),console.warn(i),I.options.iconErrorUrl?this.src=I.options.iconErrorUrl:(I._addCache(this.url),W(this))}const ye=this.options.urlModifier;let Re,Be=!1;for(let g=0;g<m.length;g++){const P=m[g],I=i[P];this._ensureMaxSize(P,I);const W=this._getCache(P,I);if(W&&"error"!==W){_[P]=this._getCache(P,I);continue}if("error"===W)continue;let Ge,je=P;if(0===P.indexOf("vector://")&&(Ge=JSON.parse(P.substring(9)),"path"===Ge.markerType&&(je=Po.getMarkerPathBase64(Ge,Ge.markerWidth,Ge.markerHeight))),0===P.indexOf("vector://")&&"path"!==Ge.markerType){Re=Re||new yf([0,0]);const{markerFill:i,markerLineColor:g}=Ge;i&&Array.isArray(i)&&(Ge.markerFill=AF(i)),g&&Array.isArray(g)&&(Ge.markerLineColor=AF(g)),delete Ge.markerHorizontalAlignment,delete Ge.markerVerticalAlignment,delete Ge.markerDx,delete Ge.markerDy,delete Ge.markerPlacement,delete Ge.markerFile,Ge.markerWidth=I[0],Ge.markerHeight=I[1],Re.setSymbol(Ge);const m=Re["_getSprite".trim()]();if(m){const i=m.canvas,g=i.width,T=i.height,I=i.getContext("2d",{willReadFrequently:!0}).getImageData(0,0,g,T).data;_[P]={data:{data:new Uint8ClampedArray(I),width:g,height:T},url:P},b.push(_[P].data.data.buffer),this._addCache(P,I,g,T)}}else{if(this._requesting[P]){Be=!0,T++,this._requesting[P].push(H);continue}this._requesting[P]=[],this._requesting[P].push(H);const i=new Image;i.index=g,i.size=I,i.onload=q,i.onerror=$,i.onabort=$,i.url=P,i.crossOrigin="Anonymous",Be=!0,T++,i.src=ye&&ye(je)||je}}Be||g(null,{icons:_,buffers:b})}_hasCache(i,g,m){const _=this._cache.get(i);return _&&"error"!==_&&_.data.width>=g&&_.data.height>=m}_addCache(i,g,m,_){this._hasCache(i,m,_)||this._cache.add(i,g?{data:{data:g,width:m,height:_},url:i}:"error")}_getCache(i,g){if(!this._hasCache(i,g[0],g[1]))return null;const m=this._cache.get(i);return m?"error"===m?m:{data:{data:new Uint8ClampedArray(m.data.data),width:m.data.width,height:m.data.height},url:m.url}:null}_ensureMaxSize(i,g){if(!g[0]||!g[1])return;const m=this.options.maxSize||2048;let[_,b]=g;const T=_/b;if(i){const g=this._cache.get(i);if(g&&"error"!==g){const{width:i,height:m}=g.data;i>_&&(_=i),m>b&&(b=m)}}_>m&&(b=m/T,_=m),b>m&&(_=m*T,b=m),g[0]=Math.floor(_),g[1]=Math.floor(b)}}function AF(i){return 3===i.length&&i.push(1),i.reduce(((i,g,m)=>i+=m<3?255*g+",":g+")"),"rgba(")}const{GlyphRequestor:yF}=JD(),_F=["GeoJSONVectorTileLayer"];class WorkerConnection extends Um.Actor{constructor(i,g){super(i);const m=g.getMap().id;this._layer=g,this._mapId=m,this._workerLayerId="vt_"+nF();const _=g.getJSONType();this._isDedicated=_F.indexOf(_)>=0,this._dedicatedVTWorkers={},this._iconRequestor=new IconRequestor({iconErrorUrl:g.options.iconErrorUrl,maxSize:g.options.maxIconSize,urlModifier:i=>{const m=g.getURLModifier();return m&&m(i)||i}});const b=!g.getRenderer().isEnableWorkAround("win-intel-gpu-crash");this._glyphRequestor=new yF((i=>{g.getMap().getRenderer().callInNextFrame(i)}),g.options.glyphSdfLimitPerFrame,b)}initialize(i){i(null)}addLayer(i){const g=this._layer,m=g.getWorkerOptions()||{},_=this._workerLayerId,b=g.getJSONType(),T={mapId:this._mapId,layerId:_,command:"addLayer",params:{type:b,options:JSON.parse(JSON.stringify(m))}};this._isDedicated?(void 0===this._dedicatedVTWorkers[_]&&(this._dedicatedVTWorkers[_]=this.getDedicatedWorker()),this.send(T,null,i,this._dedicatedVTWorkers[_])):this.broadcast(T,null,i)}abortTile(i,g){const m=this._workerLayerId,_={mapId:this._mapId,layerId:m,command:"abortTile",params:{url:i}};this._isDedicated?(void 0===this._dedicatedVTWorkers[m]&&(this._dedicatedVTWorkers[m]=this.getDedicatedWorker()),this.send(_,null,g,this._dedicatedVTWorkers[m])):this.broadcast(_,null,g)}removeLayer(i){const g=this._workerLayerId,m={mapId:this._mapId,layerId:g,command:"removeLayer"};this._isDedicated?(void 0!==this._dedicatedVTWorkers[g]&&this.send(m,null,i,this._dedicatedVTWorkers[g]),delete this._dedicatedVTWorkers[g]):this.broadcast(m,null,i)}updateStyle(i,g){const m=this._workerLayerId,_={mapId:this._mapId,layerId:m,command:"updateStyle",params:JSON.parse(JSON.stringify(i))};this._isDedicated?void 0!==this._dedicatedVTWorkers[m]&&this.send(_,null,g,this._dedicatedVTWorkers[m]):this.broadcast(_,null,g)}updateOptions(i,g){const m=this._workerLayerId,_={mapId:this._mapId,layerId:m,command:"updateOptions",params:JSON.parse(JSON.stringify(i))};this._isDedicated?void 0!==this._dedicatedVTWorkers[m]&&this.send(_,null,g,this._dedicatedVTWorkers[m]):this.broadcast(_,null,g)}loadTile(i,g){const m=iF({},i);m.tileInfo=function(i){const g={};for(const m in i)null!=i[m]&&(g[m]=i[m].toJSON?i[m].toJSON():i[m]);return g}(i.tileInfo);const _=this._workerLayerId,b={mapId:this._mapId,layerId:_,command:"loadTile",params:m},{x:T,y:P}=i.tileInfo,I=(T+P)%this.workers.length,H=[],W=m.tileArrayBuffer;W&&W instanceof ArrayBuffer&&H.push(W),this.send(b,H,g,void 0===this._dedicatedVTWorkers[_]?this.workers[I].id:this._dedicatedVTWorkers[_])}remove(){super.remove(),this._dedicatedVTWorkers={}}fetchIconGlyphs({icons:i,glyphs:g},m){this._glyphRequestor.getGlyphs(g,((g,_)=>{if(g)throw g;const b=_.buffers||[];this._iconRequestor.getIcons(i,((i,g)=>{if(i)throw i;g.buffers&&g.buffers.length&&b.push(...g.buffers),m(null,{icons:g.icons,glyphs:_.glyphs},b)}))}))}setData(i,g){const m=this._workerLayerId;this.send({mapId:this._mapId,layerId:m,command:"setData",params:{data:i}},null,g,this._dedicatedVTWorkers[m])}clearData(i){const g=this._workerLayerId;this.send({mapId:this._mapId,layerId:g,command:"clearData"},null,i,this._dedicatedVTWorkers[g])}_getTileKey(i){return i.id}}const vF={},xF={collision:!0,fading:!1,fadingDuration:224,fadeInDelay:600,fadeOutDelay:100,uniquePlacement:!1,depthFunc:"always"};class DebugPainter{constructor(i,g,m){this._regl=i,this._map=g,this._color=m||[0,1,0]}draw(i,g,m,_,b){if(this._command||this._init(),!this._data){this._data=this._regl.buffer(bF(_));this._textData=this._regl.buffer(wF(_,_/m))}if(_!==this._extent){const i=_/m;this._data(bF(_)),this._textData(wF(_,i))}this._extent=_;let T=this._debugInfoCanvas;if(!T){const i=this._map.getDevicePixelRatio()>1?2:1;T=this._debugInfoCanvas=document.createElement("canvas"),T.width=512*i,T.height=64*i;const g=T.getContext("2d");g.font="36px monospace",g.scale(i,i),this._texture=this._regl.texture({width:T.width,height:T.height,data:T})}const P=T.getContext("2d");P.clearRect(0,0,T.width,T.height),P.fillStyle=`rgba(${this._color.map((i=>255*i)).join()})`,P.fillText(i,20,36),this._texture({width:T.width,height:T.height,data:T}),this._command({transform:g,data:this._data,texData:this._texCoordData,debugLine:1,primitive:"lines",framebuffer:b||null,image:this._texture,count:8}),this._command({transform:g,data:this._textData,texData:this._texCoordData,debugLine:0,primitive:"triangle strip",framebuffer:b||null,image:this._texture,count:4})}delete(){this._texture&&(this._texture.destroy(),delete this._texture),this._texCoordData&&(this._texCoordData.destroy(),delete this._texCoordData),this._data&&(this._data.destroy(),this._textData.destroy(),delete this._data,delete this._textData),this._command&&(this._command.destroy(),delete this._command)}_init(){this._texCoordData=this._regl.buffer(new Uint8Array([0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1])),this._command=this._regl({vert:"\n                attribute vec2 aPosition;\n                attribute vec2 aTexCoord;\n                uniform mat4 transform;\n\n                varying vec2 vTexCoord;\n                void main()\n                {\n                    gl_Position = transform * vec4(aPosition, 0.0, 1.0);\n                    vTexCoord = aTexCoord;\n                }\n            ",frag:"\n                precision mediump float;\n                uniform sampler2D uImage;\n                uniform vec3 uColor;\n                uniform float uOpacity;\n                uniform float uDebugLine;\n\n                varying vec2 vTexCoord;\n\n                void main()\n                {\n                    if (uDebugLine == 1.) {\n                        gl_FragColor = vec4(uColor, 1.0) * uOpacity;\n                    } else {\n                        gl_FragColor = texture2D(uImage, vTexCoord) * uOpacity;\n                    }\n                    gl_FragColor *= gl_FragColor.a;\n                }\n            ",attributes:{aPosition:this._regl.prop("data"),aTexCoord:this._regl.prop("texData")},uniforms:{transform:this._regl.prop("transform"),uColor:this._color,uOpacity:1,uDebugLine:this._regl.prop("debugLine"),uImage:this._regl.prop("image")},count:this._regl.prop("count"),primitive:this._regl.prop("primitive"),depth:{enable:!1,mask:!1},blend:{enable:!0,func:{src:"one",dst:"one minus src alpha"},equation:"add"},viewport:{x:0,y:0,width:()=>this._map.getRenderer().canvas.width,height:()=>this._map.getRenderer().canvas.height},framebuffer:this._regl.prop("framebuffer")})}}function bF(i){return new Uint16Array([0,0,0,i,0,i,i,i,i,i,i,0,i,0,0,0])}function wF(i,g){return new Uint16Array([0,i-64*g,0,i,512*g,i-64*g,512*g,i])}const TF=new Uint16Array([0,0,0,1,1,0,1,0,0,1,1,1]),SF=[];class TileStencilRenderer{constructor(i,g,m){this._regl=i;(this._geometry=new wP.Geometry({aPosition:TF},null,TF.length/2,{positionSize:2})).generateBuffers(i),this._scene=new wP.Scene,this._meshes=[],this._counter=0,this._canvas=g,this._map=m,this._init(i)}start(){this._counter=0,this._scene.clear()}add(i,g,m){const _=this._getMesh(m);_.setUniform("ref",i),qA(SF,g,g,1);const b=_.localTransform;TA(b,SF),zA(b,m,b),_.setLocalTransform(b),this._scene.addMesh(_)}render(i){this._renderer.render(this._shader,{projViewMatrix:this._map.projViewMatrix},this._scene,i)}_getMesh(){const i=this._counter++;return this._meshes[i]||(this._meshes[i]=new wP.Mesh(this._geometry)),this._meshes[i]}_init(i){const g=this._canvas;this._shader=new wP.MeshShader({name:"tile-stencil",vert:"\n#define SHADER_NAME TILE_STENCIL_VERT\nattribute vec2 aPosition;\nuniform mat4 projViewModelMatrix;\n\nvoid main()\n{\n    gl_Position = projViewModelMatrix * vec4(aPosition, 0.0, 1.0);\n}\n",frag:"\n#define SHADER_NAME TILE_STENCIL_FRAG\nvoid main()\n{\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 0.1);\n}\n",wgslVert:"\n@group(0) @binding(0) var<uniform> projViewModelMatrix : mat4x4f;\n@vertex\nfn main(\n    @location(0) aPosition : vec2u\n    ) -> @builtin(position) vec4f {\n    return projViewModelMatrix * vec4f(vec2f(aPosition), 0.0, 1.0);\n}\n",wgslFrag:"\n@fragment\nfn main() -> @location(0) vec4f {\n  return vec4(1.0, 0.0, 0.0, 0.1);\n}\n",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}}],extraCommandProps:{viewport:{x:0,y:0,width:()=>g.width,height:()=>g.height},stencil:{enable:!0,func:{cmp:"always",ref:(i,g)=>g.ref},op:{fail:"replace",zfail:"replace",zpass:"replace"}},depth:{enable:!0,func:"always",mask:!1},colorMask:[!1,!1,!1,!1]}}),this._renderer=new wP.Renderer(i)}remove(){this._geometry.dispose();for(let i=0;i<this._meshes.length;i++)this._meshes[i].dispose();this._meshes.length=0,this._shader.dispose()}}const MF="__fea_idx",CF=-999999,PF=new Float32Array([-1e12])[0],IF="maptalks_ombb",kF=(MF+"").trim();function OF(i,g,m,_,b,T){const P={};if(function(i){if(!i)return!1;for(const g in i)if(null!=i[g])return!0;return!1}(i)){for(let I=0,H=(g||i).length;I<H;I++){let H=g?i[g[I]]:i[I];"id"===b.options.features&&b.getFeature&&(H=b.getFeature(H),H.layer=m),b instanceof Up&&(H=FF(H,T));P[g?g[I]:H[kF]]={feature:H,symbol:_}}}return P}const EF="__original_properties",RF="__external_properties",LF={get:function(i,g){return g in i?i[g]:i[EF][g]||i[RF]&&i[RF][g]},has:function(i,g){return g in i||g in i[EF]||i[RF]&&g in i[RF]}},DF={};function FF(i,g){const m=i.properties;if(m&&m[EF])return i;g&&(i=iF({},i)),i.customProps=i.customProps||{};const _=i.customProps;return _.$layer=i.layer,_.$type=i.type,_[EF]=m||DF,i.properties=new Proxy(_,LF),i}function NF(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}function HF(i,g,m){return Math.min(m,Math.max(g,i))}function BF(i,g,m){if(i===m||i===g)return i;const _=m-g;return((i-g)%_+_)%_+g}function zF(i){return null==i}function VF(i){const g=JSON.parse(JSON.stringify(i));if(Array.isArray(i))for(let m=0;m<i.length;m++){if(!g[m])continue;const{symbol:_}=g[m];if(!_)continue;const b=i[m].symbol;for(const i in b)_[i]||(_[i]=b[i])}else if(i){if(i.style){const m=VF(i.style);return g.style=m,g}if(i.symbol){const m=VF(i.symbol);return g.symbol=m,g}for(const m in i)g[m]||(g[m]=i[m])}return g}function UF(i,g,m,_,b,T){g in i||Object.defineProperty(i,g,{enumerable:!0,get:function(){const i=zF(m[_])||wL(m[_])?b:m[_];return T?T(i):i}})}const GF=[];function jF(i){for(let g=0;g<i.length;g++)GF[g]=i[g],GF[g]*=255;return 3===i.length&&(GF[3]=255),GF}function WF(i,g=4){return qF.bind(this,i,g)}function qF(i,g,m){if(Array.isArray(m))return 3===m.length&&4===g&&m.push(1),m;if(i&&i[m])return i[m];if(void 0!==m.r&&void 0!==m.g&&void 0!==m.b&&void 0!==m.a){return[m.r,m.g,m.b,m.a]}const _=iL(m).unitArray();return 3===_.length&&4===g&&_.push(1),i&&(i[m]=_),_}function XF(i,g,m,_){if(i.fill)i.fill(g,m,_);else for(let b=m;b<_;b++)i[b]=g}function ZF(i){return"number"==typeof i&&!isNaN(i)}function $F(i){return i&&(i.markerFile||i.markerType)&&void 0!==i.textName}function YF(i,g){return Object.prototype.hasOwnProperty.call(i,g)}function QF(i,g){if(g){let g=i[i.length-1];const m=[g];for(let _=i.length-2;_>=0;_--)i[_]!==g&&(m.push(i[_]),g=i[_]);return m}{let g=i[i[0]];const m=[g];for(let _=1;_<i.length;_++)i[_]!==g&&(m.push(i[_]),g=i[_]);return m}}const JF=new pl(0,0);function KF(i,g,m,_,b){const T=i.distanceToPointAtRes(g,g,_,m,JF);return b?T.y:T.x}const{TileLayerRendererable:eN,LayerAbstractRenderer:tN}=Om,{FilterUtil:nN}=JD(),rN=[],iN=new un(0,0),oN=[],sN={color:[0,0,0,0],depth:1,stencil:0},aN=i=>i.isTerrainSkin(),lN=i=>i.isTerrainVector();class VectorTileLayerRenderer extends(Ck(eN(tN))){supportRenderMode(){return!0}constructor(i){super(i),this._workerCacheIndex=0,this.ready=!1,this._styleCounter=1,this._requestingMVT={},this._plugins={},this._featurePlugins={},this.init()}getTileLevelValue(i,g){if(this.isBackTile(i.id)){const m=i.z,_=5;return m-g>=0?g+_-m:_+(g-m)}return 0}getWorkerConnection(){return this._workerConn}getStyleCounter(){return this._styleCounter}clearData(){this.clear(),this._workerConn?(this._workersyncing=!0,this._workerConn.clearData((()=>{this._workersyncing=!1,this._needRetire=!0,this.setToRedraw(),this.layer.fire("cleardata")}))):this.layer.fire("cleardata")}clear(){this.clearTileCaches(),super.clear()}setStyle(i,g){this._groundPainter&&this._groundPainter.update(),this._workerConn?(this._workerUpdateTimeout&&clearTimeout(this._workerUpdateTimeout),this._workersyncing=!0,this._workerUpdateTimeout=setTimeout((()=>{if(!this.layer)return;this._styleCounter++,this._preservePrevTiles();const m=i||this.layer._getComputedStyle();m.styleCounter=this._styleCounter,this._workerConn.updateStyle(m,(i=>{if(this._workersyncing=!1,g&&g(),i)throw new Error(i);this._needRetire=!0,this._initPlugins(),this.setToRedraw(),this.layer.fire("refreshstyle")}))}),10)):(g&&g(),this._initPlugins())}_preservePrevTiles(){if(this._prevTilesInView)for(const i in this._prevTilesInView){const g=this._prevTilesInView[i];g&&this.deleteTile(g)}this._prevTilesInView=this.tilesInView;const i=this.tileCache;for(const g in this._prevTilesInView){const m=this._prevTilesInView[g];m&&m.info&&i.getAndRemove(m.info.id)}i.reset(),this.tilesInView={},this.tilesLoading={},this._requestingMVT={},this._parentTiles=[],this._childTiles=[],this._tileZoom=void 0}updateOptions(i){this._workerConn&&this._workerConn.updateOptions(this.layer.getWorkerOptions(),(g=>{if(g)throw new Error(g);i&&(i.features||i.pickingGeometry||i.altitudeProperty)&&(this.clear(),this._clearPlugin(),this._initPlugins()),this.setToRedraw()}))}updateSceneConfig(i,g,m){const _=0===i?this._getStylePlugins():this._getFeaturePlugins();if(!_||!_[g])return;this._needRetire=!0;const b=this.layer._getComputedStyle(),T=this.layer._getTargetStyle(i,b);_[g].config=T[g].renderPlugin,_[g].updateSceneConfig({sceneConfig:m}),this.setToRedraw()}updateDataConfig(i,g,m,_){const b=0===i?this._getStylePlugins():this._getFeaturePlugins();b&&b[g]&&(this._needRetire=!0,b[g].updateDataConfig(m,_)?this.setStyle():this.setToRedraw())}updateSymbol(i,g,m){const _=0===i?this._getStylePlugins():this._getFeaturePlugins();if(!_||!_[g])return!1;const b=this.layer._getComputedStyle(),T=this.layer._getTargetStyle(i,b),P=_[g];P.style=T[g];const I=P.updateSymbol(m,T[g].symbol);return!I&&fN(m)&&this.setStyle(),this.setToRedraw(),I}testIfNeedRedraw(){const i=this._getFramePlugins();for(let g=0;g<i.length;g++)if(i[g]&&i[g].needToRedraw())return!0;return super.testIfNeedRedraw()}needRetireFrames(){if(this._needRetire)return!0;const i=this._getFramePlugins();for(let g=0;g<i.length;g++)if(i[g]&&i[g].needToRetireFrames())return!0;return!1}getCurrentTiles(){return this._vtCurrentTiles}isAnimating(){const i=this.getMap().getRenderer(),g=i.getFrameTimestamp&&i.getFrameTimestamp()||i._frameTimestamp;if(this._highlightUpdated&&(this._highlightFrametime=g,delete this._highlightUpdated),this._highlightFrametime===g)return!0;const m=this._getFramePlugins();for(let i=0;i<m.length;i++)if(m[i]&&m[i].isAnimating())return!0;return!1}needToRefreshTerrainTileOnZooming(){const i=this._getFramePlugins();for(let g=0;g<i.length;g++)if(i[g]&&i[g].needToRefreshTerrainTileOnZooming())return!0;return!1}initContext(){super.initContext();const{regl:i,device:g,reglGL:m}=this.context,_=i||g;this.regl=i,this.gl=m,this.device=g||i;this.canvas.pickingFBO=this.canvas.pickingFBO||_.framebuffer({colorFormat:!!this.device.wpu?"bgra8unorm":"rgba",depthStencil:!0,width:this.canvas.width,height:this.canvas.height}),this.pickingFBO=this.canvas.pickingFBO,this._debugPainter=new DebugPainter(_,this.getMap()),this._prepareWorker(),this._groundPainter=new GroundPainter(_,this.layer),this.layer.fire("contextcreate",{regl:i,device:g})}_prepareWorker(){this._workerConn||(this._workerConn=new WorkerConnection("@maptalks/vt",this.layer));this._workerConn.addLayer(((i,g)=>{this.layer&&(this.ready=!0,this.layer.onWorkerReady(i,g),this.layer.fire("workerready"),this.setToRedraw())}))}_incrWorkerCacheIndex(){this._workerCacheIndex++}isDrawable(){return!0}checkResources(){return rN}_drawTiles(i,g,m,_,b){if(super._drawTiles(i,g,m,_,b),this._prevTilesInView)if(Object.keys(this._prevTilesInView).length)for(const i in this._prevTilesInView){const g=this._prevTilesInView[i];g&&g.info&&g.info.id&&!this.tileCache.has(g.info.id)&&this._drawTile(g.info,g.image,b)}else this._deletePrevPlugins(),delete this._prevTilesInView}_deletePrevPlugins(){const i=this._styleCounter,g=[],m=[];for(const m in this._plugins)if(+m!==i){g.push(m);this._getStylePlugins(m).forEach((i=>{i.remove()}))}for(const g in this._featurePlugins)if(+g!==i){m.push(g);this._getFeaturePlugins(g).forEach((i=>{i.remove()}))}for(let i=0;i<g.length;i++)delete this._plugins[g[i]];for(let i=0;i<m.length;i++)delete this._featurePlugins[m[i]]}draw(i,g){this._currentTimestamp!==i&&(this._needRetire=!1,this._setPluginIndex());const m=this.layer;if(this.prepareCanvas(),!this.ready||!m.ready)return;const{plugins:_,featurePlugins:b}=this._preparePlugins();m.isDefaultRender()||_.length||b.length?(m.options.collision&&m.clearCollisionIndex(),this._frameTime=i,this._zScale=this._getCentiMeterScale(this.getMap().getGLRes()),this._parentContext=g||{},this._startFrame(i),super.draw(i),this._currentTimestamp!==i&&this._prepareRender(i),this._endFrame(i),this._currentTimestamp=i):this.completeRender()}_preparePlugins(){let i=this._plugins[this._styleCounter];i||(this._initPlugins(),this._setPluginIndex(),i=this._getStylePlugins());return{plugins:i,featurePlugins:this._getFeaturePlugins()}}_setPluginIndex(){this._getFramePlugins().forEach(((i,g)=>{i&&(i.renderIndex=g)}))}_prepareRender(){const i=this._getFramePlugins();this._pluginOffsets=this._pluginOffsets||[];let g=0;for(let m=i.length-1;m>=0;m--){const _=i[m];_.isVisible()&&_.hasMesh()&&(this._pluginOffsets[m]=g,_.needPolygonOffset()&&g++)}this._groundPainter.isEnable()&&g++,this._polygonOffsetIndex=g}getFrameTimestamp(){return this._frameTime}drawOnInteracting(i,g,m){this.draw(g,m)}drawOutline(i){(this._outline||this._outlineAll)&&(this._outlineAll?this.paintOutlineAll(i):this._outline.forEach((g=>{this[g[0]](i,...g[1])})))}getAnalysisMeshes(){return this.getShadowMeshes()}getShadowMeshes(){const i=[];return this._getAllPlugins().forEach((g=>{if(!g)return;if(!this._isVisible(g))return;const m=g.getShadowMeshes();if(Array.isArray(m))for(let g=0;g<m.length;g++)i.push(m[g])})),i}isForeground(i){return!(!this._vtCurrentTiles||!this._vtCurrentTiles[i.properties.tile.id])}_getTileZoomDiff(i){const g=this.layer;let m=g._getTileZoom(this.getMap().getZoom());const _=g.getMinZoom(),b=g.getMaxZoom();m=Po.clamp(m,_,b);return m-i.properties.tile.z}isTileNearCamera(i){return this._getTileZoomDiff(i)<=1}isBackTile(i){return!(!this._vtBgTiles||!this._vtBgTiles[i])}loadTileQueue(i){this._workersyncing||super.loadTileQueue(i)}loadTile(i){const{url:g}=i,m=this._requestingMVT[g];if(m)m.keys[i.id]||(m.tiles.push(i),m.keys[i.id]=1);else{const m=this.getMap(),_=iN.set(i.extent2d.xmin,i.extent2d.ymax),b=m.pointAtResToCoord(new un(_),i.res),T=[KF(m,1,b,i.res)/100,KF(m,1,b,i.res,1)/100],P=this.getCentimeterToPoint(i.z),I=this.getTileGLScale(i.z);this._requestingMVT[g]={keys:{},tiles:[i]},this._requestingMVT[g].keys[i.id]=1;const H=this.layer.options.fetchOptions,W=window&&window.location.href,q=this.layer.options.altitudePropertyName,$=this.layer.options.disableAltitudeWarning,ye=this.layer.options.loadTileErrorLog,Re=this.layer.options.loadTileErrorLogIgnoreCodes,Be=this.layer.options.loadTileCachMaxSize,Ge=this.layer.options.loadTileCacheLog,je={tileInfo:{res:i.res,x:i.x,y:i.y,z:i.z,url:gN(i),id:i.id,extent2d:i.extent2d},glScale:I,disableAltitudeWarning:$,loadTileErrorLog:ye,loadTileErrorLogIgnoreCodes:Re,loadTileCachMaxSize:Be,loadTileCacheLog:Ge,altitudePropertyName:q,zScale:this._zScale,centimeterToPoint:T,verticalCentimeterToPoint:P,fetchOptions:H,styleCounter:this._styleCounter,referrer:W,workerCacheIndex:this._workerCacheIndex,command:"loadTile"};this.loadTileArrayBuffer&&aF(this.loadTileArrayBuffer)?this.loadTileArrayBuffer(je.tileInfo.url,i,((i,m)=>{i?this._onReceiveMVTData(g,i):m&&m instanceof ArrayBuffer?(je.tileArrayBuffer=m,this._workerConn.loadTile(je,this._onReceiveMVTData.bind(this,g))):console.error("loadTileArrayBuffer return data is not ArrayBuffer:",m)}),je):this._workerConn.loadTile(je,this._onReceiveMVTData.bind(this,g))}return{}}getTileGLScale(i){const g=this.getMap();return this.layer.getSpatialReference().getResolution(i)/g.getGLRes()}getCentimeterToPoint(i){const g=this.getMap();return dF(this.layer.getSpatialReference().getResolution(i),g)}getRenderedFeatures(){const i=this.tileCache.keys();return this._getFeaturesByKeys(i)}getCurrentRenderedFeatures(){const i=this._vtCurrentTiles&&Object.keys(this._vtCurrentTiles);return this._getFeaturesByKeys(i)}_getFeaturesByKeys(i){const g=[];for(let m=0;m<i.length;m++){const _=this.tileCache.get(i[m]);if(!_||!_.info||!_.image)continue;const{info:b,image:T}=_,P=pN(T);g.push({tile:{id:b.id,x:b.x,y:b.y,z:b.z,url:b.url},current:!!this.tilesInView[b.id],features:P})}return g}_onReceiveMVTData(i,g,m){if(this.setToRedraw(),!this._requestingMVT[i])return;if(m&&m.canceled)return;const _=this.layer,b=_.isDefaultRender(),{tiles:T}=this._requestingMVT[i];if(delete this._requestingMVT[i],g){if(g.status&&(404===g.status||204===g.status))for(let i=0;i<T.length;i++){this.onTileError(vF,T[i])}return}if(!m){for(let i=0;i<T.length;i++){this.consumeTile({_empty:!0},T[i])}return}if(m.styleCounter!==this._styleCounter)return;let P=!1;const I=m.features,H=[];for(let i=0;i<m.data.length;i++){const g=m.data[i];if(!g||!g.data||!g.styledFeatures.length)continue;const{isUpdated:_,layer:b}=this._parseTileData(0,i,g,I,H);H.push(b),_&&(P=_)}for(let i=0;i<m.featureData.length;i++){const g=m.featureData[i];g&&g.data&&g.styledFeatures.length&&this._parseTileData(1,i,g,I)}P&&_._compileStyle();const W=this.layer.getDataSchema(T[0].z);if(this._updateSchema(W,m.schema),delete m.features,b&&m.data.length!==H.length){const i=m.data;m.data=[];for(let g=0;g<i.length;g++)i[g]&&i[g].features&&m.data.push(i[g])}const q=_.options.debugTileData;m.layers=H;for(let i=0;i<T.length;i++){const g=T[i];if(0===i&&q){const{x:i,y:m,z:b}=g;(!0===q||q.x===i&&q.y===m&&q.z===b)&&console.log("tile",{layerId:_.getId(),x:i,y:m,z:b,layers:uN(Object.values(I))})}const b=0===i?m:hN(m);for(let i=0;i<b.data.length;i++){if(!b.data[i])continue;const m=b.data[i].features;for(const i in m){m[i].tile=g}}g.extent=b.extent,this._receivedTileExtent||(this._receivedTileExtent=g.extent),b.features=Object.values(I),b.styleCounter=m.styleCounter,this.onTileLoad(b,g)}this.layer.fire("datareceived",{url:i})}_parseTileData(i,g,m,_){const{style:b,isUpdated:T}=this._updatePluginIfNecessary(i,g,m.data),P=this.layer,I=P.isDefaultRender(),H=OF(_,m.styledFeatures,g,b.symbol,P,!(!P.getData||!P.getData()));delete m.styledFeatures,m.features=H;let W=m.data;return Array.isArray(W)&&(W=W[0]),{isUpdated:T,layer:I?{layer:W.layer,type:W.type}:null}}_updateSchema(i,g){for(const m in g){i[m]||(i[m]={types:g[m].types,properties:{}});const _=g[m].properties,b=i[m].properties;for(const i in _)(!b[i]||b[i]&&"object"!==_[i]&&"object"===b[i])&&(b[i]=_[i])}}_updatePluginIfNecessary(i,g,m){Array.isArray(m)&&(m=m[0]);const _=this.layer;let b,T=!1;if(_.isDefaultRender()&&0===i){let i=this._layerPlugins;i||(i=this._layerPlugins={});const g=m.layer,_=m.type;i[g]||(i[g]=[]);const P=("plugin_"+_).trim();i[g][P]?b=i[g][P]:(b=this._getDefaultRenderPlugin(_),b.filter=m.filter,i[g].push(b),i[g][P]=b,T=!0)}else{const P=_._getComputedStyle(),I=_._getTargetStyle(i,P),H=this._getStylePlugins();if(b=I[g],!b.renderPlugin){T=!0;const{plugin:i,symbol:_,renderPlugin:P}=this._getDefaultRenderPlugin(m.type);H[g]=i,b.symbol=_,b.renderPlugin=P}}return{style:b,isUpdated:T}}_getFramePlugins(i){const g=i&&i.style;let m=this._getStylePlugins(g)||[];this.layer.isDefaultRender()&&this._layerPlugins&&(m=[],i?i.layers&&i.layers.forEach((i=>{if(!i)return;const g=("plugin_"+i.type).trim();m.push(this._layerPlugins[i.layer][g].plugin)})):Object.keys(this._layerPlugins).forEach((i=>{for(let g=0;g<this._layerPlugins[i].length;g++)m.push(this._layerPlugins[i][g].plugin)})));const _=this._getFeaturePlugins(g);return _&&_.length&&(m=m.slice(),cF(m,_)),m}_getAllPlugins(){if(this.layer.isDefaultRender()&&this._layerPlugins){const i=[];return Object.keys(this._layerPlugins).forEach((g=>{for(let m=0;m<this._layerPlugins[g].length;m++)i.push(this._layerPlugins[g][m].plugin)})),i}const i=[];for(const g in this._plugins)i.push(...this._plugins[g]);for(const g in this._featurePlugins)i.push(...this._featurePlugins[g]);return i}_getStylePlugins(i){return hF(i)&&(i=this._styleCounter),this._plugins[i]||rN}_getFeaturePlugins(i){return hF(i)&&(i=this._styleCounter),this._featurePlugins[i]||rN}_startFrame(i,g){const m=this._isRenderingTerrain(),_=this.layer.isDefaultRender()&&this._layerPlugins,b=this._parentContext;this._getAllPlugins().forEach(((T,P)=>{if(!T||g&&!g(T))return;if(!this._isVisible(P))return;const I={regl:this.regl||this.device,layer:this.layer,symbol:_?T.defaultSymbol:T.style&&T.style.symbol,gl:this.gl,isRenderingTerrain:m,sceneConfig:T.config?T.config.sceneConfig:null,dataConfig:T.config?T.config.dataConfig:null,pluginIndex:P,timestamp:i};b&&iF(I,b),T.startFrame(I)}))}_endFrame(i){const g=this._parentContext,m=g.renderMode,_=g&&g.renderTarget&&g.renderTarget.fbo,b=this.getMap().cameraPosition,T=this._getAllPlugins(),P=this._isRenderingTerrain(),I=!g.timestamp||g.isFinalRender;T.forEach(this.layer.options.collision&&!g.isPostProcess?g=>{if(!this._isVisible(g)||!g.hasMesh())return;if(m&&"default"!==m&&!g.supportRenderMode(m))return;if(P&&!lN(g))return;const _=this._getPluginContext(g,0,b,i);g.prepareRender(_),g.updateCollision(_)}:g=>{if(!this._isVisible(g)||!g.hasMesh())return;if(m&&"default"!==m&&!g.supportRenderMode(m))return;if(P&&!lN(g))return;const _=this._getPluginContext(g,0,b,i);g.prepareRender(_)});let H=!1;if(this._currentTimestamp!==g.timestamp&&!P){const g=this.layer.getPolygonOffset()+this.layer.getPolygonOffsetCount(),m=this._getPluginContext(null,g,b,i);m.offsetFactor=g,m.offsetUnits=g,this._groundPainter.paint(m)}T.forEach(((g,T)=>{if(!this._isVisitable(g))return;if(m&&"default"!==m&&!g.supportRenderMode(m))return;if(P&&!lN(g))return;this.device.clear({stencil:255,framebuffer:_});const I=this._getPluginContext(g,this._pluginOffsets[T]||0,b,i);g.painter&&g.painter.isEnableTileStencil(I)&&this._drawTileStencil(_,g.painter);const W=g.endFrame(I);W&&W.redraw&&this.setToRedraw(),H=!0})),H&&this.layer.fire("canvasisdirty"),I&&this._drawDebug()}getPolygonOffsetCount(){return this._polygonOffsetIndex||0}_drawDebug(){if(this.layer.options.debug){const i=this._parentContext,g=[],m=this.getMap().projViewMatrix;for(const _ in this.tilesInView){const b=this.tilesInView[_].info,T=this.tilesInView[_].image;if(T._empty)continue;const P=b.transform,I=T.extent,H=i&&i.renderTarget;if(P&&I){const i=this.getDebugInfo(b.id),_=_A(g,m,P),T=this.layer.getTileSize().width;this._debugPainter.draw(i,_,T,I,H&&H.fbo)}}}}_isVisitable(i){if(!i)return!0;const g=this._parentContext,m=this._isVisible(i),_=g&&g.states&&g.states.includesChanged,b=this._hasMesh(i.painter.scene.getMeshes());return!m||!_&&!b?0:b?2:1}_getPluginContext(i,g,m,_){const b=this._isRenderingTerrain(),T=b&&i&&aN(i),P={regl:this.regl||this.device,layer:this.layer,gl:this.gl,isRenderingTerrain:b,isRenderingTerrainSkin:T,sceneConfig:i&&i.config.sceneConfig,pluginIndex:i&&i.renderIndex,polygonOffsetIndex:g,cameraPosition:m,timestamp:_},I=this._parentContext;return I&&iF(P,I),P}_hasMesh(i){if(!i)return!1;const g=this._parentContext&&this._parentContext.sceneFilter;return g?i.filter((i=>g(i)||i.properties.hlBloomMesh&&g(i.properties.hlBloomMesh))).length>0:i.length>0}_drawTileStencil(i,g){const m=g.isUniqueStencilRefPerTile(),_=this.getCurrentTileZoom();let b=this._stencilRenderer;b||(b=this._stencilRenderer=new TileStencilRenderer(this.regl||this.device,this.canvas,this.getMap())),b.start();const{tiles:T}=this._stencilTiles;let{parentTiles:P,childTiles:I}=this._stencilTiles,H=1;I=I.sort(cN);for(let i=0;i<I.length;i++){const g=m?H:this.getTileLevelValue(I[i].info,_);this._addTileStencil(I[i].info,g),H++}P=P.sort(cN);for(let i=0;i<P.length;i++){const g=m?H:this.getTileLevelValue(P[i].info,_);this._addTileStencil(P[i].info,g),H++}const W=T.sort(cN);for(let i=W.length-1;i>=0;i--){const g=m?H:this.getTileLevelValue(W[i].info,_);this._addTileStencil(W[i].info,g),H++}b.render(i)}_addTileStencil(i,g){const m=iN.set(i.extent2d.xmin,i.extent2d.ymax),_=i.extent||this._receivedTileExtent||8192,b=i.transform=i.transform||this.calculateTileMatrix(m,i.z,_);i.stencilRef=g,this._stencilRenderer.add(g,_,b)}onDrawTileStart(i){super.onDrawTileStart(i);const{tiles:g,childTiles:m,parentTiles:_}=i;this._vtCurrentTiles={},this._vtBgTiles={};for(let i=0;i<g.length;i++)this._vtCurrentTiles[g[i].info.id]=1;for(let i=0;i<m.length;i++)this._vtBgTiles[m[i].info.id]=1;for(let i=0;i<_.length;i++)this._vtBgTiles[_[i].info.id]=1;this._stencilTiles=i}isEnableTileStencil(){if(this.layer.options.altitude)return!1;const i=this._getFramePlugins();for(let g=0;g<i.length;g++)if(i[g]&&i[g].painter&&!i[g].painter.isOnly2D())return!1;return!0}setTerrainHelper(i){this._terrainLayer=i}getTerrainHelper(){return this._terrainLayer}drawTileOnTerrain(...i){VectorTileLayerRenderer.prototype.drawTile.call(this,...i)}createTerrainTexture(i){const g=this.layer.getTileSize().width,m=2*g,_=2*g,b=i.texture({min:"linear",mag:"linear",type:"uint8",width:m,height:_});this._terrainDepthStencil||(this._terrainDepthStencil=i.texture({width:m,height:_,format:"depth stencil"}));const T={width:m,height:_,colors:[b],colorFormat:"rgba",ignoreStatusCheck:!0};T.depthStencil=this._terrainDepthStencil;const P=i.framebuffer(T);return P.colorTex=b,P}deleteTerrainTexture(i){i.destroy(),i.colorTex&&(i.colorTex.destroy(),delete i.colorTex)}renderTerrainSkin(i,g,m){if(!this.ready)return;const{plugins:_,featurePlugins:b}=this._preparePlugins();if(!this.layer.isDefaultRender()&&!_.length&&!b.length)return;this.isRenderingTerrainSkin=!0;const T=this._currentTimestamp,P=this._parentContext,I=this.layer.getTileSize().width;this._startFrame(T);for(let g=0;g<m.length;g++){const _=m[g],b=_.texture;this._parentContext={terrainMaskFBO:_.terrainMaskFBO,renderTarget:{fbo:b}},sN.framebuffer=b,i.clear(sN),this._parentContext.viewport=dN(I),this._drawTerrainTile(_.tile)}this._endTerrainFrame(m),this._parentContext=P,this.isRenderingTerrainSkin=!1}_drawTerrainTile(i){const{info:g,image:m}=i;this.drawTile(g,m,aN)}_endTerrainFrame(i){const g=this._getAllPlugins(),m=this.getMap().cameraPosition,_=this._currentTimestamp||0;g.forEach(this.layer.options.collision?i=>{if(!this._isVisible(i)||!i.hasMesh())return;if(!aN(i)||!this.layer.options.awareOfTerrain)return;const g=this._getPluginContext(i,0,m,_);g.isRenderingTerrainSkin=!0,i.prepareRender(g),i.updateCollision(g)}:i=>{if(!this._isVisible(i)||!i.hasMesh())return;if(!aN(i)||!this.layer.options.awareOfTerrain)return;const g=this._getPluginContext(i,0,m,_);g.isRenderingTerrainSkin=!0,i.prepareRender(g)}),g.forEach(((g,m)=>{if(!this._isVisitable(g)||!aN(g))return;for(let g=0;g<i.length;g++){this.device.clear({stencil:255,framebuffer:i[g].texture})}const _=this._getPluginContext(g,this._pluginOffsets[m]||0,[0,0,0],this._currentTimestamp);_.isRenderingTerrainSkin=!0,g.endFrame(_)}))}drawTile(i,g,m){if(!g.cache)return;const _=this._isRenderingTerrain(),b=g.cache,T=iN.set(i.extent2d.xmin,i.extent2d.ymax),P=i.extent||this._receivedTileExtent||8192,I=i.transform=i.transform||this.calculateTileMatrix(T,i.z,P),H=i.tileTranslationMatrix=i.tileTranslationMatrix||this.calculateTileTranslationMatrix(T,i.z),W=i.terrainTransform=i.terrainTransform||this.calculateTerrainTileMatrix(T,i.z,P),q=this._parentContext,$=[];cF($,g.data),cF($,g.featureData);const ye=this._getFramePlugins(g);m||!_||this.isRenderingTerrainSkin||(m=lN),ye.forEach(((T,P)=>{if(!T||m&&!m(T))return;if(!$[P])return;if(!b[P])return;if(b[P].plugin!==T)return void(b[P]&&T.deleteTile({pluginIndex:P,regl:this.regl,layer:this.layer,gl:this.gl,tileCache:b[P],tileInfo:i}));if(this.drawingParentTiles&&!T.painter.shouldDrawParentTile())return;const ye=_&&aN(T),Re={regl:this.regl||this.device,layer:this.layer,gl:this.gl,sceneConfig:T.config.sceneConfig,pluginIndex:P,tileCache:b[P],tileData:$[P],tileTransform:ye?W:I,tileVectorTransform:I,tileTranslationMatrix:H,tileExtent:g.extent,timestamp:this._frameTime,tileInfo:i,tileZoom:this._tileZoom,bloom:this._parentContext&&this._parentContext.bloom,isRenderingTerrain:_,isRenderingTerrainSkin:ye};ye&&q&&q.renderTarget&&(Re.renderTarget=q.renderTarget,T.isTerrainMask()&&(Re.renderTarget={fbo:q.terrainMaskFBO}));const Be=T.paintTile(Re);!this._needRetire&&(Be.retire||Be.redraw)&&T.supportRenderMode("taa")&&(this._needRetire=!0),Be.redraw&&this.setToRedraw()})),g&&g.style===this._styleCounter&&this._retirePrevTile(i)}_createOneTile(i,g){if(!g.loadTime||g._empty)return;let m=g.cache;m||(m=g.cache={});const _=this._isRenderingTerrain(),b=iN.set(i.extent2d.xmin,i.extent2d.ymax),T=i.transform=i.transform||this.calculateTileMatrix(b,i.z,g.extent),P=i.tileTranslationMatrix=i.tileTranslationMatrix||this.calculateTileTranslationMatrix(b,i.z),I=i.terrainTransform=i.terrainTransform||this.calculateTerrainTileMatrix(b,i.z,i.extent),H=[];cF(H,g.data),cF(H,g.featureData);this._getFramePlugins(g).forEach(((b,W)=>{if(!b)return;if(!H[W])return;const q=_&&aN(b),$=this.regl||this.device,ye=this.gl;m[W]&&m[W].plugin===b||(m[W]&&b.deleteTile({pluginIndex:W,regl:this.regl,layer:this.layer,gl:this.gl,tileCache:m[W],tileInfo:i}),m[W]={plugin:b});const Re=b.createTile({regl:$,layer:this.layer,gl:ye,sceneConfig:b.config.sceneConfig,pluginIndex:W,tileCache:m[W],tileData:H[W],tileTransform:q?I:T,tileVectorTransform:T,isRenderingTerrain:_,isRenderingTerrainSkin:q,tileTranslationMatrix:P,tileExtent:g.extent,timestamp:this._frameTime,tileInfo:i,tileZoom:this._tileZoom});m[W].geometry&&(g.data[W]="geometry created"),!this._needRetire&&Re.retire&&b.supportRenderMode("taa")&&(this._needRetire=!0)}))}checkTileInQueue(i){return i.styleCounter===this._styleCounter}pick(i,g,m){const _=[];if(!this.layer.isVisible())return _;return this._getFramePlugins().forEach((b=>{if(!b)return;if(!1===(b.painter&&b.painter.sceneConfig).picking)return;if(!b.isVisible())return;const T=b.pick(i,g,m.tolerance);T&&(T.type=b.getType(),_.push(T))})),_}deleteTile(i){if(i){if(i.image&&!i.image._empty){const g=this._getStylePlugins(i.image&&i.image.style);g&&g.forEach(((g,m)=>{g&&g.deleteTile({pluginIndex:m,regl:this.regl,layer:this.layer,gl:this.gl,tileCache:i.image.cache?i.image.cache[m]:{},tileInfo:i.info,tileData:i.image})})),i.image.cache={}}i.info&&(delete i.info.completeTerrainQuery,delete i.info.terrainQueryStatus),super.deleteTile(i)}}abortTileLoading(i,g){const m=g?gN(g):"";g&&g.url&&(this._workerConn&&this._workerConn.abortTile(m),delete this._requestingMVT[g.url]),this.loadTileArrayBuffer&&aF(this.loadTileArrayBuffer)?this.loadTileArrayBuffer(m,g,(()=>{}),{command:"abortTile"}):super.abortTileLoading(i,g)}resizeCanvas(i){super.resizeCanvas(i);const g=this.canvas;g&&(!this.pickingFBO||this.pickingFBO.width===g.width&&this.pickingFBO.height===g.height||(this.pickingFBO.resize(g.width,g.height),this._getFramePlugins().forEach((i=>{i&&i.resize(g.width,g.height)}))))}onRemove(){this._stencilRenderer&&this._stencilRenderer.remove(),this._workerConn&&(this._workerConn.removeLayer((i=>{if(i)throw i})),this._workerConn.remove(),delete this._workerConn),this.pickingFBO&&(this.canvas.pickingFBO||this.pickingFBO.destroy(),delete this.pickingFBO),this._debugPainter&&(this._debugPainter.delete(),delete this._debugPainter),this._terrainDepthStencil&&(this._terrainDepthStencil.destroy(),delete this._terrainDepthStencil),this._groundPainter&&(this._groundPainter.dispose(),delete this._groundPainter),delete this.gl,delete this.regl,super.onRemove&&super.onRemove(),this._clearPlugin()}_clearPlugin(){this._getAllPlugins().forEach((i=>{i.remove()})),this.plugins={}}hitDetect(i){if(!this.gl||!this.layer.options.hitDetect)return!1;const g=this.gl,m=new Uint8Array(4);return g.readPixels(i.x,this.canvas.height-i.y,1,1,g.RGBA,g.UNSIGNED_BYTE,m),m[3]>0}_initPlugins(){const{style:i,featureStyle:g}=this.layer._getComputedStyle(),m=i.map(((i,g)=>{const m=i.renderPlugin;if(!m)return null;if(!m.type)throw new Error("invalid plugin type for style at "+g);const _=this._createRenderPlugin(m);return _.styleCounter=this._styleCounter,_.style=i,_})),_=[];g.forEach(((i,g)=>{const m=i.renderPlugin;if(!m)return null;if(!m.type)throw new Error("invalid plugin type for features at "+g);const b=this._createRenderPlugin(m);return b.style=i,b.styleCounter=this._styleCounter,_.push(b),b}));const b=this._styleCounter;if(this._plugins[b]=m,this._featurePlugins[b]=_,this.layer.fire("pluginsinited"),this._highlighted&&this._highlighted.size||this.layer._highlighted){this.layer._highlighted&&this.layer._resumeHighlights();this.getMap().getRenderer().callInNextFrame((()=>{this._getFramePlugins().forEach((i=>{i.highlight(this._highlighted)}))}))}return m}_createRenderPlugin(i){const g=this.layer.constructor.getPlugins()[i.type];if(!g)throw new Error(`Plugin for (${i.type}) is not loaded.`);const m=new g;return m.config=i,m.config.sceneConfig||(m.config.sceneConfig={}),m}_createGLContext(i,g){const m=["webgl","experimental-webgl"];let _=null;for(let b=0;b<m.length;++b){try{_=i.getContext(m[b],g)}catch(i){}if(_)break}return _}_getCentiMeterScale(i){return dF(i,this.getMap())}debugFBO(i,g){const m=document.getElementById(i),_=g.width,b=g.height;m.width=_,m.height=b;const T=m.getContext("2d"),P=this.regl.read({framebuffer:g}),I=b/2|0,H=4*_;for(let i=0;i<P.length;i++)P[i]*=255;const W=new Uint8Array(4*_);for(let i=0;i<I;++i){const g=i*H,m=(b-i-1)*H;W.set(P.subarray(g,g+H)),P.copyWithin(g,m,m+H),P.set(W,m)}const q=new ImageData(_,b);q.data.set(P),T.putImageData(q,0,0)}_getDefaultRenderPlugin(i){let g;switch(i){case"native-line":g={type:"native-line",dataConfig:{type:"native-line",only2D:!0}};break;case"native-point":g={type:"native-point",dataConfig:{type:"native-point",only2D:!0}};break;case"fill":g={type:"fill",dataConfig:{type:"fill",only2D:!0},sceneConfig:{antialias:!0}};break;default:g=null}const m=function(i){switch(i){case"native-point":return{markerFill:"#f00",markerSize:6,markerOpacity:.5};case"native-line":return{lineColor:"#bbb",lineOpacity:.5};case"fill":return{polygonFill:"#76a6f0",polygonOpacity:.8}}return null}(i),_=this._createRenderPlugin(g);return _.defaultSymbol=m,{plugin:_,symbol:m,renderPlugin:g}}_isVisible(){return!0}isEnableWorkAround(i){return"win-intel-gpu-crash"===i&&(this.layer.options.workarounds["win-intel-gpu-crash"]&&function(i){const g=i.getExtension("WEBGL_debug_renderer_info");if(g&&"undefined"!=typeof navigator){const m=i.getParameter(g.UNMASKED_RENDERER_WEBGL),_="Win32"===navigator.platform||"Win64"===navigator.platform;if(m&&m.toLowerCase().indexOf("intel")>=0&&_)return!0}return!1}(this.gl))}getZScale(){return this._zScale}outline(i,g){g&&(Array.isArray(g)||(g=[g]),this._outline||(this._outline=[]),this._outline.push(["paintOutline",[i,g]]),this.setToRedraw())}outlineFeatures(i){i&&(Array.isArray(i)||(i=[i]),this._outline||(this._outline=[]),this._outline.push(["paintOutline",[null,i]]),this.setToRedraw())}outlineBatch(i){this._outline||(this._outline=[]),this._outline.push(["paintBatchOutline",[i]]),this.setToRedraw()}outlineAll(){this._outlineAll=!0,this.setToRedraw()}paintOutlineAll(i){const g=this._getFramePlugins();for(let m=0;m<g.length;m++)g[m].outlineAll(i)}paintOutline(i,g,m){if(!hF(g)){const _=g,b=this._getFramePlugins();if(!b[_]||b[_].painter&&!b[_].painter.isVisible())return;return void b[_].outline(i,m)}const _=this._getFramePlugins();for(let g=0;g<m.length;g++){const b=m[g];for(let g=0;g<_.length;g++)_[g].style&&_[g].style.id===b&&_[g].outline(i,[b])}}paintBatchOutline(i,g){const m=this._getFramePlugins();!m[g]||m[g].painter&&!m[g].painter.isVisible()||m[g].outlineAll(i)}cancelOutline(){delete this._outline,delete this._outlineAll,this.setToRedraw()}setZIndex(){return this.setToRedraw(),this._needRetire=!0,super.setZIndex.apply(this,arguments)}consumeTile(i,g){if(i&&!i._empty){const[m,_]=this._findTileAltitude(i);g.minAltitude=m,g.maxAltitude=_}if(this._retirePrevTile(g),super.consumeTile(i,g),"transient"===this.layer.options.features&&i.data){for(let g=0;g<i.data.length;g++){if(!i.data[g])continue;const m=i.data[g].features;if(m)for(const i in m){const g=m[i]&&m[i].feature;g&&(g.fnTypeProps?g.customProps[EF]=g.fnTypeProps:m[i]=null)}}this.layer.fire("_transientfeature",{tileImage:i})}i&&i.features&&(i.features=[]),this._createOneTile(g,i)}_findTileAltitude(i){const g=i.data;let m=-1/0,_=1/0;for(let i=0;i<g.length;i++){if(!g[i])continue;const b=g[i].data;if(b)for(let i=0;i<b.length;i++){const g=b[i];if(!g||!g.properties)continue;const{maxAltitude:T,minAltitude:P}=g.properties;T>m&&(m=T),P<_&&(_=P)}}return oN[0]=_===1/0?0:_,oN[1]=m===-1/0?0:m,oN}onTileError(i,g){this._retirePrevTile(g),super.onTileError(i,g)}_retirePrevTile(i){const{id:g}=i;if(this._prevTilesInView&&this._prevTilesInView[g]){this.deleteTile(this._prevTilesInView[g]),delete this._prevTilesInView[g]}}highlight(i){if(this._highlighted||(this._highlighted=new Map),Array.isArray(i))for(let g=0;g<i.length;g++)hF(i[g].name)&&!hF(i[g].id)&&(i[g]=iF({},i[g]),i[g].name=i[g].id),this._highlighted.set(i[g].name,i[g]);else hF(i.name)&&!hF(i.id)&&((i=iF({},i)).name=i.id),this._highlighted.set(i.name,i);this._getFramePlugins().forEach((i=>{i.highlight(this._highlighted)})),this._highlightUpdated=!0}cancelHighlight(i){if(!this._highlighted)return;if(Array.isArray(i))for(let g=0;g<i.length;g++)this._highlighted.delete(i[g]);else this._highlighted.delete(i);this._getFramePlugins().forEach((i=>{i.highlight(this._highlighted)})),this._highlightUpdated=!0}cancelAllHighlight(){if(!this._highlighted)return;delete this._highlighted;this._getFramePlugins().forEach((i=>{i.cancelAllHighlight()})),this._highlightUpdated=!0}_getLayerOpacity(){const i=this.layer.options.opacity;return hF(i)?1:i}_isRenderingTerrain(){return!!this._terrainLayer&&this.layer.options.awareOfTerrain}}function hN(i){let g;Array.isArray(i.data)?(g=[],cF(g,i.data)):(g={},iF(g,i.data));const m=iF({},i);return m.data=g,m}function cN(i,g){return g.info.z-i.info.z}function uN(i){const g={};for(let m=0;m<i.length;m++){const _=i[m].layer||"default";g[_]||(g[_]=[]),g[_].push(i[m])}return g}function fN(i){if(Array.isArray(i)){const g=i;for(let i=0;i<g.length;i++)if(fN(g[i]))return!0}for(const g in i)if(wL(i[g])||nN.isExpression(i[g]))return!0;return!1}function dN(i){return{x:0,y:0,width:2*i,height:2*i}}function pN(i){if(!i.cache)return[];for(const g in i.cache){const m=i.cache[g];if(m.geometry)for(let i=0;i<m.geometry.length;i++){const g=m.geometry[i]&&m.geometry[i].geometry;if(g&&g.properties&&g.properties.features){const i=g.properties.features.empty;delete g.properties.features.empty;const m=Object.values(g.properties.features);return void 0!==i&&(g.properties.features.empty=i),m}}}return[]}function gN(i){return Po.getAbsoluteURL(i.url)}VectorTileLayerRenderer.include({calculateTileMatrix:function(){const i=new Array(3),g=new Array(3),m=new Array(3);return function(_,b,T){const P=this.getTileGLScale(b),I=_,H=this.layer.getTileSize().width,W=mA([]);return xA(W,W,qA(i,P,P,this._zScale)),vA(W,W,qA(g,I.x,I.y,0)),xA(W,W,qA(m,H/T,-H/T,1)),W}}(),calculateTerrainTileMatrix:function(){const i=new Array(3);return function(g,m,_){const b=mA([]),T=_/2;return xA(b,b,qA(i,1/T,-1/T,0)),vA(b,b,qA(i,-T,-T,0)),b}}(),calculateTileTranslationMatrix:function(){const i=new Array(3);return function(g,m){const _=this.getTileGLScale(m),b=g,T=mA([]);return vA(T,T,qA(i,b.x*_,b.y*_,0)),T}}()});const{PackUtil:mN}=JD(),AN=new un(0,0),yN=new pl(0,0),_N=[null,0],vN=[];class VectorTileLayer extends Up{static loadFrom(i,g){return fetch(i,g||{}).then((i=>i.json())).then((i=>VectorTileLayer.fromJSON(i)))}constructor(i,g){super(i,g),this.isVectorTileLayer=!0,this.hasTerrainMask=!0,this._schema={},this.VERSION=VectorTileLayer.VERSION;this.setStyle(g&&g.style)}setURLModifier(i){this._urlModifier=i;const g=this.getRenderer();return g&&g.updateOptions(),this}getURLModifier(){return this._urlModifier}onAdd(){const i=this.getMap();this._prepareOptions();const g=this.getSpatialReference().toJSON().projection,m=i.getSpatialReference().toJSON().projection;if((g&&g.toLowerCase())!==(m&&m.toLowerCase()))throw new Error(`VectorTileLayer's projection(${g}) must be the same with map(${m}).`)}setFeatureState(i,g){if(hF(i.id))throw new Error("missing id in first parameter of setFeatureState.");this._featureStates||(this._featureStates={});const m=i.layer||"0";let _=this._featureStates[m];return this._featureStates[m]||(_=this._featureStates[m]=new Map),_.set(i.id,g),this._markFeatureState(),this}removeFeatureState(i,g){if(hF(i.id))throw new Error("missing id in first parameter of removeFeatureState.");if(!this._featureStates)return this;const m=this._featureStates[i.layer||"0"];if(!m)return this;if(g){const _=m.get(i.id);if(lF(g))for(const i in g)delete _[i];else delete _[g];m.set(i.id,_)}else m.delete(i.id);return this._markFeatureState(),this}getFeatureState(i){if(hF(i.id))throw new Error("missing id in first parameter of getFeatureState.");if(!this._featureStates)return null;return this._featureStates[i.layer||"0"].get(i.id)}_markFeatureState(){const i=this.getRenderer();if(!i)return;const g=i.getFrameTimestamp();this._featureStamp=g}_getFeatureStateStamp(){return this._featureStamp}_isFeatureStateDirty(i){return this._featureStamp&&this._featureStamp!==i}_prepareOptions(){const i=this.options,g=this.getMap().getProjection(),m="EPSG:4326"===g.code||"EPSG:4490"===g.code,_="EPSG:3857"===g.code;if(!i.spatialReference){512===this.getTileSize().width&&(_?i.spatialReference="preset-vt-3857":m&&(i.spatialReference="preset-vt-4326"))}i.tileSystem||(i.tms?_?i.tileSystem=[1,1,-6378137*Math.PI,-6378137*Math.PI]:m&&(i.tileSystem=[1,1,-180,-90]):m&&(i.tileSystem=[1,-1,-180,90]))}forceReload(){const i=this.getRenderer();return i&&i._incrWorkerCacheIndex(),super.forceReload()}onWorkerReady(){}onConfig(i){const g=this.getRenderer();g&&g.updateOptions(i)}getWorkerOptions(){const i=this.getMap().getRenderer().isWebGPU(),g=this.getRenderer();return{debug:this.options.debug,debugTile:this.options.debugTile,altitudeProperty:this.options.altitudeProperty,tileSize:this.getTileSize().width,style:this.isDefaultRender()?{style:[],featureStyle:[]}:this._getComputedStyle(),features:this.options.debugTileData||this.options.features,schema:this.options.schema,pickingGeometry:this.options.pickingGeometry,projectionCode:this.getSpatialReference().getProjection().code,workerGlyph:this.options.workerGlyph&&!this.getURLModifier(),featureIdProperty:this.options.featureIdProperty,isWebGPU:i,isWebGL1:g.gl&&g.gl instanceof WebGLRenderingContext}}setStyle(i){if(i&&(oF(i)||i.url)){const g=i,m=g.lastIndexOf("/"),_=m<0?".":g.substring(0,m);return this.ready=!1,mF.getJSON(i.url?i.url:i,i.url?i:{},((i,m)=>{if(i)throw this.setStyle([]),i;let b;m.style?(b=m,b.$root||(b.$root=_)):b={$root:_,style:m},this.options.style=g,this._setStyle(b)})),this}return this.options.style=i,this._setStyle(i),this}_tilePointToPoint(i,g,m,_){const b=_/this.getTileSize().width;return i.set(m.x+g.x/b,m.y-g.y/b)}queryTilePointTerrain(i,g,m,_,b){const T=this.getRenderer(),P=T&&T.getTerrainHelper();if(!T||!P)return _N[0]=null,_N[1]=0,_N;const I=this._tilePointToPoint(AN,i,m,_);return g&&P.queryTileTerrainByPointAtRes?P.queryTileTerrainByPointAtRes(I,b,g.id,g,vN):(_N[0]=null,_N[1]=0,_N)}queryTerrainTiles(i){const g=this.getRenderer(),m=g&&g.getTerrainHelper();return g&&m?m.getTerrainTiles(this,i):null}_setStyle(i){if(i&&i.$root){let g=i.$root;g&&"/"===g[g.length-1]&&(g=g.substring(0,g.length-1)),this._replacer=function(i){return"{$root}"===i?g:null}}this.ready=!0,i=i||[],Array.isArray(i)?i={style:i}:i.renderPlugin&&(i={style:[i]}),i=function(i){if(!i.plugins)return i;const{plugins:g,styles:m}=i;let{style:_,featureStyle:b}=m;_=_||[],b=b||[];const T=new Array(_.length);for(let i=0;i<_.length;i++)T[i]=iF({},_[i]),T[i].renderPlugin=g[_[i].renderPlugin];const P=new Array(b.length);for(let i=0;i<b.length;i++)P[i]=iF({},b[i]),P[i].renderPlugin=g[b[i].renderPlugin];const I={style:T,featureStyle:P};return i.$root&&(I.$root=i.$root),I}(i=VF(i));const g=this.getRenderer();if(g){const m=this._parseStyle(i);g.setStyle(m,(()=>{this._loadStyle(i)}))}else this._loadStyle(i)}_parseStyle(i){const g=i.background||{};return{originFeatureStyle:i.featureStyle||[],featureStyle:TN(i.featureStyle),style:i.style||[],background:{enable:g.enable||!1,color:bN(g.color)||[0,0,0,0],opacity:wN(g.opacity,1),patternFile:g.patternFile,depthRange:g.depthRange}}}_loadStyle(i){const g=this._parseStyle(i);this._originFeatureStyle=g.originFeatureStyle,this._featureStyle=g.featureStyle,this._vtStyle=g.style,this._background=g.background,this.validateStyle(),this._replacer&&this._parseStylePath(),this._compileStyle(),this.fire("setstyle",{style:this.getStyle(),computedStyle:this.getComputedStyle()})}getPolygonOffsetCount(){const i=this.getRenderer();return i?i.getPolygonOffsetCount():0}getPolygonOffset(){return this._polygonOffset||0}setPolygonOffset(i,g){return this._polygonOffset=i,this._totalPolygonOffset=g,this}getTotalPolygonOffset(){return this._totalPolygonOffset}_convertTileFeatuers(i){for(let g=0,m=i.length;g<m;g++){const m=i[g];if(!m)continue;this._convertFeatures(m.features||[])}return i}_convertFeatures(i){if(!i||!i.length)return;const g=this._getTileConfig();let m;for(let _=0,b=i.length;_<b;_++){const{feature:b,tile:T}=i[_],P=b.geometry;if(!b||!T||!P)continue;if(P.type)continue;const{x:I,y:H,res:W,extent:q}=T;undefined===I&&undefined===H&&undefined===W||(m=g.getTilePointNW(I,H,W));const $=this._convertGeometry(b.type,P,m,q,W);b.geometry=$}}getCurrentRenderedFeatures(){const i=this.getRenderer();if(!i)return[];const g=i.getCurrentRenderedFeatures()||[];return this._convertTileFeatuers(g)}getRenderedFeatures(){const i=this.getRenderer();if(!i)return[];const g=i.getRenderedFeatures()||[];return this._convertTileFeatuers(g)}getRenderedFeaturesAsync(i={}){return new Promise(((g,m)=>{const _=this.getRenderer();if(_)if(Qs){const m=_.getRenderedFeatures()||[],b=[];m.forEach((i=>{const g=i.features||[];g.length&&cF(b,g)}));const T=(i=Object.assign({},{countPerTime:1e4},i)).countPerTime,P=Math.ceil(b.length/T);let I=1;const H=()=>{const i=b.slice((I-1)*T,I*T);this._convertFeatures(i),I++};Qs.runTaskAsync({count:P,run:H}).then((()=>{g(m)}))}else g(this.getRenderedFeatures());else g([])}))}outlineAll(){const i=this.getRenderer();return i?(i.outlineAll(),this):this}outline(i,g){const m=this.getRenderer();return m?(m.outline(i,g),this):this}outlineBatch(i){const g=this.getRenderer();return g?(g.outlineBatch(i),this):this}outlineFeatures(i){const g=this.getRenderer();return g?(g.outlineFeatures(i),this):this}cancelOutline(){const i=this.getRenderer();return i?(i.cancelOutline(),this):this}highlight(i){this._validateHighlight(i);const g=this.getRenderer();return g?(g.highlight(i),this):(this._highlighted||(this._highlighted=[]),this._highlighted.push(i),this)}_validateHighlight(i){if(Array.isArray(i))for(let g=0;g<i.length;g++)this._validateHighlight(i[g]);else{if(i.filter){if(!this.options.features)throw new Error("options.features must be turned on to support filter in highlight");if(!i.name)throw new Error("A name is required for highlight with filter")}if(hF(i.filter)&&hF(i.id))throw new Error("id or filter must be provided for highlight")}}_resumeHighlights(){if(this._highlighted){for(let i=0;i<this._highlighted.length;i++)this.highlight(this._highlighted[i]);delete this._highlighted}}cancelHighlight(i){const g=this.getRenderer();return g?(g.cancelHighlight(i),this):this}cancelAllHighlight(){const i=this.getRenderer();return i?(i.cancelAllHighlight(),this):this}_parseStylePath(){Po.convertStylePath(this._vtStyle,this._replacer),Po.convertStylePath(this._featureStyle,this._replacer)}updateSceneConfig(i,g){return oF(i)&&(i=this._getStyleIndex(i)),this._updateSceneConfig(0,i,g)}updateFeatureSceneConfig(i,g,m){return this._updateSceneConfig(1,i,m,g)}_updateSceneConfig(i,g,m,_){const b=this._getTargetStyle(i);if(!b)return this;let T,P=g;if(b[g].renderPlugin.sceneConfig||(b[g].renderPlugin.sceneConfig={}),iF(b[g].renderPlugin.sceneConfig,m),void 0!==_){SN(this._originFeatureStyle,g,_),P=this._originFeatureStyle[g].style[_]._renderIdx;const i=b[P].renderPlugin;i.sceneConfig||(i.sceneConfig={}),T=i.sceneConfig}else MN(b,g),T=b[g].renderPlugin.sceneConfig;if(iF(T,m),Array.isArray(this.options.style)){const i=this.options.style[g].renderPlugin;i.sceneConfig||(i.sceneConfig={}),iF(i.sceneConfig,m)}else{const b=this._getTargetStyle(i,this.options.style);let T;void 0!==_?(SN(b,g,_),T=b[g].style[_].renderPlugin):(MN(b,g),T=b[g].renderPlugin),T.sceneConfig||(T.sceneConfig={}),iF(T.sceneConfig,m)}const I=this.getRenderer();return I&&I.updateSceneConfig(i,P,m),0===i?this.fire("updatesceneconfig",{index:g,sceneConfig:m}):1===i&&this.fire("updatefeaturesceneconfig",{index:g,styleIdx:_,sceneConfig:m}),this}updateDataConfig(i,g){return oF(i)&&(i=this._getStyleIndex(i)),this._updateDataConfig(0,i,g)}updateFeatureDataConfig(i,g,m){return this._updateDataConfig(1,i,m,g)}_updateDataConfig(i,g,m,_){const b=this._getTargetStyle(i);if(!b)return this;let T,P=g;void 0!==_?(SN(this._originFeatureStyle,g,_),P=this._originFeatureStyle[g].style[_]._renderIdx,T=b[P].renderPlugin.dataConfig):(MN(b,g),T=b[g].renderPlugin.dataConfig);const I=iF({},T);if(iF(T,m),Array.isArray(this.options.style))iF(this.options.style[g].renderPlugin.dataConfig,m);else{const b=this._getTargetStyle(i,this.options.style);let T;void 0!==_?(SN(b,g,_),T=b[g].style[_].renderPlugin):(MN(b,g),T=b[g].renderPlugin),T.dataConfig||(T.dataConfig={}),iF(T.dataConfig,m)}const H=this.getRenderer();return H&&H.updateDataConfig(i,P,m,I),0===i?this.fire("updatedataconfig",{index:g,dataConfig:m}):1===i&&this.fire("updatefeaturedataconfig",{index:g,styleIdx:_,dataConfig:m}),this}updateSymbol(i,g){return oF(i)&&(i=this._getStyleIndex(i)),this._updateSymbol(0,i,g)}updateFeatureSymbol(i,g,m){return this._updateSymbol(1,i,m,g)}_updateSymbol(i,g,m,_){const b=this._getTargetStyle(i);if(!b)return this;let T=g;void 0!==_&&(SN(this._originFeatureStyle,g,_),T=this._originFeatureStyle[g].style[_]._renderIdx);const P=b[T];if(!P)throw new Error(`No style defined at ${g}`);const I=this,H=this._replacer;function W(m,b,T){if(!m)return!1;H&&(m=JSON.parse(JSON.stringify(m)),Po.parseSymbolPath(m,H));const P=Object.keys(m);let W=!1;for(let i=0;i<P.length;i++){const g=P[i];if(xN(b[g])||xN(m[g])){W=!0;break}}for(const i in m)fF(m,i)&&(!Po.isObject(m[i])||Array.isArray(m[i])||wL(m[i])?b[i]=m[i]:(b[i]||(b[i]={}),iF(b[i],m[i])));let q=I.options.style;if(oF(q))return W;Array.isArray(q)||(q=I._getTargetStyle(i,I.options.style));const $=JSON.parse(JSON.stringify(b));return void 0!==_?(SN(q,g,_),void 0===T?q[g].style[_].symbol=$:q[g].style[_].symbol[T]=$):(MN(q,g),void 0===T?q[g].symbol=$:q[g].symbol[T]=$),W}const q=this.getRenderer();if(!q)return W(),this._compileStyle(),this;let $=!1;const ye=P.symbol;if(Array.isArray(m))for(let i=0;i<m.length;i++){const g=W(m[i],ye[i],i);g&&($=g)}else W(m,ye);return this._compileStyle(),$?q.setStyle():($=q.updateSymbol(i,T,m),$&&q.setStyle()),0===i?this.fire("updatesymbol",{index:g,symbol:m}):1===i&&this.fire("updatefeaturesymbol",{index:g,featureStyleIndex:_,symbol:m}),this}_getTargetStyle(i,g){if(g){return 0===i?g.style:g.featureStyle}return 0===i?this._vtStyle:this._featureStyle}isDefaultRender(){return!!this._isDefaultRender&&this.options.defaultRendering}validateStyle(){this._isDefaultRender=!1;let i=this._vtStyle;this.options.style||(this._isDefaultRender=!0,i=this._vtStyle=[]),Array.isArray(i)||(i=this._vtStyle=[i]);for(let g=0;g<i.length;g++){let m=i[g].filter;if(m&&m.value&&(m=m.value),m||console.warn(`render plugin at ${g} doesn't define filter, its filter will be set to 'default' by default.`),void 0!==m&&"default"!==m&&!0!==m&&!Array.isArray(m)&&void 0===m.condition)throw new Error(`Invalid filter at ${g} : ${JSON.stringify(m)}`);i[g].symbol||(i[g].symbol={})}}getStyle(){return this.options.style?JSON.parse(JSON.stringify(this.options.style)):null}_getStyleIndex(i){const g=this._vtStyle;if(!g)return-1;for(let m=0;m<g.length;m++)if(g[m].name===i)return m;throw new Error(`No style defined with name: ${i}`)}getGroundConfig(){this._backgroundConfig||(this._backgroundConfig={enable:!0,renderPlugin:{type:"fill",sceneConfig:{}},symbol:{polygonFill:[0,0,0,0],polygonOpacity:1}});const i=this._getComputedStyle().background||{};return this._backgroundConfig.enable=i.enable,this._backgroundConfig.symbol.polygonFill=i.color,this._backgroundConfig.symbol.polygonOpacity=i.opacity,this._backgroundConfig.symbol.polygonPatternFile=i.patternFile,this._backgroundConfig.renderPlugin.sceneConfig.depthRange=i.depthRange,this._backgroundConfig}getComputedStyle(){return JSON.parse(JSON.stringify(this._getComputedStyle()))}_getComputedStyle(){return{background:this._background,style:this._vtStyle||[],featureStyle:this._featureStyle||[]}}identify(i,g={}){const m=this.getMap(),_=this.getRenderer();if(!m||!_)return[];const b=m.coordToContainerPoint(new pl(i));return this.identifyAtPoint(b,g)}identifyAtPoint(i,g={}){const m=this.getMap(),_=this.getRenderer();if(!m||!_)return[];const b=m.getDevicePixelRatio();let T=_.pick(i.x*b,i.y*b,g);return this.options.features&&"id"!==this.options.features&&(T=this._convertPickedFeature(T)),g&&g.filter?T.filter((i=>g.filter(i))):T}_convertPickedFeature(i){if(!this.getRenderer())return i;const g=this._getTileConfig(),m=this.getSpatialReference();for(let _=0;_<i.length;_++){let b=i[_];if(!b||!b.data)continue;const{tile:T}=b.data,{x:P,y:I,z:H,extent:W}=T,q=m.getResolution(H),$=g.getTilePointNW(P,I,q),ye=b.data.feature&&b.data.feature.geometry;if(ye){b.data=iF({},b.data),b.data.feature=iF({},b.data.feature);const i=b.data.feature.type;b.data.feature.type="Feature",b.data.feature.geometry=this._convertGeometry(i,ye,$,W,q)}}return i}_convertGeometry(i,g,m,_,b){if(g.type&&g.coordinates)return g;let T,P;if(1===i)g.length<=1?(T="Point",P=this._convertGeometryCoords(g,m,_,b)||[]):(T="MultiPoint",P=this._convertGeometryCoords(g,m,_,b));else if(2===i)g.length<=1?(T="LineString",P=this._convertGeometryCoords(g,m,_,b)||[]):(T="MultiLineString",P=this._convertGeometryCoords(g,m,_,b));else if(3===i){P=[];let i=[],I=0;for(let T=0;T<g.length;T++){mN.calculateSignedArea(g[T])>0&&(I++,i&&i.length&&P.push(i),i=[]),i.push(this._convertGeometryCoords(g[T],m,_,b))}i.length&&P.push(i),I<=1?(T="Polygon",P=P[0]):T="MultiPolygon"}return{type:T,coordinates:P}}_convertGeometryCoords(i,g,m,_){const b=m/this.getTileSize().width,T=this.getMap(),P=i=>{const m=[];lF(i)&&(i=[i]);for(let P=0,I=i.length;P<I;P++){const I=i[P];AN.x=g.x+I.x/b,AN.y=g.y-I.y/b,T.pointAtResToCoord(AN,_,yN),m.push(yN.toArray())}return 1===i.length?m[0]:m};if(lF(i))return P(i);const I=i.length;if(1===I){return P(i[0])}{let g=[];for(let m=0;m<I;m++)g.push(P(i[m]));return g}}getDataSchema(i){return this._schema||(this._schema={}),hF(i)||this._schema[i]||(this._schema[i]={}),hF(i)?this._schema:this._schema[i]}onRemove(){super.onRemove()}clear(){const i=this.getRenderer();return i&&i.clearData(),super.clear()}static fromJSON(i){return i&&"VectorTileLayer"===i.type?new VectorTileLayer(i.id,i.options):null}_compileStyle(){}static registerPlugin(i){VectorTileLayer.plugins||(VectorTileLayer.plugins={}),VectorTileLayer.plugins[i.type]=i}static getPlugins(){return VectorTileLayer.plugins||{}}static compressStyleJSON(i){return Array.isArray(i)&&i.length?function(i){Array.isArray(i)&&(i={style:i,featureStyle:[]});const g=[],m=[],_=[];pF(i.style,g,_),pF(i.featureStyle,m,_);const b={plugins:_,styles:{style:g,featureStyle:m}};return i.$root&&(b.$root=i.$root),b}(i):i}}function xN(i){return!(!i||!i.properties)}function bN(i){return i?(Array.isArray(i)||(i=iL(i).unitArray()),3===i.length&&i.push(1),i):null}function wN(i,g){return null==i?g:i}function TN(i){if(!i||!Array.isArray(i))return[];const g=[];for(let m=0;m<i.length;m++){const _=i[m].style;if(_&&Array.isArray(_)&&_.length)for(let b=0;b<_.length;b++){const T=iF({},i[m],_[b]);_[b]._renderIdx=g.length,delete T.style,g.push(T)}else g.push(iF({},i[m]))}return g}function SN(i,g,m){if(!i[g]||!i[g].style||!i[g].style[m])throw new Error(`No plugin defined at feature style of ${g} - ${m}`)}function MN(i,g){if(!i[g])throw new Error(`No plugin defined at style of ${g}`)}VectorTileLayer.prototype._getTileZoom=function(i){return i=Math.floor(i),Up.prototype._getTileZoom.call(this,i)},VectorTileLayer.registerJSONType("VectorTileLayer"),VectorTileLayer.mergeOptions({urlTemplate:null,renderer:"gl",altitudeProperty:"altitude",forceRenderOnZooming:!0,forceRenderOnMoving:!0,forceRenderOnRotating:!0,tileSize:[512,512],features:!1,schema:!1,cascadeTiles:!0,collision:!0,collisionBuffserSize:0,picking:!0,pickingPoint:!0,pickingGeometry:!1,glyphSdfLimitPerFrame:15,tileLimitPerFrame:1,loadingLimitOnInteracting:5,loadingLimit:0,antialias:!1,iconErrorUrl:null,collisionFrameLimit:1.5,defaultRendering:!0,textGamma:1,maxIconSize:254,workarounds:{"win-intel-gpu-crash":!1},pyramidMode:1,styleScale:1,enableAltitude:!0,fadeAnimation:!1,debugTileData:!1,fetchOptions:null,awareOfTerrain:!0,altitudeQueryTimeLimitPerFrame:3,workerGlyph:!0,featureIdProperty:null,currentTilesFirst:!0,tileStackStartDepth:3,tileStackDepth:2,altitudePropertyName:null,disableAltitudeWarning:!1,loadTileErrorLog:!0,loadTileErrorLogIgnoreCodes:[404,204],loadTileCachMaxSize:0,loadTileCacheLog:!0}),VectorTileLayer.registerRenderer("gl",VectorTileLayerRenderer),VectorTileLayer.registerRenderer("gpu",VectorTileLayerRenderer),VectorTileLayer.registerRenderer("canvas",null);const CN=new ir(1,1);class Vector3DLayer extends td{static registerPainter(i,g){Vector3DLayer.painters||(Vector3DLayer.painters={}),Vector3DLayer.painters[i]=g}static get3DPainterClass(i){return Vector3DLayer.painters[i]}setURLModifier(i){return this._urlModifier=i,this}getURLModifier(){return this._urlModifier}getEvents(){let i;return i=super.getEvents?super.getEvents():{},i.spatialreferencechange=this._onSpatialReferenceChange,i}onConfig(i){if(super.onConfig(i),void 0!==i.enableBloom){const g=this.getRenderer();g&&g.updateBloom(i.enableBloom)}}updateSymbol(i,g){if(!this.options.style)throw new Error("can't call update symbol when style is not set");const m=Array.isArray(this.options.style)?this.options.style:this.options.style.style;if(!m[i])throw new Error(`invalid style at ${i}`);return iF(m[i].symbol,g),this.setStyle(this.options.style),this}getPolygonOffsetCount(){return this.isEmpty()||this.options.altitude?0:1}getPolygonOffset(){return this.options.altitude?0:this._polygonOffset||0}setPolygonOffset(i,g){return this._polygonOffset=i,this._totalPolygonOffset=g,this}getTotalPolygonOffset(){return this._totalPolygonOffset}identify(i,g={}){const m=this.getMap(),_=this.getRenderer();if(!m||!_)return[];const b=m.coordToContainerPoint(new pl(i));return this.identifyAtPoint(b,g)}identifyAtPoint(i,g={}){const m=this.getMap(),_=this.getRenderer();if(!m||!_)return[];const b=this.getMap().getDevicePixelRatio(),T=_.pick(i.x*b,i.y*b,g);return g&&g.filter?T.filter((i=>g.filter(i))):T}getComputedStyle(){return{style:this.getStyle()||[]}}outlineAll(){const i=this.getRenderer();return i?(i.outlineAll(),this):this}outline(i){if(!Array.isArray(i)||!i.length)return this;const g=this.getRenderer();return g?(g.outline(i),this):this}cancelOutline(){const i=this.getRenderer();return i?(i.cancelOutline(),this):this}toJSON(){const i={type:this.getJSONType(),id:this.getId(),options:this.config(),geometries:[]},g=this.getGeometries();for(let m=0,_=g.length;m<_;m++){const _=g[m].toJSON();i.geometries.push(_)}return i}getTileSize(){return CN}_onSpatialReferenceChange(){const i=this.getRenderer();i&&i._onSpatialReferenceChange()}}Vector3DLayer.mergeOptions({picking:!0,pickingPoint:!0,renderer:"gl",collision:!1,collisionBufferSize:0,textGamma:1,geometryEvents:!0,styleScale:1,forceRenderOnZooming:!0,forceRenderOnMoving:!0,forceRenderOnRotating:!0,meshRenderOrder:0,enableBloom:!1,enableAltitude:!0,workarounds:{"win-intel-gpu-crash":!0}});const PN={redraw:!1,retire:!1},IN=[];let kN=1;function ON(i,g){const m=tD.extend(i,{init:function(){this._meshCache={}},isVisible(){return this.painter&&this.painter.isVisible()},supportRenderMode:function(i){return this.painter.supportRenderMode(i)},hasMesh(){return this.painter&&this.painter.hasMesh()},startFrame:function(i){const m=i.sceneConfig;let _=this.painter;if(!_){_=this.painter=new g(i.regl,i.layer,i.symbol,m,i.pluginIndex,i.dataConfig)}this._meshCache||(this._meshCache={});const b=m.excludes;this._excludes?b!==this._excludes&&(this._excludesFunc=b?GL(b):null,this._excludes=b):b&&(this._excludes=b),_.startFrame(i),this._frameCache={}},updateCollision:function(i){const g=this.painter;return g&&g.isVisible()?g.updateCollision(i):null},prepareRender:function(i){const g=this.painter;return g&&g.isVisible()?g.prepareRender(i):null},endFrame:function(i){const g=this.painter;return g&&g.isVisible()?g.render(i):null},getShadowMeshes(){const i=this.painter;return i&&i.getShadowMeshes&&i.getShadowMeshes()||IN},createTile:function(i){const{tileCache:g,tileData:m,tileInfo:_}=i;let b=!1;const T=this.painter;if(!T)return{retire:b};const P=this._getMeshKey(i);let I=g.geometry;if(!I){const P=m.features,H=m.data;if(!H||!H.length)return{retire:b};const W=H;for(let i=0;i<H.length;i++)W[i].tileInfo=_;if(this.painter.colorSymbol&&!function(i){if(!i)return!0;for(const g in i)return!1;return!0}(P))for(let i=0;i<H.length;i++){const g=this._generateColorArray(P,H[i].data.aPickingId,H[i].indices,H[i].data.aPosition,H[i].positionSize);H[i].data.aColor=g}I=g.geometry=T.createGeometries(W,P);for(let g=0;g<I.length;g++)I[g]&&I[g].geometry&&(b=!0,I[g].geometry.properties.features=P,this._fillCommonProps(I[g].geometry,i))}let H=this._getMesh(P);if(!H){const{meshes:g,retire:m}=this._createMeshes(I,i);b||(b=m),H=g}return{retire:b}},_createMeshes(i,g){const{tileInfo:m,tileExtent:_,tileTransform:b,tileTranslationMatrix:T,tileVectorTransform:P,tileZoom:I,sceneConfig:H}=g;let W=!1;const q=this.painter,$=q.createMeshes(i,b,{tileExtent:_,tilePoint:[m.extent2d.xmin,m.extent2d.ymax],tileZoom:I,tileTranslationMatrix:T,tileVectorTransform:P},g);if($.length){for(let i=0;i<$.length;i++)$[i]&&(W=!0,this._fillMeshProps($[i],b,g.timestamp,kN++,q.isEnableTileStencil()));H.animation&&($._animationTime=g.timestamp);const i=this._getMeshKey(g);this._meshCache[i]=$}return{meshes:$,retire:W}},paintTile:function(i){const{tileCache:g,tileInfo:m,tileZoom:_,sceneConfig:b}=i,T=this.painter;if(!T)return PN;let P=g.geometry;if(!P)return PN;let I=!1;const H=this._getMeshKey(i);let W=this._getMesh(H);if(!W){const{meshes:g,retire:m}=this._createMeshes(P,i);I||(I=m),W=g}if(!W.length)return PN;const q=T.getTileLevelValue(m,_);W.forEach((i=>{i.properties.tile=m,i.properties.level=q}));let $=!1;if(!this._frameCache[H]){let g=null,m=b.animation;if(m){const _=i.sceneConfig.animationDuration||800,b=(i.timestamp-W._animationTime)/_;W._animationTime-W[0].properties.createTime<_&&b<1&&(!0!==m&&1!==m||(m="linear"),g="linear"===m?b:zL(m,b),$=!0)}T.addMesh(W,g,i),this._frameCache[H]=1}return{redraw:$,retire:I}},_fillMeshProps:function(i,g,m,_,b){if(i.properties.tileTransform=g,i.properties.createTime=m,i.properties.meshKey=_,i.needUpdateShadow=!0,b){const g=i.defines||{};g.ENABLE_TILE_STENCIL=1,i.setDefines(g)}"stencilRef"in i.uniforms||Object.defineProperty(i.uniforms,"stencilRef",{enumerable:!0,get:function(){return i.properties.tile&&void 0!==i.properties.tile.stencilRef?i.properties.tile.stencilRef:i.properties.level}})},_fillCommonProps:function(i,g){const{layer:m,tileInfo:_}=g,b=m.getMap(),T=(m.getSpatialReference?m.getSpatialReference():b.getSpatialReference()).getResolution(_.z),P=g.tileExtent/m.getTileSize().width;i.properties.tileResolution=T,i.properties.tileRatio=P,i.properties.z=_.z,i.properties.tileExtent=g.tileExtent},updateSceneConfig:function(i){const g=this.painter;g&&g.updateSceneConfig(i.sceneConfig)},updateDataConfig:function(i,g){const m=this.painter;return!m||m.updateDataConfig(i,g)},updateSymbol:function(i,g){const m=this.painter;if(!m)return!1;if(m.shouldDeleteMeshOnUpdateSymbol(i)){if(this._meshCache)for(const i in this._meshCache)m.deleteMesh(this._meshCache[i],!0);delete this._meshCache,delete this._frameCache}return m.updateSymbol(i,g)},pick:function(i,g,m){return this.painter&&this.painter.pick?this.painter.pick(i,g,m):null},deleteTile:function(i){if(!this._meshCache)return;const g=this._getMeshKey(i),m=this._meshCache[g];m&&this.painter&&this.painter.deleteMesh(m),delete this._meshCache[g],this._frameCache&&delete this._frameCache[g]},remove:function(){const i=this.painter;if(i&&this._meshCache){for(const g in this._meshCache)i.deleteMesh(this._meshCache[g]);i.delete(),delete this.painter}delete this._meshCache,delete this._frameCache},resize:function(i,g){const m=this.painter;m&&m.resize(i,g)},needToRedraw:function(){return!!this.painter&&this.painter.needToRedraw()},needToRetireFrames:function(){return!!this.painter&&this.painter.needToRetireFrames()},isAnimating(){return!!this.painter&&this.painter.isAnimating()},needToRefreshTerrainTileOnZooming:function(){return!!this.painter&&this.painter.needToRefreshTerrainTileOnZooming()},isTerrainSkin:function(){return!!this.painter&&this.painter.isTerrainSkin()},isTerrainVector:function(){return!!this.painter&&this.painter.isTerrainVector()},isTerrainMask:function(){return!!this.painter&&this.painter.isTerrainMask()},_generateColorArray:function(i,g,m,_,b=3){if(!_||!i||!g.length)return null;const T=new Uint8Array(_.length/b*4);let P,I;const H=this.painter.colorSymbol,W={};let q;for(let m=0,_=g.length;m<_;m++){const _=g[m];if(P=i[_].symbol,I=W[_],!I)if(H){let g;g="function"==typeof H?H(i[_].feature&&i[_].feature.properties):H,g=iL(g),I=W[_]=g.array()}else I=W[_]=[255,255,255];q=4*m,T[q]=I[0],T[q+1]=I[1],T[q+2]=I[2],T[q+3]=255*(P[this.painter.opacitySymbol]||1)}return T},_getMeshKey:function(i){const g=i.tileInfo;return g.meshKey||(g.meshKey=kN++),g.meshKey},_getMesh:function(i){return this._meshCache[i]},_filterElements(i,g){if(Array.isArray(i))i.forEach(((i,m)=>{const{features:_}=i.properties;this._filterGeoElements(i,g[m],_)}));else{const{features:m}=i.properties;this._filterGeoElements(i,Array.isArray(g)?g[0]:g,m)}},_filterGeoElements(i,g,m){const _=g.featureIndexes||g.data.featureIndexes;if(_)if(this._excludesFunc){const b=g.indices;let T=null,P=!1;const I=[];for(let i=0;i<b.length;i++){null!==T&&T===b[i]||(P=this._excludesFunc(m[_[b[i]]].feature),T=b[i]),P||I.push(b[i])}i.setElements(new g.indices.constructor(I))}else i.setElements(g.indices)},outline(i,g){const m=this.painter;m&&m.outline(i,g)},outlineAll(i){const g=this.painter;g&&g.outlineAll(i)},needPolygonOffset(){const i=this.painter;return i&&i.needPolygonOffset()},highlight(i){const g=this.painter,m=this.style.name,_=this.renderIndex;if(i){const g=[];if(i.forEach(((i,b)=>{null!=i.plugin&&(Array.isArray(i.plugin)?i.plugin.length&&i.plugin.indexOf(m)<0&&i.plugin.indexOf(_)<0&&g.push(b):i.plugin!==m&&i.plugin!==_&&g.push(b))})),g.length){const m=new Map(i);for(let i=0;i<g.length;i++)m.delete(g[i]);i=m}}return g&&g.highlight(i)},cancelAllHighlight(){const i=this.painter;return i&&i.cancelAllHighlight()}});return m}function EN(i){return!i||(void 0!==i.empty||(i.empty=function(i){for(const g in i)return!1;return!0}(i)),i.empty)}const{StyleUtil:RN}=JD(),LN="_fn_type_",DN="__current_fn_types";function FN(i,g,m,_){if(!EN(i.properties.features))for(let b=0;b<m.length;b++){const{symbolName:T}=m[b];(i[DN]=i[DN]||{})[T]=g[T],NN(i,g,m[b],_)}}function NN(i,g,m,_){const b=function(i){const g=i.properties;let m=g.aPickingId;m||(m=g.aPickingId=new i.data.aPickingId.constructor(i.data.aPickingId));return m}(i),{attrName:T,symbolName:P,related:I}=m;let H=i.data[T];return H?XN(g[P])||function(i,g){if(!Array.isArray(i))return!1;for(let m=0;m<i.length;m++)if(XN(g[i[m]]))return!0;return!1}(I,g)?(XN(g[P])&&HN(i,g,m),H):(void 0===m.index&&(i.deleteData(T),BN(i,T)),null):XN(g[P])&&function(i,g){if(i.startsWith("marker")&&!g.properties.iconAtlas)return!1;if(i.startsWith("text")&&!g.properties.glyphAtlas)return!1;return!0}(P,i)?(H=i.data[T]=new m.type(m.width*b.length),function(i,g,m,_,b){const{attrName:T}=_,P=(LN+T+"Index").trim();HN(g,m,_);const I=g.properties[P];jN(g,I,_,b)}(H,i,g,m,_),H):null}function HN(i,g,m){const{attrName:_,symbolName:b}=m,T=i.properties,P=(LN+_+"Index").trim(),I=(LN+_).trim();if(T[P]&&T[I])return;const H=function(i){if(!i)return GN;const g=[];for(let m=0;m<i.length;m++)wL(i[m][1])&&!SL(i[m][1]).isZoomConstant&&g.push(i[m][0]);return g}(g[b].stops),W="identity"===g[b].type&&RN.checkIfIdentityZoomDependent(b,g[b].property,T.features);if(!W&&!H.length)return void(void 0===m.index&&BN(i,_));const{features:q,aPickingId:$}=T,ye=function(i,g,m,_,b){const T=[];let P=0,I=g[0];for(let H=1,W=g.length;H<W;H++)!i[I]||g[H]===I&&H!==W-1||((b||UN(i[I].feature,m,_))&&T.push(P,H===W-1?W:H),I=g[H],P=H);return T}(q,$,g[b].property,H,W);if(!ye.length)return void(void 0===m.index&&BN(i,_));if(T[P]=ye,T[I])return;const Re=i.data[_];T[I]=Re.BYTES_PER_ELEMENT?new Re.constructor(Re):new m.type(Re.length)}function BN(i,g){const m=i.properties,_=(LN+g+"Index").trim(),b=(LN+g).trim();delete m[_],delete m[b]}function zN(i,g,m,_,b,T){if(!b)return;const P=b.geometry;if(!P)return;if(EN(P.properties.features))return;for(let I=0;I<_.length;I++){const H=_[I],W=H.attrName;if(!(VN(P,m,H)||g._isFeatureStateDirty&&g._isFeatureStateDirty(b.geometry._featureTimestamp))){const{aPickingId:i}=P.properties;if(!i||P._fnDataZoom===T)continue;const m=(LN+W+"Index").trim(),_=P.properties[m];if(!_)continue;jN(P,_,H,g);continue}const q=NN(P,m,H,g),$=H.define;if(q){const m=(LN+W+"Index").trim();if(jN(P,P.properties[m],H,g),g._getFeatureStateStamp&&(P._featureTimestamp=g._getFeatureStateStamp()),$){const i=b.defines;i[$]=1,b.setDefines(i)}P.generateBuffers(i)}else if($){const i=b.defines;i[$]&&(delete i[$],b.setDefines(i))}}b.setDefines(b.defines),P._fnDataZoom=T}function VN(i,g,m){const _=g[m.symbolName],b=i[DN];return!jv(_,b[m.symbolName])&&(b[m.symbolName]=_,!0)}function UN(i,g,m){for(let _=0;_<m.length;_++)if("$"===g[0]&&i[g.substring(1)]===m[_]||i.properties[g]===m[_])return!0;return!1}const GN=[];function jN(i,g,m,_){const{attrName:b,evaluate:T,index:P,width:I}=m,{aPickingId:H,features:W}=i.properties;let q;if(g){const m=(LN+b).trim();q=i.properties[m];const $=I,ye=g.length;for(let m=0;m<ye;m+=2){const b=g[m];let I=W[H[b]];I&&I.feature&&qN(q,I,T,b,g[m+1],$,P,i,_)}}else{if(q=i.data[b],function(i){return Array.isArray(i)||i.constructor===Float32Array||i.constructor===Float64Array||i.constructor===Uint8Array||i.constructor===Int8Array||i.constructor===Uint16Array||i.constructor===Int16Array||i.constructor===Uint32Array||i.constructor===Int32Array||i.constructor===Uint8ClampedArray}(q))q.dirty=!0;else{const g=(LN+b).trim();q=i.properties[g],q||(q=i.properties[g]=new m.type(m.width*H.length),q.dirty=!0)}const g=q.length/H.length,I=H.length;let $=0;for(let m=0;m<I;m++){if(H[m]===H[$]&&m<I-1)continue;let b=W[H[$]];b&&b.feature&&(qN(q,b,T,$,m===I-1?I:m,g,P,i,_),$=m)}}q.dirty&&(i.updateData(b,q),q.dirty=!1)}const WN={};function qN(i,g,m,_,b,T,P,I,H){const W=(g=g.feature).properties||{};if(void 0===W.$layer&&(g.properties||(g.properties=W),W.$layer=g.layer,W.$type=g.type),H.getFeatureState&&(WN.layer=g.layer,WN.id=g.id,g[RF]&&(g[RF]=null),!zF(g.id))){const i=H.getFeatureState(WN);g.properties[RF]=i}const q=m(W,I,i,_*T);if(Array.isArray(q)){let g=!1;for(let m=0;m<T;m++)if(i[_*T+m]!==q[m]){g=!0;break}if(g){for(let g=_*T;g<b*T;g+=T)i.set(q,g);i.dirty=!0}}else if(T>1)for(let g=_*T;g<b*T;g+=T)i[g+P]!==q&&(i[g+P]=q,i.dirty=!0);else i[_]!==q&&(XF(i,q,_,b),i.dirty=!0)}function XN(i){return RN.isFnTypeSymbol(i)}function ZN(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var $N=YN;function YN(i,g){this.x=i,this.y=g}YN.prototype={clone:function(){return new YN(this.x,this.y)},add:function(i){return this.clone()._add(i)},sub:function(i){return this.clone()._sub(i)},multByPoint:function(i){return this.clone()._multByPoint(i)},divByPoint:function(i){return this.clone()._divByPoint(i)},mult:function(i){return this.clone()._mult(i)},div:function(i){return this.clone()._div(i)},rotate:function(i){return this.clone()._rotate(i)},rotateAround:function(i,g){return this.clone()._rotateAround(i,g)},matMult:function(i){return this.clone()._matMult(i)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(i){return this.x===i.x&&this.y===i.y},dist:function(i){return Math.sqrt(this.distSqr(i))},distSqr:function(i){var g=i.x-this.x,m=i.y-this.y;return g*g+m*m},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(i){return Math.atan2(this.y-i.y,this.x-i.x)},angleWith:function(i){return this.angleWithSep(i.x,i.y)},angleWithSep:function(i,g){return Math.atan2(this.x*g-this.y*i,this.x*i+this.y*g)},_matMult:function(i){var g=i[2]*this.x+i[3]*this.y;return this.x=i[0]*this.x+i[1]*this.y,this.y=g,this},_add:function(i){return this.x+=i.x,this.y+=i.y,this},_sub:function(i){return this.x-=i.x,this.y-=i.y,this},_mult:function(i){return this.x*=i,this.y*=i,this},_div:function(i){return this.x/=i,this.y/=i,this},_multByPoint:function(i){return this.x*=i.x,this.y*=i.y,this},_divByPoint:function(i){return this.x/=i.x,this.y/=i.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var i=this.y;return this.y=this.x,this.x=-i,this},_rotate:function(i){var g=Math.cos(i),m=Math.sin(i),_=m*this.x+g*this.y;return this.x=g*this.x-m*this.y,this.y=_,this},_rotateAround:function(i,g){var m=Math.cos(i),_=Math.sin(i),b=g.y+_*(this.x-g.x)+m*(this.y-g.y);return this.x=g.x+m*(this.x-g.x)-_*(this.y-g.y),this.y=b,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},YN.convert=function(i){return i instanceof YN?i:Array.isArray(i)?new YN(i[0],i[1]):i};var QN=ZN($N);const JN=[];function KN(i,g,m,_,b){return wy(JN,g[0],g[1],g[2],1),Fy(JN,JN,m),i[2]=JN[3],Py(JN,JN,1/JN[3]),i[0]=(JN[0]+1)*_/2,i[1]=(1-JN[1])*b/2,i}const eH=[],tH=[],nH=[];const rH=[-99999,-99999],iH=new un(0,0),oH=[];function sH(i,g,m,_,b,T,P,I){const{res:H,extent:W,extent2d:q}=m.properties.tile,{xmin:$,ymax:ye}=q,Re=$+_.x*b,Be=ye-_.y*b;let Ge=null;if(I)for(let i=0;i<I.length;i++)if(aH(I[i],Re,Be,H)){Ge=I[i];break}if(!Ge)return rH;const je=iH.set($,ye),Xe=T.queryTilePointTerrain(_,Ge,je,W,H),Ze=null===Xe[0]?PF:Xe[0];if(Ze){let m=qA(oH,_.x,_.y,0);return m[2]+=100*Ze,m=KN(i,m,P,g.width,g.height),m}return i[0]=_.x,i[1]=_.y,i}function aH(i,g,m,_){const b=iH.set(g,m)._multi(_/i.res);return i.extent2d.contains(b)}const{SYMBOLS_NEED_REBUILD_IN_VT:lH,StyleUtil:hH,FuncTypeUtil:cH}=JD(),{loginIBLResOnCanvas:uH,logoutIBLResOnCanvas:fH,getIBLResOnCanvas:dH}=wP.pbr.PBRUtils,pH="__gl_textures",gH=[],mH=new un(0,0),AH=new un(0,0),yH=new Float32Array(1),_H=[],vH=i=>0===i.properties.level,xH=i=>i.properties.level>0;class Painter{static getBloomSymbol(){return["bloom"]}constructor(i,g,m,_,b,T){this._is2D=!0,this.regl=i,this.layer=g,this.canvas=(i._gl||i.context).canvas,this.sceneConfig=_||{},this.dataConfig=T||{},this.pluginIndex=b,this.scene=new wP.Scene,this.pickingFBO=g.getRenderer().pickingFBO,this.level0Filter=vH,this.levelNFilter=xH,this.loginTextureCache(),this.symbolDef=Array.isArray(m)?m.map((i=>VF(i))):[VF(m)],this._compileSymbols(),this.pickingViewport={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},this.sortByCommandKey=bH.bind(this),this.colorCache={},this._invisibleWhenCreated=this.symbolDef.map((i=>!(!i||!1!==i.visible)))}isWebGPU(){return!this.regl._gl}hasMesh(){const i=this.scene&&this.scene.getMeshes();return this.isVisible()&&i&&!!i.length}getMap(){return this.layer?this.layer.getMap():null}getTileLevelValue(i,g){const m=this.layer.getRenderer();return m.getTileLevelValue&&m.getTileLevelValue(i,g)||0}getAnalysisMeshes(){return this.getShadowMeshes?this.getShadowMeshes():_H}isVisible(){const{minZoom:i,maxZoom:g}=this.sceneConfig,m=this.getMap().getZoom();if(!zF(i)&&m<i)return!1;if(!zF(g)&&m>g)return!1;const _=this._visibleFn;if(_.length)for(let i=0;i<_.length;i++)if(_[i]&&!_[i].isFeatureConstant)return!0;const b=this.getSymbols();for(let i=0;i<b.length;i++){const g=b[i].visible;if(!1!==g&&0!==g)return!0}return!1}isMeshVisible(i){const g=i&&i.properties&&i.properties.symbolIndex;if(!g)return!1;const m=this._visibleFn,_=g.index;let b;if(m[_]){if(!m[_].isFeatureConstant)return!0;b=m[_](this.getMap().getZoom())}else b=this.getSymbol(g).visible;return!1!==b&&0!==b}isAnimating(){return!1}needToRedraw(){return this.isAnimating()||this._redraw}needToRetireFrames(){return this._needRetire}needToRefreshTerrainTileOnZooming(){return!0}isTerrainSkin(){return this.layer.options.awareOfTerrain}isTerrainMask(){return!1}isTerrainVector(){return!1}isShadowIncludeChanged(i){const g=i&&i.isRenderingTerrain&&this.isTerrainSkin();return i&&i.states&&i.states.includesChanged.shadow||g&&this._includeKeys}fillIncludes(i,g,m){if(delete this._includeKeys,m&&m.isRenderingTerrain&&this.isTerrainSkin())return;const _=m&&m.includes;if(_){let b="";for(const T in _)_[T]&&(b+=T,m[T].uniformDeclares&&g.push(...m[T].uniformDeclares),m[T].defines&&NF(i,m[T].defines));this._includeKeys=b}}setIncludeUniformValues(i,g){if(g&&g.isRenderingTerrain&&this.isTerrainSkin())return;const m=g&&g.includes;if(m)for(const _ in m)m[_]&&g[_].renderUniforms&&NF(i,g[_].renderUniforms)}createGeometries(i,g){if(!i.length)return _H;const m=[];for(let _=0;_<i.length;_++)if(i[_])if(void 0!==i[_].ref)m.push(m[i[_].ref]?{geometry:m[i[_].ref].geometry,symbolIndex:i[_].symbolIndex,ref:i[_].ref}:null);else{i[_]&&!i[_].is2D&&(this._is2D=!1);const b=this.createGeometry(i[_],g,_);if(b&&b.geometry){const T=b.geometry.properties,{feaIdToPickingIdMap:P,pickingIdToFeaIdMap:I,hasFeaIds:H}=this._getIdMap(i[_]);H&&(T.feaIdPickingMap=P,T.feaPickingIdMap=I),T.symbolIndex=b.symbolIndex,T.features=g,T.is2D=i[_].is2D,T.layer=this.layer,T.positionBounding=i[_].positionBounding,this.postCreateGeometry(b,m)}m.push(b)}return m}isOnly2D(){return this._is2D}postCreateGeometry(){}_getIdMap(i){if(!i)return{};if(Array.isArray(i)&&!(i=i[0]))return{};const g=i.featureIds,m={},_={},b=g&&g.length;if(b)for(let b=0;b<g.length;b++){const T=i.data.aPickingId[b];void 0===m[T]&&(m[T]=g[b],_[g[b]]||(_[g[b]]=[]),_[g[b]].push(i.data.aPickingId[b]))}return{hasFeaIds:b,pickingIdToFeaIdMap:m,feaIdToPickingIdMap:_}}createGeometry(){throw new Error("not implemented")}createMeshes(i,g,m,_){const b=this.layer.options.awareOfTerrain,T=[];for(let P=0;P<i.length;P++){if(!i[P])continue;if(b&&_&&_.isRenderingTerrain&&this.isTerrainVector()){const g=i[P],m=g&&g.geometry;this._updateTerrainAltitude(m,m.data,m.properties,m.positionSize||m.desc.positionSize,_)}let I=this.createMesh(i[P],g,m,_||{});Array.isArray(I)?(I=I.filter((i=>!!i)),T.push(...I)):I&&T.push(I)}return T}createMesh(){throw new Error("not implemented")}getAltitudeOffsetMatrix(){const i=100*(this.dataConfig.altitudeOffset||0),g=mA([]);return qA(gH,0,0,i),vA(g,g,gH),g}isBloom(i){return!!this.getSymbol(i.properties.symbolIndex).bloom}addMesh(i,g,m){const _=m.isRenderingTerrain&&this.isTerrainVector(),b=this.getRenderFBO(m);i=i.filter((i=>this.isMeshVisible(i))),_&&(i=i.filter((i=>i.geometry&&i.geometry.data.aTerrainAltitude)));const T=void 0===this.sceneConfig.castShadow||!!this.sceneConfig.castShadow,P=!(!m||!m.bloom);i.forEach((i=>{const g=this.isBloom(i)&&P;i.bloom=g,i.castShadow=T;let I=!1;const H=i.defines||{};if(!!H.HAS_BLOOM!==g&&(I=!0,g?H.HAS_BLOOM=1:delete H.HAS_BLOOM),_){if(i.geometry.data.aTerrainAltitude){const g=i.geometry;this._updateTerrainAltitude(g,g.data,g.properties,g.desc.positionSize,m)}i.geometry.data.aTerrainAltitude&&!H.HAS_TERRAIN_ALTITUDE&&(H.HAS_TERRAIN_ALTITUDE=1,I=!0)}else H.HAS_TERRAIN_ALTITUDE&&(delete H.HAS_TERRAIN_ALTITUDE,I=!0);I&&i.setDefines(H),b?i.setUniform("targetFramebuffer",b):i.uniforms.targetFramebuffer&&(i.uniforms.targetFramebuffer=null),this._highlightMesh(i)})),this.scene.addMesh(i)}updateCollision(){}render(i){return this.pluginIndex=i.pluginIndex,this.polygonOffsetIndex=i.polygonOffsetIndex,this.paint(i),{redraw:this._redraw,drawCount:this._drawCount}}prepareRender(i){if(this._currentTimestamp===i.timestamp)return;if(!this.createFnTypeConfig)return;const g=this.scene.getMeshes();if(!g||!g.length)return;const m=i&&i.sceneFilter,_=this.getMap().getZoom();for(let b=0;b<g.length;b++){if(!g[b]||!g[b].geometry)continue;if(m&&!m(g[b]))continue;const{symbolIndex:T}=g[b].properties,P=this.getSymbolDef(T);if(!P)continue;this._currentTimestamp=i.timestamp;const I=this.getFnTypeConfig(T);zN(this.regl,this.layer,P,I,g[b],_),this.limitMeshDefines(g[b])}}limitMeshDefines(i){return i}paint(i){const g=this.layer.getMap();if(!g)return{redraw:!1};this._renderContext=i;const m=this.getUniformValues(g,i);return this.callShader(m,i),{redraw:this._redraw}}setToRedraw(i){i&&(this._needRetire=i),this._redraw=!0}callShader(i,g){this.callCurrentTileShader(i,g),this.callBackgroundTileShader(i,g)}callCurrentTileShader(i,g){this.shader&&(this.shader.filter=g&&g.sceneFilter?[this.level0Filter,g.sceneFilter]:this.level0Filter),this.callRenderer(this.shader,i,g)}callBackgroundTileShader(i,g){this.shader&&(this.shader.filter=g&&g.sceneFilter?[this.levelNFilter,g.sceneFilter]:this.levelNFilter),this.scene.getMeshes().sort(wH),this.callRenderer(this.shader,i,g)}callRenderer(i,g,m){const _=this.scene.getMeshes(),b=[];_.forEach((i=>{i.properties.hlBloomMesh&&m&&m.bloom&&b.push(i.properties.hlBloomMesh),b.push(i)})),this._setLayerUniforms(g),this.scene.setMeshes(b),g.painterContext=m,this._drawCount+=this.renderer.render(i,g,this.scene,this.getRenderFBO(m)),this.scene.setMeshes(_)}_setLayerUniforms(i){const g=this.layer.options.altitude||0,m=this.layer.getRenderer();i.layerOpacity=m._getLayerOpacity(),i.minAltitude=g}getRenderFBO(i){return i&&i.renderTarget&&i.renderTarget.fbo}needPolygonOffset(){return!1}needRebuildOnGometryPropertiesChanged(){return!0}onFeatureChange(){}getPolygonOffset(){const i=this.layer;return{factor:()=>i.getPolygonOffset()+(this.polygonOffsetIndex||0),units:()=>i.getPolygonOffset()+(this.polygonOffsetIndex||0)}}getBlendFunc(){return{src:()=>this.sceneConfig.blendSrc||"one",dst:()=>this.sceneConfig.blendDst||"one minus src alpha"}}pick(i,g,m=3){if(!this.layer.options.picking||!1===this.sceneConfig.picking)return null;if(!this.pickingFBO||!this.picking)return null;const _=this.getMap(),b=this.getUniformValues(_);this._setLayerUniforms(b);for(let T=0;T<this.picking.length;T++){const P=this.picking[T];P.render(this.scene.getMeshes(),b,!0);let I={};P.getRenderedMeshes().length&&(I=P.pick(i,g,m,b,{viewMatrix:_.viewMatrix,projMatrix:_.projMatrix,returnPoint:this.layer.options.pickingPoint&&!1!==this.sceneConfig.pickingPoint,logDepthBufFC:2/(Math.log(_.cameraFar+1)/Math.LN2)}));const{meshId:H,pickingId:W,point:q}=I,$=(0===H||H)&&P.getMeshAt(H);if(!$||!$.geometry)continue;let ye=$.geometry.properties;ye.features||(ye=$.properties),q&&q.length&&(q[0]=Math.round(1e5*q[0])/1e5,q[1]=Math.round(1e5*q[1])/1e5,q[2]=Math.round(1e5*q[2])/1e5);const Re={data:this._convertProxyFeature(ye&&ye.features&&ye.features[W]),point:q,coordinate:I.coordinate,plugin:this.pluginIndex};return zF($.properties.nodeIndex)||(Re.data||(Re.data={}),Re.data.nodeIndex=$.properties.nodeIndex),Re}return null}_convertProxyFeature(i){const g=i&&i.feature;if(!g||!g.customProps)return i;const m=NF({},i);return m.feature=NF({},i.feature),delete m.feature.customProps,m.feature.properties=NF({},g.properties,g.properties[EF],g.properties[RF]),delete m.feature.properties[RF],delete m.feature.properties[EF],delete m.feature.properties.$layer,delete m.feature.properties.$type,m}updateSceneConfig(){}updateDataConfig(i){return NF(this.dataConfig,i),!0}deleteMesh(i,g){if(i)if(this.scene.removeMesh(i),Array.isArray(i))for(let m=0;m<i.length;m++){if(!i[m].isValid())continue;const _=i[m].geometry;!g&&_&&_.dispose(),i[m].material&&i[m].material.dispose(),i[m].dispose(),WE.deleteHighlightBloomMesh(i[m])}else{if(!i.isValid())return;!g&&i.geometry&&i.geometry.dispose(),i.material&&i.material.dispose(),i.dispose(),WE.deleteHighlightBloomMesh(i)}}startFrame(i){this._inited||(this.init(i),this._inited=!0),this._currentTimestamp!==i.timestamp&&(this._redraw=!1,this._needRetire=!1,this._drawCount=0),this.scene.clear()}resize(){}delete(){if(this.scene.clear(),this.shader&&this.shader.dispose(),this.picking){for(let i=0;i<this.picking.length;i++)this.picking[i].dispose();delete this.picking}if(this._outlineShaders){for(let i=0;i<this._outlineShaders.length;i++)this._outlineShaders[i].dispose();delete this._outlineShaders}delete this._terrainAltitudeCache,this.logoutTextureCache()}updateSymbol(i,g){Array.isArray(i)||(i=[i],g=[g]);let m=!1;for(let _=0;_<i.length;_++)if(i[_]){const b=this._updateChildSymbol(_,i[_],g[_]);b&&(m=b)}return delete this._fnTypeConfigs,this.setToRedraw(!1),m}_isNeedRefreshStyle(i,g){for(const m in g)if(YF(g,m)){if(hH.isFnTypeSymbol(g[m])&&!this.layer.options.features&&(!i[m]||i[m].property!==g[m].property))return!0;if(lH[m]&&!jv(g[m],i[m]))return!0}return!1}_updateChildSymbol(i,g,m){if(!this._symbol)return!1;const _=this._isNeedRefreshStyle(this.symbolDef[i]||{},m);if(this._invisibleWhenCreated[i]&&!1!==m.visible)return this._invisibleWhenCreated[i]=!1,!0;this.symbolDef[i]=VF(m);const b=this._symbol[i];for(const i in b)delete b[i];const T=this.getMap(),P=[],I=cH.loadSymbolFnTypes(this.symbolDef[i],(()=>(P[0]=T.getZoom(),P)));for(const i in I){const g=Object.getOwnPropertyDescriptor(I,i);g.get?Object.defineProperty(b,i,{get:g.get,set:g.set,configurable:!0,enumerable:!0}):b[i]=I[i]}return wL(m.visible)&&(this._visibleFn[i]=SL(m.visible)),_}getSymbolDef(i){return this.symbolDef[i.index]}getSymbols(){return this._symbol}getSymbol(i){return this._symbol[i.index]}_compileSymbols(){const i=this.getMap(),g=[],m=()=>(g[0]=i.getZoom(),g);this._symbol=[],this._visibleFn=[];for(let i=0;i<this.symbolDef.length;i++)this._symbol[i]=cH.loadSymbolFnTypes(NF({},this.symbolDef[i]),m),this.symbolDef[i]&&wL(this.symbolDef[i].visible)&&(this._visibleFn[i]=SL(this.symbolDef[i].visible))}getFnTypeConfig(i){this._fnTypeConfigs||(this._fnTypeConfigs=[]);const g=i.index;if(!this._fnTypeConfigs[g]){const m=this.getSymbolDef(i),_=this.getMap();this._fnTypeConfigs[g]=this.createFnTypeConfig(_,m)}return this._fnTypeConfigs[g]}_deleteFnTypeConfigs(){delete this._fnTypeConfigs}loginTextureCache(){const i=(pH+"").trim(),g=this.getMap();g[i]||(g[i]={count:0}),g[i].count++}logoutTextureCache(){const i=(pH+"").trim(),g=this.getMap(),m=this._myTextures;if(m)for(const _ in m)YF(m,_)&&g[i][_]&&(g[i][_].count--,g[i][_].count<=0&&delete g[i][_]);g[i].count--,g[i].count<=0&&(g[i]={})}getCachedTexture(i){const g=(pH+"").trim(),m=this.getMap()[g][i];return m?m.data:null}addCachedTexture(i,g){const m=(pH+"").trim(),_=this.getMap();let b=_[m][i];b?b.data=g:b=_[m][i]={data:g,count:0},this._myTextures||(this._myTextures={}),b.data.then||this._myTextures[i]||(b.count++,this._myTextures[i]=1)}disposeCachedTexture(i){let g;if(g="string"==typeof i?i:i.url,!this._myTextures||!this._myTextures[g])return;const m=(pH+"").trim();delete this._myTextures[g];const _=this.getMap();_[m][g]&&(_[m][g].count--,_[m][g].count<=0&&delete _[m][g])}shouldDeleteMeshOnUpdateSymbol(){return!1}isEnableTileStencil(){return!0}isUniqueStencilRefPerTile(){return this.isOnly2D()}supportRenderMode(i){return"taa"===i||"fxaa"===i}outline(i,g){const m={};for(let _=0;_<g.length;_++)zF(g[_])||m[g[_]]||(this._outlineOne(i,g[_]),m[g[_]]=1)}_outlineOne(i,g){if(!this.picking)return;if(this._outlineScene||(this._outlineScene=new wP.Scene),!this._outlineShaders&&(this._initOutlineShaders(),!this._outlineShaders))return void console.warn(`Plugin at ${this.pluginIndex} doesn't support outline.`);const m=this.getUniformValues(this.getMap(),this._renderContext);this._setLayerUniforms(m);const _=this._findMeshesHasFeaId(g);if(_.length)for(let b=0;b<_.length;b++){const T=_[b].geometry.properties.feaIdPickingMap;if(T){const P=T[g];if(P){const g={};this._outlineScene.setMeshes(_[b]);for(let _=0;_<P.length;_++){const b=P[_];if(!g[b]){g[b]=1,m.highlightPickingId=b;for(let g=0;g<this._outlineShaders.length;g++)this.renderer.render(this._outlineShaders[g],m,this._outlineScene,i)}}}}}}_findMeshesHasFeaId(i){const g=[],m=this.scene.getMeshes();for(let _=0;_<m.length;_++){const b=m[_],T=b.geometry.properties.feaIdPickingMap;T&&void 0!==T[i]&&g.push(b)}return g}outlineAll(i){if(!this.picking)return;if(!this._outlineShaders&&(this._initOutlineShaders(),!this._outlineShaders))return void console.warn(`Plugin at ${this.pluginIndex} doesn't support outline.`);const g=this.getUniformValues(this.getMap(),this._renderContext);this._setLayerUniforms(g),g.highlightPickingId=-1;for(let m=0;m<this._outlineShaders.length;m++)this.renderer.render(this._outlineShaders[m],g,this.scene,i)}_initOutlineShaders(){if(!this.picking)return;const i=this.layer.getRenderer().canvas;this._outlineShaders=[];for(let g=0;g<this.picking.length;g++){const m=this.picking[g].getPickingVert(),_=this.picking[g].getPickingWGSLVert(),b={PICKING_MODE:1,ENABLE_PICKING:1,HAS_PICKING_ID:1},T=this.picking[g].getUniformDeclares().slice(0);void 0!==T.uPickingId&&(b.HAS_PICKING_ID=2),this._outlineShaders[g]=new wP.MeshShader({vert:m,frag:"precision highp float;\n\n\n\nuniform float highlightPickingId;\n\n\n\nvarying float vPickingId;\n\n\n\nvoid main() {\n\n    if (highlightPickingId < 0.0 || floor(highlightPickingId + 0.5) == floor(vPickingId + 0.5)) {\n\n        gl_FragColor = vec4(1.0);\n\n    } else {\n\n        discard;\n\n    }\n\n}\n\n",wgslVert:_,wgslFrag:"struct OutlineUniforms {\n    highlightPickingId: f32,\n}\n@group(0) @binding($b) var<uniform> uniforms: OutlineUniforms;\nstruct VertexOutput {\n    @location($i) vPickingId: f32,\n};\n@fragment\nfn main(vertexOutput: VertexOutput) -> @location(0) vec4f {\n    if (uniforms.highlightPickingId < 0.0 ||\n        floor(uniforms.highlightPickingId + 0.5) == floor(vertexOutput.vPickingId + 0.5)) {\n        return vec4f(1.0);\n    } else {\n        discard;\n        return vec4f(0.0);\n    }\n}",uniforms:T,defines:b,extraCommandProps:{viewport:{x:0,y:0,width:()=>i.width,height:()=>i.height},depth:{enable:!0,mask:!1,func:"always"},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}}),this._outlineShaders[g].filter=this.picking[g].filter}}hasIBL(){const i=this.getMap().getLightManager();return!!(i&&i.getAmbientResource())}updateIBLDefines(i){const g=i.shaderDefines;let m=!1;this.hasIBL()?g[["HAS_IBL_LIGHTING"]]||(g.HAS_IBL_LIGHTING=1,m=!0):g[["HAS_IBL_LIGHTING"]]&&(delete g.HAS_IBL_LIGHTING,m=!0),m&&(i.shaderDefines=g)}getIBLRes(){const i=this.layer.getRenderer().canvas;return dH(i)}createIBLTextures(){const i=this.layer.getRenderer().canvas;uH(i,this.regl,this.getMap()),this.setToRedraw(!0),this.layer.fire("iblupdated")}disposeIBLTextures(){const i=this.layer.getRenderer().canvas;fH(i,this.getMap())}evaluateInFnTypeConfig(i,g,m,_,b){let T=this._fnCaches;T||(T=this._fnCaches={});const P=function(i){let g=0;const m=i&&i.length||0;if(!m)return g;let _;for(let b=0;b<m;b++)_=i.codePointAt(b),g=(g<<5)-g+_,g&=g;return g}(JSON.stringify(i));let I=T[P];return I||(I=T[P]=b?ML(i):SL(i)),I(m.getZoom(),_)}highlight(i){this._highlighted=i,this._highlightTimestamp=this.layer.getRenderer().getFrameTimestamp(),this.setToRedraw(!0)}cancelAllHighlight(){this._highlighted=null,this._highlightTimestamp=this.layer.getRenderer().getFrameTimestamp(),this.setToRedraw(!0)}_prepareFeatureIds(i,g){const{featureIds:m,pickingIdIndiceMap:_}=g;i.properties.aFeaIds=m,i.properties.pickingIdIndiceMap=_}_highlightMesh(i){if(i&&i.properties.isHalo)return;const g=i instanceof wP.InstancedMesh?i.properties:i.geometry.properties,{pickingIdIndiceMap:m}=g,_=this._highlighted?function(i,g,m){const _=i instanceof wP.InstancedMesh?i.properties:i.geometry.properties,{aPickingId:b,feaIdPickingMap:T,features:P}=_,I=new Map,H=m.keys();for(const i of H){const _=m.get(i);if(_)if(zF(_.id)){if(_.filter&&b){let i=null;for(let m=0;m<b.length;m++){b[m]!==i&&(i=b[m]);const T=P[i];_.filter(T&&T.feature,g)&&I.set(i,_)}}}else{const i=T[_.id];if(!i||!i.length)continue;for(let g=0;g<i.length;g++)I.set(i[g],_)}}return I}(i,this.layer,this._highlighted):null;WE.highlightMesh(this.regl,i,_,this._highlightTimestamp,m)}_updateTerrainAltitude(i,g,m,_,b){let T=m.aAnchor;if(!T){const{aPosition:i}=g;T=m.aAnchor=i.slice(0)}let P=m.aTerrainAltitude;P||(P=m.aTerrainAltitude=new Float32Array(T.length/_),P.fill(PF)),this._fillTerrainAltitude(P,T,b.tileInfo,0,P.length-1),g.aTerrainAltitude?P.dirty&&this._updateATerrainAltitude(i,P):g.aTerrainAltitude=P,P.dirty=!1}_updateATerrainAltitude(i,g){i&&i.updateData&&i.updateData("aTerrainAltitude",g)}_fillTerrainAltitude(i,g,m,_,b){const{res:T,extent:P,extent2d:I,id:H}=m,W=this.pluginIndex,q=H+"-"+W;if(m.completeTerrainQuery||(m.completeTerrainQuery=[]),m.completeTerrainQuery[W])return;if(!m.completeTerrainQuery[W]&&this._terrainAltitudeCache&&this._terrainAltitudeCache.has(q)){const g=this._terrainAltitudeCache.getAndRemove(q);return this._terrainAltitudeCache.add(q,g),i.set(g.altitudeData),m.terrainTileInfos=g.terrainTileInfos,i.dirty=!0,void(m.completeTerrainQuery[W]=!0)}const $=this.layer,ye=$.getMap(),Re=$.getRenderer(),Be=Re&&Re.getTerrainHelper();let Ge=m.terrainTileInfos;Ge||(Ge=m.terrainTileInfos=this.layer.queryTerrainTiles(m)),m.terrainQueryStatus||(m.terrainQueryStatus=[]);let je=!1,Xe=[];for(let i=0;i<m.terrainTileInfos.length;i++)if(Xe[i]=+Be.isTerrainTileLoaded(m.terrainTileInfos[i].id),Xe[i]&&m.terrainQueryStatus[W]&&!m.terrainQueryStatus[W][i]){je=!0;break}if(!je&&m.terrainQueryStatus[W])return;const Ze=$.constructor;if(ye.isInteracting()){const i=Re.getFrameTimestamp();Ze.altitudeQueryFrameTimestamp!==i&&(Ze.altitudeQueryFrameTimestamp=i,Ze.altitudeQueryFrameTime=0);if(Ze.altitudeQueryFrameTime>$.options.altitudeQueryTimeLimitPerFrame)return}const Ye=performance.now();m.terrainQueryStatus[W]=Xe;const{xmin:Qe,ymax:Je}=I,Ke=mH.set(Qe,Je),et=this.layer.getTileSize().width/m.extent,tt=g.length/i.length;let at=i.queryResult;at||(at=i.queryResult=new Map);let ht=!0;for(let m=_;m<=b;m++){let _=g[m*tt];_<0?_=0:_>P&&(_=P);let b=g[m*tt+1];b<0?b=0:b>P&&(b=P);const I=_+b*P;let H,W,q=at.get(I);if(q||0===q)i[m]!==q&&(i[m]=q,i.dirty=!0);else{for(let i=0;i<Ge.length;i++)if(aH(Ge[i],Qe+et*_,Je-et*b,T)){H=Ge[i];break}H&&(Be.getRenderer().isTileCached(H.id)||i[m]===PF)&&(AH.set(_,b),W=this.layer.queryTilePointTerrain(AH,H,Ke,P,T)),q=i[m],W&&(q=null===W[0]?PF:W[0],yH[0]=q,q=yH[0]),i[m]!==q&&(i[m]=q,i.dirty=!0),W&&W[1]?at.set(I,q):ht=!1}}Ze.altitudeQueryFrameTime=(Ze.altitudeQueryFrameTime||0)+(performance.now()-Ye),m.completeTerrainQuery[W]=ht,ht&&(this._terrainAltitudeCache||(this._terrainAltitudeCache=new Js(4*this.layer.options.maxCacheSize)),this._terrainAltitudeCache.add(q,{altitudeData:i,terrainTileInfos:Ge}))}shouldDrawParentTile(){return!0}}function bH(i,g){const m=i&&i.getCommandKey(this.regl)||"",_=g&&g.getCommandKey(this.regl)||"";return m.localeCompare(_)}function wH(i,g){return i.properties.level-g.properties.level}class BasicPainter extends Painter{createGeometry(i,g){const m=this.layer.options.debugTileData;if(m&&!zF(m.x)){const{x:g,y:_,z:b}=i.tileInfo;m.x===g&&m.y===_&&m.z===b&&console.log("glData",{layerId:this.layer.getId(),x:g,y:_,z:b,glData:i})}if(!i.data)return{geometry:null,symbolIndex:i.symbolIndex};i.iconAtlas&&i.iconAtlas.image&&(i.iconAtlas.image.dataType=i.type,i.iconAtlas.image.type="icon"),i.glyphAtlas&&i.glyphAtlas.image&&(i.glyphAtlas.image.type="glyph");const _=NF({},i.data),b={primitive:this.getPrimitive(),positionSize:i.positionSize};_.aAltitude&&(b.altitudeAttribute="aAltitude");const T=new wP.Geometry(_,i.indices,0,b);return T.properties={features:g},i.iconAtlas&&(T.properties.iconAtlas=i.iconAtlas.image,T.properties.iconPositions=i.iconAtlas.positions),i.glyphAtlas&&(T.properties.glyphAtlas=i.glyphAtlas.image),EN(g)||(T.properties.aFeaIds=i.featureIds,this._prepareFeatureIds(T,i)),i.markerPlacement&&(T.properties.markerPlacement=i.markerPlacement),i.textPlacement&&(T.properties.textPlacement=i.textPlacement),NF(T.properties,i.properties),{geometry:T,symbolIndex:i.symbolIndex}}getRayCastData(i,g){const{features:m,aFeaIds:_}=i.geometry.properties;if(!m||!_)return null;return m[_[g]]}getPrimitive(){return"triangles"}getRenderFBO(i){return i&&i.renderTarget&&i.renderTarget.fbo}supportRenderMode(i){return"noAa"===i}drawDebugAtlas(i){if(document.getElementById("MAPTALKS_ICON_DEBUG")){const g=document.getElementById("MAPTALKS_ICON_DEBUG");let m;if(g.width=i.width,g.height=i.height,g.style.width=i.width+"px",g.style.height=i.height+"px","alpha"===i.format){m=new Uint8ClampedArray(4*i.data.length);for(let g=0;g<i.data.length;g++)m[4*g+3]=i.data[g]}else m=new Uint8ClampedArray(i.data);const _=g.getContext("2d");_.imageSmoothingEnabled=!1,_.putImageData(new ImageData(m,i.width,i.height),0,0)}}}var TH="#include <gl2_vert>\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nuniform mat4 projViewModelMatrix;\n\nuniform mat4 positionMatrix;\n\n\n\n#include <fbo_picking_vert>\n\n\n\n#include <vt_position_vert>\n\n\n\nvoid main() {\n\n    vec3 myPosition = unpackVTPosition();\n\n    gl_Position = projViewModelMatrix * positionMatrix * vec4(myPosition, 1.);\n\n\n\n    fbo_picking_setData(gl_Position.w, true);\n\n}\n\n";function SH(i,g,m,_){if(_){const i=wP.Util.resizeToPowerOfTwo(g.data,g.width,g.height);g.data=i}const b={width:g.width,height:g.height,data:g.data,format:g.format,mag:"linear",min:_?"linear mipmap linear":"linear",flipY:m,premultiplyAlpha:!0};if("icon"===g.type){const i="point"!==g.dataType?"repeat":"clamp";b.wrapS=i,b.wrapT=i}return i.texture(b)}const MH=[0,0],CH=[];function PH(i){if(!i.properties.iconPositions)return MH;let g,m=0;for(const _ in i.properties.iconPositions)if(g=_,m++,m>1)return MH;if(!g)return MH;const _=i.properties.iconPositions[g],b=_.displaySize[1];return CH[0]=_.displaySize[0],CH[1]=b,CH}function IH(i){const g=new Set;for(const m of i)if(m.includes("&&")||m.includes("||")){const i=kH(m);for(const m of i)g.add(m.trim())}else g.add(m);return g}function kH(i){return i.split(/&&|\|\|/)}function OH(i,g,m,_,b){if(!i.wgpu)return g;const T=i.wgpu.limits.maxVertexBuffers;let P=0,I={};for(let i=0;i<m.length;i++){const _=m[i];if(wP.WGSLParseDefines.getDefineConditionValue(_,g)&&(P++,P+b<=T)){const i=kH(_);for(const m of i)g[m]&&(I[m]=g[m])}}for(const i in g)_.has(i)||(I[i]=g[i]);return I}const EH=["HAS_ALTITUDE","HAS_OFFSET_Z","HAS_TEXT_SIZE","HAS_MARKER_WIDTH || HAS_MARKER_HEIGHT","HAS_TEXT_FILL","HAS_MARKER_DX || HAS_MARKER_DY || HAS_TEXT_DX || HAS_TEXT_DY","HAS_OPACITY","HAS_MARKER_PITCH_ALIGN || HAS_TEXT_PITCH_ALIGN","HAS_MARKER_ROTATION_ALIGN || HAS_TEXT_ROTATION_ALIGN","HAS_MARKER_ROTATION || HAS_TEXT_ROTATION","HAS_TEXT_HALO_FILL","HAS_HALO_ATTR || HAS_TEXT_HALO_RADIUS || HAS_TEXT_HALO_OPACITY"],RH=IH(EH);function LH(i,g){return OH(i,g,EH,RH,2)}const DH=["HAS_ALTITUDE","HAS_COLOR","HAS_OPACITY","HAS_LINE_WIDTH","HAS_PATTERN || HAS_DASHARRAY || HAS_GRADIENT || HAS_TRAIL","HAS_PATTERN","HAS_GRADIENT","HAS_DASHARRAY && HAS_DASHARRAY_ATTR","HAS_DASHARRAY && HAS_DASHARRAY_COLOR","HAS_LINE_DX || HAS_LINE_DY","HAS_STROKE_WIDTH","HAS_STROKE_COLOR"],FH=IH(DH);const NH=["HAS_ALTITUDE","HAS_COLOR","HAS_OPACITY","HAS_PATTERN","HAS_PATTERN && HAS_PATTERN_WIDTH","HAS_PATTERN && HAS_PATTERN_ORIGIN","HAS_PATTERN && HAS_PATTERN_OFFSET","HAS_PATTERN && HAS_UV_SCALE","HAS_PATTERN && HAS_UV_OFFSET","HAS_PATTERN && HAS_TEX_COORD"],HH=IH(NH);const{INVALID_TEX_COORD:BH}=JD(),zH=mA([]),VH={polygonFill:[1,1,1,1],polygonOpacity:1,uvScale:[1,1],uvOffset:[0,0],patternWidth:[0,0],patternOffset:[0,0]},UH=[],GH=new pl(0,0),jH=new pl(0,0),WH=new pl(0,0),qH=[];class FillPainter extends BasicPainter{static getBloomSymbol(){return["polygonBloom"]}prepareSymbol(i){const g=i.polygonFill;Array.isArray(g)&&(3===g.length&&g.push(1),i.polygonFill=g.map((i=>255*i)))}supportRenderMode(i){return this.sceneConfig.antialias||void 0===this.sceneConfig.antialias?"fxaa"===i||"fxaaBeforeTaa"===i:super.supportRenderMode(i)}isBloom(i){return!!this.getSymbol(i.properties.symbolIndex)[FillPainter.getBloomSymbol()[0]]}needPolygonOffset(){return!0}getAnalysisMeshes(){if(!this.isVisible())return UH;const i=this.scene.getMeshes().filter((i=>0===i.properties.level));return i}createMesh(i,g,m){const _=this.getMap(),{tilePoint:b}=m,{geometry:T,symbolIndex:P,ref:I}=i,H=this.layer instanceof Up,W=this.layer.getTileSize().width,q=T.properties.tileExtent/W,$=T.properties.tileResolution,ye=_.pointAtResToCoord(GH.set(b[0],b[1]),$),Re={tileExtent:T.properties.tileExtent,tileRatio:q},Be=this.getSymbol(P),Ge=this.getSymbolDef(P);if(wL(Ge.polygonPatternFileOrigin)&&this._preparePatternOrigin(Ge,i,H?[0,0]:b,$),(wL(Ge.polygonPatternFileWidth)||wL(Ge.polygonPatternFileWidth))&&this._preparePatternWidth(Ge,i,H?q:1,ye,$),Ge.uvOffsetInMeter&&wL(Ge.uvOffset)&&this._preparePatternOffset(Ge,i,ye,$),UF(Re,"polygonFill",Be,"polygonFill",VH.polygonFill,WF(this.colorCache)),UF(Re,"polygonOpacity",Be,"polygonOpacity",VH.polygonOpacity),UF(Re,"uvScale",Be,"uvScale",VH.uvScale),void 0===I){const i=this.getFnTypeConfig(P);FN(T,Ge,i,this.layer),T.generateBuffers(this.regl)}const je=T.properties.iconAtlas,Xe=2048;if(je&&T.data.aTexInfo){const i=[];Object.defineProperty(Re,"uvOrigin",{enumerable:!0,get:()=>{const g=Re.tileScale;if(T.data.aPatternOrigin)return i[0]=b[0]*g%Xe,i[1]=b[1]*g%Xe,i;const m=Be.polygonPatternFileOrigin;return m?(GH.set(m[0],m[1]),_.coordToPointAtRes(GH,$,jH),z_(i,b[0]-jH.x,b[1]-jH.y)):(i[0]=b[0]*g%Xe,i[1]=b[1]*g%Xe,i)}});const g=[];Object.defineProperty(Re,"patternWidth",{enumerable:!0,get:()=>{if(T.data.aPatternWidth)return VH.patternWidth;const i=Ge.polygonPatternFileWidth,m=Ge.polygonPatternFileHeight;if(!i&&!m)return VH.patternWidth;const[_,b]=this._computePatternWidth(qH,i,m,H?q:1,ye,$);return z_(g,_,b)}}),Object.defineProperty(Re,"uvOffset",{enumerable:!0,get:()=>T.data.aPatternOffset||Ge.uvOffsetInMeter?VH.uvOffset:Be.uvOffset||VH.uvOffset});const m=[];Object.defineProperty(Re,"patternOffset",{enumerable:!0,get:()=>{if(T.data.aPatternOffset)return VH.uvOffset;if(!Ge.uvOffsetInMeter)return VH.uvOffset;const i=Ge.uvOffset;if(!i)return VH.uvOffset;const g=KF(_,i[0],ye,$),b=KF(_,i[1],ye,$);return z_(m,g,b)}}),Object.defineProperty(Re,"tileScale",{enumerable:!0,get:function(){return Ge.polygonPatternFileWidth||Ge.polygonPatternFileHeight?1:T.properties.tileResolution/_.getResolution()}}),Re.polygonPatternFile=SH(this.regl,je,!1,!1),Re.atlasSize=[je.width,je.height],this.drawDebugAtlas(je)}const Ze=new wP.Material(Re,VH),Ye=new wP.Mesh(T,Ze,{castShadow:!1,picking:!0}),Qe={};return je&&T.data.aTexInfo&&(Qe.HAS_PATTERN=1),je&&T.data.aTexCoord&&(Qe.HAS_TEX_COORD=1,Qe.INVALID_TEX_COORD=BH+".0"),T.data.aAltitude&&(Qe.HAS_ALTITUDE=1),T.data.aColor&&(Qe.HAS_COLOR=1),T.data.aOpacity&&(Qe.HAS_OPACITY=1),T.data.aUVScale&&(Qe.HAS_UV_SCALE=1),T.data.aUVOffset&&(Qe.HAS_UV_OFFSET=1),T.data.aPatternOrigin&&(Qe.HAS_PATTERN_ORIGIN=1),T.data.aPatternWidth&&(Qe.HAS_PATTERN_WIDTH=1),T.data.aPatternOffset&&(Qe.HAS_PATTERN_OFFSET=1),H&&(Qe.IS_VT=1),Ye.setDefines(Qe),Ye.positionMatrix=this.getAltitudeOffsetMatrix(),Ye.setLocalTransform(g),Ye.properties.symbolIndex=P,Ye}_preparePatternWidth(i,g,m,_,b){if(!(g=g&&g.geometry))return;const T=g.properties.features;if(EN(T))return;const P=i.polygonPatternFileWidth,I=i.polygonPatternFileHeight,H=SL(i.polygonPatternFileOrigin);let W,q;wL(P)&&(W=SL(P)),wL(I)&&(q=SL(I));const{aPickingId:$,aPatternOrigin:ye}=g.data,Re=new Float32Array(2*$.length);let Be,Ge,je;for(let i=0,g=$.length;i<g;i++){let g,Xe;if($[i]===Be){Re[2*i]=Ge,Re[2*i+1]=je;continue}const Ze=T[$[i]];if(g=W?W(null,Ze.feature.properties):P,Xe=q?q(null,Ze.feature.properties):I,Be=$[i],g||Xe){let T=_;if(ye){const i=H(null,Ze.feature.properties);i&&(T=WH.set(i[0],i[1]))}const[P,I]=this._computePatternWidth(qH,g,Xe,m,T,b);Ge=Re[2*i]=P,je=Re[2*i+1]=I}else Ge=Re[2*i]=0,je=Re[2*i+1]=0}g.data.aPatternWidth=Re}_preparePatternOffset(i,g,m,_){if(!(g=g&&g.geometry))return;const b=g.properties.features;if(EN(b))return;const T=this.getMap();let P=wL(i.uvOffsetInMeter)&&ML(i.uvOffsetInMeter);const I=SL(i.uvOffset),H=SL(i.polygonPatternFileOrigin),{aPickingId:W,aPatternOrigin:q}=g.data,$=new Float32Array(2*W.length);let ye,Re,Be;for(let i=0,g=W.length;i<g;i++){if(W[i]===ye){$[2*i]=Re,$[2*i+1]=Be;continue}const g=b[W[i]],Ge=I(null,g.feature.properties);let je=!0;if(P&&(je=P(null,g.feature.properties)),ye=W[i],Ge&&je){let b=m;if(q){const i=H(null,g.feature.properties);i&&(b=WH.set(i[0],i[1]))}const P=KF(T,Ge[0],b,_),I=KF(T,Ge[0],b,_);Re=$[2*i]=P,Be=$[2*i+1]=I}else Re=$[2*i]=0,Be=$[2*i+1]=0}g.data.aPatternOffset=$}_preparePatternOrigin(i,g,m,_){if(!(g=g&&g.geometry))return;const b=g.properties.features;if(EN(b))return;const T=this.getMap(),P=SL(i.polygonPatternFileOrigin),I=g.data.aPickingId,H=new Float32Array(2*I.length);let W,q,$;for(let i=0,g=I.length;i<g;i++){if(I[i]===W){H[2*i]=q,H[2*i+1]=$;continue}W=I[i];const g=P(null,b[W].feature.properties);g?(GH.set(g[0],g[1]),T.coordToPointAtRes(GH,_,jH),q=H[2*i]=jH.x,$=H[2*i+1]=jH.y):(q=H[2*i]=m[0],$=H[2*i+1]=m[1])}g.data.aPatternOrigin=H}createFnTypeConfig(i,g){const m=ML(g.polygonFill),_=SL(g.polygonOpacity),b=SL(g.uvScale),T=SL(g.uvOffset),P=new Uint8Array(1),I=new Uint16Array(2),H=new Uint8Array(2);return[{attrName:"aColor",symbolName:"polygonFill",type:Uint8Array,width:4,define:"HAS_COLOR",evaluate:(g,_)=>{let b=m(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,_,i,g,!0)),Array.isArray(b)||(b=this.colorCache[b]=this.colorCache[b]||iL(b).unitArray()),b=jF(b),b}},{attrName:"aOpacity",symbolName:"polygonOpacity",type:Uint8Array,width:1,define:"HAS_OPACITY",evaluate:(g,m)=>{let b=_(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,m,i,g)),P[0]=255*b,P[0]}},{attrName:"aUVScale",symbolName:"uvScale",type:Uint16Array,width:2,define:"HAS_UV_SCALE",evaluate:g=>{const m=b(i.getZoom(),g);return I[0]=255*m[0],I[1]=255*m[1],I}},{attrName:"aUVOffset",symbolName:"uvOffset",type:Uint8Array,width:2,define:"HAS_UV_OFFSET",evaluate:g=>{const m=T(i.getZoom(),g);return H[0]=255*m[0],H[1]=255*m[1],H}}]}paint(i){if(this.isShadowIncludeChanged(i)){this.shader.dispose();const g=this._getExtraCommandProps();this._createShader(i,g)}super.paint(i)}isEnableTileStencil(i){const g="VectorTileLayer"===this.layer.getJSONType(),m=this.layer instanceof Up;return!!!(i&&i.isRenderingTerrain&&this.isTerrainSkin())&&(g||m&&this.isOnly2D())}_getExtraCommandProps(){const i=this.canvas,g={x:(i,g)=>g.viewport?g.viewport.x:0,y:(i,g)=>g.viewport?g.viewport.y:0,width:(g,m)=>m.viewport?m.viewport.width:i?i.width:1,height:(g,m)=>m.viewport?m.viewport.height:i?i.height:1};this.renderer=new wP.Renderer(this.regl);return{viewport:g,stencil:{enable:(i,g)=>g.geometryProperties.is2D&&this.isEnableTileStencil(g.painterContext),func:{cmp:()=>this.isOnly2D()?"=":"<=",ref:(i,g)=>g.stencilRef},op:{fail:"keep",zfail:"keep",zpass:()=>{const i="VectorTileLayer"===this.layer.getJSONType(),g=this.isOnly2D();return i&&g?"zero":"replace"}}},depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],mask:(i,g)=>{if(!zF(this.sceneConfig.depthMask))return!!this.sceneConfig.depthMask;if(g.hasSSRGround)return!0;if(g.meshConfig.transparent)return!1;const m=g.polygonOpacity;return!(ZF(m)&&m<1)},func:this.sceneConfig.depthFunc||"<="},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}}}init(i){const g=this._getExtraCommandProps();if(this._createShader(i,g),this.pickingFBO){const i=[],m=this.layer instanceof Up;this.picking=[new wP.FBORayPicking(this.renderer,{name:"fill-picking",vert:TH,wgslVert:"struct VertexInput {\n#ifdef HAS_ALTITUDE\n        @location($i) aPosition: vec2i,\n        @location($i) aAltitude: f32,\n#else\n        @location($i) aPosition: vec4i,\n#endif\n}\nstruct UniformsStruct {\n    projViewModelMatrix: mat4x4f,\n    positionMatrix: mat4x4f,\n}\n@group(0) @binding($b) var<uniform> uniforms: UniformsStruct;\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n}\n#include <fbo_picking_vert>\n#include <vt_position_vert>\n@vertex\nfn main(\n    input: VertexInput,\n) -> VertexOutput {\n    let position = unpackVTPosition(input);\n    var output: VertexOutput;\n    output.position = uniforms.projViewModelMatrix * uniforms.positionMatrix * vec4f(position, 1.0);\n    fbo_picking_setData(input, &output, output.position.w, true);\n    return output;\n}",defines:{PICKING_MODE:1},uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(g,m){return _A(i,m.projViewMatrix,m.modelMatrix),i}}],extraCommandProps:g,enableStencil:()=>m&&this.isOnly2D()},this.pickingFBO,this.getMap())]}}_createShader(i,g){const m=[],_=[{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A(m,g.projViewMatrix,g.modelMatrix),m}}],b={};this.fillIncludes(b,_,i);this.shader=new wP.MeshShader({name:"vt-fill",vert:"#define SHADER_NAME FILL\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\n#ifdef HAS_COLOR\n\n    attribute vec4 aColor;\n\n    varying vec4 vColor;\n\n#endif\n\n\n\n#ifdef HAS_OPACITY\n\n    attribute float aOpacity;\n\n    varying float vOpacity;\n\n#endif\n\n\n\nuniform mat4 projViewModelMatrix;\n\nuniform mat4 positionMatrix;\n\n#ifndef IS_VT\n\n    uniform mat4 modelMatrix;\n\n#endif\n\n\n\n#ifdef HAS_PATTERN\n\n    #ifdef HAS_TEX_COORD\n\n        attribute vec2 aTexCoord;\n\n    #endif\n\n    attribute vec4 aTexInfo;\n\n\n\n    uniform vec2 patternWidth;\n\n    uniform vec2 patternOffset;\n\n    uniform vec2 uvOrigin;\n\n    uniform vec2 uvScale;\n\n    #ifdef IS_VT\n\n        uniform float tileRatio;\n\n        uniform float tileScale;\n\n    #else\n\n        uniform float glScale;\n\n    #endif\n\n\n\n    #ifdef HAS_UV_SCALE\n\n        attribute vec2 aUVScale;\n\n        varying vec2 vUVScale;\n\n    #endif\n\n\n\n    #ifdef HAS_UV_OFFSET\n\n        attribute vec2 aUVOffset;\n\n        varying vec2 vUVOffset;\n\n    #endif\n\n\n\n    #ifdef HAS_PATTERN_WIDTH\n\n        attribute vec2 aPatternWidth;\n\n    #endif\n\n\n\n    #ifdef HAS_PATTERN_ORIGIN\n\n        attribute vec2 aPatternOrigin;\n\n    #endif\n\n\n\n    #ifdef HAS_PATTERN_OFFSET\n\n        attribute vec2 aPatternOffset;\n\n    #endif\n\n\n\n    varying vec2 vTexCoord;\n\n    varying vec4 vTexInfo;\n\n\n\n    vec2 computeUV(vec2 vertex, vec2 patternWidth) {\n\n        #ifdef IS_VT\n\n            float u = vertex.x / patternWidth.x;\n\n            float v = vertex.y / patternWidth.y;\n\n            return vec2(u, v);\n\n        #else\n\n            float mapGLScale = glScale;\n\n            #ifdef HAS_PATTERN_WIDTH\n\n                float hasPatternWidth = sign(length(aPatternWidth));\n\n                mapGLScale = mix(glScale, 1.0, hasPatternWidth);\n\n            #endif\n\n            vec2 origin = uvOrigin;\n\n            #ifdef HAS_PATTERN_ORIGIN\n\n                origin = aPatternOrigin;\n\n            #endif\n\n            #ifdef HAS_PATTERN_OFFSET\n\n                vec2 myPatternOffset = aPatternOffset;\n\n            #else\n\n                vec2 myPatternOffset = patternOffset;\n\n            #endif\n\n            origin += myPatternOffset;\n\n            float u = (vertex.x - origin.x) * mapGLScale / patternWidth.x;\n\n            float v = (vertex.y - origin.y) * mapGLScale / patternWidth.y;\n\n            return vec2(u, -v);\n\n        #endif\n\n    }\n\n\n\n    vec2 computeTexCoord(vec4 localVertex, vec2 patternSize) {\n\n        #ifdef IS_VT\n\n            #ifdef HAS_PATTERN_OFFSET\n\n                vec2 myPatternOffset = aPatternOffset;\n\n            #else\n\n                vec2 myPatternOffset = patternOffset;\n\n            #endif\n\n            vec2 origin = uvOrigin + myPatternOffset;\n\n            #ifdef HAS_PATTERN_ORIGIN\n\n                origin = origin - aPatternOrigin * tileScale;\n\n            #endif\n\n            float hasPatternWidth = sign(length(patternWidth));\n\n            vec2 myPatternWidth = mix(patternSize, patternWidth, hasPatternWidth);\n\n            #ifdef HAS_PATTERN_WIDTH\n\n                myPatternWidth = aPatternWidth;\n\n            #endif\n\n            vec2 originOffset = origin * vec2(1.0, -1.0) / myPatternWidth;\n\n\n\n            return mod(originOffset, 1.0) + computeUV(localVertex.xy * tileScale / tileRatio, myPatternWidth);\n\n        #else\n\n            vec2 myPatternWidth = patternSize;\n\n            #ifdef HAS_PATTERN_WIDTH\n\n                float hasPatternWidth = sign(length(aPatternWidth));\n\n                myPatternWidth = mix(patternSize, aPatternWidth, hasPatternWidth);\n\n            #endif\n\n            vec4 position = modelMatrix * localVertex;\n\n            return computeUV(position.xy, myPatternWidth);\n\n        #endif\n\n    }\n\n#endif\n\n\n\n\n\n\n\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n    #include <vsm_shadow_vert>\n\n#endif\n\n\n\n#include <vt_position_vert>\n\n#include <highlight_vert>\n\n\n\n\n\nvoid main() {\n\n    vec3 myPosition = unpackVTPosition();\n\n    vec4 localVertex = vec4(myPosition, 1.);\n\n    gl_Position = projViewModelMatrix * positionMatrix * localVertex;\n\n\n\n    #ifdef HAS_PATTERN\n\n        vec2 patternSize = aTexInfo.zw + 1.0;\n\n        vTexInfo = vec4(aTexInfo.xy, patternSize);\n\n        #ifdef HAS_TEX_COORD\n\n            if (aTexCoord.x == INVALID_TEX_COORD) {\n\n                vTexCoord = computeTexCoord(localVertex, patternSize);\n\n            } else {\n\n                vTexCoord = aTexCoord;\n\n            }\n\n        #else\n\n            vTexCoord = computeTexCoord(localVertex, patternSize);\n\n        #endif\n\n\n\n        #ifdef HAS_UV_SCALE\n\n            vUVScale = aUVScale / 255.0;\n\n        #endif\n\n        #ifdef HAS_UV_OFFSET\n\n            vUVOffset = aUVOffset / 255.0;\n\n        #endif\n\n    #endif\n\n\n\n    #ifdef HAS_COLOR\n\n        vColor = aColor / 255.0;\n\n    #endif\n\n\n\n    highlight_setVarying();\n\n\n\n    #ifdef HAS_OPACITY\n\n        vOpacity = aOpacity / 255.0;\n\n    #endif\n\n\n\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n        shadow_computeShadowPars(localVertex);\n\n    #endif\n\n}\n\n",frag:"#define SHADER_NAME FILL\n\n\n\nprecision mediump float;\n\n\n\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n    #include <vsm_shadow_frag>\n\n#endif\n\n\n\n#ifdef HAS_PATTERN\n\n    #ifdef HAS_UV_SCALE\n\n        varying vec2 vUVScale;\n\n    #else\n\n        uniform highp vec2 uvScale;\n\n    #endif\n\n\n\n    #ifdef HAS_UV_OFFSET\n\n        varying vec2 vUVOffset;\n\n    #else\n\n        uniform vec2 uvOffset;\n\n    #endif\n\n#endif\n\n\n\n#ifdef HAS_PATTERN\n\n    uniform sampler2D polygonPatternFile;\n\n    uniform vec2 atlasSize;\n\n    varying vec2 vTexCoord;\n\n    varying vec4 vTexInfo;\n\n\n\n    vec2 computeUV() {\n\n        #ifdef HAS_UV_SCALE\n\n            vec2 myUVScale = vUVScale;\n\n        #else\n\n            vec2 myUVScale = uvScale;\n\n        #endif\n\n        #ifdef HAS_UV_OFFSET\n\n            vec2 myUVOffset = vUVOffset;\n\n        #else\n\n            vec2 myUVOffset = uvOffset;\n\n        #endif\n\n        vec2 uv = mod(vTexCoord * myUVScale + myUVOffset, 1.0);\n\n        vec2 uvStart = vTexInfo.xy;\n\n        vec2 uvSize = vTexInfo.zw;\n\n        return (uvStart + uv * uvSize) / atlasSize;\n\n    }\n\n#endif\n\n\n\n\n\n#ifdef HAS_COLOR\n\n    varying vec4 vColor;\n\n#else\n\n    uniform vec4 polygonFill;\n\n#endif\n\n\n\n#include <highlight_frag>\n\n\n\n#ifdef HAS_OPACITY\n\n    varying float vOpacity;\n\n#else\n\n    uniform lowp float polygonOpacity;\n\n#endif\n\nuniform float layerOpacity;\n\n\n\nuniform float tileExtent;\n\n\n\nvoid main() {\n\n\n\n    #ifdef HAS_COLOR\n\n        vec4 color = vColor;\n\n    #else\n\n        vec4 color = polygonFill;\n\n    #endif\n\n\n\n    #ifdef HAS_PATTERN\n\n        if (vTexInfo.z * vTexInfo.w > 1.0) {\n\n            vec2 uv = computeUV();\n\n            color = texture2D(polygonPatternFile, uv);\n\n        }\n\n    #endif\n\n\n\n    #ifdef HAS_OPACITY\n\n        gl_FragColor = color * vOpacity;\n\n    #else\n\n        gl_FragColor = color * polygonOpacity;\n\n    #endif\n\n    gl_FragColor *= layerOpacity;\n\n\n\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n        float shadowCoeff = shadow_computeShadow();\n\n        gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, shadowCoeff);\n\n    #endif\n\n\n\n    gl_FragColor = highlight_blendColor(gl_FragColor);\n\n\n\n}\n\n",wgslVert:`#define POSITION_TYPE ${this.layer instanceof Up?"vec2i":"vec2f"}\n`+"#define SHADER_NAME FILL\nstruct VertexInput {\n#ifdef HAS_ALTITUDE\n    @location($i) aPosition: POSITION_TYPE,\n    @location($i) aAltitude: f32,\n#else\n    @location($i) aPosition: vec4i,\n#endif\n#ifdef HAS_COLOR\n    @location($i) aColor: vec4u,\n#endif\n#ifdef HAS_OPACITY\n    @location($i) aOpacity: u32,\n#endif\n#ifdef HAS_PATTERN\n    #ifdef HAS_TEX_COORD\n        @location($i) aTexCoord: vec2f,\n    #endif\n    @location($i) aTexInfo: vec4u,\n    #ifdef HAS_UV_SCALE\n        @location($i) aUVScale: vec2u,\n    #endif\n    #ifdef HAS_UV_OFFSET\n        @location($i) aUVOffset: vec2u,\n    #endif\n    #ifdef HAS_PATTERN_WIDTH\n        @location($i) aPatternWidth: vec2f,\n    #endif\n    #ifdef HAS_PATTERN_ORIGIN\n        @location($i) aPatternOrigin: vec2f,\n    #endif\n    #ifdef HAS_PATTERN_OFFSET\n        @location($i) aPatternOffset: vec2f,\n    #endif\n#endif\n}\nstruct VertexOutput {\n    @builtin(position) position : vec4f,\n#ifdef HAS_COLOR\n    @location($o) vColor: vec4f,\n#endif\n#ifdef HAS_OPACITY\n    @location($o) vOpacity: f32,\n#endif\n#ifdef HAS_PATTERN\n    @location($o) vTexCoord: vec2f,\n    @location($o) vTexInfo: vec4f,\n    #ifdef HAS_UV_SCALE\n        @location($o) vUVScale: vec2f,\n    #endif\n    #ifdef HAS_UV_OFFSET\n        @location($o) vUVOffset: vec2f,\n    #endif\n#endif\n}\nstruct ModelUniforms {\n    projViewModelMatrix: mat4x4f,\n    positionMatrix: mat4x4f,\n#ifdef IS_VT\n#else\n    modelMatrix: mat4x4f,\n#endif\n#ifdef HAS_PATTERN\n    patternWidth: vec2f,\n    patternOffset: vec2f,\n    uvOrigin: vec2f,\n    uvScale: vec2f,\n#ifdef IS_VT\n    tileRatio: f32,\n    tileScale: f32,\n#else\n    glScale: f32,\n#endif\n#endif\n};\n#ifdef HAS_PATTERN && IS_VT\n#else\nstruct Uniforms {\n    glScale: f32,\n}\n#endif\n@group(0) @binding($b) var<uniform> uniforms: ModelUniforms;\n#ifdef HAS_PATTERN && IS_VT\n#else\n@group(0) @binding($b) var<uniform> shaderUniforms: Uniforms;\n#endif\n#ifdef HAS_PATTERN\n    fn computeUV(vertex: vec2f, patternWidth: vec2f) -> vec2f {\n        #ifdef IS_VT\n            let u = vertex.x / patternWidth.x;\n            let v = vertex.y / patternWidth.y;\n            return vec2f(u, v);\n        #else\n            let glScale = shaderUniforms.glScale;\n            var mapGLScale = glScale;\n            #ifdef HAS_PATTERN_WIDTH\n                let hasPatternWidth = sign(length(aPatternWidth));\n                mapGLScale = mix(glScale, 1.0, hasPatternWidth);\n            #endif\n            var origin = uniforms.uvOrigin;\n            #ifdef HAS_PATTERN_ORIGIN\n                origin = aPatternOrigin;\n            #endif\n            #ifdef HAS_PATTERN_OFFSET\n                let myPatternOffset = aPatternOffset;\n            #else\n                let myPatternOffset = uniforms.patternOffset;\n            #endif\n            origin += myPatternOffset;\n            let u = (vertex.x - origin.x) * mapGLScale / patternWidth.x;\n            let v = (vertex.y - origin.y) * mapGLScale / patternWidth.y;\n            return vec2f(u, -v);\n        #endif\n    }\n    fn computeTexCoord(localVertex: vec4f, patternSize: vec2f) -> vec2f {\n        #ifdef IS_VT\n            #ifdef HAS_PATTERN_OFFSET\n                let myPatternOffset = aPatternOffset;\n            #else\n                let myPatternOffset = uniforms.patternOffset;\n            #endif\n            var origin = uniforms.uvOrigin + myPatternOffset;\n            #ifdef HAS_PATTERN_ORIGIN\n                origin = origin - aPatternOrigin * uniforms.tileScale;\n            #endif\n            let hasPatternWidth = sign(length(uniforms.patternWidth));\n            var myPatternWidth = mix(patternSize, uniforms.patternWidth, hasPatternWidth);\n            #ifdef HAS_PATTERN_WIDTH\n                myPatternWidth = aPatternWidth;\n            #endif\n            let originOffset = origin * vec2f(1.0, -1.0) / myPatternWidth;\n            return (originOffset % 1.0) + computeUV(localVertex.xy * uniforms.tileScale / uniforms.tileRatio, myPatternWidth);\n        #else\n            var myPatternWidth = patternSize;\n            #ifdef HAS_PATTERN_WIDTH\n                let hasPatternWidth = sign(length(aPatternWidth));\n                myPatternWidth = mix(patternSize, aPatternWidth, hasPatternWidth);\n            #endif\n            let position = uniforms.modelMatrix * localVertex;\n            return computeUV(position.xy, myPatternWidth);\n        #endif\n    }\n#endif\n#if HAS_SHADOWING && !HAS_BLOOM\n    #include <vsm_shadow_vert>\n#endif\n#include <vt_position_vert>\n#include <highlight_vert>\n@vertex\nfn main(vertexInput: VertexInput) -> VertexOutput {\n    let myPosition = unpackVTPosition(vertexInput);\n    let localVertex = vec4f(myPosition, 1.0);\n    var out: VertexOutput;\n    var position = uniforms.projViewModelMatrix * uniforms.positionMatrix * localVertex;\n    out.position = position;\n    #ifdef HAS_PATTERN\n        let aTexInfo: vec4f = vec4f(vertexInput.aTexInfo);\n        let patternSize = aTexInfo.zw + 1.0;\n        out.vTexInfo = vec4f(aTexInfo.xy, patternSize);\n        #ifdef HAS_TEX_COORD\n            if (vertexInput.aTexCoord.x == INVALID_TEX_COORD) {\n                out.vTexCoord = computeTexCoord(localVertex, patternSize);\n            } else {\n                out.vTexCoord = vertexInput.aTexCoord;\n            }\n        #else\n            out.vTexCoord = computeTexCoord(localVertex, patternSize);\n        #endif\n        #ifdef HAS_UV_SCALE\n            out.vUVScale = vec2f(vertexInput.aUVScale) / 255.0;\n        #endif\n        #ifdef HAS_UV_OFFSET\n            out.vUVOffset = vec2f(vertexInput.aUVOffset) / 255.0;\n        #endif\n    #endif\n    #ifdef HAS_COLOR\n        out.vColor = vec4f(vertexInput.aColor) / 255.0;\n    #endif\n    #if HAS_HIGHLIGHT_COLOR || HAS_HIGHLIGHT_OPACITY\n        highlight_setVarying(vertexInput, out);\n    #endif\n    #ifdef HAS_OPACITY\n        out.vOpacity = f32(vertexInput.aOpacity) / 255.0;\n    #endif\n    #if HAS_SHADOWING && !HAS_BLOOM\n        shadow_computeShadowPars(localVertex);\n    #endif\n    return out;\n}",wgslFrag:"#define SHADER_NAME FILL\n#if HAS_SHADOWING && !HAS_BLOOM\n    #include <vsm_shadow_frag>\n#endif\nstruct FragmentUniforms {\n    #ifdef HAS_PATTERN\n        #ifndef HAS_UV_SCALE\n            uvScale: vec2f,\n        #endif\n        #ifndef HAS_UV_OFFSET\n            uvOffset: vec2f,\n        #endif\n        atlasSize: vec2f,\n    #endif\n    #ifndef HAS_COLOR\n        polygonFill: vec4f,\n    #endif\n    #ifndef HAS_OPACITY\n        polygonOpacity: f32,\n    #endif\n    tileExtent: f32,\n}\nstruct ShaderUniforms {\n    layerOpacity: f32,\n}\n@group(0) @binding($b) var<uniform> fragmentUniforms: FragmentUniforms;\n@group(0) @binding($b) var<uniform> uniforms: ShaderUniforms;\n#if HAS_PATTERN\n    @group(0) @binding($b) var polygonPatternFile: texture_2d<f32>;\n    @group(0) @binding($b) var polygonPatternFileSampler: sampler;\n#endif\n#ifdef HAS_PATTERN || HAS_COLOR || HAS_OPACITY || HAS_UV_SCALE || HAS_UV_OFFSET || HAS_HIGHLIGHT_COLOR || HAS_HIGHLIGHT_OPACITY\n    struct VertexOutput {\n    #ifdef HAS_PATTERN\n        @location($i) vTexCoord: vec2f,\n        @location($i) vTexInfo: vec4f,\n    #endif\n    #ifdef HAS_COLOR\n        @location($i) vColor: vec4f,\n    #endif\n    #ifdef HAS_OPACITY\n        @location($i) vOpacity: f32,\n    #endif\n    #ifdef HAS_PATTERN && HAS_UV_SCALE\n        @location($i) vUVScale: vec2f,\n    #endif\n    #ifdef HAS_PATTERN && HAS_UV_OFFSET\n        @location($i) vUVOffset: vec2f,\n    #endif\n    }\n#endif\n#include <highlight_frag>\n#ifdef HAS_PATTERN\n    fn computeUV(vertexOutput: VertexOutput) -> vec2f {\n        #ifdef HAS_UV_SCALE\n            let myUVScale = vertexOutput.vUVScale;\n        #else\n            let myUVScale = fragmentUniforms.uvScale;\n        #endif\n        #ifdef HAS_UV_OFFSET\n            let myUVOffset = vertexOutput.vUVOffset;\n        #else\n            let myUVOffset = fragmentUniforms.uvOffset;\n        #endif\n        let uv = (vertexOutput.vTexCoord * myUVScale + myUVOffset) % 1.0;\n        let uvStart = vertexOutput.vTexInfo.xy;\n        let uvSize = vertexOutput.vTexInfo.zw;\n        return (uvStart + uv * uvSize) / fragmentUniforms.atlasSize;\n    }\n#endif\n@fragment\nfn main(\n    #ifdef HAS_PATTERN || HAS_COLOR || HAS_OPACITY || HAS_UV_SCALE || HAS_UV_OFFSET || HAS_HIGHLIGHT_COLOR || HAS_HIGHLIGHT_OPACITY\n    vertexOutput: VertexOutput\n    #endif\n) -> @location(0) vec4f {\n    #ifdef HAS_COLOR\n        var color = vertexOutput.vColor;\n    #else\n        var color = fragmentUniforms.polygonFill;\n    #endif\n    #ifdef HAS_PATTERN\n        let uv = computeUV(vertexOutput);\n        var texColor = textureSample(polygonPatternFile, polygonPatternFileSampler, uv);\n        if (vertexOutput.vTexInfo.z * vertexOutput.vTexInfo.w > 1.0) {\n            color = texColor;\n        }\n    #endif\n    #ifdef HAS_OPACITY\n        var outputColor = color * vertexOutput.vOpacity;\n    #else\n        var outputColor = color * fragmentUniforms.polygonOpacity;\n    #endif\n    outputColor *= uniforms.layerOpacity;\n    #if HAS_SHADOWING && !HAS_BLOOM\n        let shadowCoeff = shadow_computeShadow();\n        outputColor.rgb = shadow_blend(outputColor.rgb, shadowCoeff);\n    #endif\n    #if HAS_HIGHLIGHT_COLOR || HAS_HIGHLIGHT_OPACITY\n        outputColor = highlight_blendColor(outputColor, vertexOutput);\n    #endif\n    return outputColor;\n}",uniforms:_,defines:b,extraCommandProps:g})}limitMeshDefines(i){let g=i.defines;g=function(i,g){return OH(i,g,NH,HH,1)}(this.regl,g),i.setDefines(g)}getUniformValues(i,g){const m=g&&g.isRenderingTerrainSkin,_={projViewMatrix:m?zH:i.projViewMatrix,glScale:g&&g.isRenderingTerrainSkin?1:1/i.getGLScale(),viewport:m&&g&&g.viewport,hasSSRGround:g&&g.hasSSRGround};return this.setIncludeUniformValues(_,g),_}_computePatternWidth(i,g,m,_,b,T){let P,I;const H=this.getMap();if(g){P=KF(H,g,b,T)}if(m){I=KF(H,m,b,T,1)}return P=P||I,I=I||P,i[0]=P,i[1]=I,i}}var XH="#define SHADER_NAME LINE\n\n\n\n#define AA_CLIP_LIMIT 2.0\n\n#define AA_LINE_WIDTH 16.0\n\n\n\n#define DEVICE_PIXEL_RATIO 1.0\n\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\n\n\n#define EXTRUDE_SCALE 63.0\n\n#define EXTRUDE_MOD 64.0\n\n#define MAX_LINE_DISTANCE 65535.0\n\n\n\n#ifdef PICKING_MODE\n\n    #include <gl2_vert>\n\n#endif\n\n\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\n#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY)\n\n    attribute vec3 aExtrude;\n\n#else\n\n    attribute vec2 aExtrude;\n\n#endif\n\n#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT) || defined(HAS_TRAIL)\n\n    attribute float aLinesofar;\n\n    varying highp float vLinesofar;\n\n#endif\n\n\n\nuniform float cameraToCenterDistance;\n\n#if defined(HAS_STROKE_WIDTH)\n\n    attribute float aLineStrokeWidth;\n\n#else\n\n    uniform float lineStrokeWidth;\n\n#endif\n\n\n\nuniform mat4 positionMatrix;\n\nuniform mat4 projViewModelMatrix;\n\nuniform mat4 modelMatrix;\n\nuniform float tileResolution;\n\nuniform float resolution;\n\nuniform float tileRatio;\n\nuniform float isRenderingTerrain;\n\n#if defined(HAS_LINE_DX) || defined(HAS_LINE_DY)\n\n    attribute vec2 aLineDxDy;\n\n#endif\n\n#ifndef HAS_LINE_DX\n\n    uniform float lineDx;\n\n#endif\n\n#ifndef HAS_LINE_DY\n\n    uniform float lineDy;\n\n#endif\n\nuniform vec2 canvasSize;\n\n\n\nuniform float layerScale;\n\n\n\nvarying vec2 vNormal;\n\nvarying vec2 vWidth;\n\nvarying float vGammaScale;\n\n#ifndef ENABLE_TILE_STENCIL\n\n    varying vec2 vPosition;\n\n#endif\n\n\n\n#ifdef USE_LINE_OFFSET\n\n    attribute vec2 aExtrudeOffset;\n\n#endif\n\n\n\n#ifdef HAS_LINE_WIDTH\n\n    attribute float aLineWidth;\n\n#else\n\n    uniform float lineWidth;\n\n#endif\n\n\n\n#ifndef PICKING_MODE\n\n    #ifndef HAS_GRADIENT\n\n        #ifdef HAS_COLOR\n\n            attribute vec4 aColor;\n\n            varying vec4 vColor;\n\n        #endif\n\n\n\n        #ifdef HAS_PATTERN\n\n            #if defined(HAS_PATTERN_ANIM) || defined(HAS_PATTERN_GAP)\n\n                attribute vec2 aLinePattern;\n\n            #endif\n\n            #ifdef HAS_PATTERN_ANIM\n\n                varying float vLinePatternAnimSpeed;\n\n            #endif\n\n\n\n            #ifdef HAS_PATTERN_GAP\n\n                varying float vLinePatternGap;\n\n            #endif\n\n\n\n            attribute vec4 aTexInfo;\n\n            varying vec4 vTexInfo;\n\n        #endif\n\n\n\n        #ifdef HAS_DASHARRAY\n\n            #ifdef HAS_DASHARRAY_ATTR\n\n                attribute vec4 aDasharray;\n\n                varying vec4 vDasharray;\n\n            #endif\n\n\n\n            #ifdef HAS_DASHARRAY_COLOR\n\n                attribute vec4 aDashColor;\n\n                varying vec4 vDashColor;\n\n            #endif\n\n        #endif\n\n    #endif\n\n\n\n    #ifdef HAS_STROKE_COLOR\n\n        attribute vec4 aStrokeColor;\n\n        varying vec4 vStrokeColor;\n\n    #endif\n\n\n\n    #ifdef HAS_OPACITY\n\n        attribute float aOpacity;\n\n        varying float vOpacity;\n\n    #endif\n\n\n\n    #ifdef HAS_GRADIENT\n\n        attribute float aGradIndex;\n\n        varying float vGradIndex;\n\n    #endif\n\n\n\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n        #include <vsm_shadow_vert>\n\n    #endif\n\n\n\n    #include <highlight_vert>\n\n#else\n\n    #include <fbo_picking_vert>\n\n#endif\n\n\n\n\n\nvarying vec3 vVertex;\n\n\n\n#include <vt_position_vert>\n\n\n\nvoid main() {\n\n    vec3 position = unpackVTPosition();\n\n\n\n    float round = mod(abs(aExtrude.x), 2.0);\n\n    float up = mod(abs(aExtrude.y), 2.0);\n\n    vNormal = vec2(round, up * 2.0 - 1.0);\n\n\n\n\n\n    vec4 pos4 = vec4(position, 1.0);\n\n    vec4 vertex = projViewModelMatrix * positionMatrix * pos4;\n\n    if (isRenderingTerrain == 1.0) {\n\n        vVertex = (positionMatrix * pos4).xyz;\n\n    } else {\n\n        vVertex = (modelMatrix * positionMatrix * pos4).xyz;\n\n    }\n\n\n\n    #ifdef HAS_STROKE_WIDTH\n\n        float strokeWidth = aLineStrokeWidth / 2.0 * layerScale;\n\n    #else\n\n        float strokeWidth = lineStrokeWidth;\n\n    #endif\n\n\n\n    #ifdef HAS_LINE_WIDTH\n\n        float myLineWidth = aLineWidth / 2.0 * layerScale;\n\n    #else\n\n        float myLineWidth = lineWidth * layerScale;\n\n    #endif\n\n    float halfwidth = myLineWidth / 2.0 + strokeWidth;\n\n\n\n    float gapwidth = sign(strokeWidth) * myLineWidth / 2.0;\n\n    float inset = gapwidth + sign(gapwidth) * ANTIALIASING;\n\n    float outset = halfwidth + sign(halfwidth) * ANTIALIASING;\n\n\n\n    #ifdef USE_LINE_OFFSET\n\n        vec2 offset = lineOffset * (vNormal.y * (aExtrude.xy - aExtrudeOffset) + aExtrudeOffset);\n\n        vec2 dist = (outset * aExtrude.xy + offset) / EXTRUDE_SCALE;\n\n    #else\n\n        vec2 extrude = aExtrude.xy / EXTRUDE_SCALE;\n\n        vec2 dist = outset * extrude;\n\n    #endif\n\n\n\n    float resScale = tileResolution / resolution;\n\n\n\n    vec4 localVertex = vec4(position + vec3(dist, 0.0) * tileRatio / resScale, 1.0);\n\n    gl_Position = projViewModelMatrix * positionMatrix * localVertex;\n\n\n\n\n\n    #ifdef HAS_LINE_DX\n\n        float myLineDx = aLineDxDy[0];\n\n    #else\n\n        float myLineDx = lineDx;\n\n    #endif\n\n    #ifdef HAS_LINE_DY\n\n        float myLineDy = aLineDxDy[1];\n\n    #else\n\n        float myLineDy = lineDy;\n\n    #endif\n\n\n\n    float projDistance = gl_Position.w;\n\n    gl_Position.xy += vec2(myLineDx, myLineDy) * 2.0 / canvasSize * projDistance;\n\n\n\n    #ifndef PICKING_MODE\n\n        vWidth = vec2(outset, inset);\n\n        if (isRenderingTerrain == 1.0) {\n\n            vGammaScale = 1.0;\n\n        } else {\n\n            vGammaScale = projDistance / cameraToCenterDistance;\n\n        }\n\n        #ifndef ENABLE_TILE_STENCIL\n\n            vPosition = position.xy;\n\n            #ifdef USE_LINE_OFFSET\n\n                vPosition += tileRatio * offset / EXTRUDE_SCALE;\n\n            #endif\n\n        #endif\n\n\n\n            #if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT)\n\n                #ifdef HAS_GRADIENT\n\n                    vLinesofar = aLinesofar / MAX_LINE_DISTANCE;\n\n                    vGradIndex = aGradIndex;\n\n                #else\n\n                    float linesofar = aLinesofar - halfwidth * aExtrude.z / EXTRUDE_SCALE / resScale * tileRatio;\n\n                    vLinesofar = linesofar / tileRatio * resScale;\n\n                #endif\n\n            #endif\n\n\n\n        #ifndef HAS_GRADIENT\n\n            #ifdef HAS_COLOR\n\n                vColor = aColor;\n\n            #endif\n\n\n\n            #ifdef HAS_DASHARRAY\n\n                #ifdef HAS_DASHARRAY_ATTR\n\n                    vDasharray = aDasharray;\n\n                #endif\n\n\n\n                #ifdef HAS_DASHARRAY_COLOR\n\n                    vDashColor = aDashColor / 255.0;\n\n                #endif\n\n            #endif\n\n\n\n            #ifdef HAS_PATTERN\n\n                vTexInfo = vec4(aTexInfo.xy, aTexInfo.zw + 1.0);\n\n                #ifdef HAS_PATTERN_ANIM\n\n                    vLinePatternAnimSpeed = aLinePattern[0] / 127.0;\n\n                #endif\n\n\n\n                #ifdef HAS_PATTERN_GAP\n\n                    vLinePatternGap = aLinePattern[1] / 10.0;\n\n                #endif\n\n            #endif\n\n        #endif\n\n\n\n        #ifdef HAS_STROKE_COLOR\n\n            vStrokeColor = aStrokeColor;\n\n        #endif\n\n\n\n        #ifdef HAS_OPACITY\n\n            vOpacity = aOpacity / 255.0;\n\n        #endif\n\n\n\n        #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n            shadow_computeShadowPars(localVertex);\n\n        #endif\n\n\n\n        highlight_setVarying();\n\n    #else\n\n        fbo_picking_setData(projDistance, true);\n\n    #endif\n\n}\n\n",ZH="#define AA_CLIP_LIMIT 2.0\n#define AA_LINE_WIDTH 16.0\n#define DEVICE_PIXEL_RATIO 1.0\n#define ANTIALIASING 1.0 / 1.0 / 2.0\n#define EXTRUDE_SCALE 63.0\n#define EXTRUDE_MOD 64.0\n#define MAX_LINE_DISTANCE 65535.0\nstruct LineUniforms {\n    lineStrokeWidth: f32,\n    positionMatrix: mat4x4f,\n    projViewModelMatrix: mat4x4f,\n    modelMatrix: mat4x4f,\n    tileResolution: f32,\n    tileRatio: f32,\n    lineDx: f32,\n    lineDy: f32,\n    lineWidth: f32\n};\nstruct ShaderUniforms {\n    resolution: f32,\n    cameraToCenterDistance: f32,\n    canvasSize: vec2f,\n    layerScale: f32,\n    isRenderingTerrain: f32,\n}\n@group(0) @binding($b) var<uniform> uniforms: LineUniforms;\n@group(0) @binding($b) var<uniform> shaderUniforms: ShaderUniforms;\nstruct VertexInput {\n#ifdef HAS_ALTITUDE\n    @location($i) aPosition: POSITION_TYPE,\n    @location($i) aAltitude: f32,\n#else\n    @location($i) aPosition: vec4i,\n#endif\n@location($i) aExtrude: vec4i,\n#if HAS_PATTERN || HAS_DASHARRAY || HAS_GRADIENT || HAS_TRAIL\n    @location($i) aLinesofar: LINESOFAR_TYPE,\n#endif\n#ifdef HAS_STROKE_WIDTH\n    @location($i) aLineStrokeWidth: u32,\n#endif\n#if HAS_LINE_DX || HAS_LINE_DY\n    @location($i) aLineDxDy: vec2i,\n#endif\n#ifdef USE_LINE_OFFSET\n    @location($i) aExtrudeOffset: vec2f,\n#endif\n#ifdef HAS_LINE_WIDTH\n    @location($i) aLineWidth: u32,\n#endif\n#ifndef PICKING_MODE\n    #ifndef HAS_GRADIENT\n        #ifdef HAS_COLOR\n            @location($i) aColor: vec4u,\n        #endif\n        #ifdef HAS_PATTERN\n            #if HAS_PATTERN_ANIM || HAS_PATTERN_GAP\n                @location($i) aLinePattern: vec2i,\n            #endif\n                @location($i) aTexInfo: vec4u,\n        #endif\n        #ifdef HAS_DASHARRAY\n            #ifdef HAS_DASHARRAY_ATTR\n                @location($i) aDasharray: vec4u,\n            #endif\n            #ifdef HAS_DASHARRAY_COLOR\n                @location($i) aDashColor: vec4u,\n            #endif\n        #endif\n    #endif\n    #ifdef HAS_STROKE_COLOR\n        @location($i) aStrokeColor: vec4u,\n    #endif\n    #ifdef HAS_OPACITY\n        @location($i) aOpacity: u32,\n    #endif\n    #ifdef HAS_GRADIENT\n        @location($i) aGradIndex: u32,\n    #endif\n#endif\n};\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location($o) vNormal: vec2f,\n    @location($o) vWidth: vec2f,\n    @location($o) vGammaScale: f32,\n#ifndef ENABLE_TILE_STENCIL\n    @location($o) vPosition: vec2f,\n#endif\n    @location($o) vVertex: vec3f,\n#if HAS_PATTERN || HAS_DASHARRAY || HAS_GRADIENT || HAS_TRAIL\n    @location($o) vLinesofar: f32,\n#endif\n#ifndef PICKING_MODE\n    #ifndef HAS_GRADIENT\n        #ifdef HAS_COLOR\n            @location($o) vColor: vec4f,\n        #endif\n        #ifdef HAS_PATTERN\n            #ifdef HAS_PATTERN_ANIM\n                @location($o) vLinePatternAnimSpeed: f32,\n            #endif\n            #ifdef HAS_PATTERN_GAP\n                @location($o) vLinePatternGap: f32,\n            #endif\n            @location($o) vTexInfo: vec4f,\n        #endif\n        #ifdef HAS_DASHARRAY\n            #ifdef HAS_DASHARRAY_ATTR\n                @location($o) vDasharray: vec4f,\n            #endif\n            #ifdef HAS_DASHARRAY_COLOR\n                @location($o) vDashColor: vec4f,\n            #endif\n        #endif\n    #endif\n    #ifdef HAS_STROKE_COLOR\n        @location($o) vStrokeColor: vec4f,\n    #endif\n    #ifdef HAS_OPACITY\n        @location($o) vOpacity: f32,\n    #endif\n    #ifdef HAS_GRADIENT\n        @location($o) vGradIndex: f32,\n    #endif\n#else\n#endif\n};\n#ifndef PICKING_MODE\n    #if HAS_SHADOWING && !HAS_BLOOM\n        #include <vsm_shadow_vert>\n    #endif\n#else\n    #include <fbo_picking_vert>\n#endif\n#include <highlight_vert>\n#include <vt_position_vert>\n@vertex\nfn main(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n    let position = unpackVTPosition(input);\n    let round = abs(f32(input.aExtrude.x)) % 2.0;\n    let up = abs(f32(input.aExtrude.y)) % 2.0;\n    output.vNormal = vec2f(round, up * 2.0 - 1.0);\n    let pos4 = vec4f(position, 1.0);\n    let vertex = uniforms.projViewModelMatrix * uniforms.positionMatrix * pos4;\n    if (shaderUniforms.isRenderingTerrain == 1.0) {\n        output.vVertex = (uniforms.positionMatrix * pos4).xyz;\n    } else {\n        output.vVertex = (uniforms.modelMatrix * uniforms.positionMatrix * pos4).xyz;\n    }\n#ifdef HAS_STROKE_WIDTH\n    let strokeWidth = f32(input.aLineStrokeWidth) / 2.0 * shaderUniforms.layerScale;\n#else\n    let strokeWidth = uniforms.lineStrokeWidth;\n#endif\n#ifdef HAS_LINE_WIDTH\n    let myLineWidth = f32(input.aLineWidth) / 2.0 * shaderUniforms.layerScale;\n#else\n    let myLineWidth = uniforms.lineWidth * shaderUniforms.layerScale;\n#endif\n    let halfwidth = myLineWidth / 2.0 + strokeWidth;\n    let gapwidth = sign(strokeWidth) * myLineWidth / 2.0;\n    let inset = gapwidth + sign(gapwidth) * ANTIALIASING;\n    var outset = halfwidth + sign(halfwidth) * ANTIALIASING;\n    let extrudeXY = vec2f(input.aExtrude.xy);\n#ifdef USE_LINE_OFFSET\n    let offset = lineOffset * (output.vNormal.y * (extrudeXY - input.aExtrudeOffset) + input.aExtrudeOffset);\n    var dist = (outset * extrudeXY + offset) / EXTRUDE_SCALE;\n#else\n    let extrude = extrudeXY / EXTRUDE_SCALE;\n    var dist = outset * extrude;\n#endif\n    let resScale = uniforms.tileResolution / shaderUniforms.resolution;\n    var localVertex = vec4f(position + vec3f(dist, 0.0) * uniforms.tileRatio / resScale, 1.0);\n    output.position = uniforms.projViewModelMatrix * uniforms.positionMatrix * localVertex;\n#ifdef HAS_LINE_DX\n    let myLineDx = f32(input.aLineDxDy.x);\n#else\n    let myLineDx = uniforms.lineDx;\n#endif\n#ifdef HAS_LINE_DY\n    let myLineDy = f32(input.aLineDxDy.y);\n#else\n    let myLineDy = uniforms.lineDy;\n#endif\n    let projDistance = output.position.w;\n    output.position.x += f32(myLineDx) * 2.0 / shaderUniforms.canvasSize.x * projDistance;\n    output.position.y += f32(myLineDy) * 2.0 / shaderUniforms.canvasSize.y * projDistance;\n#ifndef PICKING_MODE\n    output.vWidth = vec2f(outset, inset);\n    if (shaderUniforms.isRenderingTerrain == 1.0) {\n        output.vGammaScale = 1.0;\n    } else {\n        output.vGammaScale = projDistance / shaderUniforms.cameraToCenterDistance;\n    }\n    #ifndef ENABLE_TILE_STENCIL\n        output.vPosition = position.xy;\n        #ifdef USE_LINE_OFFSET\n            output.vPosition += uniforms.tileRatio * offset / EXTRUDE_SCALE;\n        #endif\n    #endif\n    #if HAS_PATTERN || HAS_DASHARRAY || HAS_GRADIENT\n        #ifdef HAS_GRADIENT\n            output.vLinesofar = input.aLinesofar / MAX_LINE_DISTANCE;\n            output.vGradIndex = f32(input.aGradIndex);\n        #else\n            let linesofar = input.aLinesofar - halfwidth * input.aExtrude.z / EXTRUDE_SCALE / resScale * uniforms.tileRatio;\n            output.vLinesofar = linesofar / uniforms.tileRatio * resScale;\n        #endif\n    #endif\n    #ifndef HAS_GRADIENT\n        #ifdef HAS_COLOR\n            output.vColor = vec4f(input.aColor);\n        #endif\n        #ifdef HAS_DASHARRAY\n            #ifdef HAS_DASHARRAY_ATTR\n                output.vDasharray = vec4f(input.aDasharray);\n            #endif\n            #ifdef HAS_DASHARRAY_COLOR\n                output.vDashColor = vec4f(input.aDashColor) / 255.0;\n            #endif\n        #endif\n        #ifdef HAS_PATTERN\n            output.vTexInfo = vec4f(vec2f(input.aTexInfo.xy), vec2f(input.aTexInfo.zw) + 1.0);\n            #ifdef HAS_PATTERN_ANIM\n                output.vLinePatternAnimSpeed = f32(input.aLinePattern.x) / 127.0;\n            #endif\n            #ifdef HAS_PATTERN_GAP\n                output.vLinePatternGap = f32(input.aLinePattern.y) / 10.0;\n            #endif\n        #endif\n    #endif\n    #ifdef HAS_STROKE_COLOR\n        output.vStrokeColor = vec4f(input.aStrokeColor);\n    #endif\n    #ifdef HAS_OPACITY\n        output.vOpacity = f32(input.aOpacity) / 255.0;\n    #endif\n    #if HAS_SHADOWING && !HAS_BLOOM\n        shadow_computeShadowPars(localVertex);\n    #endif\n    #if HAS_HIGHLIGHT_COLOR || HAS_HIGHLIGHT_OPACITY\n        highlight_setVarying(input, output);\n    #endif\n#else\n    fbo_picking_setData(input, &output, projDistance, true);\n#endif\n    return output;\n}";const $H=mA([]),YH=[];class LinePainter extends BasicPainter{static getBloomSymbol(){return["lineBloom"]}isUniqueStencilRefPerTile(){return!1}prepareSymbol(i){const g=i.lineColor;Array.isArray(g)&&(3===g.length&&g.push(1),i.lineColor=g.map((i=>255*i)));const m=i.lineStrokeColor;Array.isArray(m)&&(3===m.length&&m.push(1),i.lineStrokeColor=m.map((i=>255*i)));const _=i.lineDashColor;Array.isArray(_)&&(3===_.length&&_.push(1),i.lineDashColor=_.map((i=>255*i)))}isAnimating(){if(this._hasPatternAnim)return!0;const i=this.getSymbols(),g=this.sceneConfig.trailAnimation;if(g&&g.enable)return!0;for(let g=0;g<i.length;g++)if(i[g].linePatternFile&&i[g].linePatternAnimSpeed)return!0;return!1}needToRedraw(){return!!super.needToRedraw()||!!this.isAnimating()}isBloom(i){return!!this.getSymbol(i.properties.symbolIndex)[LinePainter.getBloomSymbol()[0]]}needPolygonOffset(){return!0}createMesh(i,g){if(!i.geometry)return null;const{geometry:m,symbolIndex:_,ref:b}=i,T=this.getSymbolDef(_);if(void 0===b){FN(m,T,this.getFnTypeConfig(_),this.layer)}const P=this.getSymbol(_),I={tileResolution:m.properties.tileResolution,tileRatio:m.properties.tileRatio,tileExtent:m.properties.tileExtent};this.setLineUniforms(P,I),UF(I,"lineColor",P,"lineColor","#fff",WF(this.colorCache)),UF(I,"linePatterGapColor",P,"linePatterGapColor",[0,0,0,0],WF(this.colorCache)),UF(I,"lineStrokeColor",P,"lineStrokeColor",[0,0,0,0],WF(this.colorCache)),UF(I,"lineDasharray",P,"lineDasharray",[0,0,0,0],(i=>{let g;if(i&&i.length){1===i.length?g=[i[0],i[0],i[0],i[0]]:2===i.length?g=[i[0],i[1],i[0],i[1]]:3===i.length?g=[i[0],i[1],i[2],i[2]]:4===i.length?g=i:i.length>4&&(g=i.slice(0,4))}return g||[0,0,0,0]})),UF(I,"lineDashColor",P,"lineDashColor",[0,0,0,0],WF(this.colorCache));const H=m.properties.iconAtlas,W=this.layer instanceof Up;H&&(I.linePatternFile=SH(this.regl,H,!1,!1),I.atlasSize=H?[H.width,H.height]:[0,0],I.flipY=W?-1:1,this.drawDebugAtlas(H)),void 0===b&&m.generateBuffers(this.regl);const q=new wP.Material(I),$=new wP.Mesh(m,q,{castShadow:!1,picking:!0});$.setLocalTransform(g),$.positionMatrix=this.getAltitudeOffsetMatrix();const ye={};return H&&(ye.HAS_PATTERN=1),$.properties.symbolIndex=_,this._prepareDashDefines($,ye),m.data.aColor&&(ye.HAS_COLOR=1),m.data.aStrokeColor&&(ye.HAS_STROKE_COLOR=1),this.setMeshDefines(ye,m,T),m.data.aAltitude&&(ye.HAS_ALTITUDE=1),$.setDefines(ye),$}addMesh(...i){delete this._hasPatternAnim;const g=i[0];Array.isArray(g)?g.forEach((i=>{this._prepareMesh(i)})):this._prepareMesh(g),super.addMesh(...i)}_prepareMesh(i){if(!i.geometry.aLineWidth&&i.material.get("lineWidth")<=0||!i.geometry.aOpacity&&i.material.get("lineOpacity")<=0)return;const g=i.defines;this._prepareDashDefines(i,g),i.setDefines(g),i.geometry.properties.hasPatternAnim&&(this._hasPatternAnim=1)}_prepareDashDefines(i,g){const m=i.geometry,_=this.getSymbol(i.properties.symbolIndex);m.data.aDasharray||Array.isArray(_.lineDasharray)&&_.lineDasharray.reduce(((i,g)=>i+g),0)>0?(g.HAS_DASHARRAY=1,m.data.aDasharray&&(g.HAS_DASHARRAY_ATTR=1),m.data.aDashColor&&(g.HAS_DASHARRAY_COLOR=1)):g.HAS_DASHARRAY&&delete g.HAS_DASHARRAY}setLineUniforms(i,g){UF(g,"lineWidth",i,"lineWidth",2),UF(g,"lineOpacity",i,"lineOpacity",1),UF(g,"lineStrokeWidth",i,"lineStrokeWidth",0),UF(g,"lineBlur",i,"lineBlur",.7),UF(g,"lineOffset",i,"lineOffset",0),UF(g,"lineDx",i,"lineDx",0),UF(g,"lineDy",i,"lineDy",0),UF(g,"linePatternAnimSpeed",i,"linePatternAnimSpeed",0),UF(g,"linePatternGap",i,"linePatternGap",0)}setMeshDefines(i,g,m){g.data.aOpacity&&(i.HAS_OPACITY=1),g.data.aLineWidth&&(i.HAS_LINE_WIDTH=1),g.data.aLineStrokeWidth&&(i.HAS_STROKE_WIDTH=1),XN(m.lineDx)&&(i.HAS_LINE_DX=1),XN(m.lineDy)&&(i.HAS_LINE_DY=1),XN(m.linePatternAnimSpeed)&&(i.HAS_PATTERN_ANIM=1),XN(m.linePatternGap)&&(i.HAS_PATTERN_GAP=1)}paint(i){this.isShadowIncludeChanged(i)&&(this.shader.dispose(),this.createShader(i)),super.paint(i)}createFnTypeConfig(i,g){const m=ML(g.lineColor),_=ML(g.aLinePatternAnimSpeed),b=ML(g.aLinePatternGap),T=this.createShapeFnTypeConfigs(i,g),P=new Int8Array(2);return[{attrName:"aColor",symbolName:"lineColor",type:Uint8Array,width:4,define:"HAS_COLOR",evaluate:(g,_)=>{let b=m(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,_,i,g,!0)),Array.isArray(b)||(b=this.colorCache[b]=this.colorCache[b]||iL(b).unitArray()),b=jF(b),b}},{attrName:"aLinePattern",symbolName:"linePatternAnimSpeed",type:Int8Array,width:2,related:["linePatternGap"],define:"HAS_LINE_PATTERN",evaluate:(g,m,b,T)=>{let I=_(i.getZoom(),g);return zF(I)&&(I=0),0!==I&&(m.properties.hasPatternAnim=1),P[0]=I/127,P[1]=b[T+1],P}},{attrName:"aLinePattern",symbolName:"linePatternGap",type:Int8Array,width:2,related:["linePatternAnimSpeed"],define:"HAS_LINE_PATTERN",evaluate:(g,m,_,T)=>{let I=b(i.getZoom(),g);return zF(I)&&(I=0),P[1]=10*I,P[0]=_[T],P}}].concat(T)}createShapeFnTypeConfigs(i,g){const m=SL(g.lineWidth),_=SL(g.lineOpacity),b=SL(g.lineStrokeWidth),T=SL(g.lineDx),P=SL(g.lineDy),I=new Uint16Array(1),H=new Int8Array(1);return[{attrName:"aLineWidth",symbolName:"lineWidth",type:Uint8Array,width:1,define:"HAS_LINE_WIDTH",evaluate:(g,_)=>{let b=m(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,_,i,g)),I[0]=Math.round(2*b),I[0]}},{attrName:"aLineStrokeWidth",symbolName:"lineStrokeWidth",type:Uint8Array,width:1,define:"HAS_STROKE_WIDTH",evaluate:g=>{const m=b(i.getZoom(),g);return I[0]=Math.round(2*m),I[0]}},{attrName:"aLineDxDy",symbolName:"lineDx",type:Int8Array,width:2,index:0,define:"HAS_LINE_DX",evaluate:g=>{const m=T(i.getZoom(),g);return H[0]=m,H[0]}},{attrName:"aLineDxDy",symbolName:"lineDy",type:Int8Array,width:2,index:1,define:"HAS_LINE_DY",evaluate:g=>{const m=P(i.getZoom(),g);return H[0]=m,H[0]}},{attrName:"aOpacity",symbolName:"lineOpacity",type:Uint8Array,width:1,define:"HAS_OPACITY",evaluate:(g,m)=>{let b=_(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,m,i,g)),I[0]=255*b,I[0]}}]}updateSceneConfig(i){i.trailAnimation&&this.createShader(this._context)}init(i){if(this.renderer=new wP.Renderer(this.regl),this.createShader(i),this.pickingFBO){const i=this.layer instanceof Up;this.picking=[new wP.FBORayPicking(this.renderer,{name:"line-picking",vert:XH,wgslVert:`#define POSITION_TYPE ${i?"vec2i":"vec2f"}\n#define LINESOFAR_TYPE ${i?"u32":"f32"}\n`+ZH,defines:{PICKING_MODE:1},uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}}],extraCommandProps:this.getExtraCommandProps()},this.pickingFBO,this.getMap())]}}createShader(i){this._context=i;const g=[],m={};this.fillIncludes(m,g,i),this.sceneConfig.trailAnimation&&this.sceneConfig.trailAnimation.enable&&(m.HAS_TRAIL=1);const _=[];g.push({name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A(_,g.projViewMatrix,g.modelMatrix),_}});const b=this.layer instanceof Up;this.shader=new wP.MeshShader({name:"vt-line",vert:XH,frag:"#define SHADER_NAME LINE\n\n#define DEVICE_PIXEL_RATIO 1.0\n\n\n\nprecision highp float;\n\n\n\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n    #include <vsm_shadow_frag>\n\n#endif\n\n\n\nuniform lowp float blendSrcIsOne;\n\nuniform lowp float lineBlur;\n\nuniform float isRenderingTerrain;\n\n\n\n#ifdef HAS_COLOR\n\n    varying vec4 vColor;\n\n#else\n\n    uniform lowp vec4 lineColor;\n\n#endif\n\n\n\n#include <highlight_frag>\n\n\n\n#ifdef HAS_STROKE_COLOR\n\n    varying vec4 vStrokeColor;\n\n#else\n\n    uniform lowp vec4 lineStrokeColor;\n\n#endif\n\n\n\n#ifdef HAS_OPACITY\n\n    varying float vOpacity;\n\n#else\n\n    uniform lowp float lineOpacity;\n\n#endif\n\n\n\nuniform float layerOpacity;\n\n\n\n#ifdef HAS_PATTERN\n\n    uniform sampler2D linePatternFile;\n\n    uniform vec2 atlasSize;\n\n    uniform float flipY;\n\n    #ifdef HAS_PATTERN_ANIM\n\n        varying float vLinePatternAnimSpeed;\n\n    #else\n\n        uniform float linePatternAnimSpeed;\n\n    #endif\n\n    #ifdef HAS_PATTERN_GAP\n\n        varying float vLinePatternGap;\n\n    #else\n\n        uniform float linePatternGap;\n\n    #endif\n\n    uniform vec4 linePatterGapColor;\n\n\n\n    varying vec4 vTexInfo;\n\n    vec2 computeUV(vec2 texCoord) {\n\n        vec2 uv = mod(texCoord, 1.0);\n\n        vec2 uvStart = vTexInfo.xy;\n\n        vec2 uvSize = vTexInfo.zw;\n\n        return (uvStart + uv * uvSize) / atlasSize;\n\n    }\n\n#endif\n\nvarying vec2 vNormal;\n\nvarying vec2 vWidth;\n\nvarying float vGammaScale;\n\n#ifndef ENABLE_TILE_STENCIL\n\n    varying vec2 vPosition;\n\n#endif\n\n\n\nuniform float tileExtent;\n\n#ifdef HAS_DASHARRAY\n\n    #ifdef HAS_DASHARRAY_ATTR\n\n        varying vec4 vDasharray;\n\n    #else\n\n        uniform vec4 lineDasharray;\n\n    #endif\n\n\n\n    #ifdef HAS_DASHARRAY_COLOR\n\n        varying vec4 vDashColor;\n\n    #else\n\n        uniform vec4 lineDashColor;\n\n    #endif\n\n#endif\n\n#if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT) || defined(HAS_TRAIL)\n\n    varying highp float vLinesofar;\n\n#endif\n\n\n\n#ifdef HAS_TRAIL\n\n    uniform float trailSpeed;\n\n    uniform float trailLength;\n\n    uniform float trailCircle;\n\n#endif\n\n\n\n#if defined(HAS_TRAIL) || defined(HAS_PATTERN)\n\n    uniform float currentTime;\n\n#endif\n\n\n\nfloat dashAntialias(float dashMod, float dashWidth) {\n\n    float dashHalf = dashWidth / 2.0;\n\n    float dashDist = abs(dashMod - dashHalf);\n\n    float blur2 = (0.1 + 1.0 / DEVICE_PIXEL_RATIO) * vGammaScale;\n\n    return clamp(min(dashDist + blur2, dashHalf - dashDist) / blur2, 0.0, 1.0);\n\n}\n\n\n\nvarying vec3 vVertex;\n\nuniform vec3 cameraPosition;\n\nuniform float cameraToCenterDistance;\n\nuniform float fogFactor;\n\nvoid main() {\n\n    #ifndef ENABLE_TILE_STENCIL\n\n        float clip = sign(tileExtent - min(tileExtent, abs(vPosition.x))) * sign(1.0 + sign(vPosition.x)) *\n\n            sign(tileExtent - min(tileExtent, abs(vPosition.y))) * sign(1.0 + sign(vPosition.y));\n\n        if (clip == 0.0) {\n\n            discard;\n\n        }\n\n    #endif\n\n    #if defined(HAS_PATTERN) || defined(HAS_DASHARRAY) || defined(HAS_GRADIENT) || defined(HAS_TRAIL)\n\n        float linesofar = vLinesofar;\n\n    #endif\n\n\n\n    float dist = length(vNormal) * vWidth.s;\n\n\n\n    #ifdef HAS_PATTERN\n\n        vec2 uvSize = vTexInfo.zw;\n\n        float hasPattern = sign(uvSize.x * uvSize.y);\n\n        float blur = mix(lineBlur, 0.0, hasPattern);\n\n    #else\n\n        float blur = lineBlur;\n\n    #endif\n\n\n\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * vGammaScale;\n\n    float alpha = clamp(min(dist - (vWidth.t - blur2), vWidth.s - dist) / blur2, 0.0, 1.0);\n\n    #ifdef HAS_COLOR\n\n        vec4 color = vColor / 255.0;\n\n    #else\n\n        vec4 color = lineColor;\n\n    #endif\n\n\n\n    #ifdef HAS_PATTERN\n\n        if (hasPattern == 1.0) {\n\n            #ifdef HAS_PATTERN_GAP\n\n                float myGap = vLinePatternGap;\n\n            #else\n\n                float myGap = linePatternGap;\n\n            #endif\n\n            #ifdef HAS_PATTERN_ANIM\n\n                float myAnimSpeed = vLinePatternAnimSpeed;\n\n            #else\n\n                float myAnimSpeed = linePatternAnimSpeed;\n\n            #endif\n\n            float patternWidth = uvSize.x * vWidth.s * 2.0 / uvSize.y;\n\n            float plusGapWidth = patternWidth * (1.0 + myGap);\n\n            linesofar += mod(currentTime * -myAnimSpeed * 0.2, plusGapWidth);\n\n            float patternx = mod(linesofar / plusGapWidth, 1.0);\n\n            float patterny = mod((flipY * vNormal.y + 1.0) / 2.0, 1.0);\n\n            vec4 patternColor = texture2D(linePatternFile, computeUV(vec2(patternx * (1.0 + myGap), patterny)));\n\n            float inGap = clamp(sign(1.0 / (1.0 + myGap) - patternx) + 0.000001, 0.0, 1.0);\n\n            patternColor = mix(linePatterGapColor, patternColor, inGap);\n\n            color *= patternColor;\n\n        }\n\n    #endif\n\n\n\n    #ifdef HAS_DASHARRAY\n\n        #ifdef HAS_DASHARRAY_ATTR\n\n            vec4 dasharray = vDasharray;\n\n        #else\n\n            vec4 dasharray = lineDasharray;\n\n        #endif\n\n\n\n        #ifdef HAS_DASHARRAY_COLOR\n\n            vec4 dashColor = vDashColor;\n\n        #else\n\n            vec4 dashColor = lineDashColor;\n\n        #endif\n\n\n\n        float dashWidth = dasharray[0] + dasharray[1] + dasharray[2] + dasharray[3];\n\n        float dashMod = mod(linesofar, dashWidth);\n\n        float firstInDash = max(sign(dasharray[0] - dashMod), 0.0);\n\n        float secondDashMod = dashMod - dasharray[0] - dasharray[1];\n\n        float secondInDash = max(sign(secondDashMod), 0.0) * max(sign(dasharray[2] - secondDashMod), 0.0);\n\n\n\n        float isInDash = firstInDash + secondInDash;\n\n\n\n        float firstDashAlpha = dashAntialias(dashMod, dasharray[0]);\n\n        float secondDashAlpha = dashAntialias(secondDashMod, dasharray[2]);\n\n\n\n        float dashAlpha = firstDashAlpha * firstInDash + secondDashAlpha * secondInDash;\n\n        color = color * (1.0 - dashAlpha) + dashColor * dashAlpha;\n\n    #endif\n\n\n\n    #ifdef HAS_STROKE_COLOR\n\n        vec4 strokeColor = vStrokeColor / 255.0;\n\n    #else\n\n        vec4 strokeColor = lineStrokeColor;\n\n    #endif\n\n    strokeColor = mix(color, strokeColor, sign(vWidth.t));\n\n    color = strokeColor * alpha + max(sign(vWidth.t - dist), 0.0) * color * (1.0 - alpha);\n\n\n\n    #ifdef HAS_TRAIL\n\n        float trailMod = mod(linesofar - currentTime * trailSpeed * 0.1, trailCircle);\n\n        float trailAlpha = trailMod < trailLength ? mix(0.0, 1.0, trailMod / trailLength) : 0.0;\n\n        color *= trailAlpha;\n\n    #endif\n\n\n\n    #ifdef HAS_OPACITY\n\n        float opacity = vOpacity;\n\n    #else\n\n        float opacity = lineOpacity;\n\n    #endif\n\n    gl_FragColor = color * opacity * layerOpacity;\n\n\n\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n        float shadowCoeff = shadow_computeShadow();\n\n        gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, shadowCoeff);\n\n    #endif\n\n\n\n    float perspectiveAlpha;\n\n    if (isRenderingTerrain == 1.0) {\n\n        perspectiveAlpha = 1.0;\n\n    } else {\n\n        perspectiveAlpha = clamp(cameraToCenterDistance * 1.5 / distance(vVertex, cameraPosition), 0.0, 1.0);\n\n    }\n\n\n\n\n\n    gl_FragColor *= perspectiveAlpha;\n\n\n\n    gl_FragColor = highlight_blendColor(gl_FragColor);\n\n    if (fogFactor > 0.0) {\n\n        vec3 dir = vec3(vVertex[0] - cameraPosition[0], vVertex[1] - cameraPosition[1], vVertex[2] - cameraPosition[2]);\n\n        float fog_dist = length(dir);\n\n        float fog_alpha = clamp(1.0 - (fog_dist * 1.2) / fogFactor, 0.0, 1.0);\n\n        gl_FragColor *= fog_alpha;\n\n    }\n\n}\n\n",wgslVert:`#define POSITION_TYPE ${b?"vec2i":"vec2f"}\n#define LINESOFAR_TYPE ${b?"u32":"f32"}\n`+ZH,wgslFrag:"#define DEVICE_PIXEL_RATIO 1.0\n#if HAS_SHADOWING && !HAS_BLOOM\n    #include <vsm_shadow_frag>\n#endif\nstruct LineFragmentUniforms {\n    lineBlur: f32,\n    lineColor: vec4f,\n    lineStrokeColor: vec4f,\n    lineOpacity: f32,\n    tileExtent: f32,\n    lineDasharray: vec4f,\n    lineDashColor: vec4f,\n    #ifdef HAS_PATTERN\n        atlasSize: vec2f,\n        flipY: f32,\n        linePatternAnimSpeed: f32,\n        linePatternGap: f32,\n        linePatterGapColor: vec4f,\n    #endif\n}\nstruct ShaderUniforms {\n    layerOpacity: f32,\n    isRenderingTerrain: f32,\n    trailSpeed: f32,\n    trailLength: f32,\n    trailCircle: f32,\n    currentTime: f32,\n    cameraPosition: vec3f,\n    cameraToCenterDistance: f32,\n    fogFactor: f32\n}\n@group(0) @binding($b) var<uniform> uniforms: LineFragmentUniforms;\n@group(0) @binding($b) var<uniform> shaderUniforms: ShaderUniforms;\n#ifdef HAS_PATTERN\n    @group(0) @binding($b) var linePatternFile: texture_2d<f32>;\n    @group(0) @binding($b) var linePatternFileSampler: sampler;\n#endif\nstruct VertexOutput {\n    @location($i) vNormal: vec2f,\n    @location($i) vWidth: vec2f,\n    @location($i) vGammaScale: f32,\n#ifndef ENABLE_TILE_STENCIL\n    @location($i) vPosition: vec2f,\n#endif\n    @location($i) vVertex: vec3f,\n#if HAS_PATTERN || HAS_DASHARRAY || HAS_GRADIENT || HAS_TRAIL\n    @location($i) vLinesofar: f32,\n#endif\n#ifndef HAS_GRADIENT\n    #ifdef HAS_COLOR\n        @location($i) vColor: vec4f,\n    #endif\n    #ifdef HAS_PATTERN\n        #ifdef HAS_PATTERN_ANIM\n            @location($i) vLinePatternAnimSpeed: f32,\n        #endif\n        #ifdef HAS_PATTERN_GAP\n            @location($i) vLinePatternGap: f32,\n        #endif\n        @location($i) vTexInfo: vec4f,\n    #endif\n    #ifdef HAS_DASHARRAY\n        #ifdef HAS_DASHARRAY_ATTR\n            @location($i) vDasharray: vec4f,\n        #endif\n        #ifdef HAS_DASHARRAY_COLOR\n            @location($i) vDashColor: vec4f,\n        #endif\n    #endif\n#endif\n#ifdef HAS_STROKE_COLOR\n    @location($i) vStrokeColor: vec4f,\n#endif\n#ifdef HAS_OPACITY\n    @location($i) vOpacity: f32,\n#endif\n#ifdef HAS_GRADIENT\n    @location($i) vGradIndex: f32,\n#endif\n};\n#include <highlight_frag>\n#if HAS_SHADOWING && !HAS_BLOOM\n    #include <vsm_shadow_frag>\n#endif\n#ifdef HAS_PATTERN\nfn computeUV(texCoord: vec2f) -> vec2f {\n    let uv = texCoord % 1.0;\n    let uvStart = input.vTexInfo.xy;\n    let uvSize = input.vTexInfo.zw;\n    return (uvStart + uv * uvSize) / uniforms.atlasSize;\n}\n#endif\nfn dashAntialias(input: VertexOutput, dashMod: f32, dashWidth: f32) -> f32 {\n    let dashHalf = dashWidth / 2.0;\n    let dashDist = abs(dashMod - dashHalf);\n    let blur2 = (0.1 + 1.0 / DEVICE_PIXEL_RATIO) * input.vGammaScale;\n    return clamp(min(dashDist + blur2, dashHalf - dashDist) / blur2, 0.0, 1.0);\n}\n@fragment\nfn main(input: VertexOutput) -> @location(0) vec4f {\n    #ifndef ENABLE_TILE_STENCIL\n        let clip = sign(uniforms.tileExtent - min(uniforms.tileExtent, abs(input.vPosition.x))) *\n            sign(1.0 + sign(input.vPosition.x)) *\n            sign(uniforms.tileExtent - min(uniforms.tileExtent, abs(input.vPosition.y))) *\n            sign(1.0 + sign(input.vPosition.y));\n        if (clip == 0.0) {\n            discard;\n        }\n    #endif\n    #if HAS_PATTERN || HAS_DASHARRAY || HAS_GRADIENT || HAS_TRAIL\n        let linesofar = input.vLinesofar;\n    #endif\n    let dist = length(input.vNormal) * input.vWidth.x;\n    #ifdef HAS_PATTERN\n        let uvSize = input.vTexInfo.zw;\n        let hasPattern = sign(uvSize.x * uvSize.y);\n        let blur = mix(uniforms.lineBlur, 0.0, hasPattern);\n    #else\n        let blur = uniforms.lineBlur;\n    #endif\n    let blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * input.vGammaScale;\n    let alpha = clamp(min(dist - (input.vWidth.y - blur2), input.vWidth.x - dist) / blur2, 0.0, 1.0);\n    #ifdef HAS_COLOR\n        var color = input.vColor / 255.0;\n    #else\n        var color = uniforms.lineColor;\n    #endif\n    #ifdef HAS_PATTERN\n        if (hasPattern == 1.0) {\n            #ifdef HAS_PATTERN_GAP\n                let myGap = input.vLinePatternGap;\n            #else\n                let myGap = uniforms.linePatternGap;\n            #endif\n            #ifdef HAS_PATTERN_ANIM\n                let myAnimSpeed = input.vLinePatternAnimSpeed;\n            #else\n                let myAnimSpeed = uniforms.linePatternAnimSpeed;\n            #endif\n            let patternWidth = uvSize.x * input.vWidth.x * 2.0 / uvSize.y;\n            let plusGapWidth = patternWidth * (1.0 + myGap);\n            let animatedLinesofar = linesofar + ((shaderUniforms.currentTime * -myAnimSpeed * 0.2) % plusGapWidth);\n            let patternx = (animatedLinesofar / plusGapWidth) % 1.0;\n            let patterny = ((uniforms.flipY * input.vNormal.y + 1.0) / 2.0) % 1.0;\n            let patternColor = textureSample(\n                linePatternFile,\n                linePatternFileSampler,\n                computeUV(vec2f(patternx * (1.0 + myGap), patterny))\n            );\n            let inGap = clamp(sign(1.0 / (1.0 + myGap) - patternx) + 0.000001, 0.0, 1.0);\n            let finalPatternColor = mix(uniforms.linePatterGapColor, patternColor, inGap);\n            color *= finalPatternColor;\n        }\n    #endif\n    #ifdef HAS_DASHARRAY\n        #ifdef HAS_DASHARRAY_ATTR\n            let dasharray = input.vDasharray;\n        #else\n            let dasharray = uniforms.lineDasharray;\n        #endif\n        #ifdef HAS_DASHARRAY_COLOR\n            let dashColor = input.vDashColor;\n        #else\n            let dashColor = uniforms.lineDashColor;\n        #endif\n        let dashWidth = dasharray[0] + dasharray[1] + dasharray[2] + dasharray[3];\n        let dashMod = linesofar % dashWidth;\n        let firstInDash = max(sign(dasharray[0] - dashMod), 0.0);\n        let secondDashMod = dashMod - dasharray[0] - dasharray[1];\n        let secondInDash = max(sign(secondDashMod), 0.0) * max(sign(dasharray[2] - secondDashMod), 0.0);\n        let isInDash = firstInDash + secondInDash;\n        let firstDashAlpha = dashAntialias(input, dashMod, dasharray[0]);\n        let secondDashAlpha = dashAntialias(input, secondDashMod, dasharray[2]);\n        let dashAlpha = firstDashAlpha * firstInDash + secondDashAlpha * secondInDash;\n        color = color * (1.0 - dashAlpha) + dashColor * dashAlpha;\n    #endif\n    #ifdef HAS_STROKE_COLOR\n        var strokeColor = input.vStrokeColor / 255.0;\n    #else\n        var strokeColor = uniforms.lineStrokeColor;\n    #endif\n    strokeColor = mix(color, strokeColor, sign(input.vWidth.y));\n    color = strokeColor * alpha + max(sign(input.vWidth.y - dist), 0.0) * color * (1.0 - alpha);\n    #ifdef HAS_TRAIL\n        let trailMod = (linesofar - shaderUniforms.currentTime * shaderUniforms.trailSpeed * 0.1) % shaderUniforms.trailCircle;\n        let trailAlpha = select(0.0, mix(0.0, 1.0, trailMod / shaderUniforms.trailLength), trailMod < shaderUniforms.trailLength);\n        color *= trailAlpha;\n    #endif\n    #ifdef HAS_OPACITY\n        let opacity = input.vOpacity;\n    #else\n        let opacity = uniforms.lineOpacity;\n    #endif\n    var fragColor = color * opacity * shaderUniforms.layerOpacity;\n    #if HAS_SHADOWING && !HAS_BLOOM\n        let shadowCoeff = shadow_computeShadow();\n        fragColor.rgb = shadow_blend(fragColor.rgb, shadowCoeff);\n    #endif\n    let cameraPosition = shaderUniforms.cameraPosition;\n    let perspectiveAlpha = select(\n        clamp(shaderUniforms.cameraToCenterDistance * 1.5 / distance(input.vVertex, cameraPosition), 0.0, 1.0),\n        1.0,\n        shaderUniforms.isRenderingTerrain == 1.0\n    );\n    fragColor *= perspectiveAlpha;\n    #if HAS_HIGHLIGHT_COLOR || HAS_HIGHLIGHT_OPACITY\n    fragColor = highlight_blendColor(fragColor, input);\n    #endif\n    if (shaderUniforms.fogFactor > 0.0) {\n        let dir = vec3f(input.vVertex.x - cameraPosition.x, input.vVertex.y - cameraPosition.y, input.vVertex.z - cameraPosition.z);\n        let fog_dist = length(dir);\n        let fog_alpha = clamp(1.0 - (fog_dist * 1.2) / shaderUniforms.fogFactor, 0.0, 1.0);\n        fragColor *= fog_alpha;\n    }\n    return fragColor;\n}",uniforms:g,defines:m,extraCommandProps:this.getExtraCommandProps(i)})}isEnableTileStencil(i){return!!!(i&&i.isRenderingTerrain&&this.isTerrainSkin())}getExtraCommandProps(){const i=this.canvas;return{viewport:{x:(i,g)=>g.viewport?g.viewport.x:0,y:(i,g)=>g.viewport?g.viewport.y:0,width:(g,m)=>m.viewport?m.viewport.width:i?i.width:1,height:(g,m)=>m.viewport?m.viewport.height:i?i.height:1},stencil:{enable:(i,g)=>this.isEnableTileStencil(g.painterContext),func:{cmp:()=>"<=",ref:(i,g)=>g.stencilRef},op:{fail:"keep",zfail:"keep",zpass:"replace"}},depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],mask:this.sceneConfig.depthMask||!1,func:this.sceneConfig.depthFunc||"<="},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}}}limitMeshDefines(i){let g=i.defines;g=function(i,g){return OH(i,g,DH,FH,2)}(this.regl,g),i.setDefines(g)}getUniformValues(i,g){const m=g&&g.isRenderingTerrainSkin,_=this.layer.getTileSize().width,b=m?$H:i.projViewMatrix,T=i.viewMatrix,P=i.cameraToCenterDistance,I=i.getResolution(),H=z_(YH,i.width,i.height);m&&z_(H,_,_);const W=this.getBlendFunc().src(),q=this.sceneConfig.trailAnimation||{},$={layerScale:this.layer.options.styleScale||1,projViewMatrix:b,viewMatrix:T,cameraToCenterDistance:P,resolution:I,canvasSize:H,trailSpeed:q.speed||1,trailLength:q.trailLength||500,trailCircle:q.trailCircle||1e3,currentTime:this.layer.getRenderer().getFrameTimestamp()||0,blendSrcIsOne:+!(1!==W&&"one"!==W),cameraPosition:i.cameraPosition,viewport:m&&g&&g.viewport,isRenderingTerrain:+!!m,fogFactor:this.layer.options.fogFactor||0};return this.setIncludeUniformValues($,g),$}}const QH={markerFile:{type:"identity",default:null,property:"_symbol_markerFile"},markerWidth:{type:"identity",default:null,property:"_symbol_markerWidth"},markerHeight:{type:"identity",default:null,property:"_symbol_markerHeight"},markerPathWidth:{type:"identity",default:20,property:"_symbol_markerPathWidth"},markerPathHeight:{type:"identity",default:20,property:"_symbol_markerPathHeight"},markerDx:{type:"identity",default:null,property:"_symbol_markerDx"},markerDy:{type:"identity",default:null,property:"_symbol_markerDy"},markerType:{type:"identity",default:null,property:"_symbol_markerType"},markerPath:{type:"identity",default:null,property:"_symbol_markerPath"},markerFill:{type:"identity",default:null,property:"_symbol_markerFill"},markerFillPatternFile:{type:"identity",default:null,property:"_symbol_markerFillPatternFile"},markerFillOpacity:{type:"identity",default:null,property:"_symbol_markerFillOpacity"},markerLineColor:{type:"identity",default:null,property:"_symbol_markerLineColor"},markerLineWidth:{type:"identity",default:null,property:"_symbol_markerLineWidth"},markerLineOpacity:{type:"identity",default:null,property:"_symbol_markerLineOpacity"},markerLineDasharray:{type:"identity",default:null,property:"_symbol_markerLineDasharray"},markerLinePatternFile:{type:"identity",default:null,property:"_symbol_markerLinePatternFile"},markerVerticalAlignment:{type:"identity",default:null,property:"_symbol_markerVerticalAlignment"},markerHorizontalAlignment:{type:"identity",default:"middle",property:"_symbol_markerHorizontalAlignment"},markerOpacity:{type:"identity",default:1,property:"_symbol_markerOpacity"},markerPitchAlignment:{type:"identity",default:"viewport",property:"_symbol_markerPitchAlignment"},markerRotationAlignment:{type:"identity",default:"viewport",property:"_symbol_markerRotationAlignment"},markerRotation:{type:"identity",default:0,property:"_symbol_markerRotation"},markerAllowOverlap:{type:"identity",default:0,property:"_symbol_markerAllowOverlap"},markerIgnorePlacement:{type:"identity",default:0,property:"_symbol_markerIgnorePlacement"},markerTextFit:{type:"identity",default:null,property:"_symbol_markerTextFit"},markerSpacing:{type:"identity",default:250,property:"_symbol_markerSpacing"},markerTextFitPadding:{type:"identity",default:null,property:"_symbol_markerTextFitPadding"},markerPlacement:{type:"identity",default:"point",property:"_symbol_markerPlacement"}},JH={textName:{type:"identity",default:null,property:"_symbol_textName"},textFaceName:{type:"identity",default:null,property:"_symbol_textFaceName"},textWrapWidth:{type:"identity",default:null,property:"_symbol_textWrapWidth"},textHorizontalAlignment:{type:"identity",default:null,property:"_symbol_textHorizontalAlignment"},textVerticalAlignment:{type:"identity",default:null,property:"_symbol_textVerticalAlignment"},textFill:{type:"identity",default:null,property:"_symbol_textFill"},textSize:{type:"identity",default:null,property:"_symbol_textSize"},textHaloRadius:{type:"identity",default:null,property:"_symbol_textHaloRadius"},textHaloFill:{type:"identity",default:null,property:"_symbol_textHaloFill"},textHaloOpacity:{type:"identity",default:255,property:"_symbol_textHaloOpacity"},textDx:{type:"identity",default:0,property:"_symbol_textDx"},textDy:{type:"identity",default:0,property:"_symbol_textDy"},textOpacity:{type:"identity",default:1,property:"_symbol_textOpacity"},textPitchAlignment:{type:"identity",default:"viewport",property:"_symbol_textPitchAlignment"},textRotationAlignment:{type:"identity",default:"viewport",property:"_symbol_textRotationAlignment"},textRotation:{type:"identity",default:0,property:"_symbol_textRotation"},textAllowOverlap:{type:"identity",default:0,property:"_symbol_textAllowOverlap"},textIgnorePlacement:{type:"identity",default:0,property:"_symbol_textIgnorePlacement"},textSpacing:{type:"identity",default:250,property:"_symbol_textSpacing"},textPlacement:{type:"identity",default:"point",property:"_symbol_textPlacement"}},KH={lineWidth:{type:"identity",default:2,property:"_symbol_lineWidth"},lineStrokeWidth:{type:"identity",default:0,property:"_symbol_lineStrokeWidth"},lineColor:{type:"identity",default:[1,1,1,1],property:"_symbol_lineColor"},lineStrokeColor:{type:"identity",default:[0,0,0,0],property:"_symbol_lineStrokeColor"},lineDx:{type:"identity",default:0,property:"_symbol_lineDx"},lineDy:{type:"identity",default:0,property:"_symbol_lineDy"},linePatternFile:{type:"identity",default:null,property:"_symbol_linePatternFile"},linePatternAnimSpeed:{type:"identity",default:0,property:"_symbol_linePatternAnimSpeed"},linePatternGap:{type:"identity",default:0,property:"_symbol_linePatternGap"},lineOpacity:{type:"identity",default:1,property:"_symbol_lineOpacity"},lineJoin:{type:"identity",default:null,property:"_symbol_lineJoin"},lineCap:{type:"identity",default:null,property:"_symbol_lineCap"},lineDasharray:{type:"identity",default:null,property:"_symbol_lineDasharray"},lineDashColor:{type:"identity",default:null,property:"_symbol_lineDashColor"}},eB="_line_gradient_property",{PackUtil:tB}=JD(),nB=new un(0,0),rB="_vector3dlayer_id",iB=(eB+"").trim();function oB(i,g,m){let _=g;lF(g)&&!hF(g.visible)&&lF(g.visible)&&(_=Ji.loadGeoSymbol(g,m)),Object.defineProperty(i,"getVisible",{get:function(){if(!m.isVisible())return!1;const i=_.visible;return!1!==i&&0!==i}})}function sB(i,g,m){const _=(MF+"").trim(),b=i.getMap(),T=b.getGLRes();let P=i.getCoordinates();const I=[],H=[];let W=1;if(i instanceof yf||i instanceof Mf){i instanceof yf&&(P=[P]);for(let i=0;i<P.length;i++)b.coordToPointAtRes(P[i],T,nB),I.push([nB.x,nB.y,P[i].z||0]),H.push([P[i].x,P[i].y])}else if(i instanceof vf||i instanceof Pf){W=2,i instanceof vf&&(P=[P]);for(let i=0;i<P.length;i++){I[i]=[],H[i]=[];for(let g=0;g<P[i].length;g++)b.coordToPointAtRes(P[i][g],T,nB),I[i].push([nB.x,nB.y,P[i][g].z||0]),H[i].push([P[i][g].x,P[i][g].y])}}else if(i instanceof gf||i instanceof If){W=3,i instanceof Df||i instanceof Hf||i instanceof Nf||i instanceof Bf?P=[[i.getShell()]]:i instanceof gf&&(P=[P]);let g=0;for(let i=0;i<P.length;i++){let m=!1;for(let _=0;_<P[i].length;_++){if(I[g]=[],H[g]=[],m)for(let m=P[i][_].length-1;m>=0;m--)b.coordToPointAtRes(P[i][_][m],T,nB),I[g].push([nB.x,nB.y,P[i][_][m].z||0]),H[g].push([P[i][_][m].x,P[i][_][m].y]);else for(let m=0;m<P[i][_].length;m++)b.coordToPointAtRes(P[i][_][m],T,nB),I[g].push([nB.x,nB.y,P[i][_][m].z||0]),H[g].push([P[i][_][m].x,P[i][_][m].y]);0===_&&(m=tB.calculateSignedArea(I[g])<0,m&&(I[g]=I[g].reverse(),H[g]=H[g].reverse())),g++}}}const q=i.getProperties()?Object.assign({},i.getProperties()):{},$=i._getInternalSymbol()||function(i){if(i instanceof yf||i instanceof Mf)return{markerType:"ellipse",markerWidth:8,markerHeight:0,markerFill:"#000"};if(i instanceof vf||i instanceof Pf)return{lineColor:"#000",lineWidth:1};if(i instanceof gf||i instanceof If)return{polygonFill:"#fff",lineColor:"#000",lineWidth:1}}(i),ye=m?Array.isArray(m)?m[0].id:m.id:g.id++;if(Array.isArray($)&&$.length){const b=[],T=$.length;for(let P=0;P<T;P++){const Re=P===T-1?q:iF({},q),Be=aB($[P],Re);for(const i in $[P])if(fF($[P],i)){Re[("_symbol_"+i).trim()]=$[P][i]}Be&&($[P].lineGradientProperty=Be);const Ge=m&&m[P]?m[P][_]:g.pickingId++,je={type:W,id:ye,properties:Re,visible:i.isVisible(),geometry:I,coordinates:H,extent:1/0};oB(je,$[P],i),je[_]=Ge,b.push(je)}return b}if($){const i=aB($,q);for(const i in $)if(fF($,i)){q[("_symbol_"+i).trim()]=$[i]}i&&($.lineGradientProperty=i)}const Re=m?m.id:g.pickingId++,Be={type:W,id:ye,properties:q,visible:i.isVisible(),geometry:I,coordinates:H,extent:1/0};return oB(Be,$,i),Be[_]=Re,Be}function aB(i,g){const m=i.lineGradientProperty;return m&&(g[iB]=g[m],g.mapbox_clip_start=0,g.mapbox_clip_end=1,delete g[m]),m}class LineGradientPainter extends LinePainter{postCreateGeometry(i){this.generateGradProperties(i)}startFrame(...i){super.startFrame(...i),this._updateMeshGradient()}_updateMeshGradient(){if(this._changedMeshes){for(let i=0;i<this._changedMeshes.length;i++){if(!this._changedMeshes[i]||!this._changedMeshes[i].isValid())continue;const{geometry:g,material:m}=this._changedMeshes[i],{symbolIndex:_}=g.properties;this.generateGradProperties({geometry:g,symbolIndex:_});const b=this._genGradientTexture(g.properties.gradients),T=m.get("lineGradientTexture");T&&T.destroy(),g.generateBuffers(this.regl),m.set("lineGradientTexture",b),m.set("lineGradientTextureHeight",b.height)}delete this._changedMeshes}}onFeatureChange(i,g){this._changedMeshes||(this._changedMeshes=[]);for(let m=0;m<g.length;m++){if(!g[m]||!g[m].isValid())continue;const _=g[m].geometry,{features:b}=_.properties;if(!b)continue;const T=i&&i[rB];b[T]&&(b[T].feature.properties[eB]=i.properties[eB],this._changedMeshes.push(g[m]),this.setToRedraw())}}needRebuildOnGometryPropertiesChanged(){return!1}generateGradProperties(i){const{symbolIndex:g,geometry:m}=i,{features:_}=m.properties,b=this.getSymbol(g).lineGradientProperty,T=m.properties.aPickingId||m.data.aPickingId,P=new Uint8Array(T.length),I=[],H=new Map;function W(i){let g=i&&i[b];Array.isArray(g)||(g=[0,"black",1,"black"]);let m,_=g.join();return H.has(_)?m=H.get(_):(m=I.length,H.set(_,m),I.push(g)),m}let q=T[0],$=_[q].feature.properties,ye=W($);for(let i=1;i<T.length;i++)T[i]!==q&&(q=T[i],$=_[q].feature.properties,ye=W($)),P[i]=ye;if(m.data.aGradIndex){const i=m.data.aGradIndex;i&&i.buffer&&i.buffer.destroy&&i.buffer.destroy()}m.data.aGradIndex=P,m.properties.gradients=I}createMesh(i,g){const{geometry:m,symbolIndex:_,ref:b}=i,T=this.getSymbolDef(_);if(void 0===b){FN(m,T,this.getFnTypeConfig(_),this.layer)}const P={tileResolution:m.properties.tileResolution,tileRatio:m.properties.tileRatio,tileExtent:m.properties.tileExtent},I=this.getSymbol(_);this.setLineUniforms(I,P);const H=this._genGradientTexture(m.properties.gradients);P.lineGradientTexture=H,P.lineGradientTextureHeight=H.height,void 0===b&&m.generateBuffers(this.regl);const W=new wP.Material(P),q=new wP.Mesh(m,W,{castShadow:!1,picking:!0});q.setLocalTransform(g);const $={HAS_GRADIENT:1};return m.data.aAltitude&&($.HAS_ALTITUDE=1),this.setMeshDefines($,m,T),q.setDefines($),q.properties.symbolIndex=_,q}_genGradientTexture(i){return this.regl.texture({width:256,height:2*i.length,data:lB(i),format:"rgba",mag:"linear",min:"linear",flipY:!1})}createFnTypeConfig(i,g){return this.createShapeFnTypeConfigs(i,g)}createShader(i){this._context=i;const g=[],m={};this.fillIncludes(m,g,i),this.sceneConfig.trailAnimation&&this.sceneConfig.trailAnimation.enable&&(m.HAS_TRAIL=1);const _=[];g.push({name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A(_,g.projViewMatrix,g.modelMatrix),_}}),this.shader=new wP.MeshShader({vert:XH,frag:"#define SHADER_NAME LINE_GRADIENT\n\n#define DEVICE_PIXEL_RATIO 1.0\n\n#define MAX_LINE_COUNT 128.0\n\n\n\nprecision mediump float;\n\n\n\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n    #include <vsm_shadow_frag>\n\n#endif\n\n\n\n#ifdef HAS_OPACITY\n\n    varying float vOpacity;\n\n#else\n\n    uniform lowp float lineOpacity;\n\n#endif\n\n\n\nuniform float layerOpacity;\n\n\n\nuniform lowp float lineBlur;\n\nuniform float lineGradientTextureHeight;\n\nuniform float tileExtent;\n\n\n\nuniform sampler2D lineGradientTexture;\n\n\n\nvarying vec2 vNormal;\n\nvarying vec2 vWidth;\n\nvarying float vGammaScale;\n\nvarying highp float vLinesofar;\n\nvarying float vGradIndex;\n\n#ifndef ENABLE_TILE_STENCIL\n\n    varying vec2 vPosition;\n\n#endif\n\n\n\n#ifdef HAS_TRAIL\n\n    uniform float trailSpeed;\n\n    uniform float trailLength;\n\n    uniform float trailCircle;\n\n    uniform float currentTime;\n\n#endif\n\n\n\n#include <highlight_frag>\n\n\n\nvoid main() {\n\n    #ifndef ENABLE_TILE_STENCIL\n\n        float clip = sign(tileExtent - min(tileExtent, abs(vPosition.x))) * sign(1.0 + sign(vPosition.x)) *\n\n            sign(tileExtent - min(tileExtent, abs(vPosition.y))) * sign(1.0 + sign(vPosition.y));\n\n        if (clip == 0.0) {\n\n            discard;\n\n        }\n\n    #endif\n\n\n\n    float dist = length(vNormal) * vWidth.s;\n\n    float blur2 = (lineBlur + 1.0 / DEVICE_PIXEL_RATIO) * vGammaScale;\n\n    float alpha = clamp(min(dist - (vWidth.t - blur2), vWidth.s - dist) / blur2, 0.0, 1.0);\n\n\n\n    float linesofar = vLinesofar;\n\n    vec4 color = texture2D(lineGradientTexture, vec2(linesofar, (vGradIndex * 2.0 + 0.5) / lineGradientTextureHeight)) * alpha;\n\n    color *= max(sign(MAX_LINE_COUNT - vGradIndex), 0.0);\n\n    #ifdef HAS_TRAIL\n\n        float trailMod = mod(linesofar - currentTime * trailSpeed * 0.1, trailCircle);\n\n        float trailAlpha = trailMod < trailLength ? mix(0.0, 1.0, trailMod / trailLength) : 0.0;\n\n        color *= trailAlpha;\n\n    #endif\n\n\n\n     #ifdef HAS_OPACITY\n\n        float opacity = vOpacity;\n\n    #else\n\n        float opacity = lineOpacity;\n\n    #endif\n\n    gl_FragColor = color * opacity * layerOpacity;\n\n\n\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n        float shadowCoeff = shadow_computeShadow();\n\n        gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, shadowCoeff);\n\n    #endif\n\n\n\n    gl_FragColor = highlight_blendColor(gl_FragColor);\n\n}\n\n",uniforms:g,defines:m,extraCommandProps:this.getExtraCommandProps()})}}function lB(i){i.length>2048&&console.warn(`Gradients count is (${i.length}), it may be slow to render.`);const g=document.createElement("canvas"),m=g.getContext("2d");g.width=256,g.height=2*i.length;for(let g=0;g<i.length;g++){const _=i[g],b=m.createLinearGradient(0,0,256,0);for(let i=0;i<_.length;i+=2)b.addColorStop(+_[i],_[i+1]);m.fillStyle=b;const T=g%256;m.fillRect(0,2*T,256,2*T+2)}return m.canvas}class CollisionGroup{constructor(i){this._meshes=i||[],this.properties={}}set meshes(i){this._meshes=i}get meshes(){return this._meshes}}const hB=224,cB=600,uB=100,fB=new Uint8Array(1),dB=[],pB={collides:0,boxes:[]},gB=[],mB=[];class CollisionPainter extends BasicPainter{createGeometry(...i){const g=super.createGeometry(...i);if(!g||!g.geometry)return g;const{geometry:m}=g,_=i[0];m.properties.collideIds=_.featureIds&&_.featureIds.length&&_.isIdUnique?_.featureIds:_.data.aPickingId;return m.properties.uniqueCollideIds=QF(m.properties.collideIds,!(this.layer instanceof Up)),g}supportRenderMode(i){const g=this.sceneConfig.renderToPointRenderTarget;return g||void 0===g?"point"===i:"fxaa"===i||"fxaaAfterTaa"===i}addMesh(i,g,m){if(i&&!this.isEnableCollision()){let g=i;Array.isArray(g)||(gB[0]=i,g=gB);for(let i=0;i<g.length;i++){const m=g[i].defines;delete m.ENABLE_COLLISION,g[i].setDefines(m);const{elements:_,visElemts:b}=g[i].geometry.properties;b&&void 0!==b.count&&b.count!==_.length&&(g[i].geometry.setElements(_),b.count=_.length)}}return super.addMesh(i,g,m)}startMeshCollision(i){const{meshKey:g}=i.properties,{renderer:m}=this._cachedInstances,_=m.isForeground(i instanceof CollisionGroup?i.meshes[0]:i);if(i.properties.isForeground=_,i instanceof CollisionGroup&&i.meshes.length)for(let g=0;g<i.meshes.length;g++)i.meshes[g].properties.isForeground=_;this._startTime=performance.now(),this._canProceed=this._canProceedCollision(),this._meshCollisionStale=this._isCachedCollisionStale(g)}endMeshCollision(i){const g=this._collisionContext.tags[i];if(this._canProceed&&g&&this._meshCollisionStale){const i=this.getMap();this._anchorCoord0||(this._anchorCoord0=new pl(0,0),this._anchorCoord1=new pl(0,0)),g.anchor0=i.containerPointToCoord(this._containerAnchor0,this._anchorCoord0),g.anchor1=i.containerPointToCoord(this._containerAnchor1,this._anchorCoord1),g.anchor0.z=i.getZoom(),g.anchor0.width=i.width,g.anchor0.height=i.height,g.anchor0.pitch=i.getPitch()}this.getMap().collisionFrameTime+=performance.now()-this._startTime}_isCachedCollisionStale(i){const g=this.getMap(),m=g.getZoom(),_=g.getPitch(),[b,T]=this._getMeshAnchor(i);return!b||!T||b.z!==m||b.width!==g.width||b.height!==g.height||b.pitch!==_||b.distanceTo(this._containerAnchor0)>3||T.distanceTo(this._containerAnchor1)>3}_startCollision(){const i=this.getMap();this._coordCache={},this._containerAnchor0=new un(i.width/3,i.height/2),this._containerAnchor1=new un(2*i.width/3,i.height/2),delete this._canProceed,this._collisionContext||(this._collisionContext={tags:{}}),this._cachedInstances={layer:this.layer,renderer:this.layer.getRenderer(),frameTimestamp:this.layer.getRenderer().getFrameTimestamp(),map:this.getMap(),zoom:i.getZoom(),collisionTags:this._collisionContext.tags,isEnableUniquePlacement:this.isEnableUniquePlacement()}}_endCollision(){}_getCachedCollision(i,g){const m=this._collisionContext;return m.tags[i]&&m.tags[i][g]}_setCollisionCache(i,g,m){const _=this._collisionContext;_.tags[i]=_.tags[i]||[],_.tags[i][g]=m}_canProceedCollision(){const i=this.getMap();if(!i.isInteracting())return!0;return i.collisionFrameTime<=this.layer.options.collisionFrameLimit}_getMeshAnchor(i){const g="__meshAnchorKey".trim(),m=this._collisionContext.tags[i];if(m&&m.anchor0){const{anchor0:i,anchor1:_}=m,b=i[g]=i[g]||i.x+","+i.y,T=_[g]=_[g]||_.x+","+_.y;let P=this._coordCache[b],I=this._coordCache[T];if(!P||!I){const g=this.getMap();P=this._coordCache[b]=g.coordToContainerPoint(i),I=this._coordCache[T]=g.coordToContainerPoint(_)}return P.z=i.z,dB[0]=P,dB[1]=I,P.width=i.width,P.height=i.height,dB}return dB[0]=dB[1]=null,dB}updateBoxCollisionFading(i,g,m,_,b){const{layer:T,renderer:P,zoom:I,collisionTags:H,isEnableUniquePlacement:W}=this._cachedInstances,{meshKey:q,isForeground:$}=g.properties;if(W&&this._isReplacedPlacement(q,b))return!1;const ye=m.length;let Re=H[q]&&H[q][b];const Be=Re,Ge=this._zooming&&Re;if(!(Ge&&0!==Re.collides)&&i){if(this._canProceed||Ge&&0===Re.collides)if((this._meshCollisionStale||Re&&Re.z!==I)&&(Re=null),Re){if(Re.boxes&&Re.boxes.length){const{boxes:i,isAllowOverlap:g}=Re;let m=0;if(!g){let g=0;for(let _=0;_<i.length;_++)if(!m){const b=this.isCollides(i[_]);if(-1===b)g++;else if(1===b){m=1;break}}g===i.length&&(m=-1)}Re.collides=m}}else{Re=Be||{collides:0,boxes:[]},Re.boxes.length=0,Re.z=I;let i=0;for(let g=0;g<ye;g++){const{mesh:T,allElements:P,boxCount:I,start:H,end:W}=m[g],q=this._isBoxVisible(T,P,I,H,W,_,b);q.isAllowOverlap&&(Re.isAllowOverlap=1),0===i&&(i=q.collides),q.boxes&&Re.boxes.push(...q.boxes)}Re.collides=i,this._setCollisionCache(q,b,Re)}}let je=i&&Re&&0===Re.collides,Xe=1,Ze=!1;if(this.sceneConfig.fading){const i=this._getBoxTimestamps(g);if(this._zoomingOut)i[b]=je?1:-1;else if($&&delete g._fadeOutStartTime,Xe=this._getBoxFading($,je,i,b),$?(Xe>0&&(je=!0),Ze=this.isBoxFading(g,b),Ze&&this.setToRedraw()):je||(this._markFadingCollided(i,b),Xe=0),je){const m=g._fadeOutStartTime;if(m&&1===Xe&&i[b]>0){let{fadeOutDelay:i,fadingDuration:g}=this.sceneConfig;zF(g)&&(g=hB),zF(i)&&(i=uB);const _=HF(1-(P.getFrameTimestamp()-m-i)/g,0,1);Xe*=_,_>0&&this.setToRedraw()}}}if(Re&&T.options.debugCollision&&this.addCollisionDebugBox(Re.boxes,Re.collides?0:1),je||Ze){const{mesh:i,start:g}=m[0],_=this.getSymbol(i.properties.symbolIndex);!this._isIgnorePlacement(_,i,g)&&Re&&Re.boxes&&this._fillCollisionIndex(Re.boxes,i)}if(je){const i=fB[0]=255*Xe;for(let g=0;g<ye;g++){const{mesh:_,allElements:b,start:T,boxStart:P,end:I,boxIndex:H}=m[g];this.setCollisionOpacity(_,b,i,void 0===P?T:P,I,H)}}return je&&Xe>0}isMeshIterable(){return!0}setCollisionOpacity(i,g,m,_,b){this._updateOpacityData(i,m,g[_],g[b-1])}_updateOpacityData(i,g,m,_){const{aOpacity:b}=i.geometry.properties;if(!b)return;if(b[m]!==g){const i=_;for(let _=m;_<=i;_++)b[_]=g;b.dirty=!0}}isBoxFading(i,g){const{frameTimestamp:m}=this._cachedInstances;let _=this.sceneConfig.fadingDuration;zF(_)&&(_=hB);return m-Math.abs(this._getBoxTimestamps(i)[g])<_}_isBoxVisible(i,g,m,_,b,T,P){const I=this.getSymbol(i.properties.symbolIndex),H=this._isIgnorePlacement(I,i,g[_]),W=this._isAllowOverlap(I,i,g[_]);if(!this.isEnableCollision()||H&&W)return pB;const q=this.isBoxCollides(i,g,m,_,b,T,P);return W&&(q.collides=0,q.isAllowOverlap=1),q}_isIgnorePlacement(i,g,m){if(!this.isEnableCollision())return!0;const _=g.geometry.properties.aOverlap;if(!_)return 1===+i[this.propIgnorePlacement];const b=_[m];return b<2?1===+i[this.propIgnorePlacement]:b%8%2}_isAllowOverlap(i,g,m){if(!this.isEnableCollision())return!0;const _=g.geometry.properties.aOverlap;if(!_)return 1===+i[this.propAllowOverlap];const b=_[m];return b<2?1===+i[this.propAllowOverlap]:(b>>2)%2}_fillCollisionIndex(i){if(Array.isArray(i[0]))for(let g=0;g<i.length;g++)this.insertCollisionBox(i[g]);else this.insertCollisionBox(i)}_getBoxFading(i,g,m,_){let{fadingDuration:b,fadeInDelay:T,fadeOutDelay:P}=this.sceneConfig;zF(b)&&(b=hB),zF(T)&&(T=cB),zF(P)&&(P=uB);const{frameTimestamp:I}=this._cachedInstances;let H=m[_],W=g?1:0;if(!H)return g&&i&&(m[_]=I+T),0;if(I<Math.abs(H)&&(!g&&H>0||g&&H<0)){const i=I-b;m[_]=H=g?i:-i}return I-Math.abs(H)<b?W=H>0?(I-H)/b:1-(I+H)/b:g?(H<0&&(m[_]=H=I+T),W=(I-H)/b):(H>0&&(m[_]=H=-(I+P)),W=1-(I+H)/b),(W<0||W>1)&&(W=HF(W,0,1)),W}_getBoxTimestamps(i){this._boxTimestamps||(this._boxTimestamps={});const{meshKey:g}=i.properties;if(!this._boxTimestamps[g]){const{frameTimestamp:i}=this._cachedInstances;this._boxTimestamps[g]={timestamp:i}}return this._boxTimestamps[g]}_refreshTimeStamps(i){if(!this._prevTimestamp)return void(this._prevTimestamp=i);const g=this.scene.getMeshes();if(g&&g.length){for(let m=0;m<g.length;m++){const _=this._getBoxTimestamps(g[m]);_.timestamp<this._prevTimestamp?delete g[m]._fading_timestamps:_.timestamp=i}this._prevTimestamp=i}}_markFadingCollided(i,g){if(!i)return;const{frameTimestamp:m}=this._cachedInstances;let{fadingDuration:_}=this.sceneConfig;zF(_)&&(_=hB),i[g]=-(m-_-1)}deleteMesh(i,g){if(i){if(Array.isArray(i))for(let g=0;g<i.length;g++){const m=i[g].properties.meshKey;this._collisionContext&&delete this._collisionContext.tags[m],this._boxTimestamps&&delete this._boxTimestamps[m]}else{const g=i.properties.meshKey;this._collisionContext&&delete this._collisionContext.tags[g],this._boxTimestamps&&delete this._boxTimestamps[g]}super.deleteMesh(i,g)}}delete(i){this._collisionMesh&&(this._collisionMesh.geometry.dispose(),this._collisionShader.dispose(),this._collisionMesh.dispose(),delete this._collisionMesh,delete this._collisionShader,delete this._collisionRenderer),delete this._collisionContext,super.delete(i)}isCollides(i){const g=this.layer,m=g.getMap(),_=m.getDevicePixelRatio();if(Py(mB,i,1/_),m.isOffscreen(mB))return-1;const b=g.getCollisionIndex(),T=this.sceneConfig.collisionBufferSize||g.options.collisionBufferSize||0;return T&&(i=vB(mB,i,T)),+b.collides(i)}insertCollisionBox(i){const g=this.layer,m=g.getCollisionIndex(),_=this.sceneConfig.collisionBufferSize||g.options.collisionBufferSize||0;let b=i;_&&(b=i._buffered=i._buffered||[],i=vB(b,i,_)),m.insertBox(b)}addCollisionDebugBox(i,g){if(i&&i.length)if(Array.isArray(i[0]))for(let m=0;m<i.length;m++){this._addCollisionBox(i[m],g)}else this._addCollisionBox(i,g)}_addCollisionBox(i,g){if(!i)return;const m=this._collisionBoxes=this._collisionBoxes||{aPosition:[],aVisible:[],indices:[]},_=this.sceneConfig.collisionBufferSize||this.layer.options.collisionBufferSize||0;_&&(i=vB(mB,i,_));const b=this.getMap(),T=b.getDevicePixelRatio();if(Py(mB,i,1/T),b.isOffscreen(mB))return;const P=m.aPosition.length/2;m.aPosition.push(i[0],i[1],i[2],i[1],i[2],i[3],i[0],i[3]),m.aVisible.push(g,g,g,g),m.indices.push(P,P+1,P+1,P+2,P+2,P+3,P+3,P)}updateCollision(i){super.updateCollision(i),this._startCollision(),this._prepareZoomEndMeshes(),this._zoomEndMeshes&&this._zoomEndMeshes.length&&(this._updateZoomMeshesLevel(),this._zoomEndMeshes&&(this.setToRedraw(),this.scene.addMesh(this._zoomEndMeshes)));(this.getMap().isZooming()||this._zoomEndMeshes&&this._zoomEndMeshes.length)&&(this._updateUniquePlacements(),this._mergeUniquePlacements(this.scene.getMeshes()))}paint(i){const g=super.paint(i);return this._renderCollisionBox(i),!1===this._canProceed&&this.setToRedraw(),g}shouldIgnoreBackground(){return!this.getMap().isZooming()&&!this._zoomEndMeshes}_prepareZoomEndMeshes(){const i=this.getMap(),g=i.isZooming();if(!g&&this._zooming){const i=this.layer.getRenderer();this._zoomEndMeshes=this.scene.getMeshes().filter((g=>!i.isForeground(g)&&!g.properties.isLinePlacement))}else g&&!this._zooming&&(this._preRes=i.getResolution());if(g)this._clearTimeout&&(clearTimeout(this._clearTimeout),delete this._zoomingOut,delete this._clearTimeout),this._zoomingOut=this._preRes&&i.getResolution()>this._preRes;else if(this._zooming&&!this._clearTimeout){let{fadeOutDelay:i,fadingDuration:g}=this.sceneConfig;zF(i)&&(i=uB),zF(g)&&(g=hB),this._clearTimeout=setTimeout((()=>{delete this._zoomingOut,delete this._clearTimeout}),i+g+1)}this._zooming=g}_renderCollisionBox(i){if(!this._collisionBoxes||!this.layer.options.debugCollision)return;this._collisionRenderer||this._initCollisionShader();const{aPosition:g,aVisible:m,indices:_}=this._collisionBoxes;if(!this._collisionMesh){const i=new wP.Geometry({aPosition:[],aVisible:[]},[],0,{positionSize:2,primitive:"lines"});this._collisionMesh=new wP.Mesh(i),this._collisionScene=new wP.Scene,this._collisionScene.addMesh(this._collisionMesh)}const b=this._collisionMesh.geometry;b.updateData("aPosition",new Float32Array(g)),b.updateData("aVisible",new Uint8Array(m)),b.setElements(_),this._collisionRenderer.render(this._collisionShader,{size:[this.canvas.width,this.canvas.height]},this._collisionScene,this.getRenderFBO(i)),delete this._collisionBoxes}_initCollisionShader(){this._collisionRenderer=new wP.Renderer(this.regl);const i=this.canvas;this._collisionShader=new wP.MeshShader({vert:"attribute vec2 aPosition;\n\nattribute float aVisible;\n\n\n\nuniform vec2 size;\n\n\n\nvarying vec4 vColor;\n\n\n\nvoid main() {\n\n    vec2 uv = (aPosition / size - 0.5) * 2.0 * vec2(1.0, -1.0);\n\n    gl_Position = vec4(uv, 0.0, 1.0);\n\n\n\n    vColor = mix(vec4(1.0, 0.0, 0.0, 1.5) * 0.5, vec4(0.0, 1.0, 0.0, 1.0) * 0.4, aVisible);\n\n}\n\n",frag:"precision mediump float;\n\n\n\nvarying vec4 vColor;\n\n\n\nvoid main() {\n\n    gl_FragColor = vec4(vColor.rgb, 0.5);\n\n}\n\n",uniforms:["size"],extraCommandProps:{viewport:{x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1},depth:{enable:!1},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}})}_updateZoomMeshesLevel(){let{fadeOutDelay:i,fadingDuration:g}=this.sceneConfig;zF(i)&&(i=uB),zF(g)&&(g=hB);const m=this.layer.getRenderer(),_=m.getCurrentTileZoom(),b=m.getFrameTimestamp(),T=[];for(let P=0;P<this._zoomEndMeshes.length;P++){const I=this._zoomEndMeshes[P],H=I.properties.tile;!I._fadeOutStartTime&&m.isBackTile(H.id)&&(I._fadeOutStartTime=b);I.properties.level=H.z-_>0?2*(H.z-_)-1:2*(_-H.z),m.isForeground(I)||I._fadeOutStartTime&&b-I._fadeOutStartTime>i+g?delete I._fadeOutStartTime:T.push(I)}delete this._zoomEndMeshes,T.length&&(this._zoomEndMeshes=T)}isEnableCollision(){return this.layer.options.collision&&!!this.sceneConfig.collision}isEnableUniquePlacement(){return this.isEnableCollision()&&this.sceneConfig.uniquePlacement}isMeshUniquePlaced(i){return this.isMeshIterable(i)}_updateUniquePlacements(){if(!this.isEnableUniquePlacement())return;const i=this.scene.getMeshes(),g=(i,g,m,_)=>{const{start:b,end:T}=g[0],P=i.geometry.properties,I=P.elements;let H=P.uniquePlacements;if(H||(H=P.uniquePlacements=[]),void 0===H[_]){const g=this.getUniqueEntryKey(i,I[b],_);H[_]=g?{key:g,index:_,start:I[b],end:I[T-1]}:null}};for(let m=0;m<i.length;m++){const _=i[m];this.isMeshUniquePlaced(_)&&this.forEachBox(_,g)}}_mergeUniquePlacements(i){if(!this.isEnableUniquePlacement())return;const g=this.getMap().getZoom();let m=!this._mergedMeshes||this._mergedMehesZoom!==g;if(!m)for(let g=0;g<i.length;g++)if(!this._mergedMeshes[i[g].properties.meshKey]){m=!0;break}if(!m)return;this._mergedMehesZoom=g,this._replacedPlacements={},this._mergedMeshes={},i=i.sort(_B);const _=this.getMap().getGLScale(),b={};for(let g=0;g<i.length;g++){const m=i[g];if(!m.geometry)continue;const{meshKey:T}=m.properties;this._mergedMeshes[T]=1;const{uniquePlacements:P}=m.geometry.properties;if(P)for(let i=0;i<P.length;i++){if(!P[i])continue;const{key:g,index:T}=P[i],I=this._getBoxTimestamps(m),H=yB(g,_),W=b[H];if(W){const i=W.length,g=W[i-3].properties.meshKey,_=W[i-2],b=W[i-1];this._replacedPlacements[g]=this._replacedPlacements[g]||{},this._replacedPlacements[g][b]=1,this._updatePlacementStamps(I,T,_,b),W.push(m,I,T)}else b[H]=[m,I,T]}}for(const i in b){const g=b[i];if(g.length<=6)continue;const m=g.length,_=g[m-2][g[m-1]];if(g[1][g[2]]!==_)for(let i=0;i<m-6;i+=3){g[i+1][g[i+2]]=_}}}_updatePlacementStamps(i,g,m,_){if(void 0!==m[_])if(void 0===i[g])i[g]=m[_];else{let b=i[g];Math.abs(m[_])>Math.abs(b)?i[g]=m[_]:m[_]=i[g]}else void 0!==i[g]&&(m[_]=i[g])}_isReplacedPlacement(i,g){return this._replacedPlacements&&this._replacedPlacements[i]&&this._replacedPlacements[i][g]}_getCollideBoxes(i,g){const{symbolIndex:m}=i.properties,_=m.type||0;let b=i.properties._collidesBoxes;b||(b=i.properties._collidesBoxes=[]);let T=b[m.index];T||(T=i.properties._collidesBoxes=[]),T[_]||(T[_]=[]),T=T[_];const P=g/6;if(!T[P]){const i=[];T[P]={boxes:i,collision:{boxes:i}}}return T[P]}_getMeshBoxes(i){let g=this._MeshBoxes;if(g||(g=this._MeshBoxes=[]),!g[i]){g[i]=[];for(let m=0;m<i;m++)g[i][m]={}}return g[i]}_isHalo0(i){if(!i||!i.geometry)return!0;const g=XN(this.getSymbolDef(i.geometry.properties.symbolIndex).textHaloRadius);if(!i.geometry.properties.glyphAtlas||!i.material.get("isHalo")||g&&i.geometry.properties.hasHalo)return!1;if(g&&!i.geometry.properties.hasHalo)return!0;return!this.getSymbol(i.geometry.properties.symbolIndex).textHaloRadius}}const AB=10;function yB(i,g){return Math.round(i[0]/g/AB)*Math.round(i[1]/g/AB)*(i[2]?Math.round(i[2]/AB):1)+"-"+i[3]}function _B(i,g){const m=g.properties.level-i.properties.level;return 0===m?i.properties.meshKey-g.properties.meshKey:m}function vB(i,g,m){return i[0]=g[0]-m,i[1]=g[1]-m,i[2]=g[2]+m,i[3]=g[3]+m,i}var xB="#include <gl2_vert>\n\n#define SHADER_NAME MARKER\n\n#define RAD 0.0174532925\n\n\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nattribute vec4 aShape;\n\n#ifdef ENABLE_COLLISION\n\n    attribute float aOpacity;\n\n#endif\n\n\n\n#ifdef HAS_OPACITY\n\n    attribute vec2 aColorOpacity;\n\n#endif\n\n\n\n#ifdef HAS_TEXT_SIZE\n\n    attribute float aTextSize;\n\n#else\n\n    uniform float textSize;\n\n#endif\n\n\n\n#if defined(HAS_TEXT_DX) || defined(HAS_TEXT_DY) || defined(HAS_MARKER_DX) || defined(HAS_MARKER_DY)\n\n    attribute vec4 aDxDy;\n\n#endif\n\n#ifndef HAS_MARKER_DX\n\n    uniform float markerDx;\n\n#endif\n\n#ifndef HAS_MARKER_DY\n\n    uniform float markerDy;\n\n#endif\n\n#ifndef HAS_TEXT_DX\n\n    uniform float textDx;\n\n#endif\n\n#ifndef HAS_TEXT_DY\n\n    uniform float textDy;\n\n#endif\n\n\n\n#ifdef HAS_MARKER_WIDTH\n\n    attribute float aMarkerWidth;\n\n#else\n\n    uniform float markerWidth;\n\n#endif\n\n#ifdef HAS_MARKER_HEIGHT\n\n    attribute float aMarkerHeight;\n\n#else\n\n    uniform float markerHeight;\n\n#endif\n\n\n\n#if defined(HAS_MARKER_PITCH_ALIGN) || defined(HAS_TEXT_PITCH_ALIGN)\n\n    attribute vec2 aPitchAlign;\n\n#endif\n\n#ifndef HAS_MARKER_PITCH_ALIGN\n\n    uniform float markerPitchWithMap;\n\n#endif\n\n#ifndef HAS_TEXT_PITCH_ALIGN\n\n    uniform float textPitchWithMap;\n\n#endif\n\n\n\n#if defined(HAS_MARKER_ROTATION_ALIGN) || defined(HAS_TEXT_ROTATION_ALIGN)\n\n    attribute vec2 aRotationAlign;\n\n#endif\n\n#ifndef HAS_MARKER_ROTATION_ALIGN\n\n    uniform float markerRotateWithMap;\n\n#endif\n\n#ifndef HAS_TEXT_ROTATION_ALIGN\n\n    uniform float textRotateWithMap;\n\n#endif\n\n\n\nuniform float flipY;\n\n#if defined(HAS_MARKER_ROTATION) || defined(HAS_TEXT_ROTATION)\n\n    attribute vec2 aRotation;\n\n#endif\n\n#ifndef HAS_MARKER_ROTATION\n\n    uniform float markerRotation;\n\n#endif\n\n#ifndef HAS_TEXT_ROTATION\n\n    uniform float textRotation;\n\n#endif\n\n\n\n\n\n#ifdef HAS_PAD_OFFSET\n\nattribute vec2 aPadOffset;\n\n#endif\n\n\n\nuniform float cameraToCenterDistance;\n\nuniform mat4 positionMatrix;\n\nuniform mat4 projViewModelMatrix;\n\nuniform float textPerspectiveRatio;\n\nuniform float markerPerspectiveRatio;\n\n\n\nuniform float glyphSize;\n\nuniform vec2 iconSize;\n\nuniform vec2 canvasSize;\n\nuniform vec2 iconTexSize;\n\nuniform vec2 glyphTexSize;\n\nuniform float mapPitch;\n\nuniform float mapRotation;\n\n\n\nuniform float zoomScale;\n\nuniform float tileRatio;\n\n\n\nuniform float layerScale;\n\nuniform float isRenderingTerrain;\n\n\n\n#include <vt_position_vert>\n\n\n\nvarying float vIsText;\n\n#ifndef PICKING_MODE\n\n    varying vec2 vTexCoord;\n\n    varying float vOpacity;\n\n    varying float vGammaScale;\n\n    varying float vTextSize;\n\n    varying float vHalo;\n\n\n\n    #ifdef HAS_TEXT_FILL\n\n        attribute vec4 aTextFill;\n\n        varying vec4 vTextFill;\n\n    #endif\n\n\n\n    #ifdef HAS_TEXT_HALO_FILL\n\n        attribute vec4 aTextHaloFill;\n\n        varying vec4 vTextHaloFill;\n\n    #endif\n\n\n\n    #if defined(HAS_TEXT_HALO_RADIUS) || defined(HAS_TEXT_HALO_OPACITY)\n\n        attribute vec2 aTextHalo;\n\n        varying vec2 vTextHalo;\n\n    #endif\n\n\n\n    #include <highlight_vert>\n\n#else\n\n    #include <fbo_picking_vert>\n\n#endif\n\n\n\nvoid main() {\n\n    vec3 position = unpackVTPosition();\n\n    #ifdef HAS_TEXT_SIZE\n\n        float myTextSize = aTextSize * layerScale;\n\n    #else\n\n        float myTextSize = textSize * layerScale;\n\n    #endif\n\n    #ifdef HAS_TEXT_DX\n\n        float myTextDx = aDxDy.z;\n\n    #else\n\n        float myTextDx = textDx;\n\n    #endif\n\n    #ifdef HAS_TEXT_DY\n\n        float myTextDy = aDxDy.w;\n\n    #else\n\n        float myTextDy = textDy;\n\n    #endif\n\n    #ifdef HAS_MARKER_WIDTH\n\n        float myMarkerWidth = aMarkerWidth;\n\n    #else\n\n        float myMarkerWidth = markerWidth;\n\n    #endif\n\n    #ifdef HAS_MARKER_HEIGHT\n\n        float myMarkerHeight = aMarkerHeight;\n\n    #else\n\n        float myMarkerHeight = markerHeight;\n\n    #endif\n\n    #ifdef HAS_MARKER_DX\n\n        float myMarkerDx = aDxDy.x;\n\n    #else\n\n        float myMarkerDx = markerDx;\n\n    #endif\n\n    #ifdef HAS_MARKER_DY\n\n        float myMarkerDy = aDxDy.y;\n\n    #else\n\n        float myMarkerDy = markerDy;\n\n    #endif\n\n    float isText = mod(aShape.z, 2.0);\n\n    float isPitchWithMap;\n\n    if (isText > 0.5) {\n\n        #ifdef HAS_TEXT_PITCH_ALIGN\n\n            isPitchWithMap = aPitchAlign.y;\n\n        #else\n\n            isPitchWithMap = textPitchWithMap;\n\n        #endif\n\n    } else {\n\n        #ifdef HAS_MARKER_PITCH_ALIGN\n\n            isPitchWithMap = aPitchAlign.x;\n\n        #else\n\n            isPitchWithMap = markerPitchWithMap;\n\n        #endif\n\n    }\n\n\n\n    float isRotateWithMap;\n\n    if (isText > 0.5) {\n\n        #ifdef HAS_TEXT_ROTATION_ALIGN\n\n            isRotateWithMap = aRotationAlign.y;\n\n        #else\n\n            isRotateWithMap = textRotateWithMap;\n\n        #endif\n\n    } else {\n\n        #ifdef HAS_MARKER_ROTATION_ALIGN\n\n            isRotateWithMap = aRotationAlign.x;\n\n        #else\n\n            isRotateWithMap = markerRotateWithMap;\n\n        #endif\n\n    }\n\n\n\n    gl_Position = projViewModelMatrix * positionMatrix * vec4(position, 1.0);\n\n    float projDistance = gl_Position.w;\n\n\n\n    float perspectiveRatio;\n\n    if (isRenderingTerrain == 1.0 && isPitchWithMap == 1.0) {\n\n        perspectiveRatio = 1.0;\n\n    } else {\n\n        float distanceRatio = (1.0 - cameraToCenterDistance / projDistance) * markerPerspectiveRatio;\n\n        perspectiveRatio = clamp(\n\n            0.5 + 0.5 * (1.0 - distanceRatio),\n\n            0.0,            4.0);\n\n    }\n\n    float rotation;\n\n    if (isText > 0.5) {\n\n        #ifdef HAS_TEXT_ROTATION\n\n            rotation = -aRotation.y / 9362.0 - mapRotation * isRotateWithMap;\n\n        #else\n\n            rotation = -textRotation - mapRotation * isRotateWithMap;\n\n        #endif\n\n    } else {\n\n        #ifdef HAS_MARKER_ROTATION\n\n            rotation = -aRotation.x / 9362.0 - mapRotation * isRotateWithMap;\n\n        #else\n\n            rotation = -markerRotation - mapRotation * isRotateWithMap;\n\n        #endif\n\n    }\n\n\n\n    if (isPitchWithMap == 1.0) {\n\n        #ifdef REVERSE_MAP_ROTATION_ON_PITCH\n\n            rotation += mapRotation;\n\n        #else\n\n            if (isText > 0.5) {\n\n                rotation -= mapRotation;\n\n            } else {\n\n                rotation += mapRotation;\n\n            }\n\n        #endif\n\n    }\n\n    float angleSin = sin(rotation);\n\n    float angleCos = cos(rotation);\n\n\n\n    mat2 shapeMatrix = mat2(angleCos, -1.0 * angleSin, angleSin, angleCos);\n\n\n\n    vec2 shape = (aShape.xy / 10.0);\n\n    if (isPitchWithMap == 1.0 && flipY == 0.0) {\n\n        shape *= vec2(1.0, -1.0);\n\n    }\n\n    vIsText = isText;\n\n    if (isText > 0.5) {\n\n        shape = shape / glyphSize * myTextSize;\n\n    } else {\n\n\n\n        #ifdef HAS_PAD_OFFSET\n\n            float padOffsetX = aPadOffset.x - 1.0;\n\n            float padOffsetY = aPadOffset.y;\n\n        #else\n\n            float padOffsetX = 0.0;\n\n            float padOffsetY = 0.0;\n\n        #endif\n\n        shape = (shape / iconSize * vec2(myMarkerWidth, myMarkerHeight) + vec2(padOffsetX, padOffsetY)) * layerScale;\n\n    }\n\n\n\n\n\n    shape = shapeMatrix * shape;\n\n\n\n    float cameraScale;\n\n    if (isRenderingTerrain == 1.0) {\n\n        cameraScale = 1.0;\n\n    } else {\n\n        cameraScale = projDistance / cameraToCenterDistance;\n\n    }\n\n\n\n    if (isPitchWithMap == 0.0) {\n\n        vec2 offset = shape * 2.0 / canvasSize;\n\n        gl_Position.xy += offset * perspectiveRatio * projDistance;\n\n    } else if (isText > 0.5) {\n\n        float offsetScale;\n\n        if (isRenderingTerrain == 1.0) {\n\n            offsetScale = tileRatio / zoomScale;\n\n        } else {\n\n            offsetScale = tileRatio / zoomScale * cameraScale * perspectiveRatio;\n\n        }\n\n        vec2 offset = shape;\n\n        gl_Position = projViewModelMatrix * positionMatrix * vec4(position + vec3(offset, 0.0) * offsetScale, 1.0);\n\n    } else {\n\n        vec2 offset = shape;\n\n        gl_Position = projViewModelMatrix * positionMatrix * vec4(position + vec3(offset, 0.0) * tileRatio / zoomScale * cameraScale * perspectiveRatio, 1.0);\n\n    }\n\n\n\n    if (isText > 0.5) {\n\n        gl_Position.xy += vec2(myTextDx, -myTextDy) * 2.0 / canvasSize * projDistance;\n\n    } else {\n\n        gl_Position.xy += vec2(myMarkerDx, -myMarkerDy) * 2.0 / canvasSize * projDistance;;\n\n    }\n\n\n\n    #ifndef PICKING_MODE\n\n        if (isPitchWithMap == 0.0) {\n\n            vGammaScale = mix(1.0, cameraScale, textPerspectiveRatio);\n\n        } else {\n\n            vGammaScale = cameraScale + mapPitch / 4.0;\n\n        }\n\n        vGammaScale = clamp(vGammaScale, 0.0, 1.0);\n\n\n\n        vec2 texCoord = floor(aShape.zw / 2.0);\n\n        if (isText > 0.5) {\n\n            vTexCoord = texCoord / glyphTexSize;\n\n        } else {\n\n            vTexCoord = texCoord / iconTexSize;\n\n        }\n\n\n\n        vHalo = mod(aShape.w, 2.0);\n\n        vTextSize = myTextSize;\n\n        #ifdef ENABLE_COLLISION\n\n            vOpacity = aOpacity / 255.0;\n\n        #else\n\n            vOpacity = 1.0;\n\n        #endif\n\n\n\n        #ifdef HAS_OPACITY\n\n            if (isText > 0.5) {\n\n                vOpacity *= aColorOpacity.y / 255.0;\n\n            } else {\n\n                vOpacity *= aColorOpacity.x / 255.0;\n\n            }\n\n        #endif\n\n\n\n        #ifdef HAS_TEXT_FILL\n\n            vTextFill = aTextFill / 255.0;\n\n        #endif\n\n\n\n        #ifdef HAS_TEXT_HALO_FILL\n\n            vTextHaloFill = aTextHaloFill / 255.0;\n\n        #endif\n\n\n\n        #if defined(HAS_TEXT_HALO_RADIUS) || defined(HAS_TEXT_HALO_OPACITY)\n\n            vTextHalo = aTextHalo;\n\n        #endif\n\n\n\n        highlight_setVarying();\n\n    #else\n\n        #ifdef ENABLE_COLLISION\n\n            bool visible = aOpacity == 255.0;\n\n        #else\n\n            bool visible = true;\n\n        #endif\n\n\n\n        fbo_picking_setData(gl_Position.w, visible);\n\n    #endif\n\n}\n\n",bB="#define RAD 0.0174532925\nstruct MarkerUniforms {\n    positionMatrix: mat4x4f,\n    projViewModelMatrix: mat4x4f,\n    textSize: f32,\n    markerDx: f32,\n    markerDy: f32,\n    textDx: f32,\n    textDy: f32,\n    markerWidth: f32,\n    markerHeight: f32,\n    markerPitchWithMap: f32,\n    textPitchWithMap: f32,\n    markerRotateWithMap: f32,\n    textRotateWithMap: f32,\n    markerRotation: f32,\n    textRotation: f32,\n    flipY: f32,\n    textPerspectiveRatio: f32,\n    markerPerspectiveRatio: f32,\n    iconTexSize: vec2f,\n    glyphTexSize: vec2f,\n    tileRatio: f32,\n    zoomScale: f32\n}\nstruct ShaderUniforms {\n    cameraToCenterDistance: f32,\n    glyphSize: f32,\n    iconSize: vec2f,\n    canvasSize: vec2f,\n    layerScale: f32,\n    isRenderingTerrain: f32,\n    mapPitch: f32,\n    mapRotation: f32\n}\n@group(0) @binding($b) var<uniform> uniforms: MarkerUniforms;\n@group(0) @binding($b) var<uniform> shaderUniforms: ShaderUniforms;\nstruct VertexInput {\n#ifdef HAS_ALTITUDE\n    @location($i) aPosition: vec2f,\n    @location($i) aAltitude: f32,\n#else\n    @location($i) aPosition: vec3f,\n#endif\n    @location($i) aShape: vec4i,\n#ifdef ENABLE_COLLISION\n    @location($i) aOpacity: u32,\n#endif\n#ifdef HAS_OPACITY\n    @location($i) aColorOpacity: vec2u,\n#endif\n#ifdef HAS_TEXT_SIZE\n    @location($i) aTextSize: u32,\n#endif\n#if HAS_TEXT_DX || HAS_TEXT_DY || HAS_MARKER_DX || HAS_MARKER_DY\n    @location($i) aDxDy: vec4i,\n#endif\n#ifdef HAS_MARKER_WIDTH\n    @location($i) aMarkerWidth: u32,\n#endif\n#ifdef HAS_MARKER_HEIGHT\n    @location($i) aMarkerHeight: u32,\n#endif\n#if HAS_MARKER_PITCH_ALIGN || HAS_TEXT_PITCH_ALIGN\n    @location($i) aPitchAlign: vec2u,\n#endif\n#if HAS_MARKER_ROTATION_ALIGN || HAS_TEXT_ROTATION_ALIGN\n    @location($i) aRotationAlign: vec2u,\n#endif\n#if HAS_MARKER_ROTATION || HAS_TEXT_ROTATION\n    @location($i) aRotation: vec2u,\n#endif\n#ifdef HAS_PAD_OFFSET\n    @location($i) aPadOffset: vec2f,\n#endif\n#ifdef HAS_TEXT_FILL\n    @location($i) aTextFill: vec4u,\n#endif\n#ifdef HAS_TEXT_HALO_FILL\n    @location($i) aTextHaloFill: vec4u,\n#endif\n#if HAS_TEXT_HALO_RADIUS || HAS_TEXT_HALO_OPACITY\n    @location($i) aTextHalo: vec2u,\n#endif\n};\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n#ifndef PICKING_MODE\n    @location($o) vTexCoord: vec2f,\n    @location($o) vOpacity: f32,\n    @location($o) vGammaScale: f32,\n    @location($o) vTextSize: f32,\n    @location($o) vHalo: f32,\n    @location($o) vIsText: f32,\n    #ifdef HAS_TEXT_FILL\n        @location($o) vTextFill: vec4f,\n    #endif\n    #ifdef HAS_TEXT_HALO_FILL\n        @location($o) vTextHaloFill: vec4f,\n    #endif\n    #if HAS_TEXT_HALO_RADIUS || HAS_TEXT_HALO_OPACITY\n        @location($o) vTextHalo: vec2f,\n    #endif\n#endif\n};\n#include <vt_position_vert>\n#ifndef PICKING_MODE\n#include <highlight_vert>\n#else\n#include <fbo_picking_vert>\n#endif\n@vertex\nfn main(vertexInput: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n    var position = unpackVTPosition(vertexInput);\n#ifdef HAS_TEXT_SIZE\n    var myTextSize = f32(vertexInput.aTextSize) * shaderUniforms.layerScale;\n#else\n    var myTextSize = uniforms.textSize * shaderUniforms.layerScale;\n#endif\n#ifdef HAS_TEXT_DX\n    var myTextDx = f32(vertexInput.aDxDy.z);\n#else\n    var myTextDx = uniforms.textDx;\n#endif\n#ifdef HAS_TEXT_DY\n    var myTextDy = f32(vertexInput.aDxDy.w);\n#else\n    var myTextDy = uniforms.textDy;\n#endif\n#ifdef HAS_MARKER_WIDTH\n    var myMarkerWidth = f32(vertexInput.aMarkerWidth);\n#else\n    var myMarkerWidth = uniforms.markerWidth;\n#endif\n#ifdef HAS_MARKER_HEIGHT\n    var myMarkerHeight = f32(vertexInput.aMarkerHeight);\n#else\n    var myMarkerHeight = uniforms.markerHeight;\n#endif\n#ifdef HAS_MARKER_DX\n    var myMarkerDx = f32(vertexInput.aDxDy.x);\n#else\n    var myMarkerDx = uniforms.markerDx;\n#endif\n#ifdef HAS_MARKER_DY\n    var myMarkerDy = f32(vertexInput.aDxDy.y);\n#else\n    var myMarkerDy = uniforms.markerDy;\n#endif\n    var isText = f32(vertexInput.aShape.z) % 2.0;\n    var isPitchWithMap: f32;\n    if (isText > 0.5) {\n#ifdef HAS_TEXT_PITCH_ALIGN\n        isPitchWithMap = f32(vertexInput.aPitchAlign.y);\n#else\n        isPitchWithMap = uniforms.textPitchWithMap;\n#endif\n    } else {\n#ifdef HAS_MARKER_PITCH_ALIGN\n        isPitchWithMap = f32(vertexInput.aPitchAlign.x);\n#else\n        isPitchWithMap = uniforms.markerPitchWithMap;\n#endif\n    }\n    var isRotateWithMap: f32;\n    if (isText > 0.5) {\n#ifdef HAS_TEXT_ROTATION_ALIGN\n        isRotateWithMap = f32(vertexInput.aRotationAlign.y);\n#else\n        isRotateWithMap = uniforms.textRotateWithMap;\n#endif\n    } else {\n#ifdef HAS_MARKER_ROTATION_ALIGN\n        isRotateWithMap = f32(vertexInput.aRotationAlign.x);\n#else\n        isRotateWithMap = uniforms.markerRotateWithMap;\n#endif\n    }\n    let positionMatrix = uniforms.positionMatrix;\n    let projViewModelMatrix = uniforms.projViewModelMatrix;\n    output.position = projViewModelMatrix * positionMatrix * vec4f(position, 1.0);\n    var projDistance = output.position.w;\n    var perspectiveRatio: f32;\n    if (shaderUniforms.isRenderingTerrain == 1.0 && isPitchWithMap == 1.0) {\n        perspectiveRatio = 1.0;\n    } else {\n        var distanceRatio = (1.0 - shaderUniforms.cameraToCenterDistance / projDistance) * uniforms.markerPerspectiveRatio;\n        perspectiveRatio = clamp(\n            0.5 + 0.5 * (1.0 - distanceRatio),\n            0.0,\n            4.0);\n    }\n    var rotation: f32;\n    let mapRotation = shaderUniforms.mapRotation;\n    if (isText > 0.5) {\n#ifdef HAS_TEXT_ROTATION\n        rotation = -f32(vertexInput.aRotation.y) / 9362.0 - mapRotation * isRotateWithMap;\n#else\n        rotation = -uniforms.textRotation - mapRotation * isRotateWithMap;\n#endif\n    } else {\n#ifdef HAS_MARKER_ROTATION\n        rotation = -f32(vertexInput.aRotation.x) / 9362.0 - mapRotation * isRotateWithMap;\n#else\n        rotation = -uniforms.markerRotation - mapRotation * isRotateWithMap;\n#endif\n    }\n    if (isPitchWithMap == 1.0) {\n#ifdef REVERSE_MAP_ROTATION_ON_PITCH\n        rotation += mapRotation;\n#else\n        if (isText > 0.5) {\n            rotation -= mapRotation;\n        } else {\n            rotation += mapRotation;\n        }\n#endif\n    }\n    var angleSin = sin(rotation);\n    var angleCos = cos(rotation);\n    var shapeMatrix = mat2x2f(angleCos, -1.0 * angleSin, angleSin, angleCos);\n    var shape = vec2f(vertexInput.aShape.xy) / 10.0;\n    if (isPitchWithMap == 1.0 && uniforms.flipY == 0.0) {\n        shape *= vec2f(1.0, -1.0);\n    }\n    if (isText > 0.5) {\n        shape = shape / shaderUniforms.glyphSize * myTextSize;\n    } else {\n#ifdef HAS_PAD_OFFSET\n        var padOffsetX = vertexInput.aPadOffset.x - 1.0;\n        var padOffsetY = vertexInput.aPadOffset.y;\n#else\n        var padOffsetX = 0.0;\n        var padOffsetY = 0.0;\n#endif\n        shape = (shape / shaderUniforms.iconSize * vec2f(myMarkerWidth, myMarkerHeight) + vec2f(padOffsetX, padOffsetY)) * shaderUniforms.layerScale;\n    }\n    shape = shapeMatrix * shape;\n    var cameraScale: f32;\n    if (shaderUniforms.isRenderingTerrain == 1.0) {\n        cameraScale = 1.0;\n    } else {\n        cameraScale = projDistance / shaderUniforms.cameraToCenterDistance;\n    }\n    let canvasSize = shaderUniforms.canvasSize;\n    if (isPitchWithMap == 0.0) {\n        var offset = shape * 2.0 / canvasSize;\n        output.position.x += offset.x * perspectiveRatio * projDistance;\n        output.position.y += offset.y * perspectiveRatio * projDistance;\n    } else if (isText > 0.5) {\n        var offsetScale: f32;\n        if (shaderUniforms.isRenderingTerrain == 1.0) {\n            offsetScale = uniforms.tileRatio / uniforms.zoomScale;\n        } else {\n            offsetScale = uniforms.tileRatio / uniforms.zoomScale * cameraScale * perspectiveRatio;\n        }\n        var offset = shape;\n        output.position = projViewModelMatrix * positionMatrix * vec4f(position + vec3f(offset, 0.0) * offsetScale, 1.0);\n    } else {\n        var offset = shape;\n        output.position = projViewModelMatrix * positionMatrix * vec4f(position + vec3f(offset, 0.0) * uniforms.tileRatio / uniforms.zoomScale * cameraScale * perspectiveRatio, 1.0);\n    }\n    if (isText > 0.5) {\n        output.position.x += myTextDx * 2.0 / canvasSize.x * projDistance;\n        output.position.y += -myTextDy * 2.0 / canvasSize.y * projDistance;\n    } else {\n        output.position.x += myMarkerDx * 2.0 / canvasSize.x * projDistance;\n        output.position.y += -myMarkerDy * 2.0 / canvasSize.y * projDistance;\n    }\n#ifndef PICKING_MODE\n    output.vIsText = isText;\n    if (isPitchWithMap == 0.0) {\n        output.vGammaScale = mix(1.0, cameraScale, uniforms.textPerspectiveRatio);\n    } else {\n        output.vGammaScale = cameraScale + shaderUniforms.mapPitch / 4.0;\n    }\n    output.vGammaScale = clamp(output.vGammaScale, 0.0, 1.0);\n    var texCoord = floor(vec2f(vertexInput.aShape.zw) / 2.0);\n    if (isText > 0.5) {\n        output.vTexCoord = texCoord / uniforms.glyphTexSize;\n    } else {\n        output.vTexCoord = texCoord / uniforms.iconTexSize;\n    }\n    output.vHalo = f32(vertexInput.aShape.w) % 2.0;\n    output.vTextSize = myTextSize;\n#ifdef ENABLE_COLLISION\n    output.vOpacity = vertexInput.aOpacity / 255.0;\n#else\n    output.vOpacity = 1.0;\n#endif\n#ifdef HAS_OPACITY\n    if (isText > 0.5) {\n        output.vOpacity *= f32(vertexInput.aColorOpacity.y) / 255.0;\n    } else {\n        output.vOpacity *= f32(vertexInput.aColorOpacity.x) / 255.0;\n    }\n#endif\n#ifdef HAS_TEXT_FILL\n    output.vTextFill = vec4f(vertexInput.aTextFill) / 255.0;\n#endif\n#ifdef HAS_TEXT_HALO_FILL\n    output.vTextHaloFill =  vec4f(vertexInput.aTextHaloFill) / 255.0;\n#endif\n#if HAS_TEXT_HALO_RADIUS || HAS_TEXT_HALO_OPACITY\n    output.vTextHalo = vec2f(vertexInput.aTextHalo);\n#endif\n#if HAS_HIGHLIGHT_COLOR || HAS_HIGHLIGHT_OPACITY\n    highlight_setVarying(vertexInput, output);\n#endif\n#else\n#ifdef ENABLE_COLLISION\n    var visible = f32(vertexInput.aOpacity) == 255.0;\n#else\n    var visible = true;\n#endif\n    fbo_picking_setData(vertexInput, &output, output.position.w, visible);\n#endif\n    return output;\n}";const wB=[],TB=[],SB=[],MB=[],CB=[],PB=[];function IB(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re){const{tileRatio:Be,tileResolution:Ge}=H,je=Be/(Ge/W.getResolution())*(q/W.cameraToCenterDistance)*$;W_(m,m,je),W_(_,_,je),W_(b,b,je),W_(T,T,je),qA(wB,m[0],m[1],ye?m[2]/Re:0),qA(TB,_[0],_[1],ye?_[2]/Re:0),qA(SB,b[0],b[1],ye?b[2]/Re:0),qA(MB,T[0],T[1],ye?T[2]/Re:0),XA(wB,wB,g),XA(TB,TB,g),XA(SB,SB,g),XA(MB,MB,g),KN(m,wB,P,W.width,W.height),KN(_,TB,P,W.width,W.height),KN(b,SB,P,W.width,W.height),KN(T,MB,P,W.width,W.height),z_(CB,Math.min(m[0],_[0],b[0],T[0]),Math.min(m[1],_[1],b[1],T[1])),z_(PB,Math.max(m[0],_[0],b[0],T[0]),Math.max(m[1],_[1],b[1],T[1])),wy(i,CB[0]+I[0],CB[1]+I[1],PB[0]+I[0],PB[1]+I[1])}function kB(i,g,m,_,b,T,P,I){1!==I&&(W_(m,m,I),W_(_,_,I),W_(b,b,I),W_(T,T,I)),z_(CB,Math.min(m[0],_[0],b[0],T[0]),Math.min(m[1],_[1],b[1],T[1])),z_(PB,Math.max(m[0],_[0],b[0],T[0]),Math.max(m[1],_[1],b[1],T[1])),wy(i,g[0]+CB[0]+P[0],g[1]+CB[1]-P[1],g[0]+PB[0]+P[0],g[1]+PB[1]-P[1])}function OB(i,g,m,_,b){g-=m*_,1===b&&(g+=m);const T=Math.sin(g),P=Math.cos(g);return Qm(i,P,-T,T,P)}const EB=2048,RB=.01,LB=[],DB=[],FB=[],NB=[],HB=[],BB=[],zB=[],VB=[],UB=[1,-1],GB=[1,1];function jB(i,g,m,_,b){const T=g.material.uniforms,P=b.cameraToCenterDistance,I=g.geometry.properties,H=this.getSymbol(I.symbolIndex),W=g.geometry.desc.positionSize,q=I.aAnchor,$=qA(LB,q[m*W],q[m*W+1],2===W?0:q[m*W+2]),{aTerrainAltitude:ye}=I;if(ye){const i=100*ye[2*m];i&&($[2]+=i)}let Re=KN(DB,$,_,b.width,b.height);const Be=Re[2];let Ge=1;if(T.markerPerspectiveRatio){Ge=HF(.5+.5*(1-(1-P/Be)*T.markerPerspectiveRatio),0,4)}const{aShape:je,aMarkerDx:Xe,aMarkerDy:Ze,aMarkerWidth:Ye,aMarkerHeight:Qe,aPitchAlign:Je,aRotationAlign:Ke,aRotation:et}=I,tt=Je?Je[2*m]:T.markerPitchWithMap,at=Ke?Ke[2*m]:T.markerRotateWithMap,ht=z_(VB,(Xe?Xe[m]:H.markerDx)||0,-((Ze?Ze[m]:H.markerDy)||0));let gt=z_(NB,je[2*m]/10,je[2*m+1]/10),yt=z_(HB,je[2*m+2]/10,je[2*m+3]/10),vt=z_(BB,je[2*m+4]/10,je[2*m+5]/10),xt=z_(zB,je[2*m+6]/10,je[2*m+7]/10);0===T.flipY&&1===tt&&(G_(gt,gt,UB),G_(yt,yt,UB),G_(vt,vt,UB),G_(xt,xt,UB));const[bt,Tt]=PH(g.geometry);let Mt=Ye?Ye[m]:H.markerWidth;zF(Mt)&&(Mt=bt||15);let Pt=Qe?Qe[m]:H.markerHeight;zF(Pt)&&(Pt=Tt||15);const It=z_(GB,Mt/EB,Pt/EB);let Et;tv(gt,gt,It),tv(yt,yt,It),tv(vt,vt,It),tv(xt,xt,It),Et=et?et[2*m]/9362:-(H.markerRotation||0)*Math.PI/180;const Lt=-Et,Dt=b.getBearing()*Math.PI/180;if(Dt*at||Lt){const i=OB(FB,Lt,Dt,at,tt);gt=Y_(gt,gt,i),yt=Y_(yt,yt,i),vt=Y_(vt,vt,i),xt=Y_(xt,xt,i)}1===tt?IB(i,$,gt,yt,vt,xt,_,ht,T,b,Be,Ge):(G_(gt,gt,UB),G_(yt,yt,UB),G_(vt,vt,UB),G_(xt,xt,UB),kB(i,Re,gt,yt,vt,xt,ht,Ge));const Ft=this.getMap().getDevicePixelRatio();return 1!==Ft&&(i[0]*=Ft,i[1]*=Ft,i[2]*=Ft,i[3]*=Ft),i}const{PackUtil:WB}=JD(),qB=[],XB=[],ZB=[],$B=[],YB=[],QB=[],JB=[1,-1];function KB(i,g,m,_,b,T,P,I,H){const W=_.material.uniforms,q=H.cameraToCenterDistance,$=_.geometry.properties,ye=this.getSymbol($.symbolIndex),Re="line"===ye.textPlacement&&!$F(ye),Be=m[2];let Ge=1;if(W.textPerspectiveRatio){Ge=HF(.5+.5*(1-(1-q/Be)*W.textPerspectiveRatio),0,4)}const{aTextDx:je,aTextDy:Xe,aPitchAlign:Ze,aRotationAlign:Ye,aRotation:Qe,aType:Je,aDxDy:Ke}=_.geometry.properties;let et,tt,at;Ke?(et=Ke[4*P+2],tt=Ke[4*P+3]):(et=je?je[P]:ye.textDx,tt=Xe?Xe[P]:ye.textDy),Ze&&(at=Je?Ze[2*P+1]:Ze[P]);const ht=Ze?at:W.textPitchWithMap;let gt;Ye&&(gt=Je?Ye[2*P+1]:Ye[P]);const yt=Ye?gt:W.textRotateWithMap,vt=z_(QB,et||0,-(tt||0));if(Re){const{aOffset:_,aShape:b}=$,T=_.length!==b.length;let q,ye,Re,je;if(T?(q=qA(XB,_[3*P]/10,_[3*P+1]/10,_[3*P+2]/10),ye=qA(ZB,_[3*P+3]/10,_[3*P+4]/10,_[3*P+5]/10),Re=qA($B,_[3*P+6]/10,_[3*P+7]/10,_[3*P+8]/10),je=qA(YB,_[3*P+9]/10,_[3*P+10]/10,_[3*P+11]/10)):(q=z_(XB,_[2*P]/10,_[2*P+1]/10),ye=z_(ZB,_[2*P+2]/10,_[2*P+3]/10),Re=z_($B,_[2*P+4]/10,_[2*P+5]/10),je=z_(YB,_[2*P+6]/10,_[2*P+7]/10)),1===ht){const m=dF(H.getResolution(),H);IB(i,g,q,ye,Re,je,I,vt,W,H,Be,Ge,T,m)}else G_(q,q,JB),G_(ye,ye,JB),G_(Re,Re,JB),G_(je,je,JB),kB(i,m,q,ye,Re,je,vt,Ge)}else{const{aShape:_}=$;let T,q=z_(XB,_[2*P]/10,-_[2*P+1]/10),je=z_(ZB,_[2*P+2]/10,-_[2*P+3]/10),Xe=z_($B,_[2*P+4]/10,-_[2*P+5]/10),Ze=z_(YB,_[2*P+6]/10,-_[2*P+7]/10);0===W.flipY&&1===ht&&(G_(q,q,JB),G_(je,je,JB),G_(Xe,Xe,JB),G_(Ze,Ze,JB)),T=Qe?Je&&Qe.length>Je.length?Qe[2*P+1]/9362:Qe[P]/9362:(ye.textRotation||0)*Math.PI/180;const Ye=Re?0:H.getBearing()*Math.PI/180;if(T||Ye){const i=OB(qB,T,Ye,yt,ht);q=Y_(q,q,i),je=Y_(je,je,i),Xe=Y_(Xe,Xe,i),Ze=Y_(Ze,Ze,i)}const Ke=b/24;W_(q,q,Ke),W_(je,je,Ke),W_(Xe,Xe,Ke),W_(Ze,Ze,Ke),1===ht?IB(i,g,q,je,Xe,Ze,I,vt,W,H,Be,Ge):kB(i,m,q,je,Xe,Ze,vt,Ge)}i[0]-=(T=T||0)+1,i[1]-=T+1,i[2]+=T+1,i[3]+=T+1;const xt=this.getMap().getDevicePixelRatio();return 1!==xt&&(i[0]*=xt,i[1]*=xt,i[2]*=xt,i[3]*=xt),i}function ez(i,g,m){const _=g.geometry.desc.positionSize,{aAnchor:b,aAltitude:T,aTerrainAltitude:P}=g.geometry.properties,I=m*_;if(T?qA(i,b[I],b[I+1],T[m]):3===_?WB.unpackPosition(i,b[I],b[I+1],b[I+2]):qA(i,b[I],b[I+1],0),P){const g=100*P[2*m];g&&(i[2]+=g)}return i}const tz={textFill:[0,0,0,1],textOpacity:1,textPitchAlignment:0,textRotationAlignment:0,textHaloRadius:0,textHaloFill:[1,1,1,1],textHaloBlur:0,textHaloOpacity:1,textPerspectiveRatio:0,textSize:14,textDx:0,textDy:0,textRotation:0};function nz(i,g,m,_,b,T,P,I,H){const W=[];if(g.isDisposed()||0===g.data.aPosition.length)return W;const q=g.properties.glyphAtlas;if(!q)return W;if(0===_.textSize||0===_.textOpacity)return W;iz.call(this,g,_,T,P,I,H);const $=oz.call(this,{},i,g,b);let ye=!1;b.textOpacity<1&&(ye=!0),g.properties.memorySize=g.getMemorySize(),g.generateBuffers(i,{excludeElementsInVAO:!0});const Re=new wP.Material($,tz),Be=new wP.Mesh(g,Re,{disableVAO:!0,transparent:ye,castShadow:!1,picking:!0});if(Be.setLocalTransform(m),Be.setUniform("alphaTest",RB),$.isHalo&&(Be.properties.isHalo=!0),P&&Be.setDefines({ENABLE_COLLISION:1}),W.push(Be),$.isHalo){const i=rz.call(this,g,b,$.glyphTex,q,P,m);i.properties.haloMesh=Be,W.push(i)}return W.forEach((i=>{const m=i.defines||{};sz.call(this,m,i),i.setDefines(m),i.properties.symbolIndex=g.properties.symbolIndex})),W}function rz(i,g,m,_,b,T){let P=!1;g.textOpacity<1&&(P=!0);const I={flipY:0,tileResolution:i.properties.tileResolution,tileRatio:i.properties.tileRatio,glyphTex:m,glyphTexSize:[_.width,_.height],isHalo:0};lz(i,I,g);const H=new wP.Material(I,tz),W=new wP.Mesh(i,H,{disableVAO:!0,transparent:P,castShadow:!1,picking:!0});return W.setUniform("alphaTest",RB),Object.defineProperty(W.properties,"textSize",{enumerable:!0,get:function(){return I.textSize}}),b&&W.setDefines({ENABLE_COLLISION:1}),W.setLocalTransform(T),W}function iz(i,g,m,_,b,T){FN(i,g,m,this.layer);const P=i.properties;if(!P.textInitialized){az.call(this,i,_||T,b),P.textInitialized=!0;const{aTextSize:g,aTextDx:m,aTextDy:I,aPitchAlign:H,aRotationAlign:W,aRotation:q,aOverlap:$,aAltitude:ye}=i.data;if(g){const i=(LN+"aTextSize").trim();P.aTextSize=P[i]||new g.constructor(g)}if(m){const i=(LN+"aTextDx").trim();P.aTextDx=P[i]||new m.constructor(m)}if(I){const i=(LN+"aTextDy").trim();P.aTextDy=P[i]||new I.constructor(I)}if(H){const i=(LN+"aPitchAlign").trim();P.aPitchAlign=P[i]||new H.constructor(H)}if(W){const i=(LN+"aRotationAlign").trim();P.aRotationAlign=P[i]||new W.constructor(W)}if(q){const i=(LN+"aRotation").trim();P.aRotation=P[i]||new q.constructor(q)}if($){const i=(LN+"aOverlap").trim();P.aOverlap=P[i]||new $.constructor($)}if(ye){const i=(LN+"aAltitude").trim();P.aAltitude=P[i]||new ye.constructor(ye)}}}function oz(i,g,m,_){const b=m.properties.glyphAtlas,T=b&&SH(g,b,!1)||g.texture(2);return NF(i=i||{},{flipY:0,tileResolution:m.properties.tileResolution,tileRatio:m.properties.tileRatio,glyphTex:T,glyphTexSize:[T&&T.width||0,T&&T.height||0]}),lz(m,i,_),i}function sz(i,g){const m=g.geometry;m.data.aTextFill&&(i.HAS_TEXT_FILL=1),m.data.aTextSize&&(i.HAS_TEXT_SIZE=1),m.data.aColorOpacity&&(i.HAS_OPACITY=1),m.data.aTextHaloFill&&g.material.uniforms.isHalo&&(i.HAS_TEXT_HALO_FILL=1);const _=this.getSymbolDef(m.properties.symbolIndex);XN(_.textHaloRadius)&&g.material.uniforms.isHalo&&(i.HAS_TEXT_HALO_RADIUS=1),XN(_.textHaloOpacity)&&g.material.uniforms.isHalo&&(i.HAS_TEXT_HALO_OPACITY=1),XN(_.textDx)&&(i.HAS_TEXT_DX=1),XN(_.textDy)&&(i.HAS_TEXT_DY=1),m.data.aPitchAlign&&(i.HAS_PITCH_ALIGN=1),XN(_.textRotationAlignment)&&(i.HAS_TEXT_ROTATION_ALIGN=1),m.data.aRotation&&(i.HAS_TEXT_ROTATION=1),m.data.aAltitude&&(i.HAS_ALTITUDE=1),m.properties.aOffset&&m.properties.aShape&&m.properties.aOffset.length!==m.properties.aShape.length&&(i.HAS_OFFSET_Z=1)}function az(i,g,m){const _=i.properties,b=this.getSymbol(_.symbolIndex),T="line"===_.textPlacement&&!$F(b),{aPosition:P,aShape:I}=i.data,H=P.length/i.desc.positionSize;if(_.vertexCount=H,_.aPickingId=i.data.aPickingId,_.aCount||(_.aCount=i.data.aCount,delete i.data.aCount),g||T){let i=I;if(I.length===4*H){i=new I.constructor(2*H);for(let g=0;g<H;g++)i[2*g]=I[4*g],i[2*g+1]=I[4*g+1]}_.aAnchor=P,_.aShape=i}if(_.visElemts||(_.elements=i.elements,_.visElemts=new i.elements.constructor(i.elements.length)),T){const{aVertical:g,aSegment:m,aGlyphOffset:b,aPitchRotation:T}=i.data,P=!!T;_.aGlyphOffset=b,_.aPitchRotation=T,_.aSegment=m,_.aVertical=g,delete i.data.aSegment,delete i.data.aVertical,delete i.data.aGlyphOffset,delete i.data.aPitchRotation;const I=H*(P?3:2);i.data.aOffset={usage:"dynamic",data:new Int16Array(I)},_.aOffset=new Int16Array(I)}if(g){i.data.aOpacity={usage:"dynamic",data:new Uint8Array(H)},_.aOpacity=new Uint8Array(H),m&&(_.aOpacity.fill(255,0),i.data.aOpacity.data.fill(255,0));const{aTextHalo:g}=i.data;if(g&&!_.aTextHalo){const i=(LN+"aTextHalo").trim();_.aTextHalo=_[i]||new g.constructor(g)}}}function lz(i,g,m){void 0===g.isHalo&&(g.isHalo=1),UF(g,"textOpacity",m,"textOpacity",tz.textOpacity),UF(g,"textFill",m,"textFill",tz.textFill,WF()),UF(g,"textHaloFill",m,"textHaloFill",tz.textHaloFill,WF()),UF(g,"textHaloBlur",m,"textHaloBlur",tz.textHaloBlur),UF(g,"textHaloRadius",m,"textHaloRadius",tz.textHaloRadius),UF(g,"textHaloOpacity",m,"textHaloOpacity",tz.textHaloOpacity),UF(g,"textPerspectiveRatio",m,"textPerspectiveRatio",tz.textPerspectiveRatio,(g=>"line"===i.properties.textPlacement?1:g)),UF(g,"textRotateWithMap",m,"textRotationAlignment",tz.textRotationAlignment,(i=>+("map"===i))),UF(g,"textPitchWithMap",m,"textPitchAlignment",tz.textPitchAlignment,(i=>+("map"===i))),UF(g,"textSize",m,"textSize",tz.textSize),UF(g,"textDx",m,"textDx",tz.textDx),UF(g,"textDy",m,"textDy",tz.textDy),UF(g,"textRotation",m,"textRotation",tz.textRotation,(i=>i*Math.PI/180))}function hz(i){const g=[];return{uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,m){return _A(g,m.projViewMatrix,m.modelMatrix)}},{name:"zoomScale",type:"function",fn:function(i,g){return g.tileResolution/g.resolution}}],extraCommandProps:{viewport:{x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1},stencil:{enable:!0,mask:255,func:{cmp:"<=",ref:(i,g)=>g.stencilRef,mask:255},op:{fail:"keep",zfail:"keep",zpass:"replace"}},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},depth:{enable:!0,range:()=>this.sceneConfig.depthRange||[0,1],func:()=>this.sceneConfig.depthFunc||"always",mask:!1},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}}}}function cz(i,g){const m=SL(g.textFill),_=SL(g.textSize),b=SL(g.textHaloFill),T=SL(g.textHaloRadius),P=SL(g.textHaloOpacity),I=SL(g.textDx),H=SL(g.textDy),W=SL(g.textOpacity),q=ML(g.textPitchAlignment),$=ML(g.textRotationAlignment),ye=SL(g.textRotation),Re=ML(g.textAllowOverlapFn),Be=ML(g.textIgnorePlacement),Ge={},je=new Int16Array(1),Xe=new Uint16Array(1);return[{attrName:"aTextFill",symbolName:"textFill",define:"HAS_TEXT_FILL",type:Uint8Array,width:4,evaluate:(g,_)=>{let b=m(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,_,i,g,!0)),Array.isArray(b)||(b=Ge[b]=Ge[b]||iL(b).unitArray()),b=jF(b),b}},{attrName:"aTextSize",symbolName:"textSize",define:"HAS_TEXT_SIZE",type:Uint8Array,width:1,evaluate:(g,m)=>{let b=_(i.getZoom(),g)||tz.textSize;return wL(b)&&(b=this.evaluateInFnTypeConfig(b,m,i,g)),je[0]=b,je[0]}},{attrName:"aTextHaloFill",symbolName:"textHaloFill",define:"HAS_TEXT_HALO_FILL",type:Uint8Array,width:4,evaluate:g=>{let m=b(i.getZoom(),g);return Array.isArray(m)||(m=Ge[m]=Ge[m]||iL(m).unitArray()),m=jF(m),m}},{attrName:"aTextHalo",symbolName:"textHaloRadius",define:"HAS_TEXT_HALO_RADIUS",type:Uint8Array,index:0,width:2,evaluate:g=>{const m=T(i.getZoom(),g);return je[0]=m,je[0]}},{attrName:"aTextHalo",symbolName:"textHaloOpacity",define:"HAS_TEXT_HALO_OPACITY",type:Uint8Array,index:1,width:2,evaluate:g=>{const m=P(i.getZoom(),g);return je[0]=255*m,je[0]}},{attrName:"aTextDx",symbolName:"textDx",define:"HAS_TEXT_DX",type:Uint8Array,width:1,evaluate:(g,m)=>{let _=I(i.getZoom(),g);return wL(_)&&(_=this.evaluateInFnTypeConfig(_,m,i,g)),je[0]=_,je[0]}},{attrName:"aTextDy",symbolName:"textDy",define:"HAS_TEXT_DY",type:Uint8Array,width:1,evaluate:(g,m)=>{let _=H(i.getZoom(),g);return wL(_)&&(_=this.evaluateInFnTypeConfig(_,m,i,g)),je[0]=_,je[0]}},{attrName:"aColorOpacity",symbolName:"textOpacity",define:"HAS_OPACITY",type:Uint8Array,width:1,evaluate:(g,m)=>{let _=W(i.getZoom(),g);return wL(_)&&(_=this.evaluateInFnTypeConfig(_,m,i,g)),je[0]=255*_,je[0]}},{attrName:"aPitchAlign",symbolName:"textPitchAlignment",type:Uint8Array,width:1,define:"HAS_PITCH_ALIGN",evaluate:g=>+("map"===q(i.getZoom(),g))},{attrName:"aRotationAlign",symbolName:"textRotationAlignment",type:Uint8Array,width:1,define:"HAS_ROTATION_ALIGN",evaluate:g=>+("map"===$(i.getZoom(),g))},{attrName:"aRotation",symbolName:"textRotation",type:Uint16Array,width:1,define:"HAS_TEXT_ROTATION",evaluate:g=>{const m=BF(ye(i.getZoom(),g),0,360)*Math.PI/180;return Xe[0]=9362*m,Xe[0]}},{attrName:"aOverlap",symbolName:"textAllowOverlap",type:Uint8Array,width:1,evaluate:m=>{let _=Re(i.getZoom(),m)||0,b=(Be?Be(i.getZoom(),m):g.textIgnorePlacement)||0;return _=1<<3+4*_,b=(Be?2:0)+b,_+b}},{attrName:"aOverlap",symbolName:"textIgnorePlacement",type:Uint8Array,width:1,evaluate:m=>{let _=(Re?Re(i.getZoom(),m):g.textAllowOverlap)||0,b=Be(i.getZoom(),m)||0;return _=(Re?8:0)+4*_,b=1<<1+b,_+b}}]}const uz=[],fz=[],dz=[],pz=[];function gz(i,g,m,_,b,T,P){i=1===i?1:0;const I=this.getMap(),H=g.geometry.properties,W=this.getSymbol(H.symbolIndex),q="line"===H.textPlacement&&!$F(W),{aTextSize:$,aTextHalo:ye,aShape:Re}=H;let Be=$?$[m[b]]:W.textSize;null==Be&&(Be=tz.textSize);const Ge=ye?ye[2*m[b]]:g.properties.textHaloRadius,je=ez(dz,g,m[b]),{aProjectedAnchor:Xe}=g.geometry.properties;let Ze=pz;const Ye=3*m[b];Xe&&Xe[Ye]!==CF?(pz[0]=Xe[Ye],pz[1]=Xe[Ye+1],pz[2]=Xe[Ye+2]):Ze=KN(pz,je,P,I.width,I.height);const Qe=_,{boxes:Je,collision:Ke}=this._getCollideBoxes(g,b);let et=0;if(q||1===g.material.uniforms.textRotateWithMap||W.textRotation){let _=0;for(let T=b;T<b+6*Qe;T+=6){const b=Je[et]=Je[et]||[];et++;const H=KB.call(this,b,je,Ze,g,Be,Ge,m[T],P,I);if(!i){const g=this.isCollides(H);1===g?i=1:-1===g&&_++}}_===Qe&&(i=-1)}else{let _=m[b],H=Re[2*_+1];for(let W=b;W<T;W+=6){const b=Re[2*m[W]+1];if(H!==b||W===T-6){const q=m[W===T-6?W:W-6],$=KB.call(this,uz,je,Ze,g,Be,Ge,_,P,I),ye=KB.call(this,fz,je,Ze,g,Be,Ge,q,P,I),Re=Je[et]=Je[et]||[];et++,Re[0]=Math.min($[0],ye[0]),Re[1]=Math.min($[1],ye[1]),Re[2]=Math.max($[2],ye[2]),Re[3]=Math.max($[3],ye[3]),_=m[W],H=b,!i&&this.isCollides(Re)&&(i=1)}}}return Ke.collides=i,Ke}function mz(i,g){const m=function(i,g){const{aPickingId:m,features:_}=i.geometry.properties,b=m[g],T=_&&_[b]&&_[b].feature;return T&&T.label}(i,g);return m?function(i,g,m){if(!m)return null;const _=i.localTransform,b=ez(Az,i,g);wy(yz,b[0],b[1],b[2],1);const T=Fy(yz,yz,_);let P=0;for(const i of m)P+=i.codePointAt(0);return[Math.floor(T[0]),Math.floor(T[1]),Math.floor(T[2]),P]}(i,g,m):null}const Az=[],yz=[];const _z=new Uint16Array(1),vz=new Int8Array(1);function xz(i,g,m,_,b,T,P,I,H){if(g.isDisposed()||0===g.data.aPosition.length)return null;const W=!!g.properties.glyphAtlas;if(!!!g.properties.iconAtlas&&!W&&!g.properties.isEmpty)return null;
//!geometry.properties.aShape 以避免重复创建collision数据
if(!g.properties.aShape){const{aPosition:i,aShape:m}=g.data,_=g.data.aPosition.length/g.desc.positionSize,b=new Uint8Array(_);I&&b.fill(255,0),g.data.aOpacity={usage:"dynamic",data:b},g.properties.aOpacity=new Uint8Array(_),I&&g.properties.aOpacity.fill(255,0),g.properties.aAnchor=i;const T=m.length/4,P=new m.constructor(2*T);for(let i=0;i<T;i++)P[2*i]=m[4*i],P[2*i+1]=m[4*i+1];g.properties.aShape=P}g.properties.visElemts||(g.properties.elements=g.elements,g.properties.visElemts=new g.elements.constructor(g.elements.length)),W&&iz.call(this,g,_,T.text,P,I,H),g.properties.memorySize=g.getMemorySize(),g.generateBuffers(i,{excludeElementsInVAO:!0});const q={flipY:0,tileResolution:g.properties.tileResolution,tileRatio:g.properties.tileRatio};wz.call(this,q,i,g,b),oz.call(this,q,i,g,b),q.isHalo=0;const $=[],ye={disableVAO:!0,transparent:!0,castShadow:!1,picking:!0};let Re;if(W){const i=NF({},q);i.isHalo=1;const _=new wP.Material(i);Re=new wP.Mesh(g,_,ye),Re.properties.isHalo=1,Re.setUniform("alphaTest",RB),Re.setLocalTransform(m)}const Be=new wP.Material(q),Ge=new wP.Mesh(g,Be,ye);let je={HAS_HALO_ATTR:1};if(P&&(je.ENABLE_COLLISION=1),Tz.call(this,g,je),Re){const i=NF({},je);sz.call(this,je,Re),Re.setDefines(i)}return W&&sz.call(this,je,Ge),je=LH(i,je),Ge.setDefines(je),Ge.setUniform("alphaTest",RB),Ge.setLocalTransform(m),Ge.properties.symbolIndex=g.properties.symbolIndex,$.push(Ge),$}function bz(i){const{aMarkerDx:g,aMarkerDy:m,aTextDx:_,aTextDy:b}=i.data,T=_||b||g||m;if(T){const P=new T.constructor(4*T.length);for(let i=0;i<P.length;i+=4){const T=i/4;g&&(P[i]=g[T]),m&&(P[i+1]=m[T]),_&&(P[i+2]=_[T]),b&&(P[i+3]=b[T])}i.data.aDxDy=P,i.properties.aDxDy=P.slice(),g&&(i.properties.aMarkerDx=g),m&&(i.properties.aMarkerDy=m),_&&(i.properties.aTextDx=_),b&&(i.properties.aTextDy=b)}}function wz(i,g,m,_){const[b,T]=PH(m);UF(i,"markerOpacity",_,"markerOpacity",1),UF(i,"markerPerspectiveRatio",_,"markerPerspectiveRatio",_.markerTextFit?0:1),UF(i,"markerWidth",_,"markerWidth",b||15),UF(i,"markerHeight",_,"markerHeight",T||15),UF(i,"markerDx",_,"markerDx",0),UF(i,"markerDy",_,"markerDy",0),UF(i,"markerRotation",_,"markerRotation",0,(i=>i*Math.PI/180)),UF(i,"markerPitchWithMap",_,"markerPitchAlignment",0,(i=>"map"===i?1:0)),UF(i,"markerRotateWithMap",_,"markerRotationAlignment",0,(i=>"map"===i?1:0));const P=m.properties.iconAtlas;i.iconTex=P?SH(g,P,!1):this._emptyTexture,i.iconTexSize=P?[P.width,P.height]:[0,0]}function Tz(i,g){i.data.aAltitude&&(g.HAS_ALTITUDE=1),i.data.aMarkerWidth&&(g.HAS_MARKER_WIDTH=1),i.data.aMarkerHeight&&(g.HAS_MARKER_HEIGHT=1),i.data.aColorOpacity&&(g.HAS_OPACITY=1);const m=this.getSymbolDef(i.properties.symbolIndex);XN(m.markerDx)&&(g.HAS_MARKER_DX=1),XN(m.markerDy)&&(g.HAS_MARKER_DY=1),XN(m.textDx)&&(g.HAS_TEXT_DX=1),XN(m.textDy)&&(g.HAS_TEXT_DY=1),XN(m.markerPitchAlignment)&&(g.HAS_MARKER_PITCH_ALIGN=1),XN(m.textPitchAlignment)&&(g.HAS_TEXT_PITCH_ALIGN=1),XN(m.markerRotationAlignment)&&(g.HAS_MARKER_ROTATION_ALIGN=1),XN(m.textRotationAlignment)&&(g.HAS_TEXT_ROTATION_ALIGN=1),XN(m.markerRotation)&&(g.HAS_MARKER_ROTATION=1),XN(m.textRotation)&&(g.HAS_TEXT_ROTATION=1),i.data.aPadOffset&&(g.HAS_PAD_OFFSET=1)}function Sz(i,g,m,_){FN(i,g,m,_),function(i){const{aMarkerWidth:g,aMarkerHeight:m,aMarkerDx:_,aMarkerDy:b,aPitchAlign:T,aRotationAlign:P,aRotation:I,aOverlap:H}=i.data;if(g){const m=(LN+"aMarkerWidth").trim();i.properties.aMarkerWidth=i.properties[m]||new g.constructor(g)}if(m){const g=(LN+"aMarkerHeight").trim();i.properties.aMarkerHeight=i.properties[g]||new m.constructor(m)}if(_){const g=(LN+"aMarkerDx").trim();i.properties.aMarkerDx=i.properties[g]||new _.constructor(_)}if(b){const g=(LN+"aMarkerDy").trim();i.properties.aMarkerDy=i.properties[g]||new b.constructor(b)}if(T){const g=(LN+"aPitchAlign").trim();i.properties.aPitchAlign=i.properties[g]||new T.constructor(T)}if(P){const g=(LN+"aRotationAlign").trim();i.properties.aRotationAlign=i.properties[g]||new P.constructor(P)}if(I){const g=(LN+"aRotation").trim();i.properties.aRotation=i.properties[g]||new I.constructor(I)}if(H){const g=(LN+"aOverlap").trim();i.properties.aOverlap=i.properties[g]||new H.constructor(H)}}(i)}function Mz(i,g){const m=SL(g.markerWidth),_=SL(g.markerHeight),b=SL(g.markerDx),T=SL(g.markerDy),P=SL(g.markerOpacity),I=SL(g.markerTextFit),H=ML(g.markerPitchAlignment),W=ML(g.textPitchAlignment),q=ML(g.markerRotationAlignment),$=ML(g.textRotationAlignment),ye=SL(g.markerRotation),Re=SL(g.textRotation),Be=ML(g.markerAllowOverlapFn),Ge=ML(g.markerIgnorePlacement),je=SL(g.textOpacity),Xe=SL(g.textDx),Ze=SL(g.textDy),Ye=new Int16Array(1),Qe=new Uint16Array(1);return[{attrName:"aMarkerWidth",symbolName:"markerWidth",type:Uint16Array,width:1,define:"HAS_MARKER_WIDTH",evaluate:(_,b,T,P)=>{const H=T[P],W=g.markerTextFit,q=I?I(i.getZoom(),_):W;if("both"===q||"width"===q)return H;let $=m(i.getZoom(),_);return wL($)&&($=this.evaluateInFnTypeConfig($,b,i,_)),Ye[0]=$,Ye[0]}},{attrName:"aMarkerHeight",symbolName:"markerHeight",type:Uint16Array,width:1,define:"HAS_MARKER_HEIGHT",evaluate:(m,b,T,P)=>{const H=T[P],W=g.markerTextFit,q=I?I(i.getZoom(),m):W;if("both"===q||"height"===q)return H;let $=_(i.getZoom(),m);return wL($)&&($=this.evaluateInFnTypeConfig($,b,i,m)),Ye[0]=$,Ye[0]}},{attrName:"aDxDy",symbolName:"markerDx",type:Int8Array,width:4,index:0,define:"HAS_MARKER_DX",evaluate:(g,m,_,T)=>{let P=b(i.getZoom(),g);wL(P)&&(P=this.evaluateInFnTypeConfig(P,m,i,g));const{aMarkerDx:I}=m.properties;return I&&(I[T/4]=P),Ye[0]=P,Ye[0]}},{attrName:"aDxDy",symbolName:"markerDy",type:Int8Array,width:4,index:1,define:"HAS_MARKER_DY",evaluate:(g,m,_,b)=>{let P=T(i.getZoom(),g);wL(P)&&(P=this.evaluateInFnTypeConfig(P,m,i,g));const{aMarkerDy:I}=m.properties;return I&&(I[Math.floor(b/4)]=P),Ye[0]=P,Ye[0]}},{attrName:"aDxDy",symbolName:"textDx",type:Int8Array,width:4,index:2,define:"HAS_TEXT_DX",evaluate:(g,m,_,b)=>{let T=Xe(i.getZoom(),g);wL(T)&&(T=this.evaluateInFnTypeConfig(T,m,i,g));const{aTextDx:P}=m.properties;return P&&(P[Math.floor(b/4)]=T),Ye[0]=T,Ye[0]}},{attrName:"aDxDy",symbolName:"textDy",type:Int8Array,width:4,index:3,define:"HAS_TEXT_DY",evaluate:(g,m,_,b)=>{let T=Ze(i.getZoom(),g);wL(T)&&(T=this.evaluateInFnTypeConfig(T,m,i,g));const{aTextDy:P}=m.properties;return P&&(P[Math.floor(b/4)]=T),Ye[0]=T,Ye[0]}},{attrName:"aColorOpacity",symbolName:"markerOpacity",type:Uint8Array,width:2,index:0,define:"HAS_OPACITY",evaluate:(g,m)=>{let _=1;return P&&(_=P(i.getZoom(),g),wL(_)&&(_=this.evaluateInFnTypeConfig(_,m,i,g))),Ye[0]=255*_,Ye[0]}},{attrName:"aColorOpacity",symbolName:"textOpacity",type:Uint8Array,width:2,index:1,define:"HAS_OPACITY",evaluate:(g,m)=>{let _=1;return je&&(_=je(i.getZoom(),g),wL(_)&&(_=this.evaluateInFnTypeConfig(_,m,i,g))),Ye[0]=255*_,Ye[0]}},{attrName:"aPitchAlign",symbolName:"markerPitchAlignment",type:Uint8Array,width:2,index:0,define:"HAS_PITCH_ALIGN",evaluate:g=>+("map"===H(i.getZoom(),g))},{attrName:"aPitchAlign",symbolName:"textPitchAlignment",type:Uint8Array,width:2,index:1,define:"HAS_PITCH_ALIGN",evaluate:g=>+("map"===W(i.getZoom(),g))},{attrName:"aRotationAlign",symbolName:"markerRotationAlignment",type:Uint8Array,width:2,index:0,define:"HAS_MARKER_ROTATION_ALIGN",evaluate:g=>+("map"===q(i.getZoom(),g))},{attrName:"aRotationAlign",symbolName:"textRotationAlignment",type:Uint8Array,width:2,index:1,define:"HAS_TEXT_ROTATION_ALIGN",evaluate:g=>+("map"===$(i.getZoom(),g))},{attrName:"aRotation",symbolName:"markerRotation",type:Uint16Array,width:2,index:0,define:"HAS_MARKER_ROTATION",evaluate:g=>{const m=BF(ye(i.getZoom(),g),0,360)*Math.PI/180;return Qe[0]=9362*m,Qe[0]}},{attrName:"aRotation",symbolName:"textRotation",type:Uint16Array,width:2,index:1,define:"HAS_TEXT_ROTATION",evaluate:g=>{const m=BF(Re(i.getZoom(),g),0,360)*Math.PI/180;return Qe[0]=9362*m,Qe[0]}},{attrName:"aOverlap",symbolName:"markerAllowOverlap",type:Uint8Array,width:1,evaluate:m=>{let _=Be(i.getZoom(),m)||0,b=(Ge?Ge(i.getZoom(),m):g.markerIgnorePlacement)||0;return _=1<<3+4*_,b=(Ge?2:0)+b,_+b}},{attrName:"aOverlap",symbolName:"markerIgnorePlacement",type:Uint8Array,width:1,evaluate:m=>{let _=(Be?Be(i.getZoom(),m):g.markerAllowOverlap)||0,b=Ge(i.getZoom(),m)||0;return _=(Be?8:0)+4*_,b=2+b,_+b}}]}function Cz(i,g,m){if(!g||!m||"none"===m)return;const{iconAtlas:_,glyphAtlas:b}=g.properties;if(!_||!b)return;!function(i){if(i.properties.iconElements)return;const g=[],m=[],_=i.elements,b=i.properties.aType;for(let i=0;i<_.length;i++){const T=_[i];0===b[T]?g.push(T):m.push(T)}i.properties.iconElements=new _.constructor(g),i.properties.textElements=new _.constructor(m)}(g);const T=function(i,g){let m=i.properties.textFitFn;wL(g)&&(m=i.properties.textFitFn=ML(g));const _="none"!==g,b=[],T=i.properties.iconElements,P=i.data.aPickingId,I=i.properties.textElements,H=i.data.aPickingId,W=i.properties.aCount,q=i.properties.features;let $,ye=I[0];$={pickingId:H[ye],start:0,end:6*W[ye]};let Re=!1,Be=!1,Ge=0;const je=new Set;for(let i=0;i<T.length;i+=6){const ye=P[T[i]];if(!Re&&$)for(;$.pickingId<ye&&$.end<I.length;){const i=$.end,g=I[i];$.start=i,$.end=i+6*W[g],$.pickingId=H[g]}if(!Re&&$&&$.pickingId<ye&&(Re=!0,!_)){if(!Be)return[];for(let g=i;g<T.length;g+=6)b[Ge++]=[-1,-1];return b}const Xe=q[ye]&&q[ye].feature,Ze=m?m(null,Xe&&Xe.properties||{}):g;if($&&ye===$.pickingId){b[Ge++]=[$.start,$.end];const i=$.end,g=I[i];$.start=i,$.end=i+6*W[g],$.pickingId=H[g],Be=!0}else if(Ze&&"none"!==Ze)for(let g=i;g<i+6;g++)je.add(g);else b[Ge++]=[-1,-1]}if(je.size)if(je.size===T.length)i.setElements([]);else{const g=[];for(let i=0;i<T.length;i++)je.has(i)||g.push(T[i]);i.setElements(new T.constructor(g))}if(!Be)return[];return b}(g,m);if(!g.getElements().length)return;if(!T.length)return;g.properties.labelIndex=T;if(T.length&&m&&"none"!==m){const m=function(i){const g=[],m=i.properties.labelIndex,{aShape:_}=i.data;let b=!1;for(let T=0;T<m.length;T++){const[P,I]=m[T];if(-1===P)g.push(0,0,0,0);else{b=!0;let m=1/0,T=1/0,H=-1/0,W=-1/0;const q=i.properties.textElements;for(let i=P;i<I;i++){const g=q[i],b=_[4*g],P=_[4*g+1];b<m&&(m=b),b>H&&(H=b),P<T&&(T=P),P>W&&(W=P)}g.push(m,T,H,W)}}if(!b)return[];return g}(g);m.length&&(g.properties.labelShape=m,Pz.call(this,i,g))}}function Pz(i,g){const m=this.getSymbolDef(g.properties.symbolIndex),_=m.markerTextFit,b=g.properties;let T="both"===_||"width"===_,P="both"===_||"height"===_;if(wL(m.markerTextFit)){let i=g.properties.textFitFn;i||(i=g.properties.textFitFn=SL(m.markerTextFit));const{features:_}=g.properties,I=g.properties.iconElements,{aPickingId:H}=g.data,W=[],q=[];let $=!0;for(let g=0;g<I.length;g+=6){const m=_[H[I[g]]],b=(m&&m.feature||{}).properties||{};let T=i(null,b);if(wL(T)){T=(b.textFitFn=b.textFitFn||SL(T))(null,b)}"both"===T?(W.push(g/6),q.push(g/6)):"width"===T?($=!1,W.push(g/6)):"height"===T&&($=!1,q.push(g/6))}$?(b.fitIcons=W,T=!0,P=!0):(W.length&&(b.fitWidthIcons=W,T=!0),q.length&&(b.fitHeightIcons=q,P=!0))}b.aPickingId||(b.aPickingId=new g.data.aPickingId.constructor(g.data.aPickingId));const{aMarkerWidth:I,aMarkerHeight:H,aPickingId:W}=b,q=W.length;if(T)if(I){const i=g.data.aMarkerWidth;g.data.aMarkerWidth=new Uint16Array(i),b.aMarkerWidth=new Uint16Array(i);const m=(LN+"aMarkerWidth").trim();b[m]&&(b[m]=b.aMarkerWidth)}else{const i=this.getSymbol(g.properties.symbolIndex).markerWidth||0;b.aMarkerWidth=new Uint16Array(q),b.aMarkerWidth.fill(i),i&&(b.aMarkerWidth.dirty=!0),g.data.aMarkerWidth=new Uint16Array(q)}if(P)if(H){const i=g.data.aMarkerHeight;g.data.aMarkerHeight=new Uint16Array(i),b.aMarkerHeight=new Uint16Array(i);const m=(LN+"aMarkerHeight").trim();b[m]&&(b[m]=b.aMarkerHeight)}else{const i=this.getSymbol(g.properties.symbolIndex).markerHeight||0;b.aMarkerHeight=new Uint16Array(q),b.aMarkerHeight.fill(i),i&&(b.aMarkerHeight.dirty=!0),g.data.aMarkerHeight=new Uint16Array(q)}const $=this.getSymbolDef(g.properties.symbolIndex),ye=SL($.textSize);kz.call(this,i,g),(!wL($.textSize)||ye.isZoomConstant&&ye.isFeatureConstant)&&(b.isFitConstant=!0)}const Iz=[0,0,0,0];function kz(i,g){const m=g.properties;if(!m.glyphAtlas||!m.textElements||!m.textElements.length)return;const _=g.properties;if(_.isFitConstant||!_.labelShape||!_.labelShape.length)return;const b=this.getSymbolDef(g.properties.symbolIndex),T=b.textSize;let P;wL(T)&&(P=m._textSizeFn?m._textSizeFn:m._textSizeFn=SL(T));const I=b.markerTextFitPadding||Iz;let H;wL(I)&&(H=_._paddingFn?_._paddingFn:_._paddingFn=ML(I));const W=i.getZoom(),{fitIcons:q,fitWidthIcons:$,fitHeightIcons:ye}=_,{aMarkerWidth:Re,aMarkerHeight:Be,labelShape:Ge}=_,je=g.properties.iconElements,{features:Xe,aPickingId:Ze}=_,Ye=(i,g,m,b)=>{const q=Ge[4*g],$=Ge[4*g+1],ye=Ge[4*g+2],je=Ge[4*g+3];if(!(q||$||ye||je))return;const Ye=Ze[i],Qe=Xe[Ye]&&Xe[Ye].feature,Je=Qe&&Qe.properties||{};let Ke=P?P(W,Je):T;if(wL(Ke)){Ke=(Je.textSizeFn=Je.textSizeFn||SL(Ke))(W,Je)}Ke/=24;let et,tt=H&&H(W,Je)||I;if(wL(tt)){tt=(Je.fitPaddingFn=Je.fitPaddingFn||ML(tt))(W,Je)}if(tt=tt||Iz,tt[0]===tt[2]&&tt[1]===tt[3]||(et=_.aPadOffset,et||(et=_.aPadOffset=new Int8Array(2*Re.length))),Re&&m){const g=Math.abs((ye-q)/10*Ke)+(tt[1]+tt[3]||0);if(_z[0]=g,Re[i]!==_z[0]&&(XF(Re,_z[0],i,i+4),Re.dirty=!0),et){const g=(tt[1]+tt[3])/2-tt[3];if(vz[0]=g,et[2*i]!==vz[0]){for(let m=i;m<i+4;m++)et[2*m]=g;et.dirty=!0}}}if(Be&&b){const g=Math.abs((je-$)/10*Ke)+(tt[0]+tt[2]||0);if(_z[0]=g,Be[i]!==_z[0]&&(XF(Be,_z[0],i,i+4),Be.dirty=!0),et){const g=tt[0]-(tt[0]+tt[2])/2;if(vz[0]=g,et[2*i+1]!==vz[0]){for(let m=i;m<i+4;m++)et[2*m+1]=g;et.dirty=!0}}}};if(q||$||ye){if(q)for(let i=0;i<q.length;i++){const g=q[i];Ye(je[6*g],g,!0,!0)}else if($||ye){if($)for(let i=0;i<$.length;i++){const g=$[i];Ye(je[6*g],g,!0,!1)}if(ye)for(let i=0;i<ye.length;i++){const g=ye[i];Ye(je[6*g],g,!1,!0)}}}else for(let i=0;i<je.length;i+=6){Ye(je[i],i/6,!0,!0)}const{aPadOffset:Qe}=_;Qe&&(g.data.aPadOffset=Qe)}const{FilterUtil:Oz}=JD(),Ez=[],Rz={collides:-1},Lz=[EB,EB],Dz=mA([]),Fz=[];class IconPainter extends CollisionPainter{static getBloomSymbol(){return["markerBloom","textBloom"]}constructor(i,g,m,_,b,T){super(i,g,m,_,b,T),this.propAllowOverlap="markerAllowOverlap",this.propIgnorePlacement="markerIgnorePlacement",this._fnTypeConfigs={},this.isLabelCollides=gz.bind(this),this._meshesToCheck=[],this._emptyTexture=i.texture(2)}needToRefreshTerrainTileOnZooming(){for(let i=0;i<this.symbolDef.length;i++){const g=this.symbolDef[i].markerPitchAlignment;if("map"===g||wL(g)||Oz.isExpression(g))return!0}return!1}isTerrainVector(){return this.layer.options.awareOfTerrain&&!this.needToRefreshTerrainTileOnZooming()}isTerrainSkin(){return super.isTerrainSkin()&&this.needToRefreshTerrainTileOnZooming()}setShaderDefines(i){this._shaderDefines=i}createFnTypeConfig(i,g){const m=Mz.call(this,i,g),_=cz.call(this,i,g);for(let i=_.length-1;i>=0;i--){const g=_[i].attrName;"aTextDx"!==g&&"aTextDy"!==g&&"aPitchAlign"!==g&&"aRotation"!==g&&"aRotationAlign"!==g&&"aColorOpacity"!==g&&"aOverlap"!==g||_.splice(i,1)}const b=m.concat(_);return b.text=_,b.icon=m,b}startFrame(...i){return this._meshesToCheck.length=0,super.startFrame(...i)}createGeometry(i,g){return i&&i.empty&&(i.data={aPosition:new Uint8Array(i.data.aPosition),aPickingId:i.data.aPickingId}),super.createGeometry(i,g)}postCreateGeometry(i){const{geometry:g,symbolIndex:m}=i,_=this.getSymbolDef(m),b=this.getFnTypeConfig(m),{iconAtlas:T,glyphAtlas:P}=g.properties;if(T||P){if(this._prepareRequiredProps(g),T&&(this.drawDebugAtlas(T),Sz(g,_,b.icon,this.layer)),P){const i=_.markerTextFit;if(i){const m=this.getMap();Cz.call(this,m,g,i)}}}else g.properties.isEmpty=!0}_prepareRequiredProps(i){const{aCount:g,aShape:m}=i.data;i.properties.aCount=g,delete i.data.aCount;const _=m.length/4,b=new Uint8Array(_),T=new Uint8Array(_);for(let i=0;i<_;i++)b[i]=m[4*i+2]%2,T[i]=m[4*i+3]%2;i.properties.aType=b,i.properties.aHalo=T,bz.call(this,i)}prepareCollideIndex(i){const{collideIds:g,elements:m,aCount:_,aType:b}=i.properties;if(!g)return;const T={};if(!m)return void(i.properties.collideBoxIndex=T);let P=0,I=m[0],H=0,W=g[I],q=b[0],$=1;_&&($=_[m[H]]);for(let i=0;i<=m.length;i+=6)if(I=m[i],g[I]!==W||q!==b[I]||i===m.length){T[W]||(T[W]=[]);let ye=H;1===q&&(ye=H+(i-H)/2),T[W].push([ye,i,(i-ye)/(6*$),P++,H]),W=g[I],q=b[I],H=i,_&&($=_[m[H]])}i.properties.collideBoxIndex=T}createMesh(i,g){const m=this.isEnableCollision(),_=this.layer,{geometry:b,symbolIndex:T}=i;b.properties.symbolIndex=T;const P=this.getSymbolDef(T),I=this.getSymbol(T),H=this.getFnTypeConfig(T),W=[],q=this.isEnableUniquePlacement(),$=xz.call(this,this.regl,b,g,P,I,H,_.options.collision,!m,q);if($.length){const i=this.getAltitudeOffsetMatrix();$[0].positionMatrix=i,$[1]&&($[1].positionMatrix=i),W.push(...$)}return"line"===b.properties.markerPlacement&&(this._rebuildCollideIds(b),W.forEach((i=>i.properties.isLinePlacement=!0))),this.prepareCollideIndex(b),W}_rebuildCollideIds(i){const g=this.layer instanceof Up,{collideIds:m,glyphAtlas:_,iconAtlas:b}=i.properties,T=new Uint16Array(m.length),P=!!_;if(!!b){const{collideIds:m,aType:b}=i.properties;if(_){let i=0,g=b[0],_=0;for(let P=1;P<m.length;P++)0===b[P]&&1===g&&(T.fill(i++,_,P),_=P),g=b[P];_<m.length&&T.fill(i++,_,m.length)}else{let i=0;for(let g=0;g<m.length;g+=4)T.fill(i++,g,g+4)}i.properties.collideIds=T,i.properties.uniqueCollideIds=QF(T,!g)}else if(P){const{collideIds:m,aCount:_}=i.properties;if(!_)return;let b=0,T=_[0];for(let i=0;i<m.length;){const g=i+4*T;m.fill(b++,i,g),i+=4*T,g<m.length&&(T=_[g])}i.properties.uniqueCollideIds=QF(m,!g)}}addMesh(i){if(this.isEnableCollision()&&i.length>0){const g=new CollisionGroup(i);g.properties.uniqueCollideIds=i[0].geometry.properties.uniqueCollideIds,g.properties.meshKey=i[0].properties.meshKey,g.properties.level=i[0].properties.level,this._meshesToCheck.push(g)}for(let g=0;g<i.length;g++){if(!this.isMeshIterable(i[g]))continue;const m=i[g].geometry,{symbolIndex:_}=m.properties;$F(this.getSymbolDef(_))&&kz.call(this,this.getMap(),m)}const g=this.getMap().getZoom();for(let m=0;m<i.length;m++){if(!this.isMeshIterable(i[m]))continue;const _=i[m].geometry,{symbolIndex:b}=_.properties,T=this.getSymbolDef(b),P=this.getFnTypeConfig(b);zN(this.regl,this.layer,T,P,i[m],g);const{aMarkerWidth:I,aMarkerHeight:H,aPadOffset:W}=_.properties;I&&I.dirty&&(_.updateData("aMarkerWidth",I),I.dirty=!1),H&&H.dirty&&(_.updateData("aMarkerHeight",H),H.dirty=!1),W&&W.dirty&&(_.updateData("aPadOffset",W),W.dirty=!1)}super.addMesh(...arguments)}limitMeshDefines(i){let g=i.defines;g=LH(this.regl,g),i.setDefines(g)}updateCollision(i){if(!this.isEnableCollision())return;super.updateCollision(i);const g=this.scene.getMeshes();g&&g.length?(this._updateIconCollision(i.timestamp),this._meshesToCheck=[],this._endCollision()):this._endCollision()}isMeshIterable(i){return i&&i.geometry&&!i.geometry.properties.isEmpty&&i.material&&this.isMeshVisible(i)&&!(this.shouldIgnoreBackground()&&!this.layer.getRenderer().isForeground(i))}_updateIconCollision(){if(!this.isEnableCollision())return;let i=this._meshesToCheck;i&&i.length&&this._updateIconAndText(i)}_updateBox(i,g,m,_){return this.updateBoxCollisionFading(!0,i,g,m,_)}isEnableUniquePlacement(){return this.isEnableCollision()&&!0===this.sceneConfig.uniquePlacement}_updateIconAndText(i){const g=this.layer.getRenderer();i=i.sort(Nz);for(let m=0;m<i.length;m++){const _=i[m];if(!_||!_.meshes.length)continue;let b=!1;if(1===_.meshes.length)b=this.isMeshIterable(_.meshes[0]);else for(let i=0;i<_.meshes.length;i++)if(this.isMeshIterable(_.meshes[i])){b=!0;break}if(!b)continue;const T=g.isForeground(_.meshes[0]);if(this.shouldIgnoreBackground()&&!T)continue;const P=_.properties.meshKey;this.startMeshCollision(_),this._startCheckMesh(_),this.forEachBox(_,this._updateBox),this._endCheckMesh(_),this.endMeshCollision(P);for(let i=0;i<_.meshes.length;i++)this._updateOpacity(_.meshes[i])}}_updateOpacity(i){const g=i&&i.geometry&&i.geometry.properties.aOpacity;g&&g.dirty&&(i.geometry.updateData("aOpacity",g),g.dirty=!1)}forEachBox(i,g){const m=i.properties.uniqueCollideIds;if(!m)return;const _={boxIndex:0},b=m.length;for(let T=0;T<b;T++)this._iterateMeshBox(i,m[T],g,_)}_iterateMeshBox(i,g,m,_){const b=this.getMap(),{collideBoxIndex:T}=i.meshes[0].geometry.properties,P=T&&T[g];if(!P||!P.length)return!1;const I=_A(Ez,b.projViewMatrix,i.meshes[0].localTransform);let H,W=!1;const q=i.meshes;let $=0;for(let i=0;i<q.length;i++){if(!this.isMeshIterable(q[i]))continue;const{collideBoxIndex:m}=q[i].geometry.properties,_=m[g];_&&($+=_.length)}if(!$)return!1;H=this._getMeshBoxes($);let ye=0;for(let i=0;i<q.length;i++){const m=q[i];if(!this.isMeshIterable(m))continue;W=!0;const _=m.geometry.properties,{elements:b,aCount:T,collideBoxIndex:P}=_,I=P[g];if(I)for(let i=0;i<I.length;i++){const[g,P,W]=I[i];let q=1;T&&(q=T[b[g]]);const $=g+0*q*6;H[ye].mesh=m,H[ye].start=$,H[ye].end=P,H[ye].boxStart=I[i][4],H[ye].boxCount=_.glyphAtlas?q:W,H[ye].allElements=b,ye++}}if(!W)return!1;return m.call(this,i,H,I,_.boxIndex++)&&this._markerVisible(i,g),!0}_startCheckMesh(i){const g=i.meshes;for(let i=0;i<g.length;i++){const m=g[i],_=m&&m.geometry;_&&(_.properties.visElemts.count=0)}}_markerVisible(i,g){const m=i.meshes;for(let i=0;i<m.length;i++){const _=m[i],b=_&&_.geometry;if(!b||b.properties.isEmpty)continue;const{collideBoxIndex:T,elements:P,visElemts:I}=b.properties,H=T[g];if(H&&H.length)for(let i=0;i<H.length;i++){const g=H[i][1];let m=I.count;for(let _=H[i][4];_<g;_++)I[m++]=P[_];I.count=m}}}_endCheckMesh(i){const g=i.meshes;for(let i=0;i<g.length;i++){const m=g[i],_=m&&m.geometry;if(!_)continue;const{visElemts:b}=_.properties;_.setElements(b,b.count)}}isBoxCollides(i,g,m,_,b,T){if(this._isTextGeo(i,g,_))return gz.call(this,0,i,g,m,_,b,T);if(i.geometry.properties.isEmpty)return Rz;const{aTerrainAltitude:P}=i.geometry.properties;if(P){if(P[2*g[_]]===PF)return Rz}const I=this.getMap(),{boxes:H,collision:W}=this._getCollideBoxes(i,_);let q=0,$=0,ye=0;for(let m=_;m<b;m+=6){const _=H[ye]=H[ye]||[];ye++;const b=jB.call(this,_,i,g[m],T,I);if(!q){const i=this.isCollides(b);1===i?q=1:-1===i&&$++}}return $===m&&(q=-1),W.collides=q,W}deleteMesh(i,g){i&&(i instanceof CollisionGroup&&(i=i.meshes),g&&(Array.isArray(i)?i.forEach((i=>{i&&i.material&&delete i.material.uniforms.iconTex})):i.material&&delete i.material.uniforms.iconTex),super.deleteMesh(i,g))}isBloom(i){const g=i&&i.material&&!zF(i.material.get("markerOpacity")),m=this.getSymbol(i.properties.symbolIndex);return!!(g?m.markerBloom:m.textBloom)}isUniqueStencilRefPerTile(){return!1}init(){const i=this.canvas;this.renderer=new wP.Renderer(this.regl);const g={viewport:{x:(i,g)=>g.viewport?g.viewport.x:0,y:(i,g)=>g.viewport?g.viewport.y:0,width:(g,m)=>m.viewport?m.viewport.width:i?i.width:1,height:(g,m)=>m.viewport?m.viewport.height:i?i.height:1},stencil:{enable:!0,func:{cmp:"<=",ref:(i,g)=>g.stencilRef},op:{fail:"keep",zfail:"keep",zpass:"replace"}},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},depth:{enable:!0,range:()=>this.sceneConfig.depthRange||[0,1],func:()=>this.sceneConfig.depthFunc||"always",mask:!!zF(this.sceneConfig.depthMask)||this.sceneConfig.depthMask},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}};if(this.shader=new wP.MeshShader({name:"marker",vert:xB,frag:"#define SHADER_NAME MARKER\n\n#define HAS_HIGHLIGHT_COLOR_POINT 1\n\n\n\nprecision mediump float;\n\n#include <gl2_frag>\n\n\n\nuniform float alphaTest;\n\nuniform sampler2D iconTex;\n\nuniform lowp float markerOpacity;\n\nuniform lowp float blendSrcIsOne;\n\nuniform float layerOpacity;\n\n\n\n#include <highlight_frag>\n\n\n\nvarying vec2 vTexCoord;\n\nvarying float vOpacity;\n\nvarying float vIsText;\n\nvarying float vHalo;\n\n\n\n#include <text_render_frag>\n\n\n\nvoid main() {\n\n    vec4 fragColor;\n\n    if (vIsText > 0.5) {\n\n        fragColor = renderText(vTexCoord);\n\n    } else {\n\n        fragColor = texture2D(iconTex, vTexCoord) * markerOpacity;\n\n    }\n\n\n\n    fragColor = fragColor * vOpacity * layerOpacity;\n\n\n\n\n\n\n\n\n\n\n\n    if (fragColor.a < 0.05) {\n\n        discard;\n\n    }\n\n\n\n    glFragColor = fragColor;\n\n\n\n    if (glFragColor.a < alphaTest) {\n\n        discard;\n\n    }\n\n    glFragColor = highlight_blendColor(glFragColor);\n\n    #if __VERSION__ == 100\n\n        gl_FragColor = glFragColor;\n\n    #endif\n\n}\n\n",wgslVert:bB,wgslFrag:"#define HAS_HIGHLIGHT_COLOR_POINT 1\nstruct MarkerFragUniforms {\n    alphaTest: f32,\n    markerOpacity: f32\n};\nstruct ShaderUniforms {\n    layerOpacity: f32\n}\n@group(0) @binding($b) var<uniform> uniforms: MarkerFragUniforms;\n@group(0) @binding($b) var<uniform> shaderUniforms: ShaderUniforms;\n@group(0) @binding($b) var iconTex: texture_2d<f32>;\n@group(0) @binding($b) var iconTexSampler: sampler;\n#include <highlight_frag>\nstruct VertexOutput {\n    @location($i) vTexCoord: vec2f,\n    @location($i) vOpacity: f32,\n    @location($i) vGammaScale: f32,\n    @location($i) vTextSize: f32,\n    @location($i) vHalo: f32,\n    @location($i) vIsText: f32,\n    #ifdef HAS_TEXT_FILL\n        @location($i) vTextFill: vec4f,\n    #endif\n    #ifdef HAS_TEXT_HALO_FILL\n        @location($i) vTextHaloFill: vec4f,\n    #endif\n    #if HAS_TEXT_HALO_RADIUS || HAS_TEXT_HALO_OPACITY\n        @location($i) vTextHalo: vec2f,\n    #endif\n}\n#include <text_render_frag>\n@fragment\nfn main(input: VertexOutput) -> @location(0) vec4f {\n    var fragColor: vec4f;\n    let isText = input.vIsText > 0.5;\n    let textColor = renderText(input);\n    let iconColor = textureSample(iconTex, iconTexSampler, input.vTexCoord) * uniforms.markerOpacity;\n    if (isText) {\n        fragColor = textColor;\n    } else {\n        fragColor = iconColor;\n    }\n    fragColor = fragColor * input.vOpacity * shaderUniforms.layerOpacity;\n    if (fragColor.a < 0.05) {\n        discard;\n    }\n    var color: vec4f;\n    color = fragColor;\n    if (color.a < uniforms.alphaTest) {\n        discard;\n    }\n    #if HAS_HIGHLIGHT_OPACITY || HAS_HIGHLIGHT_COLOR\n        return highlight_blendColor(color, input);\n    #else\n        return color;\n    #endif\n}",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A([],g.projViewMatrix,g.modelMatrix)}},{name:"zoomScale",type:"function",fn:function(i,g){return g.tileResolution/g.resolution}}],extraCommandProps:g,defines:this._shaderDefines||{}}),this.shader.version=300,this.pickingFBO){const i=new wP.FBORayPicking(this.renderer,{name:"marker-picking",vert:"#define PICKING_MODE 1\n"+xB,wgslVert:bB,defines:{PICKING_MODE:1},uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A([],g.projViewMatrix,g.modelMatrix)}},{name:"zoomScale",type:"function",fn:function(i,g){return g.tileResolution/g.resolution}}],extraCommandProps:g},this.pickingFBO,this.getMap());this.picking=[i]}}getUniformValues(i,g){const m=g&&g.isRenderingTerrainSkin,_=this.layer.getTileSize().width,b=m?Dz:i.projViewMatrix,T=i.cameraToCenterDistance,P=z_(Fz,i.width,i.height);m&&z_(P,_,_);const I=this.getBlendFunc(),H=Po.isFunction(I.src)?I.src():I.src;return{layerScale:this.layer.options.styleScale||1,mapPitch:i.getPitch()*Math.PI/180,mapRotation:i.getBearing()*Math.PI/180,projViewMatrix:b,cameraToCenterDistance:T,canvasSize:P,iconSize:Lz,resolution:i.getResolution(),glyphSize:24,gammaScale:1,blendSrcIsOne:+!("one"!==H&&1!==H),viewport:m&&g&&g.viewport,isRenderingTerrain:+!!m}}getUniqueEntryKey(i,g){if(!this._isTextGeo(i.geometry))return null;const{elements:m}=i.geometry.properties;return mz(i,m[g])}_isTextGeo(i,g,m){const{aType:_}=i.geometry.properties;return 1===_[g[m]]}delete(){return this._emptyTexture&&(wP.Util.isTextureDestroyed(this._emptyTexture)||this._emptyTexture.destroy(),this._emptyTexture=null),super.delete()}}function Nz(i,g){return i.properties.level-g.properties.level||i.properties.meshKey-g.properties.meshKey}const Hz=[],Bz=[],zz=[];function Vz(i,g,m,_,b,T,P,I,H,W,q,$,ye){const{aGlyphOffset:Re,aSegment:Be,aTextDx:Ge,aTextDy:je,symbolIndex:Xe}=g.geometry.properties,Ze=this.getSymbol(Xe),Ye=z_(zz,(Ge?Ge[b]:Ze.textDx)||0,(je?je[b]:Ze.textDy)||0),Qe=z_(Hz,Re[2*b],Re[2*b+1]),Je=qA(Bz,Be[3*b],Be[3*b+1],Be[3*b+2]),Ke=function(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be,Ge,je,Xe){Be||(Be=_);const Ze=g.geometry.properties.line,Ye=T[0]*$,Qe=ye?Ye-P:Ye+P;let Je=Qe>0?1:-1,Ke=0;ye&&(Je*=-1,Ke=Math.PI),Je<0&&(Ke+=Math.PI);const et=W+q,tt=Math.abs(Qe);let at=Je>0?H:H+1,ht=QN.convert(_),gt=QN.convert(_),yt=QN.convert(b),vt=QN.convert(b),xt=0,bt=0;for(;xt+bt<=tt;){if(at+=Je,at<W||at>=et)return null;gt.x=ht.x,gt.y=ht.y,vt.x=yt.x,vt.y=yt.y,ht.x=m[3*at],ht.y=m[3*at+1],yt.x=Ze[3*at],yt.y=Ze[3*at+1],xt+=bt,bt=gt.dist(ht)/Re}const Tt=(tt-xt)/bt,Mt=Ge&&Ge.getRenderer(),Pt=Mt&&Mt.getTerrainHelper(),It=g.properties.tile.terrainTileInfos;if(!Xe&&Pt){const{extent:m}=g.properties.tile,_=Ge.getTileSize().width/m,b=Ge.getMap();let T=yt.sub(vt).mult(Tt)._add(vt);ht=sH(eH,b,g,yt,_,Ge,je,It),gt=sH(tH,b,g,vt,_,Ge,je,It),T=sH(nH,b,g,T,_,Ge,je,It);const P=Ke+Math.atan2(ht[1]-gt[1],ht[0]-gt[0]);return i[0]=(T[0]-Be[0])/Re,i[1]=(T[1]-Be[1])/Re,i[2]=P,i}const Et=ht.sub(gt),Lt=Et.mult(Tt)._add(gt);Lt._add(Et._unit()._perp()._mult(I*Je));const Dt=Ke+Math.atan2(ht.y-gt.y,ht.x-gt.x);return i[0]=(Lt.x-_[0])/Re,i[1]=(Lt.y-_[1])/Re,i[2]=Dt,i}(i,g,_,T,P,Qe,Ye[0],Ye[1],Je[0],Je[1],Je[2],m/24,H,I,W,q,$,ye);return Ke}const Uz=[],Gz=[];function jz(i,g,m,_,b,T,P,I,H,W,q,$,ye){const{aVertical:Re}=m.geometry.properties,Be=Re[T];let Ge,je,Xe=Vz.call(this,Uz,m,_,b,T,I,H,W,!1);if(!Xe)return null;if(WA(i,Xe),Xe=Vz.call(this,Gz,m,_,b,P,I,H,W,!1),ye=Math.PI*ye/180,!Xe||Math.abs(Xe[2])>ye)return null;if(WA(g,Xe),$&&(Y_(Uz,Uz,$),Y_(Gz,Gz,$)),Be){const i=Math.abs(Gz[1]-Uz[1]),g=Math.abs(Gz[0]-Uz[0])*q;je=Uz[0]>Gz[0]?1:0,i>g?(Ge=1,je=Uz[1]<Gz[1]?0:1):Ge=0}else Ge=0,je=Uz[0]>Gz[0]?1:0;return 2*je+Ge}var Wz="#define SHADER_NAME TEXT_VERT\n\n#define RAD 0.0174532925\n\n\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nattribute vec4 aShape;\n\n#ifdef ENABLE_COLLISION\n\nattribute float aOpacity;\n\n#endif\n\n#ifdef HAS_OPACITY\n\nattribute float aColorOpacity;\n\n#endif\n\n\n\n#ifdef HAS_TEXT_SIZE\n\n    attribute float aTextSize;\n\n#else\n\n    uniform float textSize;\n\n#endif\n\n\n\n#ifdef HAS_TEXT_DX\n\n    attribute float aTextDx;\n\n#else\n\n    uniform float textDx;\n\n#endif\n\n#ifdef HAS_TEXT_DY\n\n    attribute float aTextDy;\n\n#else\n\n    uniform float textDy;\n\n#endif\n\n#if defined(HAS_PITCH_ALIGN)\n\n    attribute float aPitchAlign;\n\n#else\n\n    uniform float textPitchWithMap;\n\n#endif\n\n\n\n#if defined(HAS_TEXT_ROTATION_ALIGN)\n\n    attribute float aRotationAlign;\n\n#else\n\n    uniform float textRotateWithMap;\n\n#endif\n\n\n\nuniform float flipY;\n\n#if defined(HAS_TEXT_ROTATION)\n\n    attribute float aRotation;\n\n#else\n\n    uniform float textRotation;\n\n#endif\n\n\n\nuniform float cameraToCenterDistance;\n\nuniform mat4 positionMatrix;\n\nuniform mat4 projViewModelMatrix;\n\nuniform float textPerspectiveRatio;\n\n\n\nuniform vec2 glyphTexSize;\n\nuniform vec2 canvasSize;\n\nuniform float glyphSize;\n\nuniform float mapPitch;\n\nuniform float mapRotation;\n\n\n\nuniform float zoomScale;\n\nuniform float tileRatio;\n\nuniform float layerScale;\n\nuniform float isRenderingTerrain;\n\n\n\n#ifndef PICKING_MODE\n\n    varying vec2 vTexCoord;\n\n    varying float vGammaScale;\n\n    varying float vTextSize;\n\n    varying float vOpacity;\n\n\n\n    #ifdef HAS_TEXT_FILL\n\n        attribute vec4 aTextFill;\n\n        varying vec4 vTextFill;\n\n    #endif\n\n\n\n    #ifdef HAS_TEXT_HALO_FILL\n\n        attribute vec4 aTextHaloFill;\n\n        varying vec4 vTextHaloFill;\n\n    #endif\n\n\n\n    #if defined(HAS_TEXT_HALO_RADIUS) || defined(HAS_TEXT_HALO_OPACITY)\n\n        attribute vec2 aTextHalo;\n\n        varying vec2 vTextHalo;\n\n    #endif\n\n\n\n    #include <highlight_vert>\n\n#else\n\n    #include <fbo_picking_vert>\n\n#endif\n\n\n\n#include <vt_position_vert>\n\n\n\nvoid main() {\n\n    vec3 position = unpackVTPosition();\n\n\n\n    #ifdef HAS_TEXT_SIZE\n\n        float myTextSize = aTextSize * layerScale;\n\n    #else\n\n        float myTextSize = textSize * layerScale;\n\n    #endif\n\n    #ifdef HAS_TEXT_DX\n\n        float myTextDx = aTextDx;\n\n    #else\n\n        float myTextDx = textDx;\n\n    #endif\n\n    #ifdef HAS_TEXT_DY\n\n        float myTextDy = aTextDy;\n\n    #else\n\n        float myTextDy = textDy;\n\n    #endif\n\n    #if defined(HAS_PITCH_ALIGN)\n\n        float isPitchWithMap = aPitchAlign;\n\n    #else\n\n        float isPitchWithMap = textPitchWithMap;\n\n    #endif\n\n    #if defined(HAS_ROTATION_ALIGN)\n\n        float isRotateWithMap = aRotationAlign;\n\n    #else\n\n        float isRotateWithMap = textRotateWithMap;\n\n    #endif\n\n\n\n    gl_Position = projViewModelMatrix * positionMatrix * vec4(position, 1.0);\n\n    float projDistance = gl_Position.w;\n\n\n\n\n\n    float perspectiveRatio;\n\n    if (isRenderingTerrain == 1.0 && isPitchWithMap == 1.0) {\n\n        perspectiveRatio = 1.0;\n\n    } else {\n\n        float distanceRatio = (1.0 - cameraToCenterDistance / projDistance) * textPerspectiveRatio;\n\n        perspectiveRatio = clamp(\n\n            0.5 + 0.5 * (1.0 - distanceRatio),\n\n            0.0,            4.0);\n\n    }\n\n\n\n    #ifdef HAS_TEXT_ROTATION\n\n        float rotation = -aRotation / 9362.0 - mapRotation * isRotateWithMap;\n\n    #else\n\n        float rotation = -textRotation - mapRotation * isRotateWithMap;\n\n    #endif\n\n    if (isPitchWithMap == 1.0) {\n\n        #ifdef REVERSE_MAP_ROTATION_ON_PITCH\n\n            rotation += mapRotation;\n\n        #else\n\n            rotation -= mapRotation;\n\n        #endif\n\n    }\n\n    float angleSin = sin(rotation);\n\n    float angleCos = cos(rotation);\n\n\n\n    mat2 shapeMatrix = mat2(angleCos, -1.0 * angleSin, angleSin, angleCos);\n\n\n\n    vec2 shape = aShape.xy / 10.0;\n\n    if (isPitchWithMap == 1.0 && flipY == 0.0) {\n\n        shape = shape * vec2(1.0, -1.0);\n\n    }\n\n    vec2 texCoord = aShape.zw;\n\n    shape = shapeMatrix * (shape / glyphSize * myTextSize);\n\n\n\n\n\n    float cameraScale;\n\n    if (isRenderingTerrain == 1.0) {\n\n        cameraScale = 1.0;\n\n    } else {\n\n        cameraScale = projDistance / cameraToCenterDistance;\n\n    }\n\n\n\n    if (isPitchWithMap == 0.0) {\n\n        vec2 offset = shape * 2.0 / canvasSize;\n\n        gl_Position.xy += offset * perspectiveRatio * projDistance;\n\n    } else {\n\n        float offsetScale;\n\n        if (isRenderingTerrain == 1.0) {\n\n            offsetScale = tileRatio / zoomScale;\n\n        } else {\n\n            offsetScale = tileRatio / zoomScale * cameraScale * perspectiveRatio;\n\n        }\n\n\n\n        vec2 offset = shape;\n\n        gl_Position = projViewModelMatrix * positionMatrix * vec4(position + vec3(offset, 0.0) * offsetScale, 1.0);\n\n    }\n\n    gl_Position.xy += vec2(myTextDx, -myTextDy) * 2.0 / canvasSize * projDistance;\n\n\n\n    #ifndef PICKING_MODE\n\n        if (isPitchWithMap == 0.0) {\n\n            vGammaScale = mix(1.0, cameraScale, textPerspectiveRatio);\n\n        } else {\n\n            vGammaScale = cameraScale + mapPitch / 4.0;\n\n        }\n\n        vTexCoord = texCoord / glyphTexSize;\n\n        vGammaScale = clamp(vGammaScale, 0.0, 1.0);\n\n\n\n        vTextSize = myTextSize;\n\n        #ifdef ENABLE_COLLISION\n\n            vOpacity = aOpacity / 255.0;\n\n        #else\n\n            vOpacity = 1.0;\n\n        #endif\n\n\n\n        #ifdef HAS_OPACITY\n\n            vOpacity *= aColorOpacity / 255.0;\n\n        #endif\n\n\n\n        #ifdef HAS_TEXT_FILL\n\n            vTextFill = aTextFill / 255.0;\n\n        #endif\n\n\n\n        #ifdef HAS_TEXT_HALO_FILL\n\n            vTextHaloFill = aTextHaloFill / 255.0;\n\n        #endif\n\n\n\n        #if defined(HAS_TEXT_HALO_RADIUS) || defined(HAS_TEXT_HALO_OPACITY)\n\n            vTextHalo = aTextHalo;\n\n        #endif\n\n\n\n        highlight_setVarying();\n\n    #else\n\n        #ifdef ENABLE_COLLISION\n\n            bool visible = aOpacity == 255.0;\n\n        #else\n\n            bool visible = true;\n\n        #endif\n\n        fbo_picking_setData(gl_Position.w, visible);\n\n    #endif\n\n}\n\n",qz="#define SHADER_NAME TEXT_LINE\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nattribute vec2 aTexCoord;\n\n#ifdef HAS_OFFSET_Z\n\n    attribute vec3 aOffset;\n\n    uniform float altitudeScale;\n\n#else\n\n    attribute vec2 aOffset;\n\n#endif\n\n#ifdef ENABLE_COLLISION\n\nattribute float aOpacity;\n\n#endif\n\n#ifdef HAS_OPACITY\n\nattribute float aColorOpacity;\n\n#endif\n\n\n\n#ifdef HAS_TEXT_SIZE\n\n    attribute float aTextSize;\n\n#else\n\n    uniform float textSize;\n\n#endif\n\n#ifdef HAS_TEXT_DX\n\n    attribute float aTextDx;\n\n#else\n\n    uniform float textDx;\n\n#endif\n\n#ifdef HAS_TEXT_DY\n\n    attribute float aTextDy;\n\n#else\n\n    uniform float textDy;\n\n#endif\n\n#if defined(HAS_PITCH_ALIGN)\n\n    attribute float aPitchAlign;\n\n#else\n\n    uniform float textPitchWithMap;\n\n#endif\n\n\n\nuniform float zoomScale;\n\nuniform float cameraToCenterDistance;\n\nuniform mat4 projViewModelMatrix;\n\nuniform float textPerspectiveRatio;\n\nuniform float mapPitch;\n\n\n\nuniform vec2 glyphTexSize;\n\nuniform vec2 canvasSize;\n\nuniform float tileRatio;\n\nuniform float layerScale;\n\n\n\nuniform float isRenderingTerrain;\n\nuniform float textPitchFilter;\n\n\n\n#ifndef PICKING_MODE\n\n    varying vec2 vTexCoord;\n\n    varying float vGammaScale;\n\n    varying float vTextSize;\n\n    varying float vOpacity;\n\n\n\n\n\n    #ifdef HAS_TEXT_FILL\n\n        attribute vec4 aTextFill;\n\n        varying vec4 vTextFill;\n\n    #endif\n\n\n\n    #ifdef HAS_TEXT_HALO_FILL\n\n        attribute vec4 aTextHaloFill;\n\n        varying vec4 vTextHaloFill;\n\n    #endif\n\n\n\n    #if defined(HAS_TEXT_HALO_RADIUS) || defined(HAS_TEXT_HALO_OPACITY)\n\n        attribute vec2 aTextHalo;\n\n        varying vec2 vTextHalo;\n\n    #endif\n\n\n\n\n\n    #include <highlight_vert>\n\n#else\n\n    #include <fbo_picking_vert>\n\n#endif\n\n\n\n#include <vt_position_vert>\n\n\n\nvoid main() {\n\n    vec3 position = unpackVTPosition();\n\n    #ifdef HAS_TEXT_DX\n\n        float myTextDx = aTextDx;\n\n    #else\n\n        float myTextDx = textDx;\n\n    #endif\n\n    #ifdef HAS_TEXT_DY\n\n        float myTextDy = aTextDy;\n\n    #else\n\n        float myTextDy = textDy;\n\n    #endif\n\n    #ifdef HAS_TEXT_SIZE\n\n        float myTextSize = aTextSize * layerScale;\n\n    #else\n\n        float myTextSize = textSize * layerScale;\n\n    #endif\n\n    #ifdef HAS_PITCH_ALIGN\n\n        float isPitchWithMap = aPitchAlign;\n\n    #else\n\n        float isPitchWithMap = textPitchWithMap;\n\n    #endif\n\n    gl_Position = projViewModelMatrix * vec4(position, 1.0);\n\n    float projDistance = gl_Position.w;\n\n\n\n    float cameraScale = projDistance / cameraToCenterDistance;\n\n\n\n    float perspectiveRatio;\n\n    if (isRenderingTerrain == 1.0) {\n\n        perspectiveRatio = 1.0;\n\n    } else {\n\n        float distanceRatio = (1.0 - cameraToCenterDistance / projDistance) * textPerspectiveRatio;\n\n        perspectiveRatio = clamp(\n\n            0.5 + 0.5 * (1.0 - distanceRatio),\n\n            0.0,            4.0);\n\n    }\n\n    #ifdef HAS_OFFSET_Z\n\n        vec3 offset = aOffset / 10.0;\n\n        offset[2] /= altitudeScale;\n\n    #else\n\n        vec3 offset = vec3(aOffset / 10.0, 0.0);\n\n    #endif\n\n    vec2 texCoord = aTexCoord;\n\n\n\n    if (isPitchWithMap == 1.0) {\n\n        float offsetScale;\n\n        if (isRenderingTerrain == 1.0) {\n\n            offsetScale = tileRatio;\n\n        } else {\n\n            offsetScale = tileRatio / zoomScale * cameraScale * perspectiveRatio;\n\n        }\n\n        offset.xy *= offsetScale;\n\n        gl_Position = projViewModelMatrix * vec4(position + offset, 1.0);\n\n\n\n    } else {\n\n        gl_Position.xy += offset.xy * 2.0 / canvasSize * perspectiveRatio * projDistance;\n\n\n\n    }\n\n\n\n    gl_Position.xy += vec2(myTextDx, -myTextDy) * 2.0 / canvasSize * projDistance;\n\n\n\n\n\n    if (textPitchFilter > 0.0) {\n\n        if (textPitchFilter == 1.0 && isPitchWithMap == 0.0 || textPitchFilter == 2.0 && isPitchWithMap == 1.0) {\n\n            gl_Position = vec4(-9999.0, -9999.0, 0.0, 1.0);\n\n        }\n\n    }\n\n\n\n    #ifndef PICKING_MODE\n\n        if (isPitchWithMap == 1.0) {\n\n            vGammaScale = cameraScale + mapPitch / 4.0;\n\n        } else {\n\n            vGammaScale = mix(1.0, cameraScale, textPerspectiveRatio);\n\n        }\n\n        vGammaScale = clamp(vGammaScale, 0.0, 1.0);\n\n        vTexCoord = texCoord / glyphTexSize;\n\n        vTextSize = myTextSize;\n\n        #ifdef ENABLE_COLLISION\n\n            vOpacity = aOpacity / 255.0;\n\n        #else\n\n            vOpacity = 1.0;\n\n        #endif\n\n        #ifdef HAS_OPACITY\n\n            vOpacity *= aColorOpacity / 255.0;\n\n        #endif\n\n\n\n        #ifdef HAS_TEXT_FILL\n\n            vTextFill = aTextFill / 255.0;\n\n        #endif\n\n\n\n        #ifdef HAS_TEXT_HALO_FILL\n\n            vTextHaloFill = aTextHaloFill / 255.0;\n\n        #endif\n\n\n\n        #if defined(HAS_TEXT_HALO_RADIUS) || defined(HAS_TEXT_HALO_OPACITY)\n\n            vTextHalo = aTextHalo;\n\n        #endif\n\n\n\n        highlight_setVarying();\n\n    #else\n\n        #ifdef ENABLE_COLLISION\n\n            bool visible = aOpacity == 255.0;\n\n        #else\n\n            bool visible = true;\n\n        #endif\n\n        fbo_picking_setData(gl_Position.w, visible);\n\n    #endif\n\n}\n\n\n\n",Xz="#define SHADER_NAME TEXT_FRAG\n\n\n\nprecision mediump float;\n\n\n\nuniform float layerOpacity;\n\nvarying vec2 vTexCoord;\n\nvarying float vOpacity;\n\nuniform float alphaTest;\n\n\n\n#include <text_render_frag>\n\n\n\n#include <highlight_frag>\n\n\n\nvoid main() {\n\n    gl_FragColor = renderText(vTexCoord) * vOpacity * layerOpacity;\n\n    if (gl_FragColor.a < alphaTest) {\n\n        discard;\n\n    }\n\n    gl_FragColor = highlight_blendColor(gl_FragColor);\n\n}\n\n";const{TextUtil:Zz,PackUtil:$z,FilterUtil:Yz,TEXT_MAX_ANGLE:Qz}=JD(),Jz=function(i){const g=this.layer.getRenderer();return!this._isHalo0(i)&&g.isTileNearCamera(i)&&"line"!==i.geometry.properties.textPlacement},Kz=function(i){const g=this.layer.getRenderer();return!this._isHalo0(i)&&!g.isForeground(i)&&"line"!==i.geometry.properties.textPlacement},eV=function(i){const g=this.layer.getRenderer();return!this._isHalo0(i)&&g.isTileNearCamera(i)&&"line"===i.geometry.properties.textPlacement},tV=function(i){const g=this.layer.getRenderer(),m=i.properties.tile.z,_=g.getCurrentTileZoom();return!this._isHalo0(i)&&!g.isForeground(i)&&"line"===i.geometry.properties.textPlacement&&m<_},nV=[0,0,3],rV=[],iV=[],oV=[],sV=[],aV=[],lV=[],hV=[],cV=[],uV=[1,-1],fV=new Int16Array(3),dV=[],pV=[],gV=[],mV=[],AV=[],yV=[],_V=[],vV={},xV={},bV={},wV=[],TV=[],SV=mA([]),MV=[];class TextPainter extends CollisionPainter{static getBloomSymbol(){return["textBloom"]}constructor(i,g,m,_,b,T){super(i,g,m,_,b,T),this.propAllowOverlap="textAllowOverlap",this.propIgnorePlacement="textIgnorePlacement",this.colorCache={},this._filter0=Jz.bind(this),this._filter1=Kz.bind(this),this._lineFilter0=eV.bind(this),this._lineFilter1=tV.bind(this),this.isLabelCollides=gz.bind(this),this._genTextNames()}prepareRender(...i){super.prepareRender(...i);const g=this.scene.getMeshes();if(g&&g.length)for(let i=0;i<g.length;i++){if(g[i].properties.isHalo)continue;const{haloMesh:m}=g[i].properties;m.dirtyDefines&&g[i].setDefines(m.defines)}}updateSymbol(...i){this._tagTerrainVector=void 0,this._tagTerrainSkin=void 0;const g=super.updateSymbol(...i);return this._genTextNames(),g}isTerrainVector(){if(!super.isTerrainSkin())return!1;if(void 0!==this._tagTerrainVector)return this._tagTerrainVector;for(let i=0;i<this.symbolDef.length;i++){if("map"!==this.symbolDef[i].textPitchAlignment)return this._tagTerrainVector=!0,!0}return this._tagTerrainVector=!1,!1}isTerrainSkin(){if(!super.isTerrainSkin())return!1;if(void 0!==this._tagTerrainSkin)return this._tagTerrainSkin;for(let i=0;i<this.symbolDef.length;i++){const g=this.symbolDef[i].textPitchAlignment;if("map"===g||wL(g)||Yz.isExpression(g))return this._tagTerrainSkin=!0,!0}return this._tagTerrainSkin=!1,!1}_genTextNames(){this._textNameFn=[];for(let i=0;i<this.symbolDef.length;i++){const g=this.symbolDef[i];if(Yz.isExpression(g.textName)){const m=Yz.createExpression(g.textName,"string");this._textNameFn[i]=(i,g)=>{let _;vV.zoom=i,xV.properties=g;try{_=m.evaluateWithoutErrorHandling(vV,xV,bV,null,wV)}catch(i){_=null}return _}}else wL(g.textName)&&(this._textNameFn[i]=SL(g.textName))}}shouldDeleteMeshOnUpdateSymbol(i){if(!Array.isArray(i))return(0===i.textHaloRadius||0===this.symbolDef[0].textHaloRadius)&&i.textHaloRadius!==this.symbolDef[0].textHaloRadius;for(let g=0;g<i.length;g++)if(i[g]&&(0===i[g].textHaloRadius||0===this.symbolDef[g].textHaloRadius)&&i[g].textHaloRadius!==this.symbolDef[g].textHaloRadius)return!0;return!1}createFnTypeConfig(i,g){return cz(i,g)}isBloom(i){return!!this.getSymbol(i.properties.symbolIndex)[TextPainter.getBloomSymbol()[0]]}createGeometry(i,g,m){const _=i;if(!_.glyphAtlas)return null;const b=super.createGeometry(_,g);if(!b||!b.geometry)return null;const{geometry:T}=b;return T.properties.glyphAtlas&&this.drawDebugAtlas(T.properties.glyphAtlas),T&&_.lineVertex&&(T.properties.line=_.lineVertex,T.properties.line.id=m),b}createMesh(i,g,{tileVectorTransform:m}){const _=this.isEnableCollision(),b=this.isEnableUniquePlacement(),{geometry:T,symbolIndex:P}=i;T.properties.symbolIndex=P;const I=this.getSymbol(P),H=this.getSymbolDef(P),W=this.getFnTypeConfig(P),q=nz.call(this,this.regl,T,g,H,I,W,this.layer.options.collision,!_,b);if(q.length){"line"===T.properties.textPlacement?this._hasLineText=!0:this._hasNormalText=!0}return q.forEach((i=>{i.positionMatrix=this.getAltitudeOffsetMatrix(),i.properties.tileVectorTransform=m})),q}updateCollision(i){super.updateCollision(i);const g=this.scene.getMeshes();g&&g.length?(this._projectedLinesCache={},this._updateLabels(i.timestamp),this._endCollision()):this._endCollision()}callCurrentTileShader(i,g){this.shader.filter=g.sceneFilter?[this._filter0,g.sceneFilter]:this._filter0,this.callRenderer(this.shader,i,g),this._shaderAlongLine.filter=g.sceneFilter?[this._lineFilter0,g.sceneFilter]:this._lineFilter0,this.callRenderer(this._shaderAlongLine,i,g)}callBackgroundTileShader(i,g){this.shader.filter=g.sceneFilter?[this._filter1,g.sceneFilter]:this._filter1,this.callRenderer(this.shader,i,g),this._shaderAlongLine.filter=g.sceneFilter?[this._lineFilter1,g.sceneFilter]:this._lineFilter1,this.callRenderer(this._shaderAlongLine,i,g)}callRenderer(i,g,m){m&&m.isRenderingTerrain&&wL(this.symbolDef.textPitchAlignment)&&(g.textPitchFilter=m.isRenderingTerrainSkin?1:2),super.callRenderer(i,g,m)}_updateLabels(){let i=this.scene.getMeshes();if(!i||!i.length)return;const g=-this.getMap().getBearing()*Math.PI/180,m=Km(oV,g),_=(i,g,m,_)=>{const{start:b,end:T,mesh:P,allElements:I}=g[0];if(this.updateBoxCollisionFading(!0,P,g,m,_)){let g=i.count;for(let m=b;m<T;m++)i[g++]=I[m];i.count=g}},b=this.isEnableCollision(),T=this.layer.getRenderer();i=i.sort(PV);for(let g=0;g<i.length;g++){const P=i[g];if(!this.isMeshIterable(P))continue;if(!T.isTileNearCamera(P)){const{visElemts:i}=P.geometry.properties;i&&(i.count=0),P.geometry.setElements(i,0);continue}const I=P.geometry,H=this.getSymbol(P.properties.symbolIndex);P.properties.textHaloRadius=zF(H.textHaloRadius)?tz.textHaloRadius:H.textHaloRadius;const W=P.properties.meshKey;if("line"===I.properties.textPlacement){if(!I.properties.line)continue;b&&this.startMeshCollision(P),this._updateLineLabel(P,m);const{aOffset:i,aOpacity:g}=I.properties;i.dirty&&(I.updateData("aOffset",i),i.dirty=!1),g&&g.dirty&&(I.updateData("aOpacity",g),g.dirty=!1),b&&this.endMeshCollision(W)}else if(b){this.startMeshCollision(P);const{elements:i,aOpacity:g,visElemts:m}=I.properties;m.count=0,this.forEachBox(P,((i,g,b,T,P)=>{_(m,g,b,T)})),g&&g.dirty&&I.updateData("aOpacity",g);m.count===i.length&&I.count===i.length||!m.count&&!I.count||I.setElements(m,m.count),this.endMeshCollision(W)}}}isMeshIterable(i){return i.isValid()&&i.material&&!i.material.get("isHalo")&&!(this.shouldIgnoreBackground()&&!this.layer.getRenderer().isForeground(i))}isMeshUniquePlaced(i){if(!this.isMeshIterable(i))return!1;return"line"!==this.getSymbol(i.properties.symbolIndex).textPlacement}getUniqueEntryKey(i,g){return mz(i,g)}_updateLineLabel(i,g){const m=this.getMap(),_=i.geometry,b=_.properties;let T=b.line;if(!T)return;const P=m.getPitch(),I=m.getBearing(),{lineTextPitch:H,lineTextBearing:W}=i.properties,q=1===i.material.uniforms.textPitchWithMap,$=b.elements;if(!q){const g=_A(rV,m.projViewMatrix,i.localTransform),_=T.id+"-"+g.join();let P;this._projectedLinesCache[_]?T=this._projectedLinesCache[_]:(P=b.projectedLine=b.projectedLine||new Array(T.length),T=this._projectLine(P,T,g,m.width,m.height),this._projectedLinesCache[_]=P)}const ye=this.isEnableCollision(),Re=_.properties.visElemts=_.properties.visElemts||new $.constructor($.length),Be=_.properties.visCache=_.properties.visCache||[];ye&&(Re.count=0);const Ge=void 0===H||!m.isInteracting()||Math.abs(P-H)>2||Math.abs(I-W)>2;Ge&&(this._meshCollisionStale=!0),this.forEachBox(i,((i,m,_,b)=>{const{start:P,end:I}=m[0];let H=Be[b];if((void 0===H||Ge)&&(H=this._updateLabelAttributes(i,$,P,I,T,_,q?g:null,b)),Be[b]=H,ye&&(H=this.updateBoxCollisionFading(H,i,m,_,b),H)){let i=Re.count;for(let g=P;g<I;g++)Re[i++]=$[g];Re.count=i}})),Ge&&(i.properties.lineTextPitch=P,i.properties.lineTextBearing=I);const je=i.geometry.properties.aAltitude;je&&je.dirty&&(_.updateData("aAltitude",je),je.dirty=!1),!ye||Re.count===$.length&&_.count===Re.count||_.setElements(Re,Re.count)}_projectLine(i,g,m,_,b){const T=function(i,g,m,_,b){for(let T=0;T<g.length;T+=3)wy(JN,g[T],g[T+1],g[T+2],1),KN(JN,JN,m,_,b),i[T]=JN[0],i[T+1]=JN[1],i[T+2]=g[T+2];return i}(i,g,m,_,b);return T}forEachBox(i,g){const m=this.getMap(),_=_A(rV,m.projViewMatrix,i.properties.tileVectorTransform),{collideIds:b,aCount:T,features:P,elements:I}=i.geometry.properties;if(!b)return;const H=this.isEnableUniquePlacement(),W=this._getMeshBoxes(1);W[0].allElements=I,W[0].mesh=i;let q=0,$=I[0],ye=0,Re=b[$];for(let m=0;m<=I.length;m+=6)if($=I[m],b[$]!==Re||m===I.length){const Be=P[Re]&&P[Re].feature;if(H&&this.isMeshUniquePlaced(i)&&Be&&!Be.label){const g=Be.properties||{},{symbolIndex:m}=i.properties,_=m&&this._textNameFn[m.index]?this._textNameFn[m.index](i.properties.z,g):this.getSymbol(i.properties.symbolIndex).textName,b=Zz.resolveText(_,g);Be.label=b}const Ge=m,je=T[I[ye]];for(let m=ye;m<Ge;m+=6*je)W[0].start=m,W[0].end=m+6*je,W[0].boxCount=je,g.call(this,i,W,_,q++);Re=b[$],ye=m}}_updateLabelAttributes(i,g,m,_,b,T,P){const I=this.layer.getRenderer(),H=i.material.uniforms,W=1===H.textPitchWithMap,q=!W&&I.getTerrainHelper&&I.getTerrainHelper(),$=this.isEnableCollision(),ye=this.getMap(),Re=i.geometry,Be=Re.desc.positionSize,{aShape:Ge,aOffset:je,aAnchor:Xe,aAltitude:Ze,aPitchRotation:Ye}=Re.properties;let{aProjectedAnchor:Qe}=Re.properties;Qe||(Qe=Re.properties.aProjectedAnchor=new Array(Xe.length/Be*3));const Je=Re.properties.aTextSize,Ke=!P,et=g[m],tt=et*Be;let at;at=Re.data.aAltitude?qA(sV,Xe[tt],Xe[tt+1],Ze[et]):$z.unpackPosition(sV,Xe[tt],Xe[tt+1],Xe[tt+2]);const ht=KN(aV,at,T,ye.width,ye.height),gt=Re.properties.aTerrainAltitude;let yt;if(gt){const i=gt[et];if(i===PF)return Qe[3*et]=CF,Qe[3*et+1]=CF,Qe[3*et+2]=CF,!1;i?(yt=qA(TV,...at),yt[2]=100*i,yt=KN(yt,yt,T,ye.width,ye.height)):yt=ht}else yt=ht;const vt=ye.getDevicePixelRatio();if(Py(MV,yt,1/vt),ye.isOffscreen(MV))return $||CV(je,g,m,_),Qe[3*et]=CF,Qe[3*et+1]=CF,Qe[3*et+2]=CF,!1;Ke&&(at=ht),Qe[3*et]=yt[0],Qe[3*et+1]=yt[1],Qe[3*et+2]=yt[2];const xt=Ke?1:Re.properties.tileExtent/this.layer.getTileSize().width;let bt=!0;const Tt=g[m],Mt=g[_-1],Pt=Je?Je[Tt]:i.properties.textSize,It=this._updateNormal(i,Pt,b,Tt,Mt,at,sV,xt,P);if(null===It)return CV(je,g,m,_),!1;const Et=Mt-Tt<=3,Lt=Math.floor(It/2),Dt=It%2;for(let P=m;P<_;P+=6){const I=g[P];let ye;if(ye=Lt||P!==m||Et||q?Lt||P!==_-6||Et||q?Vz.call(this,iV,i,Pt,b,I,at,sV,xt,Lt,yt,this.layer,T,W):_V:yV,!ye){bt=!1,$||CV(je,g,m,_);break}let Re=ye[2];Dt&&(Re-=Math.PI/2);const Be=OB(lV,Re,0,H.textRotateWithMap,H.textPitchWithMap),Xe=je.length>Ge.length;let Ze;if(Xe){qA(mV,Ye[3*I],Ye[3*I+1],0);const i=ny(mV,mV),g=-Ye[3*I+2];if(g){const m=Yy(dV,i,g);wA(pV,nV),EA(gV,m),Ze=_A(gV,gV,pV)}}for(let i=0;i<4;i++){const g=2*(I+i);z_(hV,Ge[g]/10,Ge[g+1]/10),W_(hV,hV,Pt/24),Y_(hV,hV,Be),W?(G_(hV,hV,uV),V_(cV,hV,ye),Xe&&(cV[2]=0,Ze&&oy(cV,cV,Ze))):(G_(cV,ye,uV),V_(cV,hV,cV)),fV[0]=10*cV[0],fV[1]=10*cV[1],Xe&&(fV[2]=10*cV[2]);const m=(Xe?3:2)*(I+i);(je[m]!==fV[0]||je[m+1]!==fV[1]||Xe&&je[m+2]!==fV[2])&&(je.dirty=!0,je[m]=fV[0],je[m+1]=fV[1],Xe&&(je[m+2]=fV[2]))}}return bt}_updateNormal(i,g,m,_,b,T,P,I,H){const W=b-_<=3,q=this.getMap(),$=this.getSymbol(i.geometry.properties.symbolIndex);return W?0:jz.call(this,yV,_V,i,g,m,_,b,T,P,I,q.width/q.height,H,$.textMaxAngle||Qz)}isBoxCollides(i,g,m,_,b,T){return this.isLabelCollides(0,i,g,m,_,b,T)}deleteMesh(i,g){i&&(g&&(Array.isArray(i)?i.forEach((i=>{i&&i.material&&delete i.material.uniforms.texture})):i.material&&delete i.material.uniforms.texture),super.deleteMesh(i,g))}delete(){super.delete(),this._shaderAlongLine.dispose(),delete this._projectedLinesCache,this._linePicking&&this._linePicking.dispose()}isUniqueStencilRefPerTile(){return!1}isEnableTileStencil(){return!this.layer.getRenderer().isEnableWorkAround("win-intel-gpu-crash")}init(){this.renderer=new wP.Renderer(this.regl);const{uniforms:i,extraCommandProps:g}=hz.call(this,this.canvas,this.sceneConfig),m=this.canvas;g.viewport={x:(i,g)=>g.viewport?g.viewport.x:0,y:(i,g)=>g.viewport?g.viewport.y:0,width:(i,g)=>g.viewport?g.viewport.width:m?m.width:1,height:(i,g)=>g.viewport?g.viewport.height:m?m.height:1},this.shader=new wP.MeshShader({vert:Wz,frag:Xz,uniforms:i,extraCommandProps:g});let _=g;if(this.layer.getRenderer().isEnableWorkAround("win-intel-gpu-crash")&&(_=NF({},g),_.stencil=NF({},g.stencil),_.stencil.enable=!0,_.stencil.func.cmp="<",_.stencil.func.ref=(i,g)=>2*g.level+(g.isHalo||0)+1),this._shaderAlongLine=new wP.MeshShader({vert:qz,frag:Xz,uniforms:i,extraCommandProps:_}),this.pickingFBO){const g=new wP.FBORayPicking(this.renderer,{vert:"#define PICKING_MODE 1\n"+Wz,uniforms:i,extraCommandProps:{viewport:this.pickingViewport}},this.pickingFBO,this.getMap());g.filter=i=>"line"!==this.getSymbol(i.properties.symbolIndex).textPlacement;const m=new wP.FBORayPicking(this.renderer,{vert:"#define PICKING_MODE 1\n"+qz,uniforms:i,extraCommandProps:{viewport:this.pickingViewport}},this.pickingFBO,this.getMap());m.filter=i=>"line"===i.geometry.properties.textPlacement,this.picking=[g,m]}}getUniformValues(i,g){const m=g&&g.isRenderingTerrainSkin,_=this.layer.getTileSize().width,b=m?SV:i.projViewMatrix,T=i.cameraToCenterDistance,P=z_(AV,i.width,i.height);m&&z_(P,_,_);const I=dF(i.getResolution(),i);return{layerScale:this.layer.options.styleScale||1,mapPitch:i.getPitch()*Math.PI/180,mapRotation:i.getBearing()*Math.PI/180,projViewMatrix:b,viewMatrix:i.viewMatrix,cameraToCenterDistance:T,canvasSize:P,glyphSize:24,gammaScale:1*(this.layer.options.textGamma||1),resolution:i.getResolution(),altitudeScale:I,viewport:m&&g&&g.viewport,textPitchFilter:0,isRenderingTerrain:+!!m}}}function CV(i,g,m,_){for(let b=m;b<_;b+=6){const m=g[b];for(let g=0;g<4;g++){const _=3*(m+g);(i[_]||i[_+1]||i[_+2])&&(i.dirty=!0,i[_]=0,i[_+1]=0,i[_+2]=0)}}}function PV(i,g){const m=i.properties.level-g.properties.level;return 0===m?i.properties.meshKey-g.properties.meshKey:m}var IV="#define SHADER_NAME NATIVE_POINT\n\n#include <gl2_vert>\n\n\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\n#ifdef HAS_COLOR\n\n    attribute vec4 aColor;\n\n    varying vec4 vColor;\n\n#endif\n\n\n\nuniform mat4 positionMatrix;\n\nuniform mat4 projViewModelMatrix;\n\nuniform float markerSize;\n\n\n\n#ifdef PICKING_MODE\n\n    #include <fbo_picking_vert>\n\n#endif\n\n\n\n#include <vt_position_vert>\n\n\n\nvoid main() {\n\n    vec3 position = unpackVTPosition();\n\n    gl_Position = projViewModelMatrix * positionMatrix * vec4(position, 1.0);\n\n    gl_PointSize = markerSize;\n\n\n\n    #ifdef HAS_COLOR\n\n        vColor = aColor / 255.0;\n\n    #endif\n\n\n\n    #ifdef PICKING_MODE\n\n        fbo_picking_setData(gl_Position.w, true);\n\n    #endif\n\n}\n\n";const kV={markerFill:[0,0,0],markerOpacity:1,markerSize:10};class NativePointPainter extends BasicPainter{getPrimitive(){return this.isWebGPU()?"triangles":"points"}isTerrainSkin(){return!1}isTerrainVector(){return this.layer.options.awareOfTerrain}isUniqueStencilRefPerTile(){return!1}createMesh(i,g){const{geometry:m,symbolIndex:_,ref:b}=i,T=this.getSymbol(_);if(void 0===b){FN(m,this.getSymbolDef(_),this.getFnTypeConfig(_),this.layer),this.isWebGPU()||m.generateBuffers(this.regl)}const P={};UF(P,"markerOpacity",T,"markerOpacity",1),UF(P,"markerSize",T,"markerSize",10),UF(P,"markerFill",T,"markerFill","#000",WF(this.colorCache,3));const I=new wP.Material(P,kV);I.createDefines=()=>"square"!==T.markerType?{USE_CIRCLE:1}:null,I.appendDefines=i=>("square"!==T.markerType&&(i.USE_CIRCLE=1),i);const H={castShadow:!1,picking:!0};let W;if(this.isWebGPU()){const{aPosition:i,aAltitude:g}=m.data,_=new Int16Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),b=new wP.Geometry({aPosition:_},6,0,{positionSize:2});b.generateBuffers(this.regl),W=new wP.InstancedMesh({instancePosition:i,instanceAltitude:g},m.getVertexCount(),b,I,H),W.generateInstancedBuffers(this.regl)}else W=new wP.Mesh(m,I,H);const q={};return W.geometry.data.aAltitude&&(q.HAS_ALTITUDE=1),m.data.aColor&&(q.HAS_COLOR=1),W.setDefines(q),W.positionMatrix=this.getAltitudeOffsetMatrix(),W.setLocalTransform(g),W.properties.symbolIndex=_,W}createFnTypeConfig(i,g){const m=ML(g.markerFill);return[{attrName:"aColor",symbolName:"markerFill",type:Uint8Array,width:4,define:"HAS_COLOR",evaluate:(g,_)=>{let b=m(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,_,i,g,!0)),Array.isArray(b)||(b=this.colorCache[b]=this.colorCache[b]||iL(b).unitArray()),b=jF(b),b}}]}init(){this.renderer=new wP.Renderer(this.regl);const i=[],g={name:"vt-native-point",vert:IV,frag:"#define SHADER_NAME NATIVE_POINT\n\nprecision mediump float;\n\n#include <gl2_frag>\n\n\n\n#ifdef USE_CIRCLE\n\n    #if __VERSION__ == 100\n\n        #ifdef GL_OES_standard_derivatives\n\n            #define STANDARD_DERIVATIVES_ENABLED 1\n\n            #extension GL_OES_standard_derivatives : enable\n\n        #endif\n\n    #else\n\n        #define STANDARD_DERIVATIVES_ENABLED 1\n\n    #endif\n\n#endif\n\n\n\n#ifdef HAS_COLOR\n\n    varying vec4 vColor;\n\n#else\n\n    uniform vec3 markerFill;\n\n#endif\n\n\n\nuniform float markerOpacity;\n\nuniform float layerOpacity;\n\n\n\nvoid main() {\n\n    float alpha = 1.0;\n\n    #ifdef USE_CIRCLE\n\n        float r = 0.0, delta = 0.0;\n\n        vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\n        r = dot(cxy, cxy);\n\n        if (r > 1.0) {\n\n            discard;\n\n        }\n\n        #ifdef STANDARD_DERIVATIVES_ENABLED\n\n            delta = fwidth(r);\n\n            alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n\n        #endif\n\n    #endif\n\n\n\n    #ifdef HAS_COLOR\n\n        vec4 pointColor = vColor;\n\n    #else\n\n        vec4 pointColor = vec4(markerFill, 1.0);\n\n    #endif\n\n    glFragColor = pointColor * markerOpacity * alpha * layerOpacity;\n\n\n\n    #if __VERSION__ == 100\n\n        gl_FragColor = glFragColor;\n\n    #endif\n\n}\n\n",wgslVert:"struct InstanceInput {\n    @location($i) aPosition: vec2i,\n#ifdef HAS_ALTITUDE\n    @location($i) instancePosition: vec2i,\n    @location($i) instanceAltitude: f32,\n#else\n    @location($i) instancePosition: vec4i,\n#endif\n#ifndef PICKING_MODE\n    #ifdef HAS_COLOR\n        @location($i) aColor: vec4u,\n    #endif\n#endif\n};\nstruct VertexInput {\n#ifdef HAS_ALTITUDE\n    aPosition: vec2i,\n    aAltitude: f32,\n#else\n    aPosition: vec4i,\n#endif\n}\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    #ifndef PICKING_MODE\n        #ifdef HAS_COLOR\n            @location($o) vColor: vec4f,\n        #endif\n    #endif\n};\nstruct MarkerUniforms {\n    positionMatrix: mat4x4f,\n    projViewModelMatrix: mat4x4f,\n    markerSize: f32,\n};\n@group(0) @binding($b) var<uniform> uniforms: MarkerUniforms;\n@group(0) @binding($b) var<uniform> resolution: vec2f;\n#ifdef PICKING_MODE\n    #include <fbo_picking_vert>\n#endif\n#include <vt_position_vert>\n@vertex\nfn main(\n    input: InstanceInput\n) -> VertexOutput {\n    var out: VertexOutput;\n    var inputVertex: VertexInput;\n    inputVertex.aPosition = input.instancePosition;\n    #ifdef HAS_ALTITUDE\n        inputVertex.aAltitude = input.instanceAltitude;\n    #endif\n    let position = unpackVTPosition(inputVertex);\n    out.position = uniforms.projViewModelMatrix * uniforms.positionMatrix * vec4f(position, 1.0);\n    let markerSize = uniforms.markerSize / resolution;\n    let w = out.position.w;\n    out.position.x += f32(input.aPosition.x) * markerSize.x * w;\n    out.position.y += f32(input.aPosition.y) * markerSize.y * w;\n    #ifndef PICKING_MODE\n        #ifdef HAS_COLOR\n            out.vColor = input.aColor / 255.0;\n        #endif\n    #endif\n    #ifdef PICKING_MODE\n        fbo_picking_setData(w, true);\n    #endif\n    return out;\n}",wgslFrag:"struct MarkerFragmentUniforms {\n    markerOpacity: f32,\n    #ifndef HAS_COLOR\n        markerFill: vec3f,\n    #endif\n}\n@group(0) @binding($b) var<uniform> uniforms: MarkerFragmentUniforms;\n@group(0) @binding($b) var<uniform> layerOpacity: f32;\n#ifdef HAS_COLOR\nstruct VertexOuput {\n    @location($i) vColor: vec4f,\n}\n#endif\n@fragment\nfn main(\n    #ifdef HAS_COLOR\n    vertexOutput: VertexOuput,\n    #endif\n) -> @location(0) vec4f {\n    var alpha: f32 = 1.0;\n    #ifdef USE_CIRCLE\n    #endif\n    var pointColor: vec4f;\n    #ifdef HAS_COLOR\n        pointColor = vertexOutput.vColor;\n    #else\n        pointColor = vec4f(uniforms.markerFill, 1.0);\n    #endif\n    return pointColor * uniforms.markerOpacity * alpha * layerOpacity;\n}",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(g,m){return _A(i,m.projViewMatrix,m.modelMatrix),i}}],defines:null,extraCommandProps:{viewport:{x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},depth:{enable:!0,mask:!1,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"always"},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"}}};if(this.shader=new wP.MeshShader(g),this.shader.version=300,this.pickingFBO){const i=[];this.picking=[new wP.FBORayPicking(this.renderer,{vert:"#define PICKING_MODE 1\n"+IV,uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(g,m){return _A(i,m.projViewMatrix,m.modelMatrix),i}}],extraCommandProps:{viewport:this.pickingViewport}},this.pickingFBO,this.getMap())]}}getUniformValues(i){return{projViewMatrix:i.projViewMatrix,resolution:[this.canvas.width,this.canvas.height]}}}var OV="#define SHADER_NAME NATIVE_LINE\n\n\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nuniform mat4 projViewModelMatrix;\n\nuniform mat4 positionMatrix;\n\n\n\n#ifndef PICKING_MODE\n\n    #if defined(HAS_COLOR)\n\n        attribute vec4 aColor;\n\n        varying vec4 vColor;\n\n    #endif\n\n#else\n\n    #include <fbo_picking_vert>\n\n#endif\n\n\n\n#include <vt_position_vert>\n\n\n\nvoid main() {\n\n    vec3 position = unpackVTPosition();\n\n    gl_Position = projViewModelMatrix * positionMatrix * vec4(position, 1.0);\n\n\n\n    #ifndef PICKING_MODE\n\n        #if defined(HAS_COLOR)\n\n            vColor = aColor / 255.0;\n\n        #endif\n\n    #else\n\n        fbo_picking_setData(gl_Position.w, true);\n\n    #endif\n\n}\n\n",EV="struct VertexInput {\n#ifdef HAS_ALTITUDE\n    @location($i) aPosition: vec2i,\n    @location($i) aAltitude: f32,\n#else\n    @location($o) aPosition: vec4i,\n#endif\n#ifndef PICKING_MODE\n    #if HAS_COLOR\n        @location($i) aColor: vec4u,\n    #endif\n#endif\n}\nstruct MyAppUniforms {\n    projViewModelMatrix: mat4x4f,\n    positionMatrix: mat4x4f,\n};\n@group(0) @binding($b) var<uniform> uniforms: MyAppUniforms;\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n#ifndef PICKING_MODE\n    #if HAS_COLOR\n        @location($o) vColor: vec4f,\n    #endif\n#endif\n}\n#ifndef PICKING_MODE\n    #include <fbo_picking_vert>\n#endif\n#include <vt_position_vert>\n@vertex\nfn main(\n    vertexInput: VertexInput\n) -> VertexOutput {\n    var out: VertexOutput;\n    let position = unpackVTPosition(vertexInput);\n    out.position = uniforms.projViewModelMatrix * uniforms.positionMatrix * vec4f(position, 1.0);\n    #ifndef PICKING_MODE\n        #if HAS_COLOR\n            out.vColor = vertexInputWithColor.aColor / 255.0;\n        #endif\n    #else\n        fbo_picking_setData(vertexInput, &out, out.position.w, true);\n    #endif\n    return out;\n}";const RV=mA([]);class NativeLinePainter extends BasicPainter{constructor(i,g,m,_,b,T){if(super(i,g,m,_,b,T),this.primitive="lines",wL(this.symbolDef.lineColor)){const i=g.getMap(),m=ML(this.symbolDef.lineColor);this.colorSymbol=g=>m(i.getZoom(),g)}}needPolygonOffset(){return!0}createMesh(i,g){const{geometry:m,symbolIndex:_,ref:b}=i,T=this.getSymbol(_),P=this.getMeshUniforms(m,T);void 0===b&&m.generateBuffers(this.regl);const I=new wP.Material(P),H=new wP.Mesh(m,I,{castShadow:!1,picking:!0});H.setLocalTransform(g),H.properties.symbolIndex=_;const W={};return H.geometry.data.aAltitude&&(W.HAS_ALTITUDE=1),H.setDefines(W),H}getMeshUniforms(i,g){const m={};return UF(m,"lineColor",g,"lineColor","#000",WF(this.colorCache)),UF(m,"lineOpacity",g,"lineOpacity",1),m}isEnableTileStencil(i){return!!!(i&&i.isRenderingTerrain&&this.isTerrainSkin())}init(){this.renderer=new wP.Renderer(this.regl);const i=this.canvas,g=[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}}],m={name:"vt-native-line",vert:OV,frag:"#define SHADER_NAME NATIVE_LINE\n\nprecision mediump float;\n\n\n\nuniform float lineOpacity;\n\nuniform vec4 lineColor;\n\nuniform float layerOpacity;\n\n\n\n#if defined(HAS_COLOR)\n\n    varying vec4 vColor;\n\n#endif\n\n\n\nvoid main()\n\n{\n\n    gl_FragColor = lineColor * lineOpacity;\n\n    #if defined(HAS_COLOR)\n\n        gl_FragColor *= vColor;\n\n    #endif\n\n    gl_FragColor *= layerOpacity;\n\n}\n\n",wgslVert:EV,wgslFrag:"struct Uniforms {\n    lineOpacity: f32,\n    lineColor: vec4f,\n};\n@group(0) @binding($b) var<uniform> uniforms: Uniforms;\n@group(0) @binding($b) var<uniform> layerOpacity: f32;\n#if HAS_COLOR\n    struct VertexOuput {\n        @location(0) vColor: vec4f,\n    };\n#endif\n@fragment\nfn main(\n    #if HAS_COLOR\n        input: VertexOuput\n    #endif\n) -> @location(0) vec4f {\n    var outputColor: vec4f = uniforms.lineColor * uniforms.lineOpacity;\n    #if HAS_COLOR\n        outputColor *= input.vColor;\n    #endif\n    outputColor *= layerOpacity;\n    return outputColor;\n}",uniforms:g,defines:null,extraCommandProps:{viewport:{x:(i,g)=>g.viewport?g.viewport.x:0,y:(i,g)=>g.viewport?g.viewport.y:0,width:(g,m)=>m.viewport?m.viewport.width:i?i.width:1,height:(g,m)=>m.viewport?m.viewport.height:i?i.height:1},stencil:{enable:(i,g)=>this.isEnableTileStencil(g.painterContext),func:{cmp:()=>this.isOnly2D()?"=":"<=",ref:(i,g)=>g.stencilRef},op:{fail:"keep",zfail:"keep",zpass:"replace"}},depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"<="},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}}};this.shader=new wP.MeshShader(m),this.pickingFBO&&(this.picking=[new wP.FBORayPicking(this.renderer,{wgslVert:EV,vert:OV,uniforms:g,defines:{PICKING_MODE:1},extraCommandProps:{viewport:this.pickingViewport}},this.pickingFBO,this.getMap())])}getUniformValues(i,g){const m=g&&g.isRenderingTerrainSkin;return{projViewMatrix:m?RV:i.projViewMatrix,viewport:m&&g&&g.viewport}}getPrimitive(){return"lines"}}const{DEFAULT_TEX_WIDTH:LV}=JD(),DV=[1,1,1],FV=[1,1,1,1],NV=[0,0],HV=[1,1],BV=[],zV=new pl(0,0),VV=new pl(0,0),UV=[],GV=[];class MeshPainter extends Painter{isEnableTileStencil(){return!1}supportRenderMode(i){return this.isAnimating()?"fxaa"===i||"fxaaAfterTaa"===i:"taa"===i||"fxaa"===i}isTerrainSkin(){return!1}isTerrainVector(){return this.layer.options.awareOfTerrain}isAnimating(){return!1}createMesh(i,g,{tilePoint:m}){if(!this.material)return this.setToRedraw(),null;const{geometry:_,symbolIndex:b}=i,T=this.layer instanceof Up,P=new wP.Mesh(_,this.material);if(this.sceneConfig.animation){DV[2]=.01;const i=[];TA(i,DV),_A(i,g,i),g=i}const I=this.getSymbolDef(b),H=this.getFnTypeConfig(b);FN(_,I,H,this.layer);const W=this.getShader(),q=W.getGeometryDefines?W.getGeometryDefines(_):{},$=this.getSymbol(b),ye=WF(this.colorCache);if(_.data.aExtrude){q.IS_LINE_EXTRUSION=1;const{tileResolution:i,tileRatio:g}=_.properties,m=this.getMap();Object.defineProperty(P.uniforms,"linePixelScale",{enumerable:!0,get:function(){return g*m.getResolution()/i}}),UF(P.uniforms,"lineWidth",$,"lineWidth",4),UF(P.uniforms,"lineOpacity",$,"lineOpacity",1),UF(P.uniforms,"lineColor",$,"lineColor","#fff",ye),Object.defineProperty(P.uniforms,"lineHeight",{enumerable:!0,get:()=>{const i=this.dataConfig.defaultAltitude*(this.dataConfig.altitudeScale||1);return ZF(i)?i:0}})}else{UF(P.uniforms,"polygonFill",$,"polygonFill",FV,ye),UF(P.uniforms,"polygonOpacity",$,"polygonOpacity",1);const i=[];Object.defineProperty(P.uniforms,"vertexColorsOfType",{enumerable:!0,get:()=>{const g=ye($.bottomPolygonFill||FV),m=ye($.topPolygonFill||FV);i[0]=g[0],i[1]=g[1],i[2]=g[2],i[3]=g[3],i[4]=m[0],i[5]=m[1],i[6]=m[2],i[7]=m[3];const _=P.geometry.properties.vertexColors;if(_){let g=8;i.length=8+_.length;for(let m=0;m<_.length;m++)i[g++]=_[m][0],i[g++]=_[m][1],i[g++]=_[m][2],i[g++]=_[m][3]}return i}})}if(_.data.aColor&&(q.HAS_COLOR=1),_.data.aOpacity&&(q.HAS_OPACITY=1),_.data.aLineWidth&&(q.HAS_LINE_WIDTH=1),_.data.aLineHeight&&(q.HAS_LINE_HEIGHT=1),_.data.aTerrainAltitude&&(q.HAS_TERRAIN_ALTITUDE=1),_.data.aVertexColorType){const i=P.geometry.properties.vertexColors;let g=2;i&&(g+=i.length),q.VERTEX_TYPES_COUNT=g}if(_.data.aOpacity){const i=_.data.aOpacity;for(let g=0;g<i.length;g++)if(i[g]<255){_.properties.hasAlpha=!0;break}}q.HAS_MIN_ALTITUDE=1,q.HAS_LAYER_OPACITY=1,_.generateBuffers(this.regl),P.setDefines(q),P.setPositionMatrix(this.getAltitudeOffsetMatrix()),P.setLocalTransform(g),(_.properties.maxAltitude<=0||P.properties.level>=3)&&(P.castShadow=!1),P.setUniform("maxAltitude",P.geometry.properties.maxAltitude),Object.defineProperty(P.uniforms,"minAltitude",{enumerable:!0,get:()=>this.layer.options.altitude||0});const{tileResolution:Re}=_.properties,Be=this.getMap(),Ge=this.layer.getRenderer(),je=Be.pointAtResToCoord(new un(m),Re),Xe=function(i,g,m,_){return i.pointAtResToDistance(g,0,_,m)}(Be,1,je,Re),Ze=[];Object.defineProperty(P.uniforms,"uvOrigin",{enumerable:!0,get:()=>this._computeUVOffset(Ze,b,m,Re,Xe,T)}),P.setUniform("uvOffset",[0,0]),Object.defineProperty(P.uniforms,"hasAlpha",{enumerable:!0,get:()=>{const i=this.getSymbol(b);return _.properties.hasAlpha||i.polygonOpacity<1||i.lineOpacity<1||P.material&&(P.material.uniforms.baseColorTexture||P.material.uniforms.emissiveTexture)}});const Ye=this.layer.getMap().getMaxNativeZoom();return Object.defineProperty(P.uniforms,"stencilRef",{enumerable:!0,get:()=>Ge.isForeground(P)?0:Ye-P.properties.tile.z}),P.properties.symbolIndex=b,P}_computeUVOffset(i,g,m,_,b,T){if(1===this.dataConfig.topUVMode)return i[0]=0,i[1]=0,i;const P=this.getMap(),I=this.getSymbol(g).material;let H=m;!this.dataConfig.side&&I&&I.textureOrigin&&(zV.set(I.textureOrigin[0],I.textureOrigin[1]),P.coordToPointAtRes(zV,_,VV),H=z_(UV,m[0]-VV.x,m[1]-VV.y));const W=!!I&&I.uvOffsetInMeter;let q=I&&I.uvOffset||NV;const $=this.getUVOffsetAnim();$&&(q=this.getUVOffset($));const ye=I&&I.uvScale||HV;let Re=this.dataConfig.side?0:H[0],Be=this.dataConfig.side?0:H[1];const Ge=I&&I.textureWidth||LV;W&&(Re+=q[0]/b,Be+=q[1]/b);const je=z_(i,Re*b*ye[0]/Ge+(W?0:q[0]),Be*b*ye[1]/(Ge*ye[1]/ye[0])+(W?0:q[1]));return T||(je[1]*=-1),je}callShader(i,g){const m=this.sceneConfig.cullFace;this.sceneConfig.cullFace="front",this.callBackgroundTileShader(i,g),void 0===m?delete this.sceneConfig.cullFace:this.sceneConfig.cullFace=m,super.callShader(i,g)}getShadowMeshes(){if(!this.isVisible())return BV;this.shadowCount=this.scene.getMeshes().length;const i=this.scene.getMeshes().filter((i=>0===i.properties.level));for(let g=0;g<i.length;g++){const m=i[g];m.material!==this.material&&m.setMaterial(this.material)}return i}getUVOffsetAnim(){const i=this.getSymbols()[0];return i.material&&i.material.uvOffsetAnim}getUVOffset(i){const g=this.getSymbols()[0],m=g.material&&g.material.uvOffset||NV,_=!!g.material&&g.material.uvOffsetInMeter,b=performance.now()/1e3,T=z_(GV,m[0],m[1]);return T[0]=b*i[0],T[1]=b*i[0],_||(T[0]%=1,T[1]%=1),T}needPolygonOffset(){return this._needPolygonOffset}startFrame(...i){return delete this._needPolygonOffset,super.startFrame(...i)}addMesh(i,g){i.forEach((i=>{this._prepareMesh(i,g)})),super.addMesh(...arguments)}_prepareMesh(i,g){if(null!==g){const m=i.localTransform;0===g&&(g=.01),DV[2]=g,TA(m,DV),_A(m,i.properties.tileTransform,m),i.setLocalTransform(m)}else i.setLocalTransform(i.properties.tileTransform);i.material!==this.material&&i.setMaterial(this.material),i.geometry.properties.maxAltitude<=0&&(this._needPolygonOffset=!0),i.ssr=this.getSymbol(i.properties.symbolIndex).ssr?1:0}deleteMaterial(){this.material&&(this.material.dispose(),delete this.material)}deleteMesh(i,g){if(i)if(this.scene.removeMesh(i),Array.isArray(i))for(let m=0;m<i.length;m++)g||(i[m].geometry.dispose(),delete i[m].geometry.properties.layer),i[m].dispose();else g||(i.geometry.dispose(),delete i.geometry.properties.layer),i.dispose()}updateDataConfig(i,g){return!("line-extrusion"===this.dataConfig.type&&!i.altitudeProperty&&!g.altitudeProperty)}createFnTypeConfig(i,g){const m=ML(g.polygonFill||g.lineColor),_=SL(g.polygonOpacity||g.lineOpacity),b=SL(g.lineWidth),T=new Uint8Array(1),P=new Uint16Array(1);return[{attrName:"aColor",type:Uint8Array,width:4,symbolName:g.polygonFill?"polygonFill":g.lineColor?"lineColor":"polygonFill",define:"HAS_COLOR",evaluate:(g,_)=>{let b=m(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,_,i,g,!0)),Array.isArray(b)||(b=this.colorCache[b]=this.colorCache[b]||iL(b).unitArray()),b=jF(b),b}},{attrName:"aOpacity",type:Uint8Array,width:1,symbolName:g.polygonOpacity?"polygonOpacity":g.lineOpacity?"lineOpacity":"polygonOpacity",evaluate:(g,m)=>{let b=_(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,m,i,g,!1)),T[0]=255*b,T[0]<255&&(m.properties.hasAlpha=!0),T[0]}},{attrName:"aLineWidth",type:Uint8Array,width:1,symbolName:"lineWidth",define:"HAS_LINE_WIDTH",evaluate:g=>{const m=b(i.getZoom(),g);return P[0]=Math.round(2*m),P[0]}}]}updateSymbol(i,g){let m=!1;i&&i.material&&(m=function(i,g){for(const m in g)if(WV[m]&&g[m]!==i[m]&&(!i[m]||!g[m]))return!0;return!1}(this.symbolDef[0].material||{},i.material));const _=super.updateSymbol(i,g);return i&&i.material&&this._updateMaterial(i.material),m||_}_isNeedRefreshStyle(i,g){return jV(i)!==jV(g)}}function jV(i){if(!i||!i.material)return!1;for(const g in i.material)if(g.indexOf("Texture")>0&&i.material[g])return!0;return!1}const WV={normalTexture:1,bumpTexture:1};const qV=wP.ShaderLib.get("mesh_picking_vert"),XV=wP.WgslShaderLib.get("mesh_picking").vert;class PhongPainter extends MeshPainter{createGeometry(i){const g=i.data,m=this.getSymbols()[0];if(m.material&&m.material.extrusionOpacity){const i=new Uint8Array(g.aPosition.length/3);for(let m=0;m<g.aPosition.length;m+=3)i[m/3]=g.aPosition[m+2]>0?0:1;g.aExtrusionOpacity=i}const _=new wP.Geometry(g,i.indices);return NF(_.properties,i.properties),this._prepareFeatureIds(_,i),{geometry:_,symbolIndex:{index:0}}}updateSceneConfig(i){let g;if(this.sceneConfig.cullFace!==i.cullFace&&(g=!0),NF(this.sceneConfig,i),g){const i=this.getShaderConfig();this.shader.dispose(),this.shader=new wP.PhongShader(i)}this.setToRedraw()}getShader(){return this.shader}delete(i){this.getMap().off("updatelights",this._updateLights,this),super.delete(i),this.material.dispose()}init(){this.getMap().on("updatelights",this._updateLights,this);this.renderer=new wP.Renderer(this.regl);const i=this.getShaderConfig();this.shader=new wP.PhongShader(i),this._updateMaterial();const g={vert:this.getPickingVert(),wgslVert:this.getPickingWGSLVert(),uniforms:["projViewMatrix","modelMatrix","positionMatrix",{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A([],g.projViewMatrix,g.modelMatrix)}}],extraCommandProps:{viewport:this.pickingViewport}};this.picking=[new wP.FBORayPicking(this.renderer,g,this.layer.getRenderer().pickingFBO,this.getMap())]}_updateLights(){this.setToRedraw()}getShaderConfig(){const i=this.canvas,g={x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1};return{extraCommandProps:{cull:{enable:()=>void 0===this.sceneConfig.cullFace||!!this.sceneConfig.cullFace,face:()=>{let i=this.sceneConfig.cullFace;return!0===i&&(i="back"),i||"back"}},stencil:{enable:!0,func:{cmp:"<=",ref:(i,g)=>g.level},op:{fail:"keep",zfail:"keep",zpass:"replace"}},depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"<="},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},viewport:g,polygonOffset:{enable:!0,offset:this.getPolygonOffset()}}}}_updateMaterial(){this.material&&this.material.dispose();const i=this.layer instanceof Up,g=this.getSymbols()[0].material,m={};for(const _ in g)YF(g,_)&&(m[_]=g[_],"uvRotation"===_&&(m[_]=m[_]*Math.PI/180,i||(m[_]*=-1)));this.material=new wP.PhongMaterial(m)}getUniformValues(i,g){const m=i.viewMatrix,_=i.projMatrix,b=i.cameraPosition,T=this._getLightUniformValues(),P=NF({viewMatrix:m,projMatrix:_,cameraPosition:b,projViewMatrix:i.projViewMatrix},T);P.halton=g&&g.jitter?g.jitter:[0,0];const I=this.layer.getRenderer().canvas;return P.outSize=[I.width,I.height],P}getPickingVert(){return qV}getPickingWGSLVert(){return XV}_getLightUniformValues(){const i=this.getMap().getLightManager(),g=i&&i.getAmbientLight()||{},m=i&&i.getDirectionalLight()||{};return{ambientColor:g.color||[.2,.2,.2],light0_diffuse:[...m.color||[.1,.1,.1],1],lightSpecular:m.specular||[.8,.8,.8],light0_viewDirection:m.direction||[1,1,-1]}}}const ZV=[1,1,1];class WireframePainter extends Painter{createGeometry(i){const{data:g,indices:m}=i,_=new wP.Geometry(g,m,0,{primitive:"lines"});return _.generateBuffers(this.regl),{geometry:_,symbolIndex:{index:0}}}createMesh(i,g){const{geometry:m}=i,_=new wP.Mesh(m);if(_.castShadow=!1,this.sceneConfig.animation){ZV[2]=.01;const i=[];TA(i,ZV),_A(i,g,i),g=i}return _.setLocalTransform(g),_.properties.symbolIndex={index:0},_}addMesh(i,g){if(!i.length)return this;let m;null!==g?(0===g&&(g=.01),m=i[0].localTransform,ZV[2]=g,TA(m,ZV),_A(m,i[0].properties.tileTransform,m)):m=i[0].properties.tileTransform;for(let g=0;g<i.length;g++)i[g].setLocalTransform(m);return this.scene.addMesh(i),this}init(){const i=this.regl;this.scene=new wP.Scene,this.renderer=new wP.Renderer(i);const g={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},m={vert:"\n    attribute vec3 aPosition;\n    attribute vec4 aColor;\n\n    uniform mat4 projViewModelMatrix;\n    uniform vec2 outSize;\n\n    varying vec4 vColor;\n\n    void main()\n    {\n        gl_Position = projViewModelMatrix * vec4(aPosition, 1.0);\n        vColor = aColor / 255.0;\n    }\n",frag:"\n    #ifdef GL_ES\n        precision lowp float;\n    #endif\n\n    uniform float opacity;\n\n    varying vec4 vColor;\n\n    void main()\n    {\n        gl_FragColor = vColor * opacity;\n    }\n",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}}],extraCommandProps:{stencil:{enable:!0,func:{cmp:"<=",ref:(i,g)=>g.level},op:{fail:"keep",zfail:"keep",zpass:"replace"}},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},viewport:g}};this.shader=new wP.MeshShader(m)}getUniformValues(i){const g=this.sceneConfig.opacity||.3,m=this.layer.getRenderer().canvas;return{projViewMatrix:i.projViewMatrix,outSize:[m.width,m.height],opacity:g}}}const $V=wP.ShaderLib.get("mesh_picking_vert"),YV=wP.WgslShaderLib.get("mesh_picking").vert,{getPBRUniforms:QV}=wP.pbr.PBRUtils;class StandardPainter extends MeshPainter{constructor(...i){super(...i),this._loader=new wP.ResourceLoader(null,this.layer.getURLModifier())}supportRenderMode(i){return this.getSymbols()[0].ssr?"fxaa"===i||"fxaaAfterTaa"===i:super.supportRenderMode(i)}isAnimating(){const i=this._getUVOffsetAnim();if(i&&(i[0]||i[1]))return!0}needToRedraw(){const i=this._getUVOffsetAnim();return!(!i||!i[0]&&!i[1])||super.needToRedraw()}_getUVOffsetAnim(){const i=this.getSymbols()[0];return i.material&&i.material.uvOffsetAnim}createGeometry(i){if(!i.data||!i.data.aPosition||!i.data.aPosition.length)return null;const g={uv0Attribute:"aTexCoord0"};i.data.aAltitude&&(g.altitudeAttribute="aAltitude");const m=new wP.Geometry(i.data,i.indices,0,g);return NF(m.properties,i.properties),i.vertexColors&&(m.properties.vertexColors=i.vertexColors),this.material.uniforms.normalTexture&&!m.data[m.desc.tangentAttribute]&&m.data[m.desc.uv0Attribute]&&(m.data[m.desc.normalAttribute]||m.createNormal(),m.createTangent()),this._prepareFeatureIds(m,i),{geometry:m,symbolIndex:{index:0}}}paint(i){const g=!!i.shadow;i.states&&i.states.includesChanged&&(this.shader.dispose(),delete this.shader,this._updateDepthShader.dispose(),delete this._updateDepthShader,this._createShader(i));let m=!!i.ssr&&this.getSymbols()[0].ssr;const _=this.shader,b=_.shaderDefines;if(m){const g=NF({},b,i.ssr.defines);_.shaderDefines=g}if(i.onlyUpdateDepthInTaa&&(this.shader=this._updateDepthShader,!m&&this._previousSSR&&(this.shader=_,this.setToRedraw(!0))),this.updateIBLDefines(_),super.paint(i),void 0!==this.shadowCount&&g){const i=this.scene.getMeshes().length;this.shadowCount!==i&&this.setToRedraw()}this.shader=_,m&&(_.shaderDefines=b),delete this.shadowCount,this._previousSSR=m}updateSceneConfig(i){NF(this.sceneConfig,i),this.setToRedraw()}delete(){super.delete(),this.disposeIBLTextures(),this.material.dispose(),this._updateDepthShader&&(this._updateDepthShader.dispose(),delete this._updateDepthShader)}init(i){this.getMap().on("updatelights",this._onUpdatelights,this),this.createIBLTextures(),this._context=this._context||i;this.renderer=new wP.Renderer(this.regl),this._bindedOnTextureLoad=this._onTextureLoad.bind(this),this._bindDisposeCachedTexture=this.disposeCachedTexture.bind(this),this._bindOnMaterialComplete=this._onMaterialComplete.bind(this),this._updateMaterial(),this._createShader(i);const g={vert:$V,wgslVert:YV,uniforms:[{name:"projViewModelMatrix",type:"function",fn:(i,g)=>_A([],g.projViewMatrix,g.modelMatrix)}],extraCommandProps:{viewport:this.pickingViewport,depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"<=",mask:!!zF(this.sceneConfig.depthMask)||this.sceneConfig.depthMask}}};this.picking=[new wP.FBORayPicking(this.renderer,g,this.layer.getRenderer().pickingFBO,this.getMap())]}_createShader(i){const g={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},m={},_=[];_.push(...wP.SsrPass.getUniformDeclares()),this.fillIncludes(m,_,i);const b={cull:{enable:(i,g)=>!(g.geometryProperties.hasNegativeHeight||void 0!==this.sceneConfig.cullFace&&!this.sceneConfig.cullFace),face:()=>this.sceneConfig.cullFace||"back"},viewport:g,depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"<="},blend:{enable:(i,g)=>void 0===g.hasAlpha||!!g.hasAlpha,func:this.getBlendFunc(),equation:"add"},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}},T={uniforms:_,defines:this._getDefines(m),extraCommandProps:b};this.shader=new wP.pbr.StandardShader(T),T.frag="\n            precision mediump float;\n            #include <gl2_frag>\n            void main() {\n                glFragColor = vec4(0.0);\n                #if __VERSION__ == 100\n                    gl_FragColor = glFragColor;\n                #endif\n            }\n        ",T.wgslFrag="\n            fn main() -> @location(0) vec4f {\n                return vec4f(0);\n            }\n        ",this._updateDepthShader=new wP.pbr.StandardShader(T)}_onTextureLoad({resources:i}){for(let g=0;g<i.length;g++)this.addCachedTexture(i[g].url,i[g].data);this.setToRedraw(!0)}_onMaterialComplete(){this.setToRedraw(!0)}_updateMaterial(i){if(i){const g=this.getSymbols()[0].material;g&&NF(g,i)}const g=this.layer instanceof Up,m=this.dataConfig,_=i||this.getSymbols()[0].material,b={};let T=!1;for(const i in _)if(YF(_,i))if(i.indexOf("Texture")>0){let g=_[i];if(!g){b[i]=void 0;continue}const P="string"==typeof g?g:g.url,I=this.getCachedTexture(P);I?I.then?P===g?g={promise:I,wrap:"repeat"}:g.promise=I:P===g?g={data:I,wrap:"repeat"}:g.data=I:P===g&&(g={url:P,wrap:"repeat"}),g.flipY=!m.upsideUpTexture,g.min="linear mipmap linear",g.mag="linear",b[i]=new wP.Texture2D(g,this._loader),b[i].once("complete",this._bindedOnTextureLoad),b[i].once("disposed",this._bindDisposeCachedTexture),b[i].promise&&this.addCachedTexture(P,b[i].promise),T=!0}else b[i]=_[i],"uvRotation"===i&&(b[i]=Math.PI*b[i]/180,g||(b[i]*=-1));if(void 0===b.alphaTest&&this.getMaterialClazz&&(b.alphaTest=.05),this.material){for(let i in b)this.material.set(i,b[i]);this.setToRedraw(!0)}else this.material=new wP.pbr.StandardMaterial(b),this.material.once("complete",this._bindOnMaterialComplete);T||this._onMaterialComplete()}getShader(){return this.shader}getUniformValues(i,g){const{iblTexes:m,dfgLUT:_}=this.getIBLRes(),b=QV(i,m,_,g&&g.ssr,g&&g.jitter);return this.setIncludeUniformValues(b,g),b}_getDefines(i){return this.hasIBL()?i.HAS_IBL_LIGHTING=1:delete i.HAS_IBL_LIGHTING,i}_onUpdatelights(){if(!this.shader)return;const i=this.shader.shaderDefines;this._getDefines(i),this.shader.shaderDefines=i}}var JV="#include <gl2_vert>\n\n\n\n#define EXTRUDE_SCALE 63.0\n\n#define EXTRUDE_MOD 64.0\n\n#define MAX_LINE_DISTANCE 65535.0\n\n\n\nuniform mat4 projViewModelMatrix;\n\nuniform mat4 positionMatrix;\n\n\n\nuniform vec2 centiMeterToLocal;\n\n\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nattribute vec4 aTubeNormal;\n\n\n\n#ifdef HAS_LINE_WIDTH\n\n    attribute float aLineWidth;\n\n#else\n\n    uniform float lineWidth;\n\n#endif\n\n\n\n#include <vt_position_vert>\n\n\n\n#ifdef PICKING_MODE\n\n    #include <fbo_picking_vert>\n\n#else\n\n    uniform mat4 modelViewMatrix;\n\n    uniform mat3 modelNormalMatrix;\n\n    uniform mat4 modelMatrix;\n\n\n\n    #if defined(HAS_PATTERN)\n\n        uniform float resolution;\n\n        uniform float tileResolution;\n\n        uniform float tileRatio;\n\n\n\n        attribute float aLinesofar;\n\n        varying highp float vLinesofar;\n\n\n\n        attribute vec4 aTexInfo;\n\n        varying vec4 vTexInfo;\n\n\n\n        varying float vNormalY;\n\n        varying float vPatternHeight;\n\n\n\n        attribute float aNormalDistance;\n\n\n\n        #if defined(HAS_PATTERN_ANIM)\n\n            attribute float aLinePatternAnimSpeed;\n\n            varying float vLinePatternAnimSpeed;\n\n        #endif\n\n        #if defined(HAS_PATTERN_GAP)\n\n            attribute float aLinePatternGap;\n\n            varying float vLinePatternGap;\n\n        #endif\n\n    #endif\n\n\n\n    #ifdef HAS_COLOR\n\n        attribute vec4 aColor;\n\n        varying vec4 vColor;\n\n    #endif\n\n\n\n    #ifdef HAS_OPACITY\n\n        attribute float aOpacity;\n\n    #endif\n\n    varying float vOpacity;\n\n\n\n    varying vec3 vModelNormal;\n\n    varying vec4 vViewVertex;\n\n    varying vec3 vModelVertex;\n\n#endif\n\n\n\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n    #include <vsm_shadow_vert>\n\n#endif\n\n\n\n#include <highlight_vert>\n\n\n\nvoid main() {\n\n    #ifdef HAS_LINE_WIDTH\n\n        float myLineWidth = aLineWidth;\n\n    #else\n\n        float myLineWidth = lineWidth;\n\n    #endif\n\n\n\n    float halfwidth = myLineWidth / 2.0;\n\n    vec3 tubeNormal = aTubeNormal.xyz / EXTRUDE_SCALE;\n\n    vec3 position = unpackVTPosition();\n\n    vec4 localVertex = vec4(position, 1.0);\n\n    localVertex.xy += tubeNormal.xy * halfwidth * centiMeterToLocal;\n\n    localVertex.z += tubeNormal.z * halfwidth;\n\n    gl_Position = projViewModelMatrix * localVertex;\n\n\n\n    #ifdef PICKING_MODE\n\n        fbo_picking_setData(gl_Position.w, true);\n\n    #else\n\n\n\n        vViewVertex = modelViewMatrix * localVertex;\n\n\n\n        vec3 localNormal = normalize(tubeNormal);\n\n        vModelNormal = modelNormalMatrix * localNormal;\n\n        vModelVertex = (modelMatrix * localVertex).xyz;\n\n        #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n            shadow_computeShadowPars(localVertex);\n\n        #endif\n\n\n\n        #ifdef HAS_COLOR\n\n            vColor = aColor / 255.0;\n\n        #endif\n\n        #ifdef HAS_OPACITY\n\n            vOpacity = aOpacity / 255.0;\n\n        #else\n\n            vOpacity = 1.0;\n\n        #endif\n\n\n\n        #ifdef HAS_PATTERN\n\n\n\n            float scale = tileResolution / resolution;\n\n            float linesofar = aLinesofar - halfwidth * centiMeterToLocal.y * aNormalDistance / EXTRUDE_SCALE;\n\n            vLinesofar = linesofar / tileRatio * scale;\n\n            vTexInfo = vec4(aTexInfo.xy, aTexInfo.zw + 1.0);\n\n            vPatternHeight = myLineWidth * centiMeterToLocal.x / tileRatio * scale;\n\n            vNormalY = aTubeNormal.w / EXTRUDE_SCALE;\n\n            #if defined(HAS_PATTERN_ANIM)\n\n                vLinePatternAnimSpeed = aLinePatternAnimSpeed / 127.0;\n\n            #endif\n\n            #if defined(HAS_PATTERN_GAP)\n\n                vLinePatternGap = aLinePatternGap / 10.0;\n\n            #endif\n\n        #endif\n\n\n\n        highlight_setVarying();\n\n    #endif\n\n}\n\n";const{StyleUtil:KV}=JD(),{getPBRUniforms:eU}=wP.pbr.PBRUtils;class TubePainter extends BasicPainter{needToRedraw(){return super.needToRedraw()||this.isAnimating()}isTerrainSkin(){return!1}isTerrainVector(){return!0}isUniqueStencilRefPerTile(){return!1}supportRenderMode(i){return this.isAnimating()?"fxaa"===i||"fxaaAfterTaa"===i:"taa"===i||"fxaa"===i}isAnimating(){if(this._hasPatternAnim)return!0;const i=this.getSymbols();for(let g=0;g<i.length;g++)if(i[g].linePatternFile&&i[g].linePatternAnimSpeed)return!0;return!1}isBloom(i){return!!this.getSymbol(i.properties.symbolIndex).lineBloom}createMesh(i,g){if(!i.geometry)return null;const m=this.getMap(),{geometry:_,symbolIndex:b,ref:T}=i,P=this.getSymbolDef(b);if(void 0===T){FN(_,P,this.getFnTypeConfig(b),this.layer)}const I=this.getSymbol(b),{tileResolution:H,tileRatio:W}=_.properties,q={tileResolution:H,tileRatio:W};UF(q,"lineColor",I,"lineColor","#fff",WF(this.colorCache)),UF(q,"linePatternGapColor",I,"linePatternGapColor",[1,1,1,1],WF(this.colorCache)),UF(q,"lineWidth",I,"lineWidth",2,(i=>KV.getTubeSizeScale(this.dataConfig.metric)*i)),UF(q,"lineOpacity",I,"lineOpacity",1),UF(q,"linePatternAnimSpeed",I,"linePatternAnimSpeed",0),UF(q,"linePatternGap",I,"linePatternGap",0),UF(q,"metallicFactor",I,"metallicFactor",0),UF(q,"roughnessFactor",I,"roughnessFactor",.4),UF(q,"emissiveFactor",I,"emissiveFactor",[0,0,0]),UF(q,"uvScale",I,"uvScale",[1,1]);const $=_.properties.iconAtlas,ye=this.layer instanceof Up;$&&(q.linePatternFile=SH(this.regl,$,!1),q.atlasSize=$?[$.width,$.height]:[0,0],q.flipY=ye?-1:1,this.drawDebugAtlas($)),void 0===T&&_.generateBuffers(this.regl),q.alphaTest=-1;const Re=new wP.pbr.StandardMaterial(q),Be=new wP.Mesh(_,Re,{castShadow:!1,picking:!0}),Ge=m.distanceToPointAtRes(100,100,_.properties.tileResolution)._multi(W/1e4).toArray();Be.setUniform("centiMeterToLocal",Ge);const je=m.getResolution(m.getMaxNativeZoom());Be.setUniform("animSpeedScale",H/je),Be.setLocalTransform(g);const Xe={IS_LINE_EXTRUSION:1,HAS_LAYER_OPACITY:1};return"square-tube"===this.dataConfig.type&&(Xe.IS_SQUARE_TUBE=1),$&&(Xe.HAS_PATTERN=1),Be.properties.symbolIndex=b,_.data.aColor&&(Xe.HAS_COLOR=1),this.setMeshDefines(Xe,_,P),_.data.aAltitude&&(Xe.HAS_ALTITUDE=1),Be.setDefines(Xe),Be}setMeshDefines(i,g,m){g.data.aOpacity&&(i.HAS_OPACITY=1),g.data.aLineWidth&&(i.HAS_LINE_WIDTH=1),XN(m.linePatternAnimSpeed)&&(i.HAS_PATTERN_ANIM=1),XN(m.linePatternGap)&&(i.HAS_PATTERN_GAP=1)}paint(i){i.states&&i.states.includesChanged.shadow&&(this.shader.dispose(),this.createShader(i)),super.paint(i)}init(i){this.getMap().on("updatelights",this._onUpdatelights,this),this.createIBLTextures();if(this.renderer=new wP.Renderer(this.regl),this.createShader(i),this.pickingFBO){const i=[];this.picking=[new wP.FBORayPicking(this.renderer,{vert:"#define PICKING_MODE 1\n"+JV,uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}},{name:"modelNormalMatrix",type:"function",fn:(g,m)=>sA(i,m.modelMatrix)}],extraCommandProps:this.getExtraCommandProps()},this.pickingFBO,this.getMap())]}}createShader(i){this._context=i;const g=[],m={};this.fillIncludes(m,g,i),g.push({name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}}),this.shader=new wP.pbr.StandardShader({vert:JV,uniforms:g,defines:this._getDefines(m),extraCommandProps:this.getExtraCommandProps()})}getExtraCommandProps(){const i=this.canvas;return{viewport:{x:0,y:0,width:()=>i?i.width:1,height:()=>i?i.height:1},stencil:{enable:!0,func:{cmp:()=>"<=",ref:(i,g)=>g.level},op:{fail:"keep",zfail:"keep",zpass:"replace"}},cull:{enable:()=>!!this.sceneConfig.cullFace,face:this.sceneConfig.cullFace||"back"},depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],mask:this.sceneConfig.depthMask||!0,func:this.sceneConfig.depthFunc||"<="},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}}}getUniformValues(i,g){const{iblTexes:m,dfgLUT:_}=this.getIBLRes(),b=eU(i,m,_,null,g&&g.jitter),T=i.viewMatrix;return b.projViewMatrix=i.projViewMatrix,b.viewMatrix=T,b.resolution=i.getResolution(),b.currentTime=this.layer.getRenderer().getFrameTimestamp()||0,this.setIncludeUniformValues(b,g),b}createFnTypeConfig(i,g){const m=ML(g.lineColor),_=ML(g.aLinePatternAnimSpeed),b=ML(g.aLinePatternGap),T=this.createShapeFnTypeConfigs(i,g),P=new Int8Array(2);return[{attrName:"aColor",symbolName:"lineColor",type:Uint8Array,width:4,define:"HAS_COLOR",evaluate:(g,_)=>{let b=m(i.getZoom(),g);return wL(b)&&(b=this.evaluateInFnTypeConfig(b,_,i,g,!0)),Array.isArray(b)||(b=this.colorCache[b]=this.colorCache[b]||iL(b).unitArray()),b=jF(b),b}},{attrName:"aLinePattern",symbolName:"linePatternAnimSpeed",type:Int8Array,width:2,related:["linePatternGap"],define:"HAS_LINE_PATTERN",evaluate:(g,m,b,T)=>{let I=_(i.getZoom(),g);return zF(I)&&(I=0),0!==I&&(m.properties.hasPatternAnim=1),P[0]=I/127,P[1]=b[T+1],P}},{attrName:"aLinePattern",symbolName:"linePatternGap",type:Int8Array,width:2,related:["linePatternAnimSpeed"],define:"HAS_LINE_PATTERN",evaluate:(g,m,_,T)=>{let I=b(i.getZoom(),g);return zF(I)&&(I=0),P[1]=10*I,P[0]=_[T],P}}].concat(T)}createShapeFnTypeConfigs(i,g){const m=SL(g.lineWidth),_=SL(g.lineOpacity),b=new Uint16Array(1);return[{attrName:"aLineWidth",symbolName:"lineWidth",type:Uint8Array,width:1,define:"HAS_LINE_WIDTH",evaluate:(g,_)=>{let T=m(i.getZoom(),g);return wL(T)&&(T=this.evaluateInFnTypeConfig(T,_,i,g)),b[0]=Math.round(2*T),b[0]}},{attrName:"aOpacity",symbolName:"lineOpacity",type:Uint8Array,width:1,define:"HAS_OPACITY",evaluate:(g,m)=>{let T=_(i.getZoom(),g);return wL(T)&&(T=this.evaluateInFnTypeConfig(T,m,i,g)),b[0]=255*T,b[0]}}]}_getDefines(i){return this.hasIBL()?i.HAS_IBL_LIGHTING=1:delete i.HAS_IBL_LIGHTING,i}_onUpdatelights(){if(!this.shader)return;const i=this.shader.shaderDefines;this._getDefines(i),this.shader.shaderDefines=i}delete(){super.delete(),this.disposeIBLTextures(),this.shader&&(this.shader.dispose(),delete this.shader)}}const tU=wP.ShaderLib.get("mesh_picking_vert"),nU=wP.WgslShaderLib.get("mesh_picking").vert,{PackUtil:rU}=JD(),iU=[],oU=[],sU=[],aU=[],lU=[],hU=[],cU=[],uU=[0,0,0],fU=[0,0,0],dU=[1,1,1],pU=[],gU=[1,1,1,1],mU=[],AU=[1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1],yU=i=>class extends i{constructor(i,g,m,_,b,T){super(i,g,m,_,b,T),this._ready=!1;const P=_.fetchOptions||{};P.referrer=window&&window.location.href,this._gltfManager=i.gltfManager=i.gltfManager||new wP.GLTFManager(i,{fetchOptions:P,urlModifier:i=>{const m=g.getURLModifier();return m&&m(i)||i}}),this._initTRSFuncType(),this._initGLTF()}isUniqueStencilRefPerTile(){return!1}isAnimating(){const i=this.getSymbols();for(let g=0;g<i.length;g++){if(i[g]&&this._gltfPack[g]&&this._isSkinAnimating(g))return!0}return!1}createGeometry(i,g){const{data:m,positionSize:_}=i;return{geometry:{properties:NF({},i.properties),data:m,positionSize:_,features:g},symbolIndex:i.symbolIndex}}getFnTypeConfig(){return pU}createMesh(i,g,{tileTranslationMatrix:m,tileExtent:_,tilePoint:b},{timestamp:T}){if(!this._ready)return null;const P=this.getMap(),{geometry:I}=i,{positionSize:H,features:W}=I;if(!I.data.aPosition||0===I.data.aPosition.length)return null;"native-line"===this.dataConfig.type&&this._arrangeAlongLine(0,I,b);const{aPosition:q}=I.data;let $=q.length/H;const ye={instance_vectorA:new Float32Array(4*$),instance_vectorB:new Float32Array(4*$),instance_vectorC:new Float32Array(4*$),aPickingId:[]},Re=this._updateInstanceData(ye,m,_,I.properties.z,I.data,H,W);I.data.aTerrainAltitude&&(ye.aTerrainAltitude=I.data.aTerrainAltitude);const Be={},Ge=ye.aPickingId,je=function(i){const g=new Map;for(let m=0;m<i.length;m++){const _=i[m];let b=g.get(_);b||(b=[],g.set(_,b)),b.push(m)}return g}(Ge);for(const i in ye)Be[i]={buffer:this.regl.buffer({dimension:ye[i].length/$,data:ye[i]}),divisor:1};const Xe=this._hasFuncType(),Ze=this._getMeterScale(),Ye=mA([]);xA(Ye,Ye,[Ze,Ze,Ze]);const Qe=[],Je=this.getSymbols();for(let i=0;i<Je.length;i++){const g=Je[i],_=this._gltfMeshInfos[i];if(!_)continue;const b=this._gltfPack[i][0],{fixSizeOnZoom:H}=g;let W=mA([]);Xe||(W=this._getSymbolTRSMatrix(W),W=_A([],Ye,W));let q=0;_.forEach((i=>{const{geometry:m,nodeMatrix:_}=i;_A(mU,AU,_);let b=_A(mU,W,mU);Xe&&(b=_A(mU,Ye,mU));const T=m.boundingBox.copy();T.transform(b);const P=this._calAnchorTranslation(T,g);Math.abs(P)>Math.abs(q)&&(q=P)}));const Ze=[0,0,q],Ke=_.map(((_,Xe)=>{const{geometry:Ye,materialInfo:Qe,morphWeights:Je,extraInfo:Ke,nodeIndex:et}=_;g.alphaTest&&(Qe.alphaTest=g.alphaTest);const tt=new(this.getMaterialClazz(Qe))(Qe),at={},ht=new wP.InstancedMesh(Be,$,Ye,tt,{transparent:!1,picking:!0});if(b.hasSkinAnimation()){const g=this._updateAnimation(ht,i,0)[et];ht.setUniform("jointTexture",g.jointTexture),ht.setUniform("jointTextureSize",g.jointTextureSize),ht.setUniform("numJoints",g.numJoints),ht.setUniform("skinAnimation",+this._isSkinAnimating(i)),ht.properties.startTime=T,at.HAS_SKIN=1}Je&&(ht.setUniform("morphWeights",Je),at.HAS_MORPH=1),ht.setUniform("hasAlpha",Ke.alphaMode&&"BLEND"===Ke.alphaMode.toUpperCase()),UF(ht.uniforms,"polygonFill",g,"markerFill",gU,WF(this.colorCache)),UF(ht.uniforms,"polygonOpacity",g,"markerOpacity",1);const gt=[];ht.setPositionMatrix((()=>{const g=this._getMeshNodeMatrix(i,Xe,et);_A(gt,AU,g),_A(gt,W,gt);const m=mA(mU);if(0!==q&&(wA(m,Ze),_A(gt,m,gt)),ZF(H)){const i=P.getGLScale()/P.getGLScale(H);return qA(iU,i,i,i),TA(m,iU),_A(m,m,gt)}return gt}));const yt=this.layer.getRenderer().getZScale(),vt=[],xt=[];return ht.setLocalTransform((()=>{const i=this.layer.options.altitude||0;return WA(xt,Re),xt[2]+=100*i*yt,vA(vt,m,xt),vt})),Ye.generateBuffers(this.regl,{excludeElementsInVAO:!0}),ye.instance_color&&(at.HAS_INSTANCE_COLOR=1),ye.aTerrainAltitude&&(at.HAS_INSTANCE_TERRAIN_ALTITUDE=1,ht.setUniform("terrainAltitudeScale",100*this.layer.getRenderer().getZScale())),at.HAS_LAYER_OPACITY=1,NF(ht.properties,I.properties),ht.properties.aPickingId=Ge,ht.properties.nodeIndex=et,ht.properties.pickingIdIndiceMap=je,ht.setDefines(at),ht.properties.symbolIndex={index:i},ht}));Qe.push(...Ke)}return Qe.insContext={instanceData:ye,tileTranslationMatrix:m,tileExtent:_,aPosition:q,positionSize:H},Qe}_arrangeAlongLine(i,g){const{tileExtent:m,z:_}=g.properties,{data:b,positionSize:T}=g;let P=this._calGLTFScale(i);P=QA([],P,this._getMeterScale());const I={gapLength:this.dataConfig.gapLength||0,direction:this.dataConfig.direction||0,scaleVertex:!0},H=this._gltfPack[0][0],{aPosition:W,aAltitude:q,aPickingId:$}=b,ye=new pl(0,0,0),Re=new pl(0,0,0),Be=[],Ge=q?[]:Be,je=[],Xe=[],Ze=[],Ye=[],Qe=[],Je=[],Ke=this.layer.getTileSize().width/m*this.layer.getRenderer().getTileGLScale(_),et=this.layer.getRenderer().getZScale();let tt=$[0];for(let i=0;i<W.length-T;i+=T){const g=$[i/T+1];if(g!==tt){tt=g;continue}q?qA(Qe,W[i],W[i+1],q[i/T]):rU.unpackPosition(Qe,W[i],W[i+1],W[i+2]);const[m,_,b]=Qe;let at=i+T;q?qA(Je,W[at],W[at+1],q[at/T]):rU.unpackPosition(Je,W[at],W[at+1],W[at+2]);const[ht,gt,yt]=Je,vt=$[i/T],xt=ye.set(m*Ke,_*Ke,b*et),bt=Re.set(ht*Ke,gt*Ke,yt*et),Tt=xt.distanceTo(bt),Mt=H.arrangeAlongLine(xt,bt,Tt,P,1,I);for(let i=0;i<Mt.length;i++){const g=Mt[i];ye.set(m,_,b),Re.set(ht,gt,yt);const T=_U(ye,Re,g.t);Be.push(T.x,T.y),Ge.push(T.z),je.push(vt),Xe.push(-g.rotationZ*Math.PI/180),Ze.push(g.rotationXY*Math.PI/180),Ye.push(...g.scale)}}g.data={aPosition:new W.constructor(Be),aPickingId:new $.constructor(je),aZRotation:Xe,aXYRotation:Ze,aScaleXYZ:Ye},q&&(g.data.aAltitude=new q.constructor(Ge))}_calGLTFScale(i){const g=this.getSymbols()[i],m=[1,1,1],_=g.modelHeight;if(_){this._gltfPack[i][0].calModelHeightScale(m,_)}return qA(lU,g.scaleX||1,g.scaleY||1,g.scaleZ||1),$A(m,m,lU)}_getMeshNodeMatrix(i,g,m){const _=this._gltfMeshInfos[i][g];return this._isSkinAnimating(i)&&this._nodeMatrixMap&&this._nodeMatrixMap[m]||_.nodeMatrix}_updateAnimation(i,g,m){if(!this._gltfPack)return;const _=this._gltfPack[g][0];this._skinMap||(this._skinMap={}),this._nodeMatrixMap={},this._skinMap[i.uuid]||(this._skinMap[i.uuid]={});const b=this.getSymbols()[g],T=this._gltfJSON[g],{loop:P,speed:I,animationName:H}=b;return _.updateAnimation(m,P||!1,I||1,H||T.animations[0].name,i.properties.startTime||0,this._nodeMatrixMap,this._skinMap[i.uuid]),this._skinMap[i.uuid]}_calAnchorTranslation(i,g){const m=g.anchorZ||"center";let _=0;const b=i.max[2]-i.min[2];return"bottom"===m?_=b/2:"top"===m&&(_=-b/2),_}addMesh(i,g,m){if(!i)return null;if(i[0].properties.level>2)return null;const _=m.timestamp;for(let g=0;g<i.length;g++){if(!i[g]||!i[g].geometry)continue;i[g].instancedData.aTerrainAltitude&&this._updateTerrainAltitude(i[g],i[g].instancedData,i[g].properties,3,m);const b=i[g].properties.symbolIndex.index,T=this._isSkinAnimating(b);T&&this._updateAnimation(i[g],b,_),i[g].setUniform("skinAnimation",+T),this._highlightMesh(i[g])}return this.scene.addMesh(i),this}_updateATerrainAltitude(i,g){i&&i.updateInstancedData&&i.updateInstancedData("aTerrainAltitude",g)}prepareRender(i){const g=this.getSymbols();let m=!1;for(let i=0;i<g.length;i++){if(!g[i]||!this._gltfPack[i])continue;if(this._isSkinAnimating(i)&&this._gltfPack[i]&&!m){m=!0;break}}m&&this.setToRedraw(!0),super.prepareRender(i)}getShadowMeshes(){if(!this.isVisible())return pU;this.shadowCount=this.scene.getMeshes().length;const i=this.scene.getMeshes().filter((i=>0===i.properties.level));return i}_isSkinAnimating(i){const g=this.getSymbols()[i];return!!(g&&g.animation&&this._gltfPack[i]&&this._gltfPack[i][0]&&this._gltfPack[i][0].hasSkinAnimation())}_updateInstanceData(i,g,m,_,b,T,P){function I(g,m,_,b){i[g][4*m]=_[b],i[g][4*m+1]=_[b+4],i[g][4*m+2]=_[b+8],i[g][4*m+3]=_[b+12]}const{aPosition:H,aPickingId:W,aXYRotation:q,aZRotation:$,aAltitude:ye,aScaleXYZ:Re}=b,Be=H.length/T,Ge=this.layer.getTileSize().width/m*this.layer.getRenderer().getTileGLScale(_),je=this.layer.getRenderer().getZScale(),Xe=100*(this.dataConfig.altitudeOffset||0);let Ze=1/0,Ye=1/0,Qe=1/0,Je=-1/0,Ke=-1/0,et=-1/0;const tt=[],at=[];for(let i=0;i<Be;i++){ye?qA(at,H[i*T],H[i*T+1],ye[i]):rU.unpackPosition(at,H[i*T],H[i*T+1],H[i*T+2]);const g=qA(tt,at[0]*Ge,-at[1]*Ge,(at[2]+Xe)*je);g[0]<Ze&&(Ze=g[0]),g[0]>Je&&(Je=g[0]),g[1]<Ye&&(Ye=g[1]),g[1]>Ke&&(Ke=g[1]),g[2]<Qe&&(Qe=g[2]),g[2]>et&&(et=g[2])}const ht=(Ze+Je)/2,gt=(Ye+Ke)/2,yt=(Qe+et)/2,vt=[],xt=this._hasFuncType(),bt=[0,0,1],Tt=[0,0,0];for(let g=0;g<Be;g++){ye?qA(at,H[g*T],H[g*T+1],ye[g]):rU.unpackPosition(at,H[g*T],H[g*T+1],H[g*T+2]);const m=qA(tt,at[0]*Ge-ht,-at[1]*Ge-gt,(at[2]+Xe)*je-yt),_=qA(lU,1,1,1);Re&&(qA(_,Re[3*g],Re[3*g+1],Re[3*g+2]),TA(hU,_));const b=q&&q[g]||0,Be=$&&$[g]||0;if(b||Be){SA(vt,Be,bt);const i=qA(iU,Math.cos(Be),Math.sin(Be),0);bA(vt,vt,b,sy(i,i,Tt,90*Math.PI/180)),Re&&_A(vt,vt,hU);_A(vt,wA(mU,m),vt)}else wA(vt,m),Re&&_A(vt,vt,hU);if(xt){let i=this._getSymbolTRSMatrix(mU,P,W,g);const m=this._getMeterScale(),_=mA([]);xA(_,_,[m,m,m]),i=_A([],_,i),_A(vt,vt,i)}I("instance_vectorA",g,vt,0),I("instance_vectorB",g,vt,1),I("instance_vectorC",g,vt,2),i.aPickingId[g]=W[g]}return qA(tt,ht,gt,yt),tt}_getMeterScale(){if(!this._meterScale){const i=this.getMap();this._meterScale=100*dF(i.getGLRes(),i)}return this._meterScale}_getSymbolTRSMatrix(i,g,m,_){const b=this.getMap(),T=this.symbolDef[0],P=this._getMeterScale();let I=T.translationX||0,H=T.translationY||0,W=T.translationZ||0,q=T.rotationX||0,$=T.rotationY||0,ye=T.rotationZ||0,Re=T.scaleX||1,Be=T.scaleY||1,Ge=T.scaleZ||1;const je=g&&g[m&&m[_]],Xe=b.getZoom(),Ze=je&&je.feature&&je.feature.properties,Ye=this._getModelHeightScale(Xe,Ze);this._txFn&&(I=this._txFn(Xe,Ze)),this._tyFn&&(H=this._tyFn(Xe,Ze)),this._tzFn&&(W=this._tzFn(Xe,Ze));const Qe=qA(oU,I*P,H*P,W*P);this._rxFn&&(q=this._rxFn(Xe,Ze)),this._ryFn&&($=this._ryFn(Xe,Ze)),this._rzFn&&(ye=this._rzFn(Xe,Ze));const Je=qA(sU,q,$,ye);this._sxFn&&(Re=this._sxFn(Xe,Ze)),this._syFn&&(Be=this._syFn(Xe,Ze)),this._szFn&&(Ge=this._szFn(Xe,Ze));const Ke=qA(aU,Re*Ye,Be*Ye,Ge*Ye);return this._getGLTFMatrix(i,Qe,Je,Ke)}_getModelHeightScale(i,g){const m=this.symbolDef[0];let _=this._modelHeightFn?this._modelHeightFn(i,g):m.modelHeight;if(hF(_))return 1;const b=this._gltfBBox[0];return _/Math.abs(b.max[1]-b.min[1])}getShaderConfig(){const i=super.getShaderConfig();return i.positionAttribute="POSITION",i.normalAttribute="NORMAL",i}init(i){super.init(i),this._initGLTF()}_initTRSFuncType(){const i=this.symbolDef[0];wL(i.modelHeight)&&(this._modelHeightFn=SL(i.modelHeight)),wL(i.translationX)&&(this._txFn=SL(i.translationX)),wL(i.translationY)&&(this._tyFn=SL(i.translationY)),wL(i.translationZ)&&(this._tzFn=SL(i.translationZ)),wL(i.rotationX)&&(this._rxFn=SL(i.rotationX)),wL(i.rotationY)&&(this._ryFn=SL(i.rotationY)),wL(i.rotationZ)&&(this._rzFn=SL(i.rotationZ)),wL(i.scaleX)&&(this._sxFn=SL(i.scaleX)),wL(i.scaleY)&&(this._syFn=SL(i.scaleY)),wL(i.scaleZ)&&(this._szFn=SL(i.scaleZ))}_hasFuncType(){return!!(this._modelHeightFn&&!this._modelHeightFn.isFeatureConstant||this._txFn&&!this._txFn.isFeatureConstant||this._tyFn&&!this._tyFn.isFeatureConstant||this._tzFn&&!this._tzFn.isFeatureConstant||this._rxFn&&!this._rxFn.isFeatureConstant||this._ryFn&&!this._ryFn.isFeatureConstant||this._rzFn&&!this._rzFn.isFeatureConstant||this._sxFn&&!this._sxFn.isFeatureConstant||this._syFn&&!this._syFn.isFeatureConstant||this._szFn&&!this._szFn.isFeatureConstant)}_initGLTF(){if(this._gltfPack)return;this._gltfPack=[],this._gltfJSON=[],this._gltfBBox=[],this._gltfMeshInfos=[];const i=this.getSymbols();this._loaded=0;for(let g=0;g<i.length;g++){const m=i[g].url||"pyramid";this._gltfManager.loginGLTF(m);const _=this._gltfManager.getGLTF(m);if(_.then)_.then((m=>{if(!m.gltfPack)return this._loaded++,void(this._loaded>=i.length&&(this._ready=!0,this.setToRedraw(!0)));const{gltfPack:_,json:b,bbox:T}=m;this._gltfPack[g]=[_],this._gltfMeshInfos[g]=_.getMeshesInfo(),this._gltfJSON[g]=b,this._gltfBBox[g]=T,this._loaded++,this._loaded>=i.length&&(this._ready=!0),this.setToRedraw(!0)}));else{const{gltfPack:i,json:m,bbox:b}=_;i&&(this._gltfPack[g]=[i],this._gltfMeshInfos[g]=i.getMeshesInfo(),this._gltfJSON[g]=m,this._gltfBBox[g]=b,this._loaded++)}}this._loaded>=i.length&&(this._ready=!0)}getPickingVert(){return tU}getPickingWGSLVert(){return nU}deleteMesh(i){if(i){this.scene.removeMesh(i);for(let g=0;g<i.length;g++){const m=this._skinMap&&this._skinMap[i[g].uuid];if(m){for(const i in m)m[i].jointTexture&&m[i].jointTexture.destroy();delete this._skinMap[i[g].uuid]}i[g].disposeInstancedData(),i[g].dispose()}}}delete(){super.delete();const i=this.getSymbols();for(let g=0;g<i.length;g++){this._gltfManager.logoutGLTF(i[g].url||"pyramid")}if(this._skinMap){for(const i in this._skinMap){const g=this._skinMap[i];for(const i in g)g[i].jointTexture&&g[i].jointTexture.destroy()}delete this._skinMap}delete this._nodeMatrixMap}_getGLTFMatrix(i,g,m,_){const b=qA(iU,...g||uU),T=m||fU,P=_||dU;return OA(i,o_(cU,T[0],T[1],T[2]),b,P)}shouldDrawParentTile(){return!1}};function _U(i,g,m){const _=vU(i.x,g.x,m),b=vU(i.y,g.y,m),T=vU(i.z||0,g.z||0,m);return new i.constructor(_,b,T)}function vU(i,g,m){return i+m*(g-i)}class GLTFPhongPainter extends(yU(PhongPainter)){getMaterialClazz(i){return i.diffuseFactor?wP.PhongSpecularGlossinessMaterial:wP.PhongMaterial}}class GLTFStandardPainter extends(yU(StandardPainter)){getMaterialClazz(i){return i.specularGlossinessTexture||i.diffuseTexture?wP.pbr.StandardSpecularGlossinessMaterial:wP.pbr.StandardMaterial}}const{getPBRUniforms:xU}=wP.pbr.PBRUtils,bU={color:[2.0303,2.028,2.028],direction:[0,-.2717,-1]},wU=.3737,TU={index:0},SU=[0,0,0],MU=[2,2];class WaterPainter extends BasicPainter{supportRenderMode(i){return"fxaa"===i||"fxaaBeforeTaa"===i}needPolygonOffset(){return!0}isTerrainSkin(){return!1}isTerrainVector(){return!0}needToRedraw(){if(super.needToRedraw())return!0;return this.getSymbol(TU).animation}createMesh(i,g){const{geometry:m}=i;m.generateBuffers(this.regl);const _=new wP.Mesh(m,null,{castShadow:!1,picking:!0});return _.properties.symbolIndex=TU,_.setLocalTransform(g),_}callShader(i,g){super.callShader(i,g),this.transformWater();const m=this._getWaterUniform(this.getMap(),g);this._drawCount+=this.renderer.render(this._waterShader,m,this._waterScene,this.getRenderFBO(g))}addMesh(i,g){this._prepareMesh(i,g),super.addMesh(...arguments)}_prepareMesh(i){const g=this.getSymbol(TU).ssr;for(let m=0;m<i.length;m++)i[m].ssr=g?1:0}paint(i){i.states&&i.states.includesChanged&&(this.shader.dispose(),this._waterShader.dispose(),this._createShader(i));const g=!!i.ssr&&this.getSymbol(TU).ssr,m=this._waterShader,_=m.shaderDefines;if(g){const g=NF({},_,i.ssr.defines);m.shaderDefines=g}this.updateIBLDefines(m),this._water.ssr=g?1:0,super.paint(i),g&&(m.shaderDefines=_)}isEnableTileStencil(){return!1}init(i){this.createIBLTextures();this.renderer=new wP.Renderer(this.regl),this.createGround(),this._createShader(i),this.pickingFBO&&(this.picking=[new wP.FBORayPicking(this.renderer,{vert:TH,uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}}],extraCommandProps:{viewport:this.pickingViewport}},this.pickingFBO,this.getMap())]),this._loadTextures()}_loadTextures(){const i=this.regl;this._emptyTex||(this._emptyTex=i.texture(2));const g=this.layer.getURLModifier(),m=this.getSymbol({index:0}),_=m.texWaveNormal,b=this.getCachedTexture(_),T=this;if(b)this._normalTex||(b.isLoading?setTimeout((()=>{this.shader&&this._loadTextures()}),20):this._normalTex=this._createTex(i,b));else{const m=new Image;m.isLoading=!0,m.onload=function(){delete this.isLoading,T._normalTex=T._createTex(i,this),T.setToRedraw()},m.onerror=()=>{console.error("invalid water wave normal texture:"+_)},this.addCachedTexture(_,m),m.src=g&&g(_)||_}const P=m.texWavePerturbation,I=this.getCachedTexture(P);if(I)this._pertTex||(I.isLoading?setTimeout((()=>{this._loadTextures()}),20):this._pertTex=this._createTex(i,I));else{const m=new Image;m.isLoading=!0,m.onload=function(){delete this.isLoading,T._pertTex=T._createTex(i,this),T.setToRedraw()},m.onerror=()=>{console.error("invalid water wave perturbation texture:"+P)},this.addCachedTexture(P,m),m.src=g&&g(P)||P}}_createTex(i,g){return this._emptyTex?i.texture({width:g.width,height:g.height,mag:"linear",min:"linear mipmap linear",wrapS:"repeat",wrapT:"repeat",flipY:!0,data:g}):null}_createShader(i){const g=this.canvas,m=[],_=[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}},{name:"modelViewNormalMatrix",type:"function",fn:(i,g)=>{const m=_A([],g.viewMatrix,g.modelMatrix),_=yA(m,m);return sA([],AA(_,_))}},{name:"modelViewMatrix",type:"function",fn:(i,g)=>_A([],g.viewMatrix,g.modelMatrix)},{name:"environmentTransform",type:"function",fn:(i,g)=>uA(m,Math.PI*(g.environmentOrientation||0)/180)}],b={TIME_NOISE_TEXTURE_REPEAT:wU};this.fillIncludes(b,_,i);const T={x:0,y:0,width:()=>g?g.width:1,height:()=>g?g.height:1};this.shader=new wP.MeshShader({vert:"\n                attribute vec3 aPosition;\n\n                uniform mat4 projViewModelMatrix;\n                uniform float minAltitude;\n\n                void main() {\n                    vec3 position = aPosition;\n                    position.z += minAltitude * 100.0;\n                    gl_Position = projViewModelMatrix * vec4(position, 1.);\n                }\n            ",frag:"\n    #define SHADER_NAME WATER_STENCIL\n    precision mediump float;\n    void main() {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){const m=[];return _A(m,g.projViewMatrix,g.modelMatrix),m}}],extraCommandProps:{viewport:T,colorMask:[!1,!1,!1,!1],stencil:{enable:!0,func:{cmp:"<=",ref:254},op:{fail:"keep",zfail:"keep",zpass:"replace"}},depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"<="},polygonOffset:{enable:!0,offset:this.getPolygonOffset()}}});const P={viewport:T,stencil:{enable:!0,func:{cmp:"==",ref:254},op:{fail:"keep",zfail:"keep",zpass:"replace"}},depth:{enable:!1}};_.push(...wP.SsrPass.getUniformDeclares()),this._waterShader=new wP.MeshShader({vert:"#define SHADER_NAME WATER\n\n\n\nuniform mat4 modelMatrix;\n\nuniform mat4 projViewModelMatrix;\n\nattribute vec3 aPosition;\n\nattribute vec2 aTexCoord;\n\n\n\nuniform vec2 uvOffset;\n\nuniform vec2 noiseUvOffset;\n\nuniform vec2 uvScale;\n\n\n\nvarying vec2 vUv;\n\nvarying vec2 vNoiseUv;\n\nvarying vec3 vPos;\n\nvarying mat3 vTbnMatrix;\n\n#ifdef HAS_SSR\n\n    uniform mat4 modelViewMatrix;\n\n    varying vec4 vViewVertex;\n\n#endif\n\n\n\n#include <highlight_vert>\n\n\n\nmat3 getTBNMatrix(in vec3 n) {\n\n    vec3 t = normalize(cross(n, vec3(0.0, 1.0, 0.0)));\n\n    vec3 bi = normalize(cross(n, t));\n\n    return mat3(t, bi, n);\n\n}\n\n\n\n#if defined(HAS_SHADOWING)\n\n    #include <vsm_shadow_vert>\n\n#endif\n\n\n\nconst vec3 NORMAL = vec3(0., 0., 1.);\n\n\n\nvoid main(void) {\n\n    vec4 localVertex = vec4(aPosition, 1.);\n\n    vec4 vertex = modelMatrix * localVertex;\n\n    vPos = vertex.xyz;\n\n    vTbnMatrix = getTBNMatrix(NORMAL);\n\n    gl_Position = projViewModelMatrix * localVertex;\n\n    vUv = aTexCoord * uvScale + uvOffset;\n\n    vNoiseUv = aTexCoord * uvScale * TIME_NOISE_TEXTURE_REPEAT + noiseUvOffset;\n\n\n\n    #ifdef HAS_SSR\n\n        vec4 viewVertex = modelViewMatrix * localVertex;\n\n        vViewVertex = viewVertex;\n\n    #endif\n\n\n\n    #if defined(HAS_SHADOWING)\n\n        shadow_computeShadowPars(localVertex);\n\n    #endif\n\n\n\n    highlight_setVarying();\n\n}\n\n",frag:"#define SHADER_NAME WATER\n\n\n\nprecision highp float;\n\nprecision highp sampler2D;\n\n\n\n#include <hsv_frag>\n\nuniform vec3 hsv;\n\nuniform float contrast;\n\nuniform float layerOpacity;\n\n\n\n#if defined(HAS_SHADOWING)\n\n    #include <vsm_shadow_frag>\n\n#endif\n\n\n\n#include <highlight_frag>\n\n\n\n#if defined(HAS_IBL_LIGHTING)\n\n    uniform vec3 hdrHSV;\n\n    uniform samplerCube prefilterMap;\n\n    uniform sampler2D brdfLUT;\n\n    uniform mat3 environmentTransform;\n\n    uniform vec3 diffuseSPH[9];\n\n\n\n    vec3 computeDiffuseSPH(const in vec3 normal) {\n\n        vec3 n = environmentTransform * normal;\n\n\n\n        float x = n.x;\n\n        float y = n.y;\n\n        float z = n.z;\n\n        vec3 result = (\n\n            diffuseSPH[0] +\n\n\n\n            diffuseSPH[1] * x +\n\n            diffuseSPH[2] * y +\n\n            diffuseSPH[3] * z +\n\n\n\n            diffuseSPH[4] * z * x +\n\n            diffuseSPH[5] * y * z +\n\n            diffuseSPH[6] * y * x +\n\n            diffuseSPH[7] * (3.0 * z * z - 1.0) +\n\n            diffuseSPH[8] * (x*x - y*y)\n\n          );\n\n        if (length(hdrHSV) > 0.0) {\n\n            result = hsv_apply(result, hdrHSV);\n\n        }\n\n        return max(result, vec3(0.0));\n\n    }\n\n\n\n    vec3 integrateBRDF(const in vec3 specular, const in float roughness, const in float NoV, const in float f90) {\n\n        vec4 rgba = texture2D(brdfLUT, vec2(NoV, roughness));\n\n        float b = (rgba[3] * 65280.0 + rgba[2] * 255.0);\n\n        float a = (rgba[1] * 65280.0 + rgba[0] * 255.0);\n\n        const float div = 1.0 / 65535.0;\n\n        return (specular * a + b * f90) * div;\n\n\n\n    }\n\n#else\n\n    uniform vec3 ambientColor;\n\n#endif\n\n\n\nstruct PBRShadingWater {\n\n    float NdotL;    float NdotV;    float NdotH;    float VdotH;    float LdotH;    float VdotN;};\n\n\n\nvec3 decodeRGBM(const in vec4 color, const in float range) {\n\n    if(range <= 0.0) return color.rgb;\n\n    return range * color.rgb * color.a;\n\n}\n\n\n\n#ifdef HAS_SSR\n\n    varying vec4 vViewVertex;\n\n    uniform mat3 modelViewNormalMatrix;\n\n    uniform sampler2D TextureDepth;\n\n    uniform highp vec2 outSize;\n\n    uniform float ssrFactor;\n\n    uniform float ssrQuality;\n\n    uniform sampler2D TextureReflected;\n\n    uniform highp mat4 projMatrix;\n\n    uniform mat4 invProjMatrix;\n\n    uniform vec4 outputFovInfo[2];\n\n    uniform mat4 reprojViewProjMatrix;\n\n    uniform vec2 cameraNearFar;\n\n    float decodeDepth(const in vec4 pack) {\n\n        return pack.r + pack.g / 255.0;\n\n    }\n\n    float interleavedGradientNoise(const in vec2 fragCoord, const in float frameMod) {\n\n        vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n\n        return fract(magic.z * fract(dot(fragCoord.xy + frameMod * vec2(47.0, 17.0) * 0.695, magic.xy))) * 0.5;\n\n    }\n\n    vec3 computeLodNearestPixelSizePowLevel(const in float lodLevelIn, const in float maxLod, const in vec2 size) {\n\n        float lodLevel = min(maxLod - 0.01, lodLevelIn);\n\n        float lowerLevel = floor(lodLevel);\n\n        float higherLevel = min(maxLod, lowerLevel + 1.0);\n\n        float powLevel = pow(2.0, higherLevel);\n\n        vec2 pixelSize = 2.0 * powLevel / size;\n\n        if (lodLevel - lowerLevel > 0.5) powLevel *= 2.0;\n\n        return vec3(pixelSize, powLevel);\n\n    }\n\n    vec2 computeLodUVNearest(const in vec2 uvIn, const in vec3 pixelSizePowLevel) {\n\n        vec2 uv = max(pixelSizePowLevel.xy, min(1.0 - pixelSizePowLevel.xy, uvIn));\n\n        return vec2(2.0 * uv.x, pixelSizePowLevel.z - 1.0 - uv.y) / pixelSizePowLevel.z;\n\n    }\n\n    vec3 ssrViewToScreen(const in mat4 projection, const in vec3 viewVertex) {\n\n        vec4 projected = projection * vec4(viewVertex, 1.0);\n\n        return vec3(0.5 + 0.5 * projected.xy / projected.w, projected.w);\n\n    }\n\n    vec3 fetchColorLod(const in float level, const in vec2 uv) {\n\n        return texture2D(TextureReflected, uv).rgb;\n\n    }\n\n\n\n    float linearizeDepth(float depth) {\n\n        highp mat4 projection = projMatrix;\n\n        highp float z = depth * 2.0 - 1.0;        return -projection[3].z / (z + projection[2].z);\n\n    }\n\n\n\n    float fetchDepth(const vec2 uv) {\n\n        float depth = decodeDepth(texture2D(TextureDepth, uv));\n\n        return depth;\n\n    }\n\n\n\n\n\n    vec3 unrealImportanceSampling(const in float frameMod, const in vec3 tangentX, const in vec3 tangentY, const in vec3 tangentZ, const in vec3 eyeVector, const in float rough4) {\n\n        vec2 E;\n\n        E.x = interleavedGradientNoise(gl_FragCoord.yx, frameMod);\n\n        E.y = fract(E.x * 52.9829189);\n\n        E.y = mix(E.y, 1.0, 0.7);\n\n        float phi = 2.0 * 3.14159 * E.x;\n\n        float cosTheta = pow(max(E.y, 0.000001), rough4 / (2.0 - rough4));\n\n        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n        vec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\n        h = h.x * tangentX + h.y * tangentY + h.z * tangentZ;\n\n        return normalize((2.0 * dot(eyeVector, h)) * h - eyeVector);\n\n    }\n\n    float getStepOffset(const in float frameMod) {\n\n        return (interleavedGradientNoise(gl_FragCoord.xy, frameMod) - 0.5);\n\n    }\n\n    vec3 computeRayDirUV(const in vec3 rayOriginUV, const in float rayLen, const in vec3 rayDirView) {\n\n        vec3 rayDirUV = ssrViewToScreen(projMatrix, vViewVertex.xyz + rayDirView * rayLen);\n\n        rayDirUV.z = 1.0 / rayDirUV.z;\n\n        rayDirUV -= rayOriginUV;\n\n        float scaleMaxX = min(1.0, 0.99 * (1.0 - rayOriginUV.x) / max(1e-5, rayDirUV.x));\n\n        float scaleMaxY = min(1.0, 0.99 * (1.0 - rayOriginUV.y) / max(1e-5, rayDirUV.y));\n\n        float scaleMinX = min(1.0, 0.99 * rayOriginUV.x / max(1e-5, -rayDirUV.x));\n\n        float scaleMinY = min(1.0, 0.99 * rayOriginUV.y / max(1e-5, -rayDirUV.y));\n\n        return rayDirUV * min(scaleMaxX, scaleMaxY) * min(scaleMinX, scaleMinY);\n\n    }\n\n\n\n    float binarySearch(const in vec3 rayOriginUV, const in vec3 rayDirUV, inout float startSteps, inout float endSteps) {\n\n        float steps = (endSteps + startSteps) * 0.5;\n\n        vec3 sampleUV = rayOriginUV + rayDirUV * steps;\n\n        float z = fetchDepth(sampleUV.xy);\n\n        float depth = linearizeDepth(z);\n\n        float sampleDepth = -1.0 / sampleUV.z;\n\n        startSteps = depth > sampleDepth ? startSteps : steps;\n\n        endSteps = depth > sampleDepth ? steps : endSteps;\n\n        return steps;\n\n    }\n\n\n\n    vec4 rayTraceUnrealSimple(\n\n    const in vec3 rayOriginUV, const in float rayLen, in float depthTolerance, const in vec3 rayDirView, const in float roughness, const in float frameMod) {\n\n        const int checkSteps = 20;\n\n        float invNumSteps = 1.0 / float(checkSteps);\n\n        depthTolerance *= invNumSteps;\n\n        vec3 rayDirUV = computeRayDirUV(rayOriginUV, rayLen, rayDirView);\n\n        float sampleTime =invNumSteps;\n\n        vec3 diffSampleW = vec3(0.0, sampleTime, 1.0);\n\n        vec3 sampleUV;\n\n        float z, depth, sampleDepth, depthDiff, timeLerp, hitTime;\n\n        bool hit;\n\n        float hitDepth = 1.0;\n\n        float steps;\n\n\n\n        for (int i = 0; i < checkSteps; i++) {\n\n            sampleUV = rayOriginUV + rayDirUV * diffSampleW.y;\n\n            z = fetchDepth(sampleUV.xy);\n\n            depth = linearizeDepth(z);\n\n            sampleDepth = -1.0 / sampleUV.z;\n\n            depthDiff = sampleDepth - depth;\n\n            depthDiff *= clamp(sign(abs(depthDiff) - rayLen * invNumSteps * invNumSteps), 0.0, 1.0);\n\n            hit = abs(depthDiff + depthTolerance) < depthTolerance;\n\n            timeLerp = clamp(diffSampleW.x / (diffSampleW.x - depthDiff), 0.0, 1.0);\n\n            hitTime = hit ? (diffSampleW.y + timeLerp * invNumSteps - invNumSteps) : 1.0;\n\n            diffSampleW.z = min(diffSampleW.z, hitTime);\n\n            diffSampleW.x = depthDiff;\n\n            if (hit) {\n\n                float startSteps = diffSampleW.y - invNumSteps;\n\n                float endSteps = diffSampleW.y;\n\n                steps = binarySearch(rayOriginUV, rayDirUV, startSteps, endSteps);\n\n                steps = binarySearch(rayOriginUV, rayDirUV, startSteps, endSteps);\n\n                steps = binarySearch(rayOriginUV, rayDirUV, startSteps, endSteps);\n\n                hitDepth = steps;\n\n                break;\n\n            }\n\n            diffSampleW.y += invNumSteps;\n\n        }\n\n\n\n        return vec4(rayOriginUV + rayDirUV * hitDepth, 1.0 - hitDepth);\n\n    }\n\n\n\n\n\n\n\n    vec3 fetchColorContribution(\n\n    in vec4 resRay, const in float maskSsr, const in vec3 specularEnvironment, const in vec3 specularColor, const in float roughness) {\n\n        vec4 AB = mix(outputFovInfo[0], outputFovInfo[1], resRay.x);\n\n        resRay.xyz = vec3(mix(AB.xy, AB.zw, resRay.y), 1.0) * -1.0 / resRay.z;\n\n        resRay.xyz = (reprojViewProjMatrix * vec4(resRay.xyz, 1.0)).xyw;\n\n        resRay.xy /= resRay.z;\n\n\n\n        float maskEdge = clamp(6.0 - 6.0 * max(abs(resRay.x), abs(resRay.y)), 0.0, 1.0);\n\n        resRay.xy = 0.5 + 0.5 * resRay.xy;\n\n        return vec3(resRay.xy, 1.0);\n\n    }\n\n\n\n\n\n\n\n    vec3 ssr(const in vec3 specularEnvironment, const in vec3 specularColor, const in float roughness, const in vec3 normal, const in vec3 eyeVector) {\n\n        float uFrameModTaaSS = 0.0;\n\n        vec4 result = vec4(0.0);\n\n        float rough4 = roughness * roughness;\n\n        rough4 = rough4 * rough4;\n\n        vec3 upVector = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\n        vec3 tangentX = normalize(cross(upVector, normal));\n\n        vec3 tangentY = cross(normal, tangentX);\n\n        float maskSsr = ssrFactor * clamp(-4.0 * dot(eyeVector, normal) + 3.8, 0.0, 1.0);\n\n        maskSsr *= clamp(4.7 - roughness * 5.0, 0.0, 1.0);\n\n        vec3 rayOriginUV = ssrViewToScreen(projMatrix, vViewVertex.xyz);\n\n        rayOriginUV.z = 1.0 / rayOriginUV.z;\n\n        vec3 rayDirView = unrealImportanceSampling(uFrameModTaaSS, tangentX, tangentY, normal, eyeVector, rough4);\n\n\n\n        float rayLen = mix(cameraNearFar.y + vViewVertex.z, -vViewVertex.z - cameraNearFar.x, rayDirView.z * 0.5 + 0.5);\n\n        float depthTolerance = 0.5 * rayLen;\n\n        vec4 resRay;\n\n        if (dot(rayDirView, normal) > 0.001 && maskSsr > 0.0) {\n\n            resRay = rayTraceUnrealSimple(rayOriginUV, rayLen, depthTolerance, rayDirView, roughness, uFrameModTaaSS);\n\n            if (resRay.w > 0.0) return fetchColorContribution(resRay, maskSsr, specularEnvironment, specularColor, roughness);\n\n        }\n\n        return vec3(0.0);\n\n    }\n\n#endif\n\n\n\nconst vec3 NORMAL = vec3(0., 0., 1.);\n\n\n\nuniform mat4 viewMatrix;\n\nuniform sampler2D normalTexture;\n\nuniform sampler2D heightTexture;\n\nuniform vec4 waveParams;\n\nuniform vec2 waterDir;\n\nuniform vec4 waterBaseColor;\n\nuniform vec3 lightDirection;\n\nuniform vec3 lightColor;\n\nuniform vec3 camPos;\n\nuniform float timeElapsed;\n\nvarying vec2 vUv;\n\nvarying vec2 vNoiseUv;\n\nvarying vec3 vPos;\n\nvarying mat3 vTbnMatrix;\n\n\n\nfloat normals2FoamIntensity(vec3 n, float waveStrength) {\n\n    float normalizationFactor = max(0.015, waveStrength);\n\n    return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);\n\n}\n\nconst vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);\n\nvec2 textureDenormalized2D(sampler2D _tex, vec2 uv) {\n\n    return 2.0 * texture2D(_tex, uv).rg - 1.0;\n\n}\n\nfloat sampleNoiseTexture(vec2 uv) {\n\n    return texture2D(heightTexture, uv).b;\n\n}\n\nvec3 textureDenormalized3D(sampler2D _tex, vec2 uv) {\n\n    return 2.0 * texture2D(_tex, uv).rgb - 1.0;\n\n}\n\nfloat computeProgress(vec2 uv, float time) {\n\n    return fract(time);\n\n}\n\nfloat computeWeight(vec2 uv, float time) {\n\n    float progress = computeProgress(uv, time);\n\n    return 1.0 - abs(1.0 - 2.0 * progress);\n\n}\n\nvec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {\n\n    float flowStrength = waveParams[2];\n\n    float flowOffset = waveParams[3];\n\n    vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;\n\n    float progress = computeProgress(uv, time + phaseOffset);\n\n    float weight = computeWeight(uv, time + phaseOffset);\n\n    vec2 result = uv;\n\n    result -= flowVector * (progress + flowOffset);\n\n    result += phaseOffset;\n\n    result += (time - progress) * FLOW_JUMP;\n\n    return vec3(result, weight);\n\n}\n\n\n\nconst float TIME_NOISE_STRENGTH = 7.77;\n\n\n\nvec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {\n\n    float waveStrength = waveParams[0];\n\n    vec2 waveMovement = time * -_waveDir;\n\n    float timeNoise = sampleNoiseTexture(vNoiseUv) * TIME_NOISE_STRENGTH;\n\n    vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);\n\n    vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);\n\n    vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;\n\n    vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;\n\n    vec3 mixNormal = normalize(normal_A + normal_B);\n\n    mixNormal.xy *= waveStrength;\n\n    mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));\n\n    return mixNormal;\n\n}\n\nvec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {\n\n    float waveTextureRepeat = waveParams[1];\n\n    vec3 normal = getWaveLayer(normalTexture, heightTexture, _uv * waveTextureRepeat, waterDir, _time);\n\n    float foam = normals2FoamIntensity(normal, waveParams[0]);\n\n    return vec4(normal, foam);\n\n}\n\n\n\n\n\nconst float PI = 3.141592653589793;\n\nconst float LIGHT_NORMALIZATION = 1.0 / PI;\n\nconst float INV_PI = 0.3183098861837907;\n\nconst float HALF_PI = 1.570796326794897;\n\nconst float correctionViewingPowerFactor = 0.4;\n\n\n\nfloat dtrExponent = 2.2;\n\nvec3 fresnelReflection(float angle, vec3 f0, float f90) {\n\n    return f0 + (f90 - f0) * pow(1.0 - angle, 5.0);\n\n}\n\nfloat normalDistributionWater(float NdotH, float roughness) {\n\n    float r2 = roughness * roughness;\n\n    float NdotH2 = NdotH * NdotH;\n\n    float denom = pow((NdotH2 * (r2 - 1.0) + 1.0), dtrExponent) * PI;\n\n    return r2 / denom;\n\n}\n\nfloat geometricOcclusionKelemen(float LoH) {\n\n    return 0.25 / (LoH * LoH);\n\n}\n\nvec3 tonemapACES(const vec3 x) {\n\n    return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);\n\n}\n\nconst float GAMMA = 2.2;\n\nconst float INV_GAMMA = 0.4545454545;\n\n\n\nvec4 delinearizeGamma(vec4 color) {\n\n    return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);\n\n}\n\nvec3 linearizeGamma(vec3 color) {\n\n    return pow(color, vec3(GAMMA));\n\n}\n\nconst vec3 fresnelSky = vec3(0.02, 1.0, 5.0);\n\n\n\nconst vec2 fresnelMaterial = vec2(0.02, 0.1);\n\n\n\nconst float roughness = 0.06;\n\nconst float foamIntensityExternal = 1.7;\n\nconst vec3 skyZenitColor = vec3(0, 0.6, 0.9);\n\nconst vec3 skyColor = vec3(0.72, 0.92, 1.0);\n\nconst float ssrIntensity = 0.65;\n\nconst float ssrHeightFadeStart = 300000.0;\n\nconst float ssrHeightFadeEnd = 500000.0;\n\nconst float waterDiffusion = 0.775;\n\nconst float waterSeeColorMod = 0.8;\n\n\n\nPBRShadingWater shadingInfo;\n\n\n\nvec3 brdfSpecularWater(in PBRShadingWater props, float roughness, vec3 F0, float F0Max) {\n\n    vec3  F = fresnelReflection(props.VdotH, F0, F0Max);\n\n    float dSun = normalDistributionWater(props.NdotH, roughness);\n\n    float V = geometricOcclusionKelemen(props.LdotH);\n\n    float diffusionSunHaze = mix(roughness + 0.045, roughness + 0.385, 1.0 - props.VdotH);\n\n    float strengthSunHaze = 1.2;\n\n    float dSunHaze = normalDistributionWater(props.NdotH, diffusionSunHaze) * strengthSunHaze;\n\n    return ((dSun + dSunHaze) * V) * F;\n\n}\n\nvec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod) {\n\n    return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;\n\n}\n\nvec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {\n\n    float exponent = pow((1.0 - cosTheta), fresnelSky[2]);\n\n    return mix(zenit, horizon, exponent);\n\n}\n\n\n\nvec3 getSkyColor(in vec3 n, in vec3 v, in float upDotV, in float roughness) {\n\n    #ifdef HAS_IBL_LIGHTING\n\n        vec3 R = reflect(-v, n);\n\n        vec3 prefilteredColor = textureCube(prefilterMap, environmentTransform * R).rgb;\n\n        float factor = clamp(1.0 + dot(R, n), 0.0, 1.0);\n\n        prefilteredColor *= factor * factor;\n\n        vec3 specular = prefilteredColor;\n\n        vec3 diffuse = computeDiffuseSPH(n);\n\n        float f90 = clamp(50.0 * waterBaseColor.g, 0.0, 1.0);\n\n        vec3 brdf = integrateBRDF(waterBaseColor.rgb, roughness, dot(n, v), f90);\n\n        return specular * brdf + diffuse;\n\n    #else\n\n        vec3 skyHorizon = linearizeGamma(skyColor);\n\n        vec3 skyZenit = linearizeGamma(skyZenitColor);\n\n        vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );\n\n        return skyColor;\n\n    #endif\n\n}\n\n\n\n\n\nvec3 renderPixel(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 positionView) {\n\n    float reflectionHit = 0.;\n\n    vec3 seaWaterColor = linearizeGamma(color);\n\n    vec3 h = normalize(l + v);\n\n    shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);\n\n    shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);\n\n    shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);\n\n    shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n\n    shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n\n    shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n\n    float upDotV = max(dot(localUp, v), 0.0);\n\n    vec3 skyColor = getSkyColor(n, v, upDotV, roughness);\n\n    float upDotL = max(dot(localUp, l), 0.0);\n\n    float daytimeMod = 0.1 + upDotL * 0.9;\n\n    skyColor *= daytimeMod;\n\n    float shadowModifier = clamp(shadow, 0.8, 1.0);\n\n    vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);\n\n    vec3 reflSky = fresnelModifier * skyColor * shadowModifier;\n\n    vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;\n\n    vec3 specular = vec3(0.0);\n\n    if(upDotV > 0.0 && upDotL > 0.0) {\n\n        vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);\n\n        vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;\n\n        specular = shadingInfo.NdotL * incidentLight * specularSun;\n\n    }\n\n    vec3 foam = vec3(0.0);\n\n    if(upDotV > 0.0) {\n\n        foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);\n\n    }\n\n    vec3 reflectedColor = vec3(0.0);\n\n    #ifdef HAS_SSR\n\n        float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -positionView.z);\n\n        mat4 ssrViewMat = viewMatrix;\n\n        vec4 viewPosition = vec4(positionView.xyz, 1.0);\n\n        vec3 viewDir = normalize(viewPosition.xyz);\n\n        vec4 viewNormalVectorCoordinate = ssrViewMat *vec4(n, 0.0);\n\n        vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);\n\n        vec4 viewUp = ssrViewMat *vec4(localUp, 0.0);\n\n        float correctionViewingFactor = pow(max(dot(-viewDir, viewUp.xyz), 0.0), correctionViewingPowerFactor);\n\n        vec3 viewNormalCorrected = mix(viewUp.xyz, viewNormal, correctionViewingFactor);\n\n\n\n        vec3 ssrCoord = ssr(vec3(0.0), vec3(1.0), roughness, normalize(viewNormalCorrected), -normalize(vViewVertex.xyz));\n\n        if (ssrCoord.z > 0.0) {\n\n            vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - ssrCoord.xy));\n\n            reflectionHit = waterDiffusion * clamp(1.0 - (1.3*dCoords.y), 0.0, 1.0) * heightMod;\n\n            vec3 ssrFetched = fetchColorLod(0.0, ssrCoord.xy);\n\n            reflectedColor = linearizeGamma(ssrFetched) * reflectionHit * fresnelModifier.y * ssrIntensity;\n\n        }\n\n\n\n    #endif\n\n    float seeColorMod = mix(waterSeeColorMod, waterSeeColorMod*0.5, reflectionHit);\n\n    return tonemapACES((1. - reflectionHit) * reflSky + reflectedColor + reflSea * seeColorMod + specular + foam);\n\n\n\n\n\n\n\n}\n\n\n\nvoid main() {\n\n    vec3 localUp = NORMAL;\n\n    vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vUv, timeElapsed);\n\n\n\n    vec3 n = normalize(vTbnMatrix * tangentNormalFoam.xyz);\n\n    vec3 v = -normalize(vPos - camPos);\n\n    vec3 l = normalize(-lightDirection);\n\n\n\n    #if defined(HAS_SHADOWING)\n\n        float shadow = shadow_computeShadow();\n\n    #else\n\n        float shadow = 1.0;\n\n    #endif\n\n    vec4 vPosView = viewMatrix * vec4(vPos, 1.0);\n\n    vec4 final = vec4(renderPixel(n, v, l, waterBaseColor.rgb, lightColor, localUp, shadow, tangentNormalFoam.w, vPosView.xyz), waterBaseColor.a);\n\n    gl_FragColor = delinearizeGamma(final);\n\n\n\n    if (contrast != 1.0) {\n\n        gl_FragColor = contrastMatrix(contrast) * gl_FragColor;\n\n    }\n\n    if (length(hsv) > 0.0) {\n\n        gl_FragColor = hsv_apply(gl_FragColor, hsv);\n\n    }\n\n\n\n    gl_FragColor = highlight_blendColor(gl_FragColor) * layerOpacity;\n\n}\n\n",defines:b,uniforms:_,extraCommandProps:P})}getUniformValues(i){return{projViewMatrix:i.projViewMatrix,minAltitude:this.layer.options.altitude||0}}_getWaterUniform(i,g){const{iblTexes:m,dfgLUT:_}=this.getIBLRes(),b=xU(i,m,_,g&&g.ssr,g&&g.jitter),T=i.getLightManager();let P=T&&T.getDirectionalLight()||{};const I=T&&T.getAmbientLight()||{},H=this.getSymbol(TU),W=this._waterDir=this._waterDir||[],q=this._waveParams=this._waveParams||[];wy(q,.09,H.uvScale||3,.03,-.5);NF(b,{ambientColor:I.color||[.2,.2,.2],viewMatrix:i.viewMatrix,lightDirection:P.direction||bU.direction,lightColor:P.color||bU.color,camPos:i.cameraPosition,timeElapsed:H.animation?(this.layer.getRenderer().getFrameTimestamp()||0)/(1/(H.waterSpeed||1)*1e4):0,normalTexture:this._normalTex||this._emptyTex,heightTexture:this._pertTex||this._emptyTex,waveParams:q,waterDir:CU(W,H.waterDirection||0),waterBaseColor:H.waterBaseColor||[.1451,.2588,.4863,1],contrast:H.contrast||1,hsv:H.hsv||SU});const $=this.layer.getRenderer();return b.layerOpacity=$._getLayerOpacity(),this.setIncludeUniformValues(b,g),g&&g.ssr&&g.ssr.renderUniforms&&NF(b,g.ssr.renderUniforms),b}delete(){super.delete(),this._emptyTex&&(this._emptyTex.destroy(),delete this._emptyTex),this._normalTex&&this._normalTex.destroy(),this._pertTex&&this._pertTex.destroy(),this.shader&&(this.shader.dispose(),delete this.shader),this._waterShader&&this._waterShader.dispose(),this._water&&(this._water.geometry.dispose(),this._water.material&&this._water.material.dispose(),this._water.dispose(),delete this._water),this.disposeIBLTextures()}createGround(){const i=new wP.Plane;i.data.aTexCoord=new Uint8Array([0,1,1,1,0,0,1,0]),i.generateBuffers(this.renderer.device),this._water=new wP.Mesh(i,null,{castShadow:!1}),this._waterScene=new wP.Scene([this._water])}transformWater(){const i=this.getMap(),g=GroundPainter.getGroundTransform(this._water.localTransform,i);this._water.setLocalTransform(g);const m=i._get2DExtentAtRes(i.getGLRes()),_=m.getWidth(),b=m.getHeight(),T=i.cameraLookAt,P=(T[0]-_)/MU[0],I=(T[1]+b)/MU[1],H=P*wU%1,W=I*wU%1,q=_/MU[0]*2,$=b/MU[1]*2;this._water.setUniform("uvOffset",[P%1,I%1]),this._water.setUniform("noiseUvOffset",[H,W]),this._water.setUniform("uvScale",[q,-$])}}function CU(i,g){return g=function(i){return Math.PI*i/180}(g),i[0]=Math.sin(g),i[1]=Math.cos(g),i}var PU="#define SHADER_NAME BILL_BOARD\n\n#include <gl2_vert>\n\n\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nattribute vec2 aExtrude;\n\nattribute vec2 aTexCoord;\n\nattribute vec4 aQuat;\n\nvarying vec2 vTexCoord;\n\n\n\nuniform mat4 positionMatrix;\n\nuniform mat4 projViewModelMatrix;\n\n\n\nuniform float extrudeScale;\n\n\n\n#ifdef PICKING_MODE\n\n    #include <fbo_picking_vert>\n\n#endif\n\n\n\n#include <vt_position_vert>\n\n\n\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n    #include <vsm_shadow_vert>\n\n#endif\n\n\n\nmat4 quatToMat4(vec4 q) {\n\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n\n\n\n    float x2 = x * x, y2 = y * y, z2 = z * z;\n\n    float xy = x * y, xz = x * z, yz = y * z;\n\n    float wx = w * x, wy = w * y, wz = w * z;\n\n\n\n    return mat4(\n\n        1.0 - 2.0 * (y2 + z2), 2.0 * (xy + wz), 2.0 * (xz - wy), 0.0,\n\n        2.0 * (xy - wz), 1.0 - 2.0 * (x2 + z2), 2.0 * (yz + wx), 0.0,\n\n        2.0 * (xz + wy), 2.0 * (yz - wx), 1.0 - 2.0 * (x2 + y2), 0.0,\n\n        0.0, 0.0, 0.0, 1.0\n\n    );\n\n}\n\n\n\nvoid main() {\n\n    vec4 extrude = vec4(aExtrude.x * extrudeScale, 0.0, aExtrude.y, 1.0);\n\n    mat4 rotationMat4 = quatToMat4(aQuat);\n\n    vec3 offset = (rotationMat4 * extrude).xyz;\n\n    vec3 position = unpackVTPosition(offset);\n\n\n\n    vTexCoord = aTexCoord;\n\n\n\n    gl_Position = projViewModelMatrix * positionMatrix * vec4(position, 1.0);\n\n\n\n    #ifdef PICKING_MODE\n\n        fbo_picking_setData(gl_Position.w, true);\n\n    #elif defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n        shadow_computeShadowPars(vec4(position, 1.0));\n\n    #endif\n\n}\n\n";function IU(i,g,m){m=m||{},this.w=i||64,this.h=g||64,this.autoResize=!!m.autoResize,this.shelves=[],this.freebins=[],this.stats={},this.bins={},this.maxId=0}function kU(i,g,m){this.x=0,this.y=i,this.w=this.free=g,this.h=m}function OU(i,g,m,_,b,T,P){this.id=i,this.x=g,this.y=m,this.w=_,this.h=b,this.maxw=T||_,this.maxh=P||b,this.refcount=0}
/*!
   * Codes from mapbox-gl-js
   * github.com/mapbox/mapbox-gl-js
   * MIT License
   */function EU(i,{width:g,height:m},_,b){if(b){if(b.length!==g*m*_)throw new RangeError("mismatched image size")}else b=new Uint8Array(g*m*_);return i.width=g,i.height=m,i.data=b,i}function RU(i,g,m,_,b,T){if(0===b.width||0===b.height)return g;if(b.width>i.width||b.height>i.height||m.x>i.width-b.width||m.y>i.height-b.height)throw new RangeError("out of range source coordinates for image copy");if(b.width>g.width||b.height>g.height||_.x>g.width-b.width||_.y>g.height-b.height)throw new RangeError("out of range destination coordinates for image copy");const P=i.data,I=g.data;if(P===I)return g;for(let H=0;H<b.height;H++){const W=((m.y+H)*i.width+m.x)*T,q=((_.y+H)*g.width+_.x)*T;for(let i=0;i<b.width*T;i++)I[q+i]=P[W+i]}return g}IU.prototype.pack=function(i,g){i=[].concat(i),g=g||{};for(var m,_,b,T=[],P=0;P<i.length;P++)if(_=i[P].h||i[P].height,(m=i[P].w||i[P].width)&&_){if(!(b=this.packOne(m,_,i[P].id)))continue;g.inPlace&&(i[P].x=b.x,i[P].y=b.y,i[P].id=b.id),T.push(b)}return this.shrink(),T},IU.prototype.packOne=function(i,g,m){var _,b,T,P,I,H,W,q,$={freebin:-1,shelf:-1,waste:1/0},ye=0;if("string"==typeof m||"number"==typeof m){if(_=this.getBin(m))return this.ref(_),_;"number"==typeof m&&(this.maxId=Math.max(m,this.maxId))}else m=++this.maxId;for(P=0;P<this.freebins.length;P++){if(g===(_=this.freebins[P]).maxh&&i===_.maxw)return this.allocFreebin(P,i,g,m);g>_.maxh||i>_.maxw||g<=_.maxh&&i<=_.maxw&&(T=_.maxw*_.maxh-i*g)<$.waste&&($.waste=T,$.freebin=P)}for(P=0;P<this.shelves.length;P++)if(ye+=(b=this.shelves[P]).h,!(i>b.free)){if(g===b.h)return this.allocShelf(P,i,g,m);g>b.h||g<b.h&&(T=(b.h-g)*i)<$.waste&&($.freebin=-1,$.waste=T,$.shelf=P)}return-1!==$.freebin?this.allocFreebin($.freebin,i,g,m):-1!==$.shelf?this.allocShelf($.shelf,i,g,m):g<=this.h-ye&&i<=this.w?(b=new kU(ye,this.w,g),this.allocShelf(this.shelves.push(b)-1,i,g,m)):this.autoResize?(I=H=this.h,((W=q=this.w)<=I||i>W)&&(q=2*Math.max(i,W)),(I<W||g>I)&&(H=2*Math.max(g,I)),this.resize(q,H),this.packOne(i,g,m)):null},IU.prototype.allocFreebin=function(i,g,m,_){var b=this.freebins.splice(i,1)[0];return b.id=_,b.w=g,b.h=m,b.refcount=0,this.bins[_]=b,this.ref(b),b},IU.prototype.allocShelf=function(i,g,m,_){var b=this.shelves[i].alloc(g,m,_);return this.bins[_]=b,this.ref(b),b},IU.prototype.shrink=function(){if(this.shelves.length>0){for(var i=0,g=0,m=0;m<this.shelves.length;m++){var _=this.shelves[m];g+=_.h,i=Math.max(_.w-_.free,i)}this.resize(i,g)}},IU.prototype.getBin=function(i){return this.bins[i]},IU.prototype.ref=function(i){if(1===++i.refcount){var g=i.h;this.stats[g]=1+(0|this.stats[g])}return i.refcount},IU.prototype.unref=function(i){return 0===i.refcount?0:(0===--i.refcount&&(this.stats[i.h]--,delete this.bins[i.id],this.freebins.push(i)),i.refcount)},IU.prototype.clear=function(){this.shelves=[],this.freebins=[],this.stats={},this.bins={},this.maxId=0},IU.prototype.resize=function(i,g){this.w=i,this.h=g;for(var m=0;m<this.shelves.length;m++)this.shelves[m].resize(i);return!0},kU.prototype.alloc=function(i,g,m){if(i>this.free||g>this.h)return null;var _=this.x;return this.x+=i,this.free-=i,new OU(m,_,this.y,i,g,i,this.h)},kU.prototype.resize=function(i){return this.free+=i-this.w,this.w=i,!0};class RGBAImage{constructor(i,g){EU(this,i,4,g)}resize(i){!function(i,{width:g,height:m},_){if(g===i.width&&m===i.height)return;const b=EU({},{width:g,height:m},_);RU(i,b,{x:0,y:0},{x:0,y:0},{width:Math.min(i.width,g),height:Math.min(i.height,m)},_),i.width=g,i.height=m,i.data=b.data}(this,i,4)}clone(){return new RGBAImage({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(i,g,m,_,b){RU(i,g,m,_,b,4)}}const LU=new un(0,0),DU=[],FU=[];let NU;class BillBoardPainter extends BasicPainter{constructor(...i){super(...i),this._ready=!0;const g=this.getSymbolDef({index:0}),m=oF(g&&g.source);if(this._ready=!m,wL(g.width)?this._widthFn=SL(g.width):this._width=g.width,wL(g.height)?this._heightFn=SL(g.height):this._height=g.height,wL(g.rotationX)?this._rotationXFn=SL(g.rotationX):this._rotationX=g.rotationX,wL(g.rotationY)?this._rotationYFn=SL(g.rotationY):this._rotationY=g.rotationY,wL(g.rotationZ)?this._rotationZFn=SL(g.rotationZ):this._rotationZ=g.rotationZ,m){const i=this._image=new Image;i.onload=()=>{this._ready=!0},i.src=g.source}}needToRedraw(){const i=this.getSymbolDef({index:0});if(!i||!aF(i.source))return super.needToRedraw();const g=this.layer.getRenderer().getCurrentTiles();if(!g||EN(g))return super.needToRedraw();return this._checkIfSourceUpdated()||super.needToRedraw()}_checkIfSourceUpdated(){let i=!1;const g=this.layer.getRenderer(),m=g.getCurrentTiles(),_=this.getSymbolDef({index:0}).source,b=g.tileCache,T=[];for(const g in m){const m=b.get(g);if(!(m&&m.image&&m.image.cache&&m.image.cache[0]))continue;let{geometry:P}=m.image.cache[0];if(!P||!P[0]||!P[0].geometry)continue;P=P[0].geometry.properties.billGeometry;const{oldPickingId:I,contextCache:H,textureCache:W,features:q,billTexture:$}=P.properties;if(!I||!I.length)continue;let ye=!1,Re=!1;const Be=I.length;for(let g=0;g<Be;g++){const m=I[g],b=H[m]=H[m]||{},P=q[m]&&q[m].feature;if(!P)continue;const $=W[m];let Be=0,Ge=0;$&&(Be=$.width,Ge=$.height);let je,Xe=_(b,P.properties);Xe.redraw?(ye=i=!0,je=W[m]=Xe.data,Be===je.width&&Ge===je.height||(Re=!0)):je=W[m],T.push({id:m,w:je.width,h:je.height})}if(ye){const i=this._fillFnTextureData(Re?P.properties.aTexCoord:null,P,T);$({width:i.width,height:i.height,data:i.data,format:i.format,mag:"linear",min:"linear",flipY:!1,premultiplyAlpha:!0}),Re&&P.updateData("aTexCoord",P.properties.aTexCoord)}}return i}isTerrainSkin(){return!1}isTerrainVector(){return this.layer.options.awareOfTerrain}isUniqueStencilRefPerTile(){return!1}createMesh(i,g,{tilePoint:m}){if(!this._ready)return null;let{geometry:_}=i;const{features:b,tileResolution:T,tileRatio:P}=_.properties;if(!_.data.aPosition||0===_.data.aPosition.length)return null;const I=this._createBillboard(_,_.desc.positionSize,b);I.generateBuffers(this.regl),_.properties.billGeometry=I;const H=new wP.Material({billTexture:I.properties.billTexture}),W=new wP.Mesh(I,H,{castShadow:!1,picking:!0}),q=this.getMap();LU.set(m[0],m[1]);const $=q.altitudeToPoint(1,T)*P;W.setUniform("extrudeScale",$/100);const ye=[];W.setFunctionUniform("textureSize",(()=>{const i=I.properties.billTexture;return ye[0]=i.width,ye[1]=i.height,ye}));const Re={};return W.geometry.data.aAltitude&&(Re.HAS_ALTITUDE=1),W.setDefines(Re),W.positionMatrix=this.getAltitudeOffsetMatrix(),W.setLocalTransform(g),W.properties.symbolIndex={index:0},W}_createBillboard(i,g,m){const _=i.properties.z,{aPosition:b,aPickingId:T}=i.data,P=i.properties;P.oldPickingId=T;const I=P.contextCache=[],H=P.textureCache=[],W=T.length,q=6*W,$=new b.constructor(q*g),ye=new Int16Array(2*q),Re=new Float32Array(4*q),Be=new T.constructor(q),Ge=this.getSymbolDef({index:0}).source,je=[];for(let i=0;i<W;i++){const m=b.subarray(i*g,(i+1)*g),_=T[i];$.set(m,6*i*g),$.set(m,(6*i+1)*g),$.set(m,(6*i+2)*g),$.set(m,(6*i+3)*g),$.set(m,(6*i+4)*g),$.set(m,(6*i+5)*g),Be[6*i]=_,Be[6*i+1]=_,Be[6*i+2]=_,Be[6*i+3]=_,Be[6*i+4]=_,Be[6*i+5]=_}const Xe=aF(Ge);for(let i=0;i<W;i++){const g=T[i],b=m[g];let P;if(Xe){P=Ge(I[g]=I[g]||{},b&&b.feature&&b.feature.properties).data,H[g]=P,je.push({id:g,w:P.width,h:P.height})}else P=this._image;this._fillExtrude(ye,i,b,_),this._fillQuat(Re,i,b,_)}const Ze=new Int16Array(2*q);if(je.length){const g=this._fillFnTextureData(Ze,i,je);P.billTexture=SH(this.regl,g,!1,!1)}else{const i={x:0,y:0,w:this._image.width,h:this._image.height};for(let g=0;g<W;g++)this._fillTexCoord(Ze,g,i,1);const g=this._image;P.billTexture=this.regl.texture({width:g.width,height:g.height,data:g})}const Ye=function(i){return i<65536?Uint16Array:Uint32Array}(6*W),Qe=[];for(let i=0;i<W;i++){const g=6*i;Qe.push(g,g+1,g+2),Qe.push(g+3,g+4,g+5)}const Je={aPosition:$,aPickingId:Be,aExtrude:ye,aQuat:Re,aTexCoord:Ze},{feaPickingIdMap:Ke,aFeaIds:et}=i.properties,tt=new et.constructor(q);for(let i=0;i<Be.length;i++)tt[i]=Ke[Be[i]];P.aFeaIds=tt,P.aTexCoord=Ze;const at=new wP.Geometry(Je,new Ye(Qe),0,{positionSize:g});return at.properties=i.properties,at}_fillQuat(i,g,m,_){let b=this._rotationX||0,T=this._rotationY||0,P=this._rotationZ||0;const I=m&&m.feature&&m.feature.properties;this._rotationXFn&&(b=this._rotationXFn(_,I)),this._rotationYFn&&(T=this._rotationYFn(_,I)),this._rotationZFn&&(P=this._rotationZFn(_,I)),o_(FU,b,T,-P);const H=6*g;for(let g=0;g<6;g++)i.set(FU,4*(H+g))}_fillExtrude(i,g,m,_){let b=this._width||0,T=this._height||0;const P=m&&m.feature&&m.feature.properties;this._widthFn&&(b=this._widthFn(_,P)),this._heightFn&&(T=this._heightFn(_,P));const I=b/2*100,H=T/2*100;DU[0]=-I,DU[1]=-H;const W=12*g;i.set(DU,W),DU[0]=I,DU[1]=H,i.set(DU,W+2),DU[0]=-I,DU[1]=H,i.set(DU,W+4),DU[0]=-I,DU[1]=-H,i.set(DU,W+6),DU[0]=I,DU[1]=-H,i.set(DU,W+8),DU[0]=I,DU[1]=H,i.set(DU,W+10)}_fillFnTextureData(i,g,m){const _=g.properties,{textureCache:b,oldPickingId:T}=_,P=T.length,I=new IU(0,0,{autoResize:!0}),H=(NU||(NU=document.createElement("canvas")),NU),W=H.getContext("2d");I.pack(m,{inPlace:!0});const q=this.sceneConfig.textureLimit||1024;let $=1;I.w*I.h>q*q&&($=Math.sqrt(q*q/(I.w*I.h)),I.resize(Math.floor(I.w*$),Math.floor(I.h*$)));const ye=new RGBAImage({width:I.w,height:I.h});for(let g=0;g<P;g++){const _=m[g];i&&this._fillTexCoord(i,g,_,$);const T=b[_.id];if(!T)continue;const P=Math.floor(_.w*$),I=Math.floor(_.h*$);H.width=P,H.height=I,W.drawImage(T,0,0,P,I);const q=W.getImageData(0,0,P,I);RGBAImage.copy(q,ye,{x:0,y:0},{x:Math.floor(_.x*$),y:Math.floor(_.y*$)},{width:P,height:I})}return ye.format="rgba",ye}_fillTexCoord(i,g,m,_){const{x:b,y:T,w:P,h:I}=m,H=Math.floor(b*_),W=Math.floor((b+P)*_),q=Math.floor(T*_),$=Math.floor((T+I)*_),ye=12*g;DU[0]=H,DU[1]=$,i.set(DU,ye),DU[0]=W,DU[1]=q,i.set(DU,ye+2),DU[0]=H,DU[1]=q,i.set(DU,ye+4),DU[0]=H,DU[1]=$,i.set(DU,ye+6),DU[0]=W,DU[1]=$,i.set(DU,ye+8),DU[0]=W,DU[1]=q,i.set(DU,ye+10)}init(){this.renderer=new wP.Renderer(this.regl);const i=[],g={vert:PU,frag:"#define SHADER_NAME BILL_BOARD\n\nprecision mediump float;\n\n#include <gl2_frag>\n\n\n\nuniform sampler2D billTexture;\n\nuniform vec2 textureSize;\n\n\n\nvarying vec2 vTexCoord;\n\n\n\nvoid main() {\n\n    glFragColor = texture2D(billTexture, vTexCoord / textureSize);\n\n\n\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n\n        float shadowCoeff = shadow_computeShadow();\n\n        glFragColor.rgb = shadow_blend(glFragColor.rgb, shadowCoeff);\n\n    #endif\n\n    #if __VERSION__ == 100\n\n        gl_FragColor = glFragColor;\n\n    #endif\n\n}\n\n",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(g,m){return _A(i,m.projViewMatrix,m.modelMatrix),i}}],defines:null,extraCommandProps:{viewport:{x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"<="},blend:{enable:!0,func:this.getBlendFunc(),equation:"add"},cull:{enable:!1}}};if(this.shader=new wP.MeshShader(g),this.shader.version=300,this.pickingFBO){const i=[];this.picking=[new wP.FBORayPicking(this.renderer,{vert:"#define PICKING_MODE 1\n"+PU,uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(g,m){return _A(i,m.projViewMatrix,m.modelMatrix),i}}],extraCommandProps:{viewport:this.pickingViewport,depth:{enable:!0,range:this.sceneConfig.depthRange||[0,1],func:this.sceneConfig.depthFunc||"<="},cull:{enable:!1}}},this.pickingFBO,this.getMap())]}}getUniformValues(i){return{projViewMatrix:i.projViewMatrix}}deleteMesh(i,g){if(Array.isArray(i))for(let g=0;g<i.length;g++){const m=i[g];if(m.geometry){const i=m.geometry.properties;i.textureCache&&(delete i.billTexture,delete i.textureCache,delete i.contextCache)}}else if(i.geometry){const g=i.geometry.properties;g.textureCache&&(delete g.billTexture,delete g.textureCache,delete g.contextCache)}return super.deleteMesh(i,g)}}const HU=mA([]),BU={};class TerrainFlatMaskPainter extends BasicPainter{isEnableTileStencil(){return!1}isTerrainMask(){return this.layer.options.awareOfTerrain}needPolygonOffset(){return!1}createMesh(i,g){const{geometry:m,symbolIndex:_}=i,b=new wP.Material({},BU),T=new wP.Mesh(m,b,{castShadow:!1,picking:!1});T.positionMatrix=this.getAltitudeOffsetMatrix(),T.setLocalTransform(g),T.properties.symbolIndex=_;const P={};return m.data.aAltitude&&(P.HAS_ALTITUDE=1),T.setDefines(P),T}init(i){const g=this.canvas,m={x:(i,g)=>g.viewport?g.viewport.x:0,y:(i,g)=>g.viewport?g.viewport.y:0,width:(i,m)=>m.viewport?m.viewport.width:g?g.width:1,height:(i,m)=>m.viewport?m.viewport.height:g?g.height:1};this.renderer=new wP.Renderer(this.regl);this._createShader(i,{viewport:m,depth:{enable:!0,func:">="}})}_createShader(i,g){const m=[];this.shader=new wP.MeshShader({name:"vt-terrain-flat-mask",vert:"#define SHADER_NAME VT_HEIGHT_MASK_VERT\n\n#include <gl2_vert>\n\n#ifdef HAS_ALTITUDE\n\n    attribute vec2 aPosition;\n\n    attribute float aAltitude;\n\n#else\n\n    attribute vec3 aPosition;\n\n#endif\n\n\n\nuniform mat4 projViewModelMatrix;\n\nuniform mat4 positionMatrix;\n\n\n\n#include <vt_position_vert>\n\n\n\nvarying float vAltitude;\n\n\n\nvoid main() {\n\n    vec3 myPosition = unpackVTPosition();\n\n    vec4 localVertex = positionMatrix * vec4(myPosition, 1.);\n\n    vAltitude = localVertex.z / 100.0;\n\n    localVertex.z = 0.0;\n\n    gl_Position = projViewModelMatrix * localVertex;\n\n}\n\n",frag:"#define SHADER_NAME VT_HEIGHT_MASK_FRAG\n\nprecision highp float;\n\n#include <gl2_frag>\n\n\n\nvarying float vAltitude;\n\n\n\n#include <common_pack_float>\n\n\n\nvoid main() {\n\n    glFragColor = encodeFloat32(vAltitude);\n\n    #if __VERSION__ == 100\n\n        gl_FragColor = glFragColor;\n\n    #endif\n\n}\n\n",uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A(m,g.projViewMatrix,g.modelMatrix),m}}],extraCommandProps:g})}getUniformValues(i,g){return{projViewMatrix:HU,viewport:g&&g.viewport}}}const zU=ON("fill",FillPainter);zU.registerAt(VectorTileLayer);const VU=ON("line",LinePainter);VU.registerAt(VectorTileLayer);const UU=ON("line-gradient",LineGradientPainter);UU.registerAt(VectorTileLayer);const GU=ON("icon",IconPainter);GU.registerAt(VectorTileLayer);const jU=ON("text",TextPainter);jU.registerAt(VectorTileLayer);const WU=ON("native-line",NativeLinePainter);WU.registerAt(VectorTileLayer);ON("native-point",NativePointPainter).registerAt(VectorTileLayer);const qU=ON("phong",PhongPainter);qU.registerAt(VectorTileLayer);const XU=ON("wireframe",WireframePainter);XU.registerAt(VectorTileLayer);const ZU=ON("lit",StandardPainter);ZU.registerAt(VectorTileLayer);const $U=ON("tube",TubePainter);$U.registerAt(VectorTileLayer);const YU=ON("gltf-phong",GLTFPhongPainter);YU.registerAt(VectorTileLayer);const QU=ON("gltf-lit",GLTFStandardPainter);QU.registerAt(VectorTileLayer);const JU=ON("heatmap",class HeatmapPainter extends BasicPainter{createFnTypeConfig(i,g){const m=SL(g.heatmapWeight),_=new Int16Array(1);return[{attrName:"aWeight",symbolName:"heatmapWeight",type:Int16Array,width:1,define:"HAS_HEAT_WEIGHT",evaluate:g=>{const b=m(i.getZoom(),g);return _[0]=255*b,_[0]}}]}createMesh(i,g){const{geometry:m,symbolIndex:_,ref:b}=i;if(void 0===b){FN(m,this.getSymbolDef(_),this.getFnTypeConfig(_),this.layer)}const T=this.getSymbol(_),P={tileRatio:m.properties.tileRatio,dataResolution:m.properties.tileResolution};UF(P,"heatmapIntensity",T,"heatmapIntensity",1),UF(P,"heatmapRadius",T,"heatmapRadius",6),UF(P,"heatmapWeight",T,"heatmapWeight",1),UF(P,"heatmapOpacity",T,"heatmapOpacity",1),m.generateBuffers(this.regl);const I=new wP.Material(P),H=new wP.Mesh(m,I,{transparent:!0,castShadow:!1,picking:!0}),W={};return m.data.aWeight&&(W.HAS_HEAT_WEIGHT=1),H.setDefines(W),H.setLocalTransform(g),H.properties.symbolIndex=_,H}callRenderer(i,g,m){const _=this.getRenderFBO(m);this._drawCount+=this._process.render(this.scene,g,_)}getUniformValues(i){const g=this.getSymbol({index:0}),{projViewMatrix:m}=i;return{glScale:1/i.getGLScale(),resolution:i.getResolution(),projViewMatrix:m,heatmapOpacity:g.heatmapOpacity}}getHeatmapMeshes(){return this.scene.getMeshes()}delete(){super.delete(...arguments),this._process.dispose(),delete this._process}init(){this.renderer=new wP.Renderer(this.regl);const i=this.getPolygonOffset(),g=this.getSymbols()[0];this._process=new HeatmapProcess(this.regl,this.sceneConfig,this.layer,g.heatmapColor,null,i)}});JU.registerAt(VectorTileLayer);const KU=ON("water",WaterPainter);KU.registerAt(VectorTileLayer);const eG=ON("billboard",BillBoardPainter);eG.registerAt(VectorTileLayer);const tG=ON("terrain-flat-mask",TerrainFlatMaskPainter);tG.registerAt(VectorTileLayer),Vector3DLayer.registerPainter("lit",StandardPainter),Vector3DLayer.registerPainter("icon",IconPainter),Vector3DLayer.registerPainter("fill",FillPainter),Vector3DLayer.registerPainter("line",LinePainter),Vector3DLayer.registerPainter("line-gradient",LineGradientPainter),Vector3DLayer.registerPainter("water",WaterPainter),Vector3DLayer.registerPainter("tube",TubePainter),Vector3DLayer.registerPainter("billboard",BillBoardPainter);class MapboxVectorTileLayer extends VectorTileLayer{getTileUrl(i,g,m){const _=this.getMap().getResolution(m);return super.getTileUrl(i,g,function(i){return 19-Math.log(i/nG)/Math.LN2}(_))}static fromJSON(i){return i&&"MapboxVectorTileLayer"===i.type?new MapboxVectorTileLayer(i.id,i.options):null}}MapboxVectorTileLayer.registerJSONType("MapboxVectorTileLayer");const nG=12756274*Math.PI/(256*Math.pow(2,20));class GeoJSONVectorTileLayer extends VectorTileLayer{constructor(i,g){(g=g||{}).spatialReference=null,super(i,g),this.setData(g.data)}onAdd(){this._prepareOptions()}_prepareOptions(){const i=this.getMap(),g=i.getMaxNativeZoom(),m=i.getProjection(),_="EPSG:4326"===m.code||"EPSG:4490"===m.code;var b;_&&(this.options.tileSystem=[1,-1,-180,90]),this.options.spatialReference=_?function(i,g){return{projection:g,fullExtent:{top:90,left:-180,bottom:-90,right:180},resolutions:function(){const g=[];for(let m=0;m<=i+1;m++)g[m]=90/(128*Math.pow(2,m));return g}()}}(g,m.code):(b=g,{projection:"EPSG:3857",resolutions:function(){const i=[],g=6378137*Math.PI;for(let m=0;m<=b+1;m++)i[m]=g/(256*Math.pow(2,m));return i}(),fullExtent:{top:6378137*Math.PI,left:-6378137*Math.PI,bottom:-6378137*Math.PI,right:6378137*Math.PI}})}getWorkerOptions(){const i=super.getWorkerOptions();let g=this.options.data;return oF(g)||g&&g.url?(g.url&&(g=JSON.parse(JSON.stringify(g))),g=iG(g,this.getURLModifier())):g=this.features,i.data=g,i.tileBuffer=this.options.tileBuffer,i.extent=this.options.extent,i.hasAltitude=this.options.enableAltitude,i.simplifyTolerance=this.options.simplifyTolerance,i.projection=this.getSpatialReference().getProjection().code,i.generateOMBB=this.options.generateOMBB,i.convertFn=this.options.convertFn?this.options.convertFn+"":null,i}setData(i){if(this.options.data=i,i&&(oF(i)||i.url)){return!!this.getRenderer()&&this._updateWorker(),this}return this._setData(i),this._updateWorker(),this}_setData(i){if(this.options.convertFn){i=new Function("data",this.options.convertFn+"\nreturn convert(data)")(i)}return this.features=i,this._generateIdMap(),this}_updateWorker(){const i=this.getRenderer();if(i){const g=i.getWorkerConnection();if(g){let m=this.options.data;oF(m)||m&&m.url?(m.url&&(m=JSON.parse(JSON.stringify(m))),m=iG(m,this.getURLModifier())):m=this.features,g.setData(m,((g,m)=>{i.clear(),this.onWorkerReady(null,m),i.setToRedraw(),setTimeout((()=>{i.setToRedraw()}),500)}))}}}getExtent(){return this._dataExtent}onWorkerReady(i,g){i?this.fire("dataerror",{error:i}):(g&&(g.extent&&this._setExtent(g.extent),g.idMap&&(this._idMaps=g.idMap)),this.fire("dataload",{extent:g&&g.extent}))}_setExtent(i){this._dataExtent=new Pl(...i)}_fetchData(i,g){oF(i)?mF.getJSON(i,g):mF.getJSON(i.url,i,g)}getData(){return this.features||null}getTileUrl(i,g,m){return this.getId()+","+i+","+g+","+m}getFeature(i){return this._idMaps[i]}static fromJSON(i){return i&&"GeoJSONVectorTileLayer"===i.type?new GeoJSONVectorTileLayer(i.id,i.options):null}getGeometryById(i){return this._idMaps?this._idMaps[i]:null}_generateIdMap(){if(!this.features)return;if(this.features=JSON.parse(JSON.stringify(this.features)),!this.features)return;let i=0;this._idMaps={};const g=this.options.featureIdProperty,m=this.features;Array.isArray(m)?m.forEach((m=>{if(m){if(sF(m.id)||(m.id=i++),g){let i=g;lF(g)&&(i=g[m.layer||"0"]),m.id=m.properties[i]}this._idMaps[m.id]=m}})):m.features&&m.features.forEach((m=>{if(m){if(sF(m.id)||(m.id=i++),g){let i=g;lF(g)&&(i=g[m.layer||"0"]),m.id=m.properties[i]}this._idMaps[m.id]=m}}))}}function rG(i){let g=document.createElement("a");return g.href=i,i=g.href,g=null,i}function iG(i,g){return i.url?i.url=g?g(i.url):rG(i.url):i=g?g(i):rG(i),i}GeoJSONVectorTileLayer.registerJSONType("GeoJSONVectorTileLayer"),GeoJSONVectorTileLayer.mergeOptions({features:"id",tileBuffer:64,extent:8192,pyramidMode:1,simplifyTolerance:3,tileStackDepth:0,generateOMBB:!0});const{LayerAbstractRenderer:oG}=Om,{SYMBOLS_NEED_REBUILD_IN_VECTOR:sG,GlyphRequestor:aG,PointPack:lG,LinePack:hG,StyledPoint:cG,VectorPack:uG,StyledVector:fG}=JD();let dG=!1,pG=1;const gG="_symbol_".trim(),mG=(MF+"").trim();let AG=new Float32Array(1);const yG=[];class Vector3DLayerRenderer extends(Ck(oG)){constructor(...i){super(...i),this.features={},this._geometries={},this._counter=0,this._allFeatures={},this._featureMapping={},this._markerFeatures={},this._textFeatures={},this._lineFeatures={},this._dirtyAll=!0,this._kidGen={id:0,pickingId:0},this._dirtyTargetsInCurrentFrame={}}setURLModifier(i){this._urlModifier=i}getURLModifier(){return this._urlModifier}needToRedraw(){const i=super.needToRedraw();return i||(this.painter&&this.painter.needToRedraw()||this._markerPainter&&this._markerPainter.needToRedraw()||this._linePainter&&this._linePainter.needToRedraw())}getAnalysisMeshes(){return this.painter&&this.painter.getAnalysisMeshes()||yG}getRayCastData(){return null}_checkFeaturesVisibleChange(){const i=this.features;if(!i)return this;for(const g in i){let m=i[g]||[];if(Array.isArray(m)||(m=[m]),m.length)for(let i=0;i<m.length;i++){const g=m[i];if(!g)continue;const _=g.getVisible;_!==g._visible&&(g._visible=_,this._showHideUpdated=!0)}}return this}draw(i,g){this._frameTime=i;const m=this.layer;this.prepareCanvas(),this._zScale=this._getCentiMeterScale(this.getMap().getGLRes()),this._parentContext=g||{};const _=this._parentContext.renderMode,b=this._preparePaintContext();if(this._startFrame(b,_),this._dirtyAll)this.buildMesh(),this._buildMarkerMesh(),this._buildLineMesh(),this._dirtyTargetsInCurrentFrame={},this._dirtyGeo=!1,this._dirtyAll=!1,this._dirtyLine=!1;else if(this._dirtyGeo){const i=this.atlas,g=this._markerAtlas,m=this._lineAtlas;delete this.atlas,delete this._markerAtlas,delete this._lineAtlas,this.buildMesh(i),this._buildMarkerMesh(g),this._buildLineMesh(m),this._dirtyGeo=!1,this._dirtyLine=!1}else if(this._dirtyLine){const i=this._lineAtlas;delete this._lineAtlas,this._buildLineMesh(i),this._dirtyLine=!1}if(!this.meshes&&!this._markerMeshes&&!this._lineMeshes)return void this.completeRender();this._checkFeaturesVisibleChange(),this._showHideUpdated&&(this._updateMeshVisible(),this._showHideUpdated=!1),this._updateDirtyTargets();const T=!_||"default"===_;let P=0;0===this.layer.options.meshRenderOrder&&this._renderMeshes(b,P,_);let I=0;if(this._lineMeshes&&(T||this._linePainter.supportRenderMode(_))){this._linePainter.startFrame(b),this._linePainter.addMesh(this._lineMeshes,null,{bloom:this._parentContext.bloom}),this._linePainter.prepareRender(b);const i=b.polygonOffsetIndex||0;P=this.meshes&&this.meshes.length?P-1:P,b.polygonOffsetIndex=(b.polygonOffsetIndex||0)+P,I=this._linePainter.render(b).drawCount,b.polygonOffsetIndex=i}if(1===this.layer.options.meshRenderOrder&&this._renderMeshes(b,I?P-1:P,_),this._markerMeshes&&(T||this._markerPainter.supportRenderMode(_))){const g=!this._parentContext.timestamp||this._parentContext.isFinalRender,_=!this._collisionTimestamp||this._collisionTimestamp!==i;m.options.collision&&_&&m.clearCollisionIndex();const T=this.layer.options.sceneConfig;this._markerPainter.sceneConfig.collision=!T||(!!hF(T.collision)||T.collision),this._markerPainter.startFrame(b),this._markerPainter.addMesh(this._markerMeshes,null,{bloom:this._parentContext.bloom}),this._markerPainter.prepareRender(b),m.options.collision&&_&&(this._markerPainter.updateCollision(b),g&&(this._collisionTimestamp=i)),this._markerPainter.render(b)}(T||g&&g.isFinalRender)&&(this.completeRender(),this.layer.fire("canvasisdirty"))}_startFrame(i,g){this.painter&&(!g||"default"===g||this.painter.supportRenderMode(g))&&this.painter.startFrame(i)}_renderMeshes(i,g,m){if(this.painter&&this.meshes&&(!m||"default"===m||this.painter.supportRenderMode(m))){this.painter.addMesh(this.meshes,null,{bloom:i&&i.bloom}),this.painter.prepareRender(i),i.polygonOffsetIndex=(i.polygonOffsetIndex||0)+g;return this.painter.render(i)}return{redraw:!1,drawCount:0}}supportRenderMode(){return!0}isForeground(){return!0}_preparePaintContext(){const i={regl:this.regl,layer:this.layer,symbol:this._layerSymbol,gl:this.gl,sceneConfig:this.layer.options.sceneConfig,pluginIndex:0,cameraPosition:this.getMap().cameraPosition,timestamp:this.getFrameTimestamp()};return this._parentContext&&iF(i,this._parentContext),i}drawOnInteracting(i,g,m){this.draw(g,m)}getFrameTimestamp(){return this._frameTime}_getFeaturesToRender(i,g){(i=i||g)===g&&(g=null);const m=[],_=[0,0,0,0];this.layer._sortGeometries();const b=this.layer.getGeometries();for(let T=0;T<b.length;T++){const P=b[T][rB];if(!this.features[P])continue;const I=this.features[P];if(Array.isArray(I))for(let b=0;b<I.length;b++){const T=I[b],P=T[mG];(!i||i[P]||g&&(!g||g[P]))&&(T.visible||(this._showHideUpdated=!0),this._addCoordsToCenter(T.geometry,_,T.coordinates),m.push(T))}else{I.visible||(this._showHideUpdated=!0);const b=I[mG];if(i&&!i[b]&&(!g||g&&!g[b]))continue;this._addCoordsToCenter(I.geometry,_,I.coordinates),m.push(I)}}if(m.length||(this.meshes&&this.painter&&(this.painter.deleteMesh(this.meshes),delete this.meshes),this._markerMeshes&&(this._markerPainter.deleteMesh(this._markerMeshes),delete this._markerMeshes),this._lineMeshes&&(this._linePainter.deleteMesh(this._lineMeshes),delete this._lineMeshes)),_[3]&&(_[0]/=_[3],_[1]/=_[3]),isNaN(_[0])||isNaN(_[1]))throw new Error(`invalid geometry coordinates for ${this.layer.getJSONType()}`);return{features:m,center:_}}buildMesh(){}createVectorPacks(i,g,m,_,b,T){if(!i||!_||!_.length)return Promise.resolve(null);const P=this._getPackOptions(b,T);P.requestor=this.requestor;return new g(_,m,P).load()}createMesh(i,g,m,_,b,T){return this.createVectorPacks(i,g,m,_,b,T).then((P=>this._createMesh(P,i,g,m,_,b,T)))}_createMesh(i,g,m,_,b,T,P){if(!i)return null;const I=g.createGeometries([i.data],OF(b,null,0,_,this.layer));for(let i=0;i<I.length;i++)I[i]&&this._fillCommonProps(I[i].geometry);const H=mA([]);vA(H,H,qA([],P[0],P[1],0)),xA(H,H,qA([],1,1,this._zScale));const W=g.createMeshes(I,H,{tilePoint:[P[0],P[1]]});for(let i=0;i<W.length;i++){const g=W[i];g.properties.level=0,g.properties.tileTransform=H;const m=g.defines;m.ENABLE_TILE_STENCIL=1,g.setDefines(m),g.properties.meshKey=this.layer.getId()}return{meshes:W,atlas:{iconAtlas:i.data.iconAtlas}}}_addCoordsToCenter(i,g,m){for(let _=0;_<i.length;_++)if(Array.isArray(i[_][0]))for(let b=0;b<i[_].length;b++)if(Array.isArray(i[_][b][0]))for(let T=0;T<i[_][b].length;T++)isNaN(+i[_][b][T][0])||isNaN(+i[_][b][T][1])||this._addCoord(g,i[_][b][T][0],i[_][b][T][1],i[_][b][T][2],1,m[_][b][T]);else isNaN(+i[_][b][0])||isNaN(+i[_][b][1])||this._addCoord(g,i[_][b][0],i[_][b][1],i[_][b][2],1,m[_][b]);else isNaN(+i[_][0])||isNaN(+i[_][1])||this._addCoord(g,i[_][0],i[_][1],i[_][2],1,m[_])}_addCoord(i,g,m,_,b,T){const P=this.getMap().getProjection().isSphere();let I=!1;(T[0]>180||T[0]<-180)&&P&&!dG&&(I=!0,dG=!0,console.warn(`Layer(${this.layer.getId()}) has invalid longitude value: ${T[0]}`)),(T[1]>90||T[1]<-90)&&P&&!dG&&(I=!0,dG=!0,console.warn(`Layer(${this.layer.getId()}) has invalid latitude value: ${T[1]}`)),I||(i[0]+=g,i[1]+=m,i[2]+=_||0,i[3]+=b)}_fillCommonProps(i){const g=this.getMap().getGLRes(),m=i.properties;m.tileResolution=g,m.tileRatio=1,m.z=1,m.tileExtent=1,m.elements=i.elements,m.aPickingId=i.data.aPickingId}_isEnableWorkAround(i){return"win-intel-gpu-crash"===i&&(this.gl&&this.layer.options.workarounds["win-intel-gpu-crash"]&&vG(this.gl))}prepareRequestors(){if(this._iconRequestor)return;const i=this.layer;this._iconRequestor=new IconRequestor({iconErrorUrl:i.options.iconErrorUrl,urlModifier:g=>{const m=i.getURLModifier();return m&&m(g)||g}});const g=!this._isEnableWorkAround("win-intel-gpu-crash");this._glyphRequestor=new aG((g=>{i.getMap().getRenderer().callInNextFrame(g)}),i.options.glyphSdfLimitPerFrame,g),this.requestor=this._fetchPattern.bind(this),this._markerRequestor=this._fetchIconGlyphs.bind(this)}_fetchPattern(i,g,m){const _=[];this._iconRequestor.getIcons(i,((i,g)=>{if(i)throw i;g.buffers&&_.push(...g.buffers),m(null,{icons:g.icons},_)}))}_fetchIconGlyphs(i,g,m){this._glyphRequestor.getGlyphs(g,((g,_)=>{if(g)throw g;const b=_.buffers||[];this._iconRequestor.getIcons(i,((i,g)=>{if(i)throw i;g.buffers&&g.buffers.length&&b.push(...g.buffers),m(null,{icons:g.icons,glyphs:_.glyphs},b)}))}))}_buildMarkerMesh(i){const g=Object.keys(this._markerFeatures),m=Object.keys(this._textFeatures);if(!g.length&&!m.length)return void(this._markerMeshes&&(this._markerPainter.deleteMesh(this._markerMeshes),delete this._markerMeshes));const{features:_,center:b}=this._getFeaturesToRender(this._markerFeatures,this._textFeatures),T=[],P=[];for(let i=0;i<_.length;i++){const g=_[i][mG];this._markerFeatures[g]&&T.push(_[i]),this._textFeatures[g]&&P.push(_[i])}if(!T.length&&!P.length)return void(this._markerMeshes&&(this._markerPainter.deleteMesh(this._markerMeshes),delete this._markerMeshes));const I=this._showHideUpdated;this._markerCenter=b;const H=this._createPointPacks(T,P,i,b);this._markerAtlas={};const W=[],q=[];this._isCreatingMarkerMesh=!0,Promise.all(H).then((i=>{if(this._markerMeshes&&(this._markerPainter.deleteMesh(this._markerMeshes),delete this._markerMeshes),!i||!i.length)return void this.setToRedraw();const g=this._markerPainter.createGeometries(i.map((i=>(i&&i.data&&(i.data.isIdUnique=!0),i&&i.data))),this._allFeatures);for(let m=0;m<g.length;m++)this._fillCommonProps(g[m].geometry,i[m]&&i[m].data);const m=i[0]&&i[0].data.iconAtlas,_=i[0]&&i[0].data.glyphAtlas||i[1]&&i[1].data.glyphAtlas;m&&(this._markerAtlas.iconAtlas=m),_&&(this._markerAtlas.glyphAtlas=_);const T=mA([]);vA(T,T,qA(q,b[0],b[1],0)),xA(T,T,qA(W,1,1,this._zScale));const P=this._markerPainter.createMeshes(g,T);for(let i=0;i<P.length;i++)P[i].geometry.properties.originElements=P[i].geometry.properties.elements.slice(),P[i].properties.level=0,P[i].material.set("flipY",1),P[i].properties.meshKey=pG++;this._markerMeshes=P,I&&(this._showHideUpdated=!0),this._isCreatingMarkerMesh=!1,this.setToRedraw(),this.layer.fire("buildmarkermesh")}))}_updateMeshVisible(){if(this._markerMeshes&&(this._updateVisElements(this._markerMeshes[0],this._markerFeatures),this._updateVisElements(this._markerMeshes[1],this._textFeatures),this._markerMeshes[0]&&this._markerPainter.prepareCollideIndex(this._markerMeshes[0].geometry),this._markerMeshes[1]&&this._markerPainter.prepareCollideIndex(this._markerMeshes[1].geometry)),this._lineMeshes)for(let i=0;i<this._lineMeshes.length;i++)this._updateVisElements(this._lineMeshes[i],this._lineFeatures);if(this.meshes)for(let i=0;i<this.meshes.length;i++)this._updateVisElements(this.meshes[i],this._allFeatures)}_updateVisElements(i,g){if(!i)return;const{aPickingId:m,originElements:_}=i.geometry.properties,b=[];for(let i=0;i<_.length;i++){const T=m[_[i]];g[T]&&g[T].feature.getVisible&&b.push(_[i])}const T=i.geometry.properties.elements=new _.constructor(b);i.geometry.setElements(T)}_getPackOptions(i,g){return{zoom:this.getMap().getZoom(),EXTENT:1/0,atlas:i,center:g,positionType:Float32Array,isWebGL1:this.gl&&this.gl instanceof WebGLRenderingContext}}_createPointPacks(i,g,m,_){const b=this._getPackOptions(m,_);return b.defaultAltitude=0,b.forceAltitudeAttribute=!0,b.requestor=this._markerRequestor,b.markerWidthType=Uint16Array,b.markerHeightType=Uint16Array,b.defaultMarkerVerticalAlignment="top",b.allowEmptyPack=1,[this._markerSymbol].map(((m,_)=>new lG(0===_?i:g,m,b).load()))}updateMesh(){}_updateMarkerMesh(i){const g=i._getInternalSymbol(),m={zoom:this.getMap().getZoom(),isVector3D:!0,defaultMarkerVerticalAlignment:"top"},_=this._convertGeo(i);if(!this._markerMeshes)return!1;let b=this.features[_];Array.isArray(b)||(b=[b]);const T=[],P=[],I=[],H=this.getMap().getZoom();let W,q;W=Array.isArray(g)?g.map((i=>i?CL(i,(()=>(T[0]=H,T))):i)):CL(g,(()=>(T[0]=H,T))),q=Array.isArray(g)?g.map((i=>i?uG.genFnTypes(i):i)):uG.genFnTypes(g);for(let i=0;i<b.length;i++){if(!b[i])continue;const _=Array.isArray(g)?g[i]:g,T=Array.isArray(W)?W[i]:W,P=Array.isArray(q)?q[i]:q,I=new cG(b,_,T,P,m).getIconAndGlyph();if(!this._markerAtlas||!lG.isAtlasLoaded(I,this._markerAtlas))return this.markRebuild(),this.setToRedraw(),!1}for(let i=0;i<b.length;i++){const g=b[i][mG];this._markerFeatures[g]&&P.push(b[i]),this._textFeatures[g]&&I.push(b[i])}const $=b[0].id,ye=this._createPointPacks(P,I,this._markerAtlas,this._markerCenter),Re=this._markerMeshes;return Promise.all(ye).then((i=>{for(let g=0;g<i.length;g++){if(!i[g])continue;i[g].data&&(i[g].data.isIdUnique=!0);const m=Re[g],_=m.geometry.properties.aFeaIds.indexOf($);if(_<0)continue;const b=i[g].data.featureIds.length,T=i[g].data.dynamicAttributes;for(const P in i[g].data.data){if("aPickingId"===P)continue;if(T[P])continue;const I=i[g].data.data[P];I&&m.geometry.updateSubData(P,I,_*I.length/b)}}this.setToRedraw()})),!0}_updateLineMesh(i){return this._updateMesh(i,this._lineMeshes,this._lineAtlas,this._lineCenter,this._linePainter,hG,KH,this._groupLineFeas)}_updateMesh(i,g,m,_,b,T,P,I){if(!g)return!1;if(!m)return this.markRebuild(),this.setToRedraw(),!1;const H=i._getInternalSymbol(),W={zoom:this.getMap().getZoom()};let q=this.features[i[rB]];Array.isArray(q)||(q=[q]);const $=[];for(let i=0;i<q.length;i++){const g=q[i];if(!g)continue;const _=Array.isArray(H)?H[i]:H,b=uG.genFnTypes(_),P=new fG(q,_,b,W),I=T===hG?P.getLineResource():P.getPolygonResource();if(!uG.isAtlasLoaded(I,m[i]))return this.markRebuild(),this.setToRedraw(),!1;$.push(g)}const ye=q[0].id,Re=I.call(this,$);for(let i=0;i<Re.length;i++)if(Re[i].length){const m=g.filter((g=>g.feaGroupIndex===i));if(!m.length)return this.markRebuild(),this.setToRedraw(),!1;if(m[0].geometry.properties.aFeaIds.indexOf(ye)<0)return this.markRebuild(),this.setToRedraw(),!1}const Be=iF({},P),Ge=Re.map((i=>this.createVectorPacks(b,T,Be,i,m[0],_)));return Promise.all(Ge).then((i=>{for(let m=0;m<i.length;m++){let _;if(Array.isArray(g)){for(let i=0;i<g.length;i++)if(g[i].feaGroupIndex===m){_=g[i];break}}else _=g;_&&this._updateMeshData(_,ye,i[m])}})),!0}_updateMeshData(i,g,m){const _=i.geometry.properties.aFeaIds,b=_.indexOf(g);if(!(b<0)){if(m){const g=m.data.dynamicAttributes,_=m.data.featureIds.length,T=m.data.data;for(const m in T)if(!g[m]&&fF(T,m)&&T[m]){const g=T[m];i.geometry.updateSubData(m,g,b*g.length/_)}}else{let m=b+1;for(;_[m]===g;)m++;const T=m-b,P=i.geometry.desc.positionSize;AG.length!==3*T&&(AG=new Float32Array(T*P),AG.fill(-1/0,0)),i.geometry.updateSubData(i.geometry.desc.positionAttribute,AG,b*P)}this.layer.fire("updatemesh"),this.setToRedraw()}}_buildLineMesh(i){if(!Object.keys(this._lineFeatures).length)return void(this._lineMeshes&&(this._linePainter.deleteMesh(this._lineMeshes),delete this._lineMeshes));const{features:g,center:m}=this._getFeaturesToRender(this._lineFeatures);if(!g.length)return;const _=this._showHideUpdated;this._lineCenter=m;const b=this._groupLineFeas(g),T=iF({},KH),P=b.map(((g,_)=>this.createMesh(this._linePainter,hG,T,g,i&&i[_],m)));this._isCreatingLineMesh=!0,Promise.all(P).then((i=>{this._lineMeshes&&this._linePainter.deleteMesh(this._lineMeshes);const g=[],m=[];for(let _=0;_<i.length;_++){const b=i[_]&&i[_].meshes;if(b){for(let i=0;i<b.length;i++){const m=b[i];m.feaGroupIndex=_,g.push(m),m.geometry.properties.originElements=m.geometry.properties.elements.slice()}m[_]=i[_].atlas}}this._lineMeshes=g,this._lineAtlas=m,_&&(this._showHideUpdated=_),this._isCreatingLineMesh=!1,this.setToRedraw(),this.layer.fire("buildlinemesh")}))}_groupLineFeas(i){const g=(gG+"lineDasharray").trim(),m=(gG+"linePatternFile").trim(),_=[],b=[],T=[];for(let P=0;P<i.length;P++){const I=i[P],H=I.properties&&I.properties[g];H&&MG(H)?T.push(I):I.properties&&I.properties[m]?b.push(I):_.push(I)}return[_,b,T]}markRebuildGeometry(){this._dirtyGeo=!0,this.setToRedraw()}markRebuild(){this._dirtyAll=!0,this.setToRedraw()}_convertGeometries(i){const g=this.layer.getId();for(let m=0;m<i.length;m++){const _=i[m];let b=!1;for(let i=0;i<this.GeometryTypes.length;i++)if(_ instanceof this.GeometryTypes[i]){b=!0;break}if(!b)throw new Error(`${_.getJSONType()} can't be added to ${this.layer.getJSONType()}(id:${g}).`);this._convertGeo(_)}}_convertGeo(i){void 0===i[rB]&&(i[rB]=this._counter++);const g=i[rB];this.features[g]&&this._removeFeatures(g),this.features[g]=sB(i,this._kidGen,this.features[g]);return this._refreshFeatures(this.features[g],g),this._geometries[g]=i,g}_refreshFeatures(i,g){if(!i)return;const m=Array.isArray(i)?i[0].id:i.id;if(this._featureMapping[m]=i,Array.isArray(i))for(let m=0;m<i.length;m++){const _=i[m][mG];if(i[m][rB]=g,this._allFeatures[_]={feature:i[m]},this._allFeatures[_][rB]=g,!this.needCheckPointLineSymbols())continue;const b={feature:i[m]};(xG(i[m])||bG(i[m]))&&(this._markerFeatures[_]=b),bG(i[m])&&(this._textFeatures[_]=b),SG(i[m])&&(this._lineFeatures[_]=b)}else{i[rB]=g;const m={feature:i},_=i[mG];if(this._allFeatures[_]=m,!this.needCheckPointLineSymbols())return;(xG(i)||bG(i))&&(this._markerFeatures[_]=m),bG(i)&&(this._textFeatures[_]=m),SG(i)&&(this._lineFeatures[_]=m)}}needCheckPointLineSymbols(){return!0}_removeFeatures(i){const g=this.features[i];if(g)if(Array.isArray(g))for(let i=0;i<g.length;i++){const m=g[i][mG];delete this._featureMapping[g[i].id],delete this._allFeatures[m],delete this._markerFeatures[m],delete this._textFeatures[m],delete this._lineFeatures[m]}else{const i=g[mG];delete this._featureMapping[g.id],delete this._allFeatures[i],delete this._markerFeatures[i],delete this._textFeatures[i],delete this._lineFeatures[i]}}_removeAllFeatures(){this._featureMapping={},this._allFeatures={},this._markerFeatures={},this._textFeatures={},this._lineFeatures={}}pick(i,g,m){const _=[];if(!this.layer.isVisible())return _;return[this.painter,this._markerPainter,this._linePainter].forEach((b=>{if(!b)return;const T=b.pick(i,g,m.tolerance);if(T&&T.data&&T.data.feature){const i=this._geometries[T.data.feature[rB]];m&&m.includeInternals?_.push(i):(T.geometry=i,delete T.plugin,delete T.data,delete T.point,_.push(T))}})),_}_getFeaKeyId(i){const g=this.features[i[rB]];return Array.isArray(g)?g[0][mG]:g[mG]}_updateDirtyTargets(){let i=!1;for(const g in this._dirtyTargetsInCurrentFrame){const m=this._dirtyTargetsInCurrentFrame[g],_=this._getFeaKeyId(m);if(!this._isCreatingMarkerMesh&&(this._markerFeatures[_]||this._textFeatures[_])){const g=this._updateMarkerMesh(m);i=i||g}if(!this._isCreatingLineMesh&&this._lineFeatures[_]){const g=this._updateLineMesh(m);i=i||g}if(!this._isCreatingMesh){const g=this.updateMesh(m);i=i||g}}this._dirtyTargetsInCurrentFrame={},i&&(_G(this),this.layer.fire("partialupdate"))}_convertAndRebuild(i){this._convertGeo(i),this.markRebuild(),_G(this)}onGeometryAdd(i){this.setToRedraw(),this.canvas&&i&&i.length&&(this._convertGeometries(i),this.markRebuild(),_G(this))}onGeometryRemove(i){if(i&&i.length){for(let g=0;g<i.length;g++){const m=i[g][rB];void 0!==m&&(delete this._geometries[m],this._removeFeatures(m),delete this.features[m])}this.markRebuild(),_G(this)}}onGeometrySymbolChange(i){const g=i.target._getParent()||i.target,m=g[rB];if(void 0===m)return;let _=i.properties;if(Array.isArray(_)){const i={};for(let g=0;g<_.length;g++)_[g]&&iF(i,_[g]);_=i}else if(_&&void 0!==_[0]){const i={};for(const g in _)_[g]&&iF(i,_[g]);_=i}for(const i in _)if(fF(_,i)&&sG[i])return void this._convertAndRebuild(g);const b=g._getInternalSymbol(),T=this.features[m];if(this._convertGeo(g),T)if(function(i,g){return Array.isArray(i)?!!Array.isArray(g)&&i.length===g.length:!Array.isArray(g)}(b,T)){if(Array.isArray(b))for(let i=0;i<b.length;i++){if(!CG(b[i],T[i]))return void this._convertAndRebuild(g)}else if(!CG(b,T))return void this._convertAndRebuild(g);this.onGeometryPositionChange(i)}else this._convertAndRebuild(g);else this._convertAndRebuild(g)}onGeometryShapeChange(i){const g=i.target._getParent()||i.target;void 0!==g[rB]&&(this._convertGeometries([g]),this.markRebuildGeometry(),_G(this))}onGeometryPositionChange(i){const g=i.target._getParent()||i.target,m=g[rB];void 0!==m&&(this._convertGeometries([g]),this._dirtyTargetsInCurrentFrame[m]=g,_G(this))}onGeometryZIndexChange(i){void 0!==(i.target._getParent()||i.target)[rB]&&this.markRebuild()}onGeometryShow(i){void 0!==(i.target._getParent()||i.target)[rB]&&this._onShowHide(i)}onGeometryHide(i){void 0!==(i.target._getParent()||i.target)[rB]&&this._onShowHide(i)}_onShowHide(i){const g=i.target._getParent()||i.target,m=this.features[g[rB]];if(m){const i=g.isVisible();if(Array.isArray(m)){if(i===m[0].visible)return;for(let g=0;g<m.length;g++)m[g].visible=i}else{if(i===m.visible)return;m.visible=i}this._markShowHide(),_G(this)}}_markShowHide(){this._showHideUpdated=!0}onGeometryPropertiesChange(i){const g=i.target._getParent()||i.target,m=g[rB];void 0!==m&&this.painter&&(this.features[m]=sB(g,this._kidGen),this._refreshFeatures(this.features[m],m),this._markerMeshes&&this._markerMeshes.length&&this._markerPainter.needRebuildOnGometryPropertiesChanged()||this._lineMeshes&&this._lineMeshes.length&&this._linePainter.needRebuildOnGometryPropertiesChanged()||this.meshes&&this.meshes.length&&this.painter.needRebuildOnGometryPropertiesChanged()?this.markRebuild():this.painter.onFeatureChange(this.features[m],this.meshes),_G(this))}initContext(){super.initContext();const{regl:i,device:g,reglGL:m}=this.context,_=i||g;this.regl=i,this.gl=m,this.device=g||i;this.canvas.pickingFBO=this.canvas.pickingFBO||_.framebuffer({colorFormat:!!this.device.wpu?"bgra8unorm":"rgba",depthStencil:!0,width:this.canvas.width,height:this.canvas.height}),this.pickingFBO=this.canvas.pickingFBO,this.prepareRequestors(),this._initPainters()}_initPainters(){this.painter=this.createPainter();const i=Vector3DLayer.get3DPainterClass("icon");let g=i.getBloomSymbol();const m=iF({},QH,JH);m.markerPerspectiveRatio=this.layer.options.markerPerspectiveRatio||0,this._defineSymbolBloom(m,g),this._markerSymbol=m;const _=iF({},xF,this.layer.options.sceneConfig||{});this._markerPainter=new i(this.regl||this.device,this.layer,m,_,0),this._markerPainter.setShaderDefines({REVERSE_MAP_ROTATION_ON_PITCH:1});const b=Vector3DLayer.get3DPainterClass("line"),T=iF({},KH);g=b.getBloomSymbol(),this._defineSymbolBloom(T,g),this._lineSymbol=T;const P=iF({},this.layer.options.sceneConfig||{});void 0===P.depthMask&&(P.depthMask=!0),this._linePainter=new b(this.regl||this.device,this.layer,T,P,0),this.rebuildGeometries()}rebuildGeometries(){this._removeAllFeatures();const i=this.getCurrentNeedRenderGeos();i&&i.length&&this.onGeometryAdd(i),this.markRebuild()}getCurrentNeedRenderGeos(){return this.layer.getGeometries()}_defineSymbolBloom(i,g){for(let m=0;m<g.length;m++)i[g[m]]=this.layer.options.enableBloom}updateBloom(i){this._markerPainter&&this._updatePainterBloom(this._markerPainter,this._markerSymbol,i),this._linePainter&&this._updatePainterBloom(this._linePainter,this._lineSymbol,i),this.painter&&this._updatePainterBloom(this.painter,this.painterSymbol,i)}_updatePainterBloom(i,g,m){const _=i.constructor.getBloomSymbol().reduce(((i,_)=>(i[_]=m,g[_]=m,i)),{});i.updateSymbol(_,g)}createPainter(){}resizeCanvas(i){super.resizeCanvas(i);const g=this.canvas;g&&(!this.pickingFBO||this.pickingFBO.width===g.width&&this.pickingFBO.height===g.height||this.pickingFBO.resize(g.width,g.height),this.painter&&this.painter.resize(g.width,g.height))}onRemove(){super.onRemove(),this.painter&&(this.painter.delete(),delete this.painter),this._markerPainter&&(this._markerPainter.delete(),delete this._markerPainter),this._linePainter&&(this._linePainter.delete(),delete this._linePainter)}drawOutline(i){if(this._outlineAll&&(this.painter&&this.painter.outlineAll(i),this._markerPainter.outlineAll(i),this._linePainter.outlineAll(i)),this._outlineFeatures)for(let g=0;g<this._outlineFeatures.length;g++)this.painter&&this.painter.outline(i,this._outlineFeatures[g]),this._markerPainter.outline(i,this._outlineFeatures[g]),this._linePainter.outline(i,this._outlineFeatures[g])}outlineAll(){this._outlineAll=!0,this.setToRedraw()}outline(i){this._outlineFeatures||(this._outlineFeatures=[]);const g=[];for(let m=0;m<i.length;m++){const _=this.layer.getGeometryById(i[m]);if(_){const i=this.features[_[rB]];if(Array.isArray(i))for(let m=0;m<i.length;m++)g.push(i[m].id);else g.push(i.id)}}this._outlineFeatures.push(g),this.setToRedraw()}cancelOutline(){delete this._outlineAll,delete this._outlineFeatures,this.setToRedraw()}isEnableWorkAround(i){return"win-intel-gpu-crash"===i&&(this.layer.options.workarounds["win-intel-gpu-crash"]&&vG(this.gl))}_getCentiMeterScale(i){return dF(i,this.getMap())}_onSpatialReferenceChange(){const i=this.layer.getGeometries();i&&this._convertGeometries(i),this.markRebuild()}_getLayerOpacity(){const i=this.layer.options.opacity;return hF(i)?1:i}}function _G(i){i.setToRedraw()}function vG(i){const g=i.getExtension("WEBGL_debug_renderer_info");if(g&&"undefined"!=typeof navigator){const m=i.getParameter(g.UNMASKED_RENDERER_WEBGL),_="Win32"===navigator.platform||"Win64"===navigator.platform;if(m&&m.toLowerCase().indexOf("intel")>=0&&_)return!0}return!1}function xG({properties:i}){const g=(gG+"markerFile").trim(),m=(gG+"markerType").trim();return i[g]||i[m]}function bG({properties:i}){return i[(gG+"textName").trim()]}const wG=(gG+"lineWidth").trim(),TG=(eB+"").trim();function SG(i){return 2===i.type&&!i.properties[TG]||3===i.type&&void 0!==i.properties[wG]}function MG(i){if(!Array.isArray(i))return 0;let g=0;for(let m=0;m<i.length;m++)g+=i[m];return g}function CG(i,g){const m=Object.keys(i).sort().join(),_=Object.keys(g.properties||{}).filter((i=>0===i.indexOf(gG))).map((i=>i.substring(gG.length))).sort().join();if(m!==_)return!1;for(const m in i)if(fF(i,m)){const _=(gG+m).trim();if(wL(i[m])!==wL(g.properties[_]))return!1}return!0}function PG(i,g,m){if(!i||i.type!==g)return null;const _=new m(i.id,i.options),b=i.geometries,T=[];for(let i=0;i<b.length;i++){const g=gu.fromJSON(b[i]);g&&T.push(g)}return _.addGeometry(T),_}class PointLayer extends Vector3DLayer{static fromJSON(i){return PG(i,"PointLayer",PointLayer)}constructor(...i){super(...i),this.options.sceneConfig||(this.options.sceneConfig=iF({},xF))}getPolygonOffsetCount(){return 0}getPolygonOffset(){return 0}}PointLayer.mergeOptions({glyphSdfLimitPerFrame:15,iconErrorUrl:null,workarounds:{"win-intel-gpu-crash":!0},collision:!1,collisionFrameLimit:1}),PointLayer.registerJSONType("PointLayer"),PointLayer.registerRenderer("canvas",null);class PointLayerRenderer extends Vector3DLayerRenderer{constructor(...i){super(...i),this.GeometryTypes=[yf,Mf]}onGeometryAdd(i){i&&(Array.isArray(i)?i.forEach((i=>{i.options.maxMarkerWidth=i.options.maxMarkerHeight=255})):i.options.maxMarkerWidth=i.options.maxMarkerHeight=255,super.onGeometryAdd(i))}}PointLayer.registerRenderer("gl",PointLayerRenderer),PointLayer.registerRenderer("gpu",PointLayerRenderer);const{LinePack:IG}=JD();class LineStringLayer extends Vector3DLayer{static fromJSON(i){return PG(i,"LineStringLayer",LineStringLayer)}}LineStringLayer.mergeOptions({meshRenderOrder:1}),LineStringLayer.registerJSONType("LineStringLayer");const kG=(eB+"").trim();class LineStringLayerRenderer extends Vector3DLayerRenderer{constructor(...i){super(...i),this.GeometryTypes=[vf,Pf]}createPainter(){const i=Vector3DLayer.get3DPainterClass("line-gradient");this.painterSymbol=iF({},{lineGradientProperty:kG},KH),this._defineSymbolBloom(this.painterSymbol,i.getBloomSymbol());const g=iF({},this.layer.options.sceneConfig||{});void 0===g.depthMask&&(g.depthMask=!0);return new i(this.device||this.regl,this.layer,this.painterSymbol,g,0)}buildMesh(){let{features:i,center:g}=this._getFeaturesToRender();if(i=i.filter((i=>!!i.properties[kG])),!i.length)return;const m=this._showHideUpdated;this._meshCenter=g;const _=iF({},this.painterSymbol),b=this.createMesh(this.painter,IG,_,i,null,g);this._isCreatingMesh=!0,b.then((i=>{this.meshes&&this.painter.deleteMesh(this.meshes);const g=[],_=i&&i.meshes;if(_){g.push(..._);for(let i=0;i<_.length;i++)_[i].feaGroupIndex=0,_[i].geometry.properties.originElements=_[i].geometry.properties.elements.slice()}this.meshes=g,m&&(this._showHideUpdated=m),this._isCreatingMesh=!1,this.setToRedraw()}))}}LineStringLayer.registerRenderer("gl",LineStringLayerRenderer),LineStringLayer.registerRenderer("gpu",LineStringLayerRenderer),LineStringLayer.registerRenderer("canvas",null);const{PolygonPack:OG}=JD();class PolygonLayer extends Vector3DLayer{static fromJSON(i){return PG(i,"PolygonLayer",PolygonLayer)}}PolygonLayer.registerJSONType("PolygonLayer");const EG={polygonFill:{type:"identity",default:[1,1,1,1],property:"_symbol_polygonFill"},polygonPatternFile:{type:"identity",default:void 0,property:"_symbol_polygonPatternFile"},polygonOpacity:{type:"identity",default:1,property:"_symbol_polygonOpacity"},uvScale:{type:"identity",default:[1,1],property:"_symbol_uvScale"},uvOffset:{type:"identity",default:[0,0],property:"_symbol_uvOffset"},uvOffsetInMeter:{type:"identity",default:!1,property:"_symbol_uvOffsetInMeter"},polygonPatternFileWidth:{type:"identity",default:void 0,property:"_symbol_polygonPatternFileWidth"},polygonPatternFileHeight:{type:"identity",default:void 0,property:"_symbol_polygonPatternFileHeight"},polygonPatternFileOrigin:{type:"identity",default:void 0,property:"_symbol_polygonPatternFileOrigin"},polygonPatternUV:{type:"identity",default:void 0,property:"_symbol_polygonPatternUV"}};class PolygonLayerRenderer extends Vector3DLayerRenderer{constructor(){super(...arguments),this.GeometryTypes=[gf,If]}getPolygonOffsetCount(){return this.options.altitude>0?0:2}buildMesh(i){const{features:g,center:m}=this._getFeaturesToRender();if(!g.length)return;const _=this._showHideUpdated;this._meshCenter=m;const b=this._groupPolygonFeatures(g),T=iF({},EG),P=b.map(((g,_)=>this.createMesh(this.painter,OG,T,g,i&&i[_],m)));this._isCreatingMesh=!0,Promise.all(P).then((i=>{this.meshes&&this.painter.deleteMesh(this.meshes),i=function(i){const g=[];for(let m=0;m<i.length;m++)Array.isArray(i[m])?g.push(...i[m]):g.push(i[m]);return g}(i);const g=[],m=[];for(let _=0;_<i.length;_++){const b=i[_]&&i[_].meshes;if(b){g.push(...b);for(let i=0;i<b.length;i++)b[i].feaGroupIndex=_,b[i].geometry.properties.originElements=b[i].geometry.properties.elements.slice(),1===_&&(b[i].transparent=!0);m[_]=i[_].atlas}}this.meshes=g,this.atlas=m,_&&(this._showHideUpdated=_),this._isCreatingMesh=!1,this.setToRedraw(),this.layer.fire("buildmesh")}))}getRayCastData(i,g){const m=this.painter.getRayCastData(i,g);if(!m||!m.feature)return null;return this._geometries[m.feature[rB]]}_groupPolygonFeatures(i){const g=[],m=[];for(let _=0;_<i.length;_++){const b=i[_];b.properties&&b.properties._symbol_polygonOpacity<1?m.push(b):g.push(b)}return[g,m]}createPainter(){const i=Vector3DLayer.get3DPainterClass("fill"),g=this.painterSymbol=iF({},EG);this._defineSymbolBloom(g,i.getBloomSymbol());return new i(this.regl||this.device,this.layer,g,this.layer.options.sceneConfig,0)}updateMesh(i){return this._updateMesh(i,this.meshes,this.atlas,this._meshCenter,this.painter,OG,EG,this._groupPolygonFeatures)}}function RG(i,g,m,_,b,T,P){const I=m&&Array.isArray(m[0]);for(let T=0,H=m.length;T<H;T++){i[g]=(I?m[T][0]:m[T].x)*_,i[g+1]=(I?m[T][1]:m[T].y)*_,P!==Float32Array&&(i[g]=Math.round(i[g]),i[g+1]=Math.round(i[g+1]));let H=b||0;Array.isArray(b)&&(H=b[T]),H=H?Math.round(_*H):0,i[g+2]=H,g+=3}return i.trySetLength&&i.trySetLength(g),g}function LG(i,g,m,_){const b=i[3*g],T=i[3*g+1];return b===i[3*m]&&(b<0||b>_)||T===i[3*m+1]&&(T<0||T>_)}PolygonLayer.registerRenderer("gl",PolygonLayerRenderer),PolygonLayer.registerRenderer("gpu",PolygonLayerRenderer),PolygonLayer.registerRenderer("canvas",null);const DG=Math.PI/180,FG=6378137*Math.PI/180,NG=85.0511287798;function HG(i,g,m){return function(i,g){const m=NG,_=g[0],b=Math.max(Math.min(m,g[1]),-85.0511287798);let T;T=0===b?0:Math.log(Math.tan((90+b)*DG/2))/DG;return i[0]=_*FG,i[1]=T*FG,i}(i,g)}function BG(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be){0===i?function(i,g,m,_,b,T,P,I,H,W){const q=1/(100*T[0]),$=1/(100*T[1]),ye=W&&W[0]||0,Re=W&&W[1]||0,Be=[0,0];for(let b=i;b<g;b+=3){const i=b/3*2,g=_[b+1]-Re;m[i]=Be[0]+(_[b]-ye)/P*q/I,m[i+1]=Be[1]-g/P*$/H}}(g,m,_,b,0,P,I,H,W,Be):1===i&&function(i,g,m,_,b,T,P,I,H,W,q){if(!i)return;let $,ye,Re,Be;0===i[4]?($=i[0],ye=i[1],Re=i[2],Be=i[3]):($=i[1],ye=i[2],Re=i[3],Be=i[0]);const Ge=q_($,ye),je=q_(ye,Re),Xe=[],Ze=[],Ye=[];for(let i=g;i<m;i+=3){const g=i/3*2;z_(Xe,(T.x/H+b[i]/P)*I,T.y/H*I+(q?b[i+1]:-b[i+1])/P*I),"EPSG:4326"!==W&&"EPSG:4490"!==W||HG(Xe,Xe),zG(Ze,Xe,$,ye),zG(Ye,Xe,Be,$),_[g]=q_($,Ze)/Ge,_[g+1]=q_($,Ye)/je}}(q,g,m,_,b,T,I,$,ye,Re,!!Be)}function zG(i,g,m,_){const b=m[0]-_[0],T=m[1]-_[1];let P=(g[0]-m[0])*(m[0]-_[0])+(g[1]-m[1])*(m[1]-_[1]);return P/=b*b+T*T,i[0]=m[0]+P*b,i[1]=m[1]+P*T,i}function VG(i,g,m,_,b){return T=_,P=b,I=i[3*g[m-1]],H=i[3*g[m-1]+1],Math.sqrt((I-T)*(I-T)+(H-P)*(H-P));var T,P,I,H}const{PackUtil:UG,ArrayPool:GG}=JD();function jG(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be,Ge,je){const Xe=g.getLength(),Ze=b/3;for(let m=2,_=Xe;m<_;m+=3)i[b+m-2]=g[m-2],i[b+m-1]=g[m-1],i[b+m-0]=g[m]-P;b+=Xe;for(let m=2,_=Xe;m<_;m+=3)i[b+m-2]=g[m-2],i[b+m-1]=g[m-1],i[b+m-0]=g[m]-I;i.trySetLength((b+=Xe)+Xe),i.copyWithin(b,b-2*Xe,b-Xe),i.trySetLength((b+=Xe)+Xe),i.copyWithin(b,b-2*Xe,b-Xe),b+=Xe,(m=m||[]).push(Xe/3);const Ye=m.getLength();for(let g=0;g<Ye;g++){WG(Ze+(m[g-1]||0),Ze+m[g],i,Xe/3,H,_,W,q,$,ye,T,Re,Be,Ge,je)}return b}function WG(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be){const Ge=T.getLength();let je,Xe;for(let P=i,I=g;P<I-1;P++)if(je=P,Xe=P+1,b===1/0||!LG(m,je,Xe,b))if((P-i)%2==1&&(je+=2*_,Xe+=2*_),Be){let i=T.currentIndex;T[i++]=je+_,T[i++]=Xe,T[i++]=je,T[i++]=Xe+_,T[i++]=Xe,T[i++]=je+_,T.currentIndex=i}else{let i=T.currentIndex;T[i++]=je+_,T[i++]=je,T[i++]=Xe,T[i++]=Xe,T[i++]=Xe+_,T[i++]=je+_,T.currentIndex=i}P&&function(i,g,m,_,b,T,P,I,H,W,q,$){let ye,Re=0,Be=0,Ge=0,je=0;const Xe=$?[1,3,4]:[2,3,4];for(let $=T.getLength()-1;$>=P;$--){const P=T[$],Ze=3*P+2,Ye=b[3*P],Qe=b[3*P+1],Je=b[Ze];Re||Be||(Re=Math.max(b[Ze],b[3*T[$-3]+2]),Be=Math.min(b[Ze],b[3*T[$-3]+2]),ye=Re-Be);let Ke=Ge;const et=$%6;let tt;0===i?(5===et&&(je=VG(b,T,$,Ye,Qe)),Ke=et===Xe[0]||et===Xe[1]||et===Xe[2]?Ge:Ge+je):1===i&&(et===Xe[0]||et===Xe[1]||et===Xe[2]?Ke=0:5===et?(je=VG(b,T,$,Ye,Qe),Ke=je):Ke=je),tt=1===g?Je===Re?1:0:"bottom"===m?Je===Re?ye/100/H:0:Je===Re?0:-ye/100/H,_[2*P]=Ke/W*(1/(100*q))/I,_[2*P+1]=tt,0===et&&(Ge+=je)}}(I,H,W,q,m,T,Ge,$[0],$[1],ye,Re,Be)}function qG(i){const g=[i[0]];let m=i[0];for(let _=1;_<i.length;_++)Array.isArray(i[_])?i[_][0]===m[0]&&i[_][1]===m[1]&&i[_][2]===m[2]||g.push(i[_]):i[_].x===m.x&&i[_].y===m.y&&i[_].z===m.z||g.push(i[_]),m=i[_];return g}const{StyleUtil:XG,PackUtil:ZG,ArrayPool:$G}=JD(),YG=$G.getInstance();function QG(i,g,m,_,b,T,P,I,H,W,q,$,ye,Re,Be,Ge){void 0===g.top&&(g.top=!0),void 0===g.side&&(g.side=!0),YG.reset();const{altitudeScale:je,altitudeProperty:Xe,defaultAltitude:Ze,heightProperty:Ye,minHeightProperty:Qe,defaultHeight:Je,tangent:Ke,uv:et,topUVMode:tt,sideUVMode:at,sideVerticalUVMode:ht,top:gt,side:yt,textureYOrigin:vt,topThickness:xt}=g,bt=!!Ge,Tt=function(i,g,{altitudeScale:m,altitudeProperty:_,defaultAltitude:b,heightProperty:T,minHeightProperty:P,defaultHeight:I},{center:H,side:W,top:q,topThickness:$,uvOrigin:ye,uv:Re,uvSize:Be,topUVMode:Ge,sideUVMode:je,sideVerticalUVMode:Xe,textureYOrigin:Ze,tileRatio:Ye,centimeterToPoint:Qe,verticalCentimeterToPoint:Je,positionType:Ke,res:et,glScale:tt,projectionCode:at},ht,gt){let yt=g/i[0].extent;g===1/0&&(yt=1);const vt=g===1/0,xt=gt.get(),bt=gt.get(),Tt=gt.get(),Mt=gt.getProxy(),Pt=gt.get(),It=gt.get(),Et=gt.get(),Lt=!!Re,Dt=!!q,Ft=!!W,Ht=Lt?gt.get():null;function Bt(i,m,_,b,T,P){let I=m;if(Dt){const W=oD(Mt,_,3);if(0===W.length)return m;let q=Mt.getLength(),Re=Pt.currentIndex;for(let i=0;i<q;i++)Pt[Re++]=Mt[i];if(Pt.currentIndex=Re,m+=Mt.getLength(),P)for(let g=2,m=W.length;g<m;g+=3)W[g]+=i/3,W[g-1]+=i/3,W[g-2]+=i/3;else{let g;for(let m=2,_=W.length;m<_;m+=3)g=W[m-1],W[m-1]=W[m]+i/3,W[m]=g+i/3,W[m-2]+=i/3}q=W.length,Re=It.currentIndex;for(let i=0;i<q;i++)It[Re++]=W[i];It.currentIndex=Re,Lt&&BG(Ge||0,i,m,Ht,Pt,ye,Qe,Ye,Be[0],Be[1],T,et,tt,at,H),$>0&&!Ft&&(m=jG(Pt,Mt,_,It,m,Ht,0,$,g,Lt,je||0,Xe||0,Ze,Be,Ye,Je,b<0?!P:P)),Et.setLength(m/3),Et.fill(1,I/3,m/3)}if(Ft){Dt&&($=0),I=m,m=jG(Pt,Mt,_,It,m,Ht,$,b,g,Lt,je||0,Xe||0,Ze,Be,Ye,Je,b<0?!P:P),Et.setLength(m/3);const i=Mt.getLength()/3;Et.fill(1,I/3,I/3+i),Et.fill(0,I/3+i,I/3+2*i),Et.fill(1,I/3+2*i,I/3+3*i),Et.fill(0,I/3+3*i,m/3)}return m}let zt=-1/0,Vt=1/0,Ut=0;const Gt=[-1,-1,g+1,g+1];let jt=0,Wt=i.length;sF(ht)&&(jt=ht,Wt=ht+1);let qt=0,Xt=!1;const Zt=gt.getProxy();let $t=!1;for(;jt<Wt;jt++){const H=i[jt],W=H.id;sF(W)&&(Math.abs(W)>qt&&(qt=Math.abs(W)),W<0&&(Xt=!0));const q=H.geometry,$=H.properties[IF];let ye=Array.isArray($&&$[0]&&$[0][0])?$[0]:$;const{altitude:Re,height:Be}=UG.getFeaAltitudeAndHeight(H,m,_,b,T,I,P);Be<0?($t=!0,Vt=Math.min(Re,Vt),zt=Math.max(Re-Be,zt)):(zt=Math.max(Re,zt),Vt=Math.min(Re-Be,Vt));const Ge=Pt.getLength();let je=0,Xe=Ut;Zt.setLength(0),Mt.setLength(0);const Ze=UG.calculateSignedArea(q[0])<0;for(let i=0,m=q.length;i<m;i++){let _=q[i];Ze&&(_=_.reverse()),_=qG(_);const b=UG.calculateSignedArea(_)<0;if(!b&&i>0&&(je++,ye=$&&$[je],Ut=Bt(Xe,Ut,Zt,Be*yt,ye,vt),Mt.setLength(0),Zt.setLength(0),Xe=Ut),g!==1/0&&(_=UG.clipPolygon(_,Gt)),!_.length){i===m-1&&(Ut=Bt(Xe,Ut,Zt,Be*yt,ye,vt));continue}const T=_.length;if(Array.isArray(_[0])?_[0][0]===_[T-1][0]&&_[0][1]===_[T-1][1]||_.push([_[0][0],_[0][1]]):_[0].x===_[T-1].x&&_[0].y===_[T-1].y||_.push(_[0]),b){let i=Zt.currentIndex;Zt[i++]=Mt.getLength()/3,Zt.currentIndex=i}RG(Mt,Mt.getLength(),_,yt,Re,0,Ke),i===m-1&&(Ut=Bt(Xe,Ut,Zt,Be*yt,ye,vt))}const Ye=Pt.getLength()-Ge,Qe=(MF+"").trim();for(let i=0;i<Ye/3;i++){let i=bt.currentIndex;bt[i++]=void 0===H[Qe]?jt:H[Qe],bt.currentIndex=i,i=xt.currentIndex,xt[i++]=jt,xt.currentIndex=i,sF(W)&&(i=Tt.currentIndex,Tt[i++]=W,Tt.currentIndex=i)}}const Yt=UG.getUnsignedArrayType(bt.getLength()?bt[bt.getLength()-1]:0),Qt={hasNegativeHeight:$t,maxAltitude:zt===-1/0?0:zt,minAltitude:Vt===1/0?0:Vt,vertices:Pt,verticeTypes:Et,indices:It,pickingIds:GG.createTypedArray(bt,Yt),featureIndexes:xt};if(Tt.getLength()){const i=Xt?UG.getPosArrayType(qt):UG.getUnsignedArrayType(qt);Qt.featureIds=GG.createTypedArray(Tt,i)}else Qt.featureIds=[];return Ht&&(Ht.setLength(Pt.getLength()/3*2),Qt.uvs=Ht),Qt}(i,m,{altitudeScale:je,altitudeProperty:Xe,defaultAltitude:Ze||0,heightProperty:Ye,minHeightProperty:Qe,defaultHeight:Je||0},{center:Ge,top:gt,side:yt,topThickness:10*xt||0,uv:et||Ke,uvSize:[b,b],uvOrigin:_,topUVMode:tt,sideUVMode:at,sideVerticalUVMode:ht,textureYOrigin:vt,tileRatio:I,centimeterToPoint:H,verticalCentimeterToPoint:W,positionType:Be,res:T,glScale:P,projectionCode:ye},Re,YG),Mt=[],Pt=Tt.vertices.getLength()/3,It=ZG.getIndexArrayType(Pt),Et=$G.createTypedArray(Tt.indices,It);delete Tt.indices,Mt.push(Et.buffer,Tt.pickingIds.buffer);const Lt=Math.max(Math.abs(Tt.maxAltitude),Math.abs(Tt.minAltitude)),Dt=Be||ZG.getPosArrayType(Math.max(512,Lt));Tt.vertices=$G.createTypedArray(Tt.vertices,Dt);const Ft=Ke?YG.getProxy():new Float32Array(3*Pt);Ft.setLength&&Ft.setLength(3*Pt);const Ht=Pv(Tt.vertices,Et,Ft);let Bt=!0;const zt=Ht.getLength?Ht.getLength():Ht.length;for(let i=0;i<zt;i++){bt||(Ht[i]=-Ht[i]);const g=Ht[i]%1;1-Math.abs(g)>1e-6?Bt=!1:0!==g&&(Ht[i]=Math.round(Ht[i]))}if(Tt.normals=Ht,Ke){let i=YG.get();i.setLength(4*Pt),i=Nv(Tt.vertices,Tt.normals,Tt.uvs,Et,i),i=function(i,g){const m=g.getLength(),_=new Float32Array(m),b=[],T=[],P=[];for(let I=0;I<m;I+=4){const m=I/4*3;qA(T,i[m]||0,i[m+1]||0,i[m+2]||0),wy(b,g[I]||0,g[I+1]||0,g[I+2]||0,g[I+3]||0),Mv(P,T,b),by(_.subarray(I,I+4),P)}return _}(Tt.normals,i),Tt.tangents=i,Mt.push(i.buffer),delete Tt.normals}if(Tt.normals&&(Bt&&(Tt.normals=$G.createTypedArray(Tt.normals,Int8Array)),Mt.push(Tt.normals.buffer)),Tt.uvs){Tt.uvs=$G.createTypedArray(Tt.uvs,Float32Array),Mt.push(Tt.uvs.buffer)}if(Ge){const i=Tt.vertices,g=i.length;for(let m=0;m<g;m+=3)i[m]-=Ge[0],i[m+1]-=Ge[1]}const Vt=function(i,g,m,_){const b={},T={},P=_.getLength();if(uF(g.polygonFill)){let I=ML(g.polygonFill);const H=new Uint8Array(4*P);H.fill(255);for(let g=0;g<P;g++){const T=i[_[g]],P=T.properties||{};P.$layer=T.layer,P.$type=T.type;let W=I(m,P);wL(W)&&(b.aColor=1,I=ML(W),W=I(m,P)),delete P.$layer,delete P.$type,XG.normalizeColor(JG,W),H[4*g]=JG[0],H[4*g+1]=JG[1],H[4*g+2]=JG[2],H[4*g+3]=JG[3]}T.aColor=H}if(uF(g.polygonOpacity)){let I=SL(g.polygonOpacity);const H=new Uint8Array(P);H.fill(255);for(let g=0;g<P;g++){const T=i[_[g]],P=T.properties||{};P.$layer=T.layer,P.$type=T.type;let W=I(m,P);wL(W)&&(b.aOpacity=1,I=ML(W),W=I(m,P)),delete P.$layer,delete P.$type,H[g]=255*W}T.aOpacity=H}return T.dynamicAttributes=b,T}(i,q,$,Tt.featureIndexes),Ut=function(i,g,m,_,b){const T=[[],[]],P=uF(_.topPolygonFill),I=uF(_.bottomPolygonFill),H=[255,255,255,255],W=g.getLength();if(P||I){let q=P&&ML(_.topPolygonFill),$=I&&ML(_.bottomPolygonFill),ye=null,Re=null,Be=null,Ge=null;for(let _=0;_<W;_++){if(1===i[_]&&!P||0===i[_]&&!I)continue;const W=1===i[_];if(W&&g[_]===ye){i[_]=Be;continue}if(!W&&g[_]===Re){i[_]=Ge;continue}const je=m[g[_]],Xe=je.properties||{};Xe.$layer=je.layer,Xe.$type=je.type;let Ze=W?q:$,Ye=Ze(b,Xe);wL(Ye)&&(Ze=ML(Ye),Ye=Ze(b,Xe)),delete Xe.$layer,delete Xe.$type,XG.normalizeColor(JG,Ye),Cy(JG,JG,H);let Qe=KG(T,JG);Qe<0&&(Qe=T.length,T.push(by([],JG))),i[_]=Qe,W?(ye=g[_],Be=Qe):(Re=g[_],Ge=Qe)}}return T.slice(2)}(Tt.verticeTypes,Tt.featureIndexes,i,q,$),Gt={data:{data:{aVertexColorType:$G.createTypedArray(Tt.verticeTypes,Ut.length<=252?Uint8Array:Uint16Array),aPosition:Tt.vertices,aNormal:Tt.normals,aTexCoord0:Tt.uvs,aTangent:Tt.tangents,aPickingId:Tt.pickingIds},indices:Et,properties:{maxAltitude:Tt.maxAltitude/100,minAltitude:Tt.minAltitude/100,hasNegativeHeight:Tt.hasNegativeHeight},dynamicAttributes:Vt.dynamicAttributes,vertexColors:Ut},buffers:Mt};return Tt.featureIds.length?(Gt.data.featureIds=Tt.featureIds,Mt.push(Gt.data.featureIds.buffer)):Gt.data.featureIds=[],Vt.aColor&&(Gt.data.data.aColor=Vt.aColor,Gt.buffers.push(Vt.aColor.buffer)),Vt.aOpacity&&(Gt.data.data.aOpacity=Vt.aOpacity,Gt.buffers.push(Vt.aOpacity.buffer)),Gt.buffers.push(Gt.data.data.aPosition.buffer),Gt.data.pickingIdIndiceMap=ZG.generatePickingIndiceIndex(Gt.data.data.aPickingId,Gt.data.indices),Gt}const JG=[];function KG(i,g){for(let m=0;m<i.length;m++)if(Ny(g,i[m]))return m;return-1}JD();class TinyQueue{constructor(i=[],g=ej){if(this.data=i,this.length=this.data.length,this.compare=g,this.length>0)for(let i=(this.length>>1)-1;i>=0;i--)this._down(i)}push(i){this.data.push(i),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const i=this.data[0],g=this.data.pop();return this.length--,this.length>0&&(this.data[0]=g,this._down(0)),i}peek(){return this.data[0]}_up(i){const{data:g,compare:m}=this,_=g[i];for(;i>0;){const b=i-1>>1,T=g[b];if(m(_,T)>=0)break;g[i]=T,i=b}g[i]=_}_down(i){const{data:g,compare:m}=this,_=this.length>>1,b=g[i];for(;i<_;){let _=1+(i<<1),T=g[_];const P=_+1;if(P<this.length&&m(g[P],T)<0&&(_=P,T=g[P]),m(T,b)>=0)break;g[i]=T,i=_}g[i]=b}}function ej(i,g){return i<g?-1:i>g?1:0}var tj={exports:{}},nj=function(i,g,m,_){var b=i[0],T=i[1],P=!1;void 0===m&&(m=0),void 0===_&&(_=g.length);for(var I=(_-m)/2,H=0,W=I-1;H<I;W=H++){var q=g[m+2*H+0],$=g[m+2*H+1],ye=g[m+2*W+1];$>T!=ye>T&&b<(g[m+2*W+0]-q)*(T-$)/(ye-$)+q&&(P=!P)}return P},rj=function(i,g,m,_){var b=i[0],T=i[1],P=!1;void 0===m&&(m=0),void 0===_&&(_=g.length);for(var I=_-m,H=0,W=I-1;H<I;W=H++){var q=g[H+m][0],$=g[H+m][1],ye=g[W+m][1];$>T!=ye>T&&b<(g[W+m][0]-q)*(T-$)/(ye-$)+q&&(P=!P)}return P};tj.exports=function(i,g,m,_){return g.length>0&&Array.isArray(g[0])?rj(i,g,m,_):nj(i,g,m,_)};var ij=tj.exports.nested=rj;tj.exports.flat=nj;const oj=11102230246251565e-32,sj=134217729,aj=(3+8*oj)*oj;function lj(i,g,m,_,b){let T,P,I,H,W=g[0],q=_[0],$=0,ye=0;q>W==q>-W?(T=W,W=g[++$]):(T=q,q=_[++ye]);let Re=0;if($<i&&ye<m)for(q>W==q>-W?(P=W+T,I=T-(P-W),W=g[++$]):(P=q+T,I=T-(P-q),q=_[++ye]),T=P,0!==I&&(b[Re++]=I);$<i&&ye<m;)q>W==q>-W?(P=T+W,H=P-T,I=T-(P-H)+(W-H),W=g[++$]):(P=T+q,H=P-T,I=T-(P-H)+(q-H),q=_[++ye]),T=P,0!==I&&(b[Re++]=I);for(;$<i;)P=T+W,H=P-T,I=T-(P-H)+(W-H),W=g[++$],T=P,0!==I&&(b[Re++]=I);for(;ye<m;)P=T+q,H=P-T,I=T-(P-H)+(q-H),q=_[++ye],T=P,0!==I&&(b[Re++]=I);return 0===T&&0!==Re||(b[Re++]=T),Re}function hj(i){return new Float64Array(i)}const cj=hj(4),uj=hj(8),fj=hj(12),dj=hj(16),pj=hj(4);function gj(i,g,m,_,b,T){const P=(g-T)*(m-b),I=(i-b)*(_-T),H=P-I;if(0===P||0===I||P>0!=I>0)return H;const W=Math.abs(P+I);return Math.abs(H)>=33306690738754716e-32*W?H:-function(i,g,m,_,b,T,P){let I,H,W,q,$,ye,Re,Be,Ge,je,Xe,Ze,Ye,Qe,Je,Ke,et,tt;const at=i-b,ht=m-b,gt=g-T,yt=_-T;Qe=at*yt,ye=sj*at,Re=ye-(ye-at),Be=at-Re,ye=sj*yt,Ge=ye-(ye-yt),je=yt-Ge,Je=Be*je-(Qe-Re*Ge-Be*Ge-Re*je),Ke=gt*ht,ye=sj*gt,Re=ye-(ye-gt),Be=gt-Re,ye=sj*ht,Ge=ye-(ye-ht),je=ht-Ge,et=Be*je-(Ke-Re*Ge-Be*Ge-Re*je),Xe=Je-et,$=Je-Xe,cj[0]=Je-(Xe+$)+($-et),Ze=Qe+Xe,$=Ze-Qe,Ye=Qe-(Ze-$)+(Xe-$),Xe=Ye-Ke,$=Ye-Xe,cj[1]=Ye-(Xe+$)+($-Ke),tt=Ze+Xe,$=tt-Ze,cj[2]=Ze-(tt-$)+(Xe-$),cj[3]=tt;let vt=function(i,g){let m=g[0];for(let _=1;_<i;_++)m+=g[_];return m}(4,cj),xt=22204460492503146e-32*P;if(vt>=xt||-vt>=xt)return vt;if($=i-at,I=i-(at+$)+($-b),$=m-ht,W=m-(ht+$)+($-b),$=g-gt,H=g-(gt+$)+($-T),$=_-yt,q=_-(yt+$)+($-T),0===I&&0===H&&0===W&&0===q)return vt;if(xt=11093356479670487e-47*P+aj*Math.abs(vt),vt+=at*q+yt*I-(gt*W+ht*H),vt>=xt||-vt>=xt)return vt;Qe=I*yt,ye=sj*I,Re=ye-(ye-I),Be=I-Re,ye=sj*yt,Ge=ye-(ye-yt),je=yt-Ge,Je=Be*je-(Qe-Re*Ge-Be*Ge-Re*je),Ke=H*ht,ye=sj*H,Re=ye-(ye-H),Be=H-Re,ye=sj*ht,Ge=ye-(ye-ht),je=ht-Ge,et=Be*je-(Ke-Re*Ge-Be*Ge-Re*je),Xe=Je-et,$=Je-Xe,pj[0]=Je-(Xe+$)+($-et),Ze=Qe+Xe,$=Ze-Qe,Ye=Qe-(Ze-$)+(Xe-$),Xe=Ye-Ke,$=Ye-Xe,pj[1]=Ye-(Xe+$)+($-Ke),tt=Ze+Xe,$=tt-Ze,pj[2]=Ze-(tt-$)+(Xe-$),pj[3]=tt;const bt=lj(4,cj,4,pj,uj);Qe=at*q,ye=sj*at,Re=ye-(ye-at),Be=at-Re,ye=sj*q,Ge=ye-(ye-q),je=q-Ge,Je=Be*je-(Qe-Re*Ge-Be*Ge-Re*je),Ke=gt*W,ye=sj*gt,Re=ye-(ye-gt),Be=gt-Re,ye=sj*W,Ge=ye-(ye-W),je=W-Ge,et=Be*je-(Ke-Re*Ge-Be*Ge-Re*je),Xe=Je-et,$=Je-Xe,pj[0]=Je-(Xe+$)+($-et),Ze=Qe+Xe,$=Ze-Qe,Ye=Qe-(Ze-$)+(Xe-$),Xe=Ye-Ke,$=Ye-Xe,pj[1]=Ye-(Xe+$)+($-Ke),tt=Ze+Xe,$=tt-Ze,pj[2]=Ze-(tt-$)+(Xe-$),pj[3]=tt;const Tt=lj(bt,uj,4,pj,fj);Qe=I*q,ye=sj*I,Re=ye-(ye-I),Be=I-Re,ye=sj*q,Ge=ye-(ye-q),je=q-Ge,Je=Be*je-(Qe-Re*Ge-Be*Ge-Re*je),Ke=H*W,ye=sj*H,Re=ye-(ye-H),Be=H-Re,ye=sj*W,Ge=ye-(ye-W),je=W-Ge,et=Be*je-(Ke-Re*Ge-Be*Ge-Re*je),Xe=Je-et,$=Je-Xe,pj[0]=Je-(Xe+$)+($-et),Ze=Qe+Xe,$=Ze-Qe,Ye=Qe-(Ze-$)+(Xe-$),Xe=Ye-Ke,$=Ye-Xe,pj[1]=Ye-(Xe+$)+($-Ke),tt=Ze+Xe,$=tt-Ze,pj[2]=Ze-(tt-$)+(Xe-$),pj[3]=tt;const Mt=lj(Tt,fj,4,pj,dj);return dj[Mt-1]}(i,g,m,_,b,T,W)}function mj(i,g,m){g=Math.max(0,void 0===g?2:g),m=m||0;var _=function(i){for(var g=i[0],m=i[0],_=i[0],b=i[0],T=0;T<i.length;T++){var P=i[T];P[0]<g[0]&&(g=P),P[0]>_[0]&&(_=P),P[1]<m[1]&&(m=P),P[1]>b[1]&&(b=P)}var I=[g,m,_,b],H=I.slice();for(T=0;T<i.length;T++)ij(i[T],I)||H.push(i[T]);return function(i){i.sort(Pj);for(var g=[],m=0;m<i.length;m++){for(;g.length>=2&&bj(g[g.length-2],g[g.length-1],i[m])<=0;)g.pop();g.push(i[m])}for(var _=[],b=i.length-1;b>=0;b--){for(;_.length>=2&&bj(_[_.length-2],_[_.length-1],i[b])<=0;)_.pop();_.push(i[b])}return _.pop(),g.pop(),g.concat(_)}(H)}(i),b=new RBush(16);b.toBBox=function(i){return{minX:i[0],minY:i[1],maxX:i[0],maxY:i[1]}},b.compareMinX=function(i,g){return i[0]-g[0]},b.compareMinY=function(i,g){return i[1]-g[1]},b.load(i);for(var T,P=[],I=0;I<_.length;I++){var H=_[I];b.remove(H),T=Tj(H,T),P.push(T)}var W=new RBush(16);for(I=0;I<P.length;I++)W.insert(wj(P[I]));for(var q=g*g,$=m*m;P.length;){var ye=P.shift(),Re=ye.p,Be=ye.next.p,Ge=Sj(Re,Be);if(!(Ge<$)){var je=Ge/q;(H=Aj(b,ye.prev.p,Re,Be,ye.next.next.p,je,W))&&Math.min(Sj(H,Re),Sj(H,Be))<=je&&(P.push(ye),P.push(Tj(H,ye)),b.remove(H),W.remove(ye),W.insert(wj(ye)),W.insert(wj(ye.next)))}}ye=T;var Xe=[];do{Xe.push(ye.p),ye=ye.next}while(ye!==T);return Xe.push(ye.p),Xe}function Aj(i,g,m,_,b,T,P){for(var I=new TinyQueue([],yj),H=i.data;H;){for(var W=0;W<H.children.length;W++){var q=H.children[W],$=H.leaf?Mj(q,m,_):_j(m,_,q);$>T||I.push({node:q,dist:$})}for(;I.length&&!I.peek().node.children;){var ye=I.pop(),Re=ye.node,Be=Mj(Re,g,m),Ge=Mj(Re,_,b);if(ye.dist<Be&&ye.dist<Ge&&xj(m,Re,P)&&xj(_,Re,P))return Re}(H=I.pop())&&(H=H.node)}return null}function yj(i,g){return i.dist-g.dist}function _j(i,g,m){if(vj(i,m)||vj(g,m))return 0;var _=Cj(i[0],i[1],g[0],g[1],m.minX,m.minY,m.maxX,m.minY);if(0===_)return 0;var b=Cj(i[0],i[1],g[0],g[1],m.minX,m.minY,m.minX,m.maxY);if(0===b)return 0;var T=Cj(i[0],i[1],g[0],g[1],m.maxX,m.minY,m.maxX,m.maxY);if(0===T)return 0;var P=Cj(i[0],i[1],g[0],g[1],m.minX,m.maxY,m.maxX,m.maxY);return 0===P?0:Math.min(_,b,T,P)}function vj(i,g){return i[0]>=g.minX&&i[0]<=g.maxX&&i[1]>=g.minY&&i[1]<=g.maxY}function xj(i,g,m){for(var _,b,T,P,I=Math.min(i[0],g[0]),H=Math.min(i[1],g[1]),W=Math.max(i[0],g[0]),q=Math.max(i[1],g[1]),$=m.search({minX:I,minY:H,maxX:W,maxY:q}),ye=0;ye<$.length;ye++)if(b=$[ye].next.p,T=i,(_=$[ye].p)!==(P=g)&&b!==T&&bj(_,b,T)>0!=bj(_,b,P)>0&&bj(T,P,_)>0!=bj(T,P,b)>0)return!1;return!0}function bj(i,g,m){return gj(i[0],i[1],g[0],g[1],m[0],m[1])}function wj(i){var g=i.p,m=i.next.p;return i.minX=Math.min(g[0],m[0]),i.minY=Math.min(g[1],m[1]),i.maxX=Math.max(g[0],m[0]),i.maxY=Math.max(g[1],m[1]),i}function Tj(i,g){var m={p:i,prev:null,next:null,minX:0,minY:0,maxX:0,maxY:0};return g?(m.next=g.next,m.prev=g,g.next.prev=m,g.next=m):(m.prev=m,m.next=m),m}function Sj(i,g){var m=i[0]-g[0],_=i[1]-g[1];return m*m+_*_}function Mj(i,g,m){var _=g[0],b=g[1],T=m[0]-_,P=m[1]-b;if(0!==T||0!==P){var I=((i[0]-_)*T+(i[1]-b)*P)/(T*T+P*P);I>1?(_=m[0],b=m[1]):I>0&&(_+=T*I,b+=P*I)}return(T=i[0]-_)*T+(P=i[1]-b)*P}function Cj(i,g,m,_,b,T,P,I){var H,W,q,$,ye=m-i,Re=_-g,Be=P-b,Ge=I-T,je=i-b,Xe=g-T,Ze=ye*ye+Re*Re,Ye=ye*Be+Re*Ge,Qe=Be*Be+Ge*Ge,Je=ye*je+Re*Xe,Ke=Be*je+Ge*Xe,et=Ze*Qe-Ye*Ye,tt=et,at=et;0===et?(W=0,tt=1,$=Ke,at=Qe):($=Ze*Ke-Ye*Je,(W=Ye*Ke-Qe*Je)<0?(W=0,$=Ke,at=Qe):W>tt&&(W=tt,$=Ke+Ye,at=Qe)),$<0?($=0,-Je<0?W=0:-Je>Ze?W=tt:(W=-Je,tt=Ze)):$>at&&($=at,-Je+Ye<0?W=0:-Je+Ye>Ze?W=tt:(W=-Je+Ye,tt=Ze));var ht=(1-(q=0===$?0:$/at))*b+q*P-((1-(H=0===W?0:W/tt))*i+H*m),gt=(1-q)*T+q*I-((1-H)*g+H*_);return ht*ht+gt*gt}function Pj(i,g){return i[0]===g[0]?i[1]-g[1]:i[0]-g[0]}const{PackUtil:Ij}=JD();class Vector{constructor(i,g){this.x=i,this.y=g}clone(){return new Vector(this.x,this.y)}normalize(){const i=this.length();this.x/=i,this.y/=i}negate(){this.x=-this.x,this.y=-this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}diff(i){return new Vector(this.x-i.x,this.y-i.y)}distance(i){const g=this.x-i.x,m=this.y-i.y;return Math.sqrt(g*g+m*m)}dot(i){return this.x*i.x+this.y*i.y}equals(i){return this.x===i.x&&this.y===i.y}orthogonal(){return new Vector(this.y,-this.x)}}function kj(i,g,m,_){const b=((m.x-i.x)*_.y-(m.y-i.y)*_.x)/(g.x*_.y-g.y*_.x);return new Vector(i.x+b*g.x,i.y+b*g.y)}const Oj=[],Ej=[];function Rj(i){if(sF(i[0]&&i[0].x)){const g=[];let m=0;for(let _=0;_<i.length;_++)Ej[m]?(Ej[m][0]=i[_].x,Ej[m][1]=i[_].y):Ej[m]=[i[_].x,i[_].y],g.push(Ej[m]),m++;i=g}try{const g=mj(i,1/0);let m=[1/0,1/0],_=[-1/0,-1/0];for(let i=0;i<g.length;i++)g[i][0]<m[0]&&(m[0]=g[i][0]),g[i][0]>_[0]&&(_[0]=g[i][0]),g[i][1]<m[1]&&(m[1]=g[i][1]),g[i][1]>_[1]&&(_[1]=g[i][1]);const b=[];let T=[],P=0;for(let i=0;i<g.length;i++)i===g.length-1&&g[i][0]===g[0][0]&&g[i][1]===g[0][1]||(HG(b,g[i]),Oj[P]?(Oj[P].x=b[0],Oj[P].y=b[1]):Oj[P]=new Vector(b[0],b[1]),T.push(Oj[P]),P++);Ij.calculateSignedArea(T)<0&&(T=T.reverse());const I=function(i){let g,m=Number.MAX_VALUE;const _=function(i,_,b,T,P,I,H,W){var q=kj(i,_,P,I),$=kj(b,T,P,I),ye=kj(H,W,i,_),Re=kj(H,W,b,T),Be=q.distance($)*q.distance(ye);0!==Be&&Be<m&&(g=[q,ye,Re,$],m=Be)};var b=[];for(let g=0;g<i.length;g++)b.push(i[(g+1)%i.length].diff(i[g])),b[g].normalize();var T,P,I,H,W=new Vector(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),q=new Vector(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);for(let g=0;g<i.length;g++){var $=i[g];$.x<W.x&&(W.x=$.x,T=g),$.x>q.x&&(q.x=$.x,P=g),$.y<W.y&&(W.y=$.y,H=g),$.y>q.y&&(q.y=$.y,I=g)}var ye=new Vector(0,-1),Re=new Vector(0,1),Be=new Vector(-1,0),Ge=new Vector(1,0);for(let g=0;g<i.length;g++){var je=[Math.acos(ye.dot(b[T])),Math.acos(Re.dot(b[P])),Math.acos(Be.dot(b[I])),Math.acos(Ge.dot(b[H]))];switch(je.indexOf(Math.min.apply(Math,je))){case 0:(Re=(ye=b[T].clone()).clone()).negate(),(Ge=(Be=ye.orthogonal()).clone()).negate(),T=(T+1)%i.length;break;case 1:(ye=(Re=b[P].clone()).clone()).negate(),(Ge=(Be=ye.orthogonal()).clone()).negate(),P=(P+1)%i.length;break;case 2:(Ge=(Be=b[I].clone()).clone()).negate(),(Re=(ye=Ge.orthogonal()).clone()).negate(),I=(I+1)%i.length;break;case 3:(Be=(Ge=b[H].clone()).clone()).negate(),(Re=(ye=Ge.orthogonal()).clone()).negate(),H=(H+1)%i.length}_(i[T],ye,i[P],Re,i[I],Be,i[H],Ge)}return g}(T);if(!I||4!==I.length)return null;const H=I[0].distance(I[1]),W=I[1].distance(I[2]),q=I.map((i=>[i.x,i.y]));return q.push(+(W>H)),q}catch(i){return null}}const{DEFAULT_TEX_WIDTH:Lj}=JD();class ExtrudePolygonLayer extends Vector3DLayer{static fromJSON(i){return PG(i,"ExtrudePolygonLayer",ExtrudePolygonLayer)}getPolygonOffsetCount(){return 0}getPolygonOffset(){return 0}onConfig(i){const g=this.getRenderer();return g&&g.onConfig(i),super.onConfig(i)}updateMaterial(i){this.options.material||(this.options.material={}),i?iF(this.options.material,i):this.options.material=null;const g=this.getRenderer();return g&&g.updateMaterial(i),this}updateSideMaterial(i){let g=!1;this.options.sideMaterial||(this.options.sideMaterial={},g=!0),i?iF(this.options.sideMaterial,i):this.options.sideMaterial=null;const m=this.getRenderer();return m&&(g&&m._deleteSideMaterial(),m.updateSideMaterial(i)),this}updateDataConfig(i){if(!i)return this;this.options.dataConfig||(this.options.dataConfig={});const g=JSON.parse(JSON.stringify(this.options.dataConfig));iF(this.options.dataConfig,i);const m=this.getRenderer();return m&&m.updateDataConfig(i,g),this}}ExtrudePolygonLayer.registerJSONType("ExtrudePolygonLayer"),ExtrudePolygonLayer.mergeOptions({cullFace:!1,castShadow:!0});const Dj={polygonFill:{type:"identity",default:[1,1,1,1],property:"_symbol_polygonFill"},polygonOpacity:{type:"identity",default:1,property:"_symbol_polygonOpacity"},topPolygonFill:{type:"identity",default:[1,1,1,1],property:"_symbol_topPolygonFill"},bottomPolygonFill:{type:"identity",default:[1,1,1,1],property:"_symbol_bottomPolygonFill"}},Fj={defaultAltitude:20},Nj=i=>1===i.properties.top;class ExtrudePolygonLayerRenderer extends PolygonLayerRenderer{constructor(...i){super(...i),this.GeometryTypes=[gf,If]}_groupPolygonFeatures(i){return[i]}onConfig(i){this.painter&&(hF(i.cullFace)||this.painter.updateSceneConfig({cullFace:i.cullFace}))}updateMaterial(i){this.painter&&(this.painter._updateMaterial(i),this.layer.options.sideMaterial||this.sidePainter._updateMaterial(i),this.setToRedraw())}_deleteSideMaterial(){this.sidePainter&&this.sidePainter.deleteMaterial()}updateSideMaterial(i){this.sidePainter&&(i?this.sidePainter._updateMaterial(i):(this.sidePainter.deleteMaterial(),this.sidePainter._updateMaterial(this.layer.options.material)),this.setToRedraw())}updateDataConfig(i,g){this.painter&&(this.painter.updateDataConfig(i,g),this.markRebuild())}updateBloom(i){super.updateBloom(i),this.sidePainter&&this._updatePainterBloom(this.sidePainter,this.sidePainterSymbol,i)}needCheckPointLineSymbols(){return!1}draw(i,g){return super.draw(i,g)}createPainter(){const i=Vector3DLayer.get3DPainterClass("lit");this.painterSymbol=iF({},Dj),this.sidePainterSymbol=iF({},Dj),this._defineSymbolBloom(this.painterSymbol,i.getBloomSymbol());const g=this.layer,m=iF({},Fj,g.options.dataConfig||{});g.options.material&&(this.painterSymbol.material=g.options.material),this.sidePainterSymbol.material=g.options.sideMaterial?g.options.sideMaterial:g.options.material;const _={cullFace:g.options.cullFace};Object.defineProperty(_,"castShadow",{enumerable:!0,get:()=>g.options.castShadow}),Object.defineProperty(_,"depthMask",{enumerable:!0,get:()=>g.options.depthMask});const b=iF({},m);b.upsideUpTexture=!0;const T=new i(this.regl,g,this.painterSymbol,_,0,b);return this.sidePainter=new i(this.regl,g,this.sidePainterSymbol,_,0,m),T}_startFrame(...i){super._startFrame(...i);const g=this.painter;this.painter=this.sidePainter,super._startFrame(...i),this.painter=g}_renderMeshes(...i){const g=i[0],m=g.sceneFilter;g.sceneFilter=i=>(!m||m(i))&&Nj(i);const _=super._renderMeshes(...i);g.sceneFilter=i=>(!m||m(i))&&Nj(i);const b=this.painter;this.painter=this.sidePainter;const T=g.sceneFilter=i=>(!m||m(i))&&(i=>1===i.properties.side)(i);return super._renderMeshes(...i),this.painter=b,g.sceneFilter=m,{redraw:_.redraw||T.redraw,drawCount:(_.drawCount||0)+(T.drawCount||0)}}createMesh(i,g,m,_,b,T){const P=[];this._extrudeCenter=T;const I=this._createPackData(_,m,!0,!1),H=this._createPackData(_,m,!1,!0);if(I){const b=this._createMesh(I,i,g,m,_,null,T);b.meshes[0].properties.top=1,P.push(b)}if(H){const b=this._createMesh(H,i,g,m,_,null,T);b.meshes[0].properties.side=1,P.push(b)}return P}_createPackData(i,g,m,_){const b=this.getMap();g=Dj;const T=this._extrudeCenter,P=1/0,I=b.getZoom(),H=new un(0,0),W=new pl(0,0),q=iF({},Fj,this.layer.options.dataConfig);if(q.uv=!0,q.top&&(q.top=m),q.side&&(q.side=_),!1===q.top&&!1===q.side)return null;if(!i.length)return null;const $=b.getGLRes(),ye=b.getProjection().code,Re=m?this.painterSymbol&&this.painterSymbol.material:this.sidePainterSymbol&&this.sidePainterSymbol.material,Be=Re&&Re.textureWidth||Lj,Ge=[KF(b,1,W,$)/100,KF(b,1,W,$,1)/100];return QG(i,q,P,H,Be,b.getGLRes(),1,1,Ge,this._zScale,g,I,ye,undefined,Float32Array,T)}updateMesh(i){let g=this.features[i[rB]];if(!g||!this.meshes)return;const m=this._createPackData([g],this.painterSymbol,!0,!1);let _=0;m&&m.data&&this._updateMeshData(this.meshes[_++],g.id,m);const b=this._createPackData([g],this.painterSymbol,!1,!0);b&&b.data&&this._updateMeshData(this.meshes[_++],g.id,b)}_convertGeo(i){if(i.getProperties()||i.setProperties({}),!i.getProperties()[IF]){const g=i.getCoordinates();if(i instanceof If){const m=[];for(let i=0;i<g.length;i++){m[i]=Rj(g[i]&&g[i][0])}i.getProperties()[IF]=m}else{const m=Rj(g[0]);i.getProperties()[IF]=m}}return super._convertGeo(i)}resizeCanvas(i){super.resizeCanvas(i),this.sidePainter&&this.sidePainter.resize(this.canvas.width,this.canvas.height)}onRemove(){super.onRemove(),this.sidePainter&&(this.sidePainter.delete(),delete this.sidePainter)}drawOutline(i){if(super.drawOutline(i),this._outlineAll&&this.sidePainter&&this.sidePainter.outlineAll(i),this._outlineFeatures)for(let g=0;g<this._outlineFeatures.length;g++)this.sidePainter&&this.sidePainter.outline(i,this._outlineFeatures[g])}getShadowMeshes(){return this.painter?this.painter.getShadowMeshes():[]}}ExtrudePolygonLayer.registerRenderer("gl",ExtrudePolygonLayerRenderer),ExtrudePolygonLayer.registerRenderer("gpu",ExtrudePolygonLayerRenderer),ExtrudePolygonLayer.registerRenderer("canvas",null),nd.setLayerClass(PointLayer,LineStringLayer,PolygonLayer);const{PackUtil:Hj,FilterUtil:Bj,SYMBOLS_NEED_REBUILD_IN_VT:zj,SYMBOLS_NEED_REBUILD_IN_VECTOR:Vj}=JD();wP.ShaderLib.register("vt_position_vert","#ifdef HAS_TERRAIN_ALTITUDE\n\n    attribute float aTerrainAltitude;\n\n#endif\n\nuniform float minAltitude;\n\n\n\nvec3 unpackVTPosition(vec2 aPosition, float aAltitude) {\n\n    float altitude = aAltitude;\n\n    #ifdef HAS_TERRAIN_ALTITUDE\n\n        altitude += aTerrainAltitude * 100.0;\n\n    #endif\n\n    altitude += minAltitude * 100.0;\n\n    return vec3(aPosition, altitude);\n\n}\n\n\n\n#ifdef HAS_ALTITUDE\n\n    vec3 unpackVTPosition(vec3 offset) {\n\n        return unpackVTPosition(aPosition + offset.xy, aAltitude + offset.z);\n\n    }\n\n    vec3 unpackVTPosition() {\n\n        return unpackVTPosition(aPosition, aAltitude);\n\n    }\n\n#else\n\n    float position_modValue = 16384.0;\n\n    float position_delta = 0.00001;\n\n\n\n    vec3 unpackVTPosition(vec3 offset) {\n\n        float z = aPosition.z;\n\n        vec2 pos = sign(aPosition.xy + position_delta) * mod(abs(aPosition.xy), position_modValue);\n\n        vec2 highs = floor(abs(aPosition.xy) / position_modValue);\n\n\n\n        float altitude = sign(z + position_delta) * (highs.x * 2.0 + highs.y) * pow(2.0, 15.0) + z;\n\n        return unpackVTPosition(pos + offset.xy, altitude + offset.z);\n\n    }\n\n\n\n    vec3 unpackVTPosition() {\n\n        return unpackVTPosition(vec3(0.0));\n\n    }\n\n#endif\n\n"),wP.ShaderLib.register("text_render_frag","#define HAS_HIGHLIGHT_COLOR_POINT 1\n\n#define SDF_PX 8.0\n\n#define DEVICE_PIXEL_RATIO 1.0\n\n#define EDGE_GAMMA 0.105 / DEVICE_PIXEL_RATIO\n\n\n\nuniform sampler2D glyphTex;\n\nuniform float textOpacity;\n\nuniform highp float gammaScale;\n\nuniform float isHalo;\n\nuniform highp float textHaloBlur;\n\n\n\n#if defined(HAS_TEXT_HALO_OPACITY) || defined(HAS_TEXT_HALO_RADIUS)\n\n    varying vec2 vTextHalo;\n\n#endif\n\n#ifndef HAS_TEXT_HALO_OPACITY\n\n    uniform float textHaloOpacity;\n\n#endif\n\n#ifndef HAS_TEXT_HALO_RADIUS\n\n    uniform highp float textHaloRadius;\n\n#endif\n\nvarying float vTextSize;\n\nvarying float vGammaScale;\n\n\n\n#ifdef HAS_TEXT_FILL\n\n    varying vec4 vTextFill;\n\n#else\n\n    uniform vec4 textFill;\n\n#endif\n\n\n\n#ifdef HAS_TEXT_HALO_FILL\n\n    varying vec4 vTextHaloFill;\n\n#else\n\n    uniform vec4 textHaloFill;\n\n#endif\n\n\n\nvec4 renderText(vec2 texCoord) {\n\n    #ifdef HAS_TEXT_FILL\n\n        vec4 myTextFill = vTextFill;\n\n    #else\n\n        vec4 myTextFill = textFill;\n\n    #endif\n\n    float fontScale = vTextSize / 24.0;\n\n\n\n    vec4 color = myTextFill;\n\n    highp float gamma = EDGE_GAMMA / (fontScale * gammaScale);\n\n    lowp float buff = 185.0 / 256.0;    bool isHaloText;\n\n    #ifdef HAS_HALO_ATTR\n\n        isHaloText = vHalo > 0.5;\n\n    #else\n\n        isHaloText = isHalo == 1.0;\n\n    #endif\n\n    if (isHaloText) {\n\n        #ifdef HAS_TEXT_HALO_FILL\n\n            vec4 haloFill = vTextHaloFill;\n\n        #else\n\n            vec4 haloFill = textHaloFill;\n\n        #endif\n\n        #ifdef HAS_TEXT_HALO_RADIUS\n\n            float haloRadius = vTextHalo.x;\n\n        #else\n\n            float haloRadius = textHaloRadius;\n\n        #endif\n\n        if (haloRadius == 0.0) {\n\n            discard;\n\n        }\n\n        color = haloFill;\n\n        gamma = (textHaloBlur * 1.19 / SDF_PX + EDGE_GAMMA) / (fontScale * gammaScale);\n\n        buff = (6.0 - haloRadius / fontScale) / SDF_PX;\n\n        #ifdef HAS_TEXT_HALO_OPACITY\n\n            float haloOpacity = vTextHalo.y / 255.0;\n\n        #else\n\n            float haloOpacity = textHaloOpacity;\n\n        #endif\n\n\n\n        color *= haloOpacity * 1.25;\n\n    }\n\n\n\n    float dist = texture2D(glyphTex, texCoord).a;\n\n    highp float gammaScaled = gamma * vGammaScale * 0.7;\n\n\n\n    float alpha = clamp(smoothstep(buff - gammaScaled, buff + gammaScaled, dist), 0.0, 1.0);\n\n    return color * (alpha * textOpacity);\n\n}\n\n"),wP.WgslShaderLib.register("vt_position",KD),wP.WgslShaderLib.register("text_render",eF);VA.create();const Uj=function(i,g){const m=i.toString(),_=m.indexOf("{")+1,b=m.substring(0,_);let T=`${b}\n    (`+g.toString()+")({});\n";return T+="\n"+m.substring(b.length),T}(YD,QD);if(rx){const i=Uu.VERSION;if(i.indexOf("1.0.0-beta")>=0||i.indexOf("1.0.0-alpha")>=0){Os("@maptalks/vt",rx.inject(Uj))}else Os("@maptalks/vt",(function(){return rx.inject(Uj)}))}else Os("@maptalks/vt",Uj);"undefined"!=typeof console&&console.log("@maptalks/vt v0.109.0");for(
/*!
  * Contains code from THREE.js
  * MIT License
  * https://github.com/mrdoob/three.js
  */
var Gj=[],jj=0;jj<6;jj++)Gj[jj]=[];var Wj=[];function qj(i,g,m){rW(i);for(var _=0;_<6;_++){var b=Gj[_];if(Wj[0]=b[0]>0?g[1][0]:g[0][0],Wj[1]=b[1]>0?g[1][1]:g[0][1],Wj[2]=b[2]>0?g[1][2]:g[0][2],oW(b,Wj)<0)return!1}return!0}var Xj=3,Zj=4,$j=5,Yj=6,Qj=7,Jj=8,Kj=9,eW=10,tW=11;function nW(i,g){var m=g,_=g,b=i[0],T=i[1],P=i[2],I=Math.abs(b*_[Xj]+T*_[Zj]+P*_[$j])+Math.abs(b*_[Yj]+T*_[Qj]+P*_[Jj])+Math.abs(b*_[Kj]+T*_[eW]+P*_[tW]),H=oW(i,m);return!(H<=-I)}function rW(i){var g=i[0],m=i[1],_=i[2],b=i[3],T=i[4],P=i[5],I=i[6],H=i[7],W=i[8],q=i[9],$=i[10],ye=i[11],Re=i[12],Be=i[13],Ge=i[14],je=i[15];iW(Gj[0],b-g,H-T,ye-W,je-Re),iW(Gj[1],b+g,H+T,ye+W,je+Re),iW(Gj[2],b+m,H+P,ye+q,je+Be),iW(Gj[3],b-m,H-P,ye-q,je-Be),iW(Gj[4],b-_,H-I,ye-$,je-Ge),iW(Gj[5],b+_,H+I,ye+$,je+Ge)}function iW(i,g,m,_,b){var T=1/Math.sqrt(g*g+m*m+_*_);return i[0]=g*T,i[1]=m*T,i[2]=_*T,i[3]=b*T,i}function oW(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]+i[3]}
/*!
   * @maptalks/3dtiles v0.106.6
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.org
   */const sW="${",aW=`function(e){\n/*!\n     * @maptalks/gl v0.110.0\n     * LICENSE : UNLICENSED\n     * (c) 2016-2025 maptalks.com\n     */\nconst t=function(){if("undefined"!=typeof undefinedThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof undefined)return global;throw new Error("unable to locate global object")},r=t(),n=r.gl_trans__coders=r.gl_trans__coders||{};function a(){return t().maptalks_gltf_loader}n.inject=function(e){const n=e.toString(),a=n.indexOf("{")+1,o=n.substring(0,a),s=r.gl_trans__coders=r.gl_trans__coders||{};let i=\`${sW}o}\\n    const _____getGlobal = ${sW}t.toString()};\\n    const g___lobals = _____getGlobal()\\n    const tran_____scoders = g___lobals['gl_trans__coders'] = g___lobals['gl_trans__coders'] || {};\`;for(const e in s)"inject"!==e&&"getTranscoder"!==e&&"registerTranscoder"!==e&&(i+='tran_____scoders["'+e+'"] ='+s[e].toString()+"\\n;");return i+="\\n("+t().maptalks_gltf_loader_bundle.toString()+")({});\\n",i+="\\n"+n.substring(o.length),i},n.registerTranscoder=function(e,t){n[e]=t},n.getTranscoder=function(e){return n[e]};var o=1e-6,s="undefined"!=typeof Float32Array?Float32Array:Array;function i(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function c(e,t,r){var n=t[0],a=t[1],o=t[2],s=t[3],i=t[4],c=t[5],l=t[6],u=t[7],h=t[8],f=t[9],d=t[10],m=t[11],p=t[12],b=t[13],g=t[14],y=t[15],_=r[0],T=r[1],w=r[2],v=r[3];return e[0]=_*n+T*i+w*h+v*p,e[1]=_*a+T*c+w*f+v*b,e[2]=_*o+T*l+w*d+v*g,e[3]=_*s+T*u+w*m+v*y,_=r[4],T=r[5],w=r[6],v=r[7],e[4]=_*n+T*i+w*h+v*p,e[5]=_*a+T*c+w*f+v*b,e[6]=_*o+T*l+w*d+v*g,e[7]=_*s+T*u+w*m+v*y,_=r[8],T=r[9],w=r[10],v=r[11],e[8]=_*n+T*i+w*h+v*p,e[9]=_*a+T*c+w*f+v*b,e[10]=_*o+T*l+w*d+v*g,e[11]=_*s+T*u+w*m+v*y,_=r[12],T=r[13],w=r[14],v=r[15],e[12]=_*n+T*i+w*h+v*p,e[13]=_*a+T*c+w*f+v*b,e[14]=_*o+T*l+w*d+v*g,e[15]=_*s+T*u+w*m+v*y,e}function l(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function u(){var e=new s(3);return s!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function h(e){var t=e[0],r=e[1],n=e[2];return Math.hypot(t,r,n)}function f(e,t,r){var n=new s(3);return n[0]=e,n[1]=t,n[2]=r,n}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function m(e,t,r,n){return e[0]=t,e[1]=r,e[2]=n,e}function p(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e}function b(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e}function g(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function y(e,t){var r=t[0],n=t[1],a=t[2],o=r*r+n*n+a*a;return o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e}function _(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function T(e,t,r){var n=t[0],a=t[1],o=t[2],s=r[0],i=r[1],c=r[2];return e[0]=a*c-o*i,e[1]=o*s-n*c,e[2]=n*i-a*s,e}function w(e,t,r){var n=t[0],a=t[1],o=t[2],s=r[3]*n+r[7]*a+r[11]*o+r[15];return s=s||1,e[0]=(r[0]*n+r[4]*a+r[8]*o+r[12])/s,e[1]=(r[1]*n+r[5]*a+r[9]*o+r[13])/s,e[2]=(r[2]*n+r[6]*a+r[10]*o+r[14])/s,e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var v=function(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e},O=b,A=h;function I(){var e=new s(4);return s!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}u(),function(){var e,t=(e=new s(4),s!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e)}();var M;function x(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}u(),f(1,0,0),f(0,1,0),I(),I(),M=new s(9),s!=Float32Array&&(M[1]=0,M[2]=0,M[3]=0,M[5]=0,M[6]=0,M[7]=0),M[0]=1,M[4]=1,M[8]=1;var C={exports:{}},S={exports:{}},N=function(e){return!(!e||"string"==typeof e)&&(e instanceof Array||Array.isArray(e)||e.length>=0&&(e.splice instanceof Function||Object.getOwnPropertyDescriptor(e,e.length-1)&&"String"!==e.constructor.name))},L=Array.prototype.concat,k=Array.prototype.slice,E=S.exports=function(e){for(var t=[],r=0,n=e.length;r<n;r++){var a=e[r];N(a)?t=L.call(t,k.call(a)):t.push(a)}return t};E.wrap=function(e){return function(){return e(E(arguments))}};var P=S.exports,U={"aliceblue":[240,248,255],"antiquewhite":[250,235,215],"aqua":[0,255,255],"aquamarine":[127,255,212],"azure":[240,255,255],"beige":[245,245,220],"bisque":[255,228,196],"black":[0,0,0],"blanchedalmond":[255,235,205],"blue":[0,0,255],"blueviolet":[138,43,226],"brown":[165,42,42],"burlywood":[222,184,135],"cadetblue":[95,158,160],"chartreuse":[127,255,0],"chocolate":[210,105,30],"coral":[255,127,80],"cornflowerblue":[100,149,237],"cornsilk":[255,248,220],"crimson":[220,20,60],"cyan":[0,255,255],"darkblue":[0,0,139],"darkcyan":[0,139,139],"darkgoldenrod":[184,134,11],"darkgray":[169,169,169],"darkgreen":[0,100,0],"darkgrey":[169,169,169],"darkkhaki":[189,183,107],"darkmagenta":[139,0,139],"darkolivegreen":[85,107,47],"darkorange":[255,140,0],"darkorchid":[153,50,204],"darkred":[139,0,0],"darksalmon":[233,150,122],"darkseagreen":[143,188,143],"darkslateblue":[72,61,139],"darkslategray":[47,79,79],"darkslategrey":[47,79,79],"darkturquoise":[0,206,209],"darkviolet":[148,0,211],"deeppink":[255,20,147],"deepskyblue":[0,191,255],"dimgray":[105,105,105],"dimgrey":[105,105,105],"dodgerblue":[30,144,255],"firebrick":[178,34,34],"floralwhite":[255,250,240],"forestgreen":[34,139,34],"fuchsia":[255,0,255],"gainsboro":[220,220,220],"ghostwhite":[248,248,255],"gold":[255,215,0],"goldenrod":[218,165,32],"gray":[128,128,128],"green":[0,128,0],"greenyellow":[173,255,47],"grey":[128,128,128],"honeydew":[240,255,240],"hotpink":[255,105,180],"indianred":[205,92,92],"indigo":[75,0,130],"ivory":[255,255,240],"khaki":[240,230,140],"lavender":[230,230,250],"lavenderblush":[255,240,245],"lawngreen":[124,252,0],"lemonchiffon":[255,250,205],"lightblue":[173,216,230],"lightcoral":[240,128,128],"lightcyan":[224,255,255],"lightgoldenrodyellow":[250,250,210],"lightgray":[211,211,211],"lightgreen":[144,238,144],"lightgrey":[211,211,211],"lightpink":[255,182,193],"lightsalmon":[255,160,122],"lightseagreen":[32,178,170],"lightskyblue":[135,206,250],"lightslategray":[119,136,153],"lightslategrey":[119,136,153],"lightsteelblue":[176,196,222],"lightyellow":[255,255,224],"lime":[0,255,0],"limegreen":[50,205,50],"linen":[250,240,230],"magenta":[255,0,255],"maroon":[128,0,0],"mediumaquamarine":[102,205,170],"mediumblue":[0,0,205],"mediumorchid":[186,85,211],"mediumpurple":[147,112,219],"mediumseagreen":[60,179,113],"mediumslateblue":[123,104,238],"mediumspringgreen":[0,250,154],"mediumturquoise":[72,209,204],"mediumvioletred":[199,21,133],"midnightblue":[25,25,112],"mintcream":[245,255,250],"mistyrose":[255,228,225],"moccasin":[255,228,181],"navajowhite":[255,222,173],"navy":[0,0,128],"oldlace":[253,245,230],"olive":[128,128,0],"olivedrab":[107,142,35],"orange":[255,165,0],"orangered":[255,69,0],"orchid":[218,112,214],"palegoldenrod":[238,232,170],"palegreen":[152,251,152],"paleturquoise":[175,238,238],"palevioletred":[219,112,147],"papayawhip":[255,239,213],"peachpuff":[255,218,185],"peru":[205,133,63],"pink":[255,192,203],"plum":[221,160,221],"powderblue":[176,224,230],"purple":[128,0,128],"rebeccapurple":[102,51,153],"red":[255,0,0],"rosybrown":[188,143,143],"royalblue":[65,105,225],"saddlebrown":[139,69,19],"salmon":[250,128,114],"sandybrown":[244,164,96],"seagreen":[46,139,87],"seashell":[255,245,238],"sienna":[160,82,45],"silver":[192,192,192],"skyblue":[135,206,235],"slateblue":[106,90,205],"slategray":[112,128,144],"slategrey":[112,128,144],"snow":[255,250,250],"springgreen":[0,255,127],"steelblue":[70,130,180],"tan":[210,180,140],"teal":[0,128,128],"thistle":[216,191,216],"tomato":[255,99,71],"turquoise":[64,224,208],"violet":[238,130,238],"wheat":[245,222,179],"white":[255,255,255],"whitesmoke":[245,245,245],"yellow":[255,255,0],"yellowgreen":[154,205,50]},R=P,B=Object.hasOwnProperty,F=Object.create(null);for(var D in U)B.call(U,D)&&(F[U[D]]=D);var j=C.exports={to:{},get:{}};function G(e,t,r){return Math.min(Math.max(t,e),r)}function z(e){var t=Math.round(e).toString(16).toUpperCase();return t.length<2?"0"+t:t}j.get=function(e){var t,r;switch(e.substring(0,3).toLowerCase()){case"hsl":t=j.get.hsl(e),r="hsl";break;case"hwb":t=j.get.hwb(e),r="hwb";break;default:t=j.get.rgb(e),r="rgb"}return t?{model:r,value:t}:null},j.get.rgb=function(e){if(!e)return null;var t,r,n,a=[0,0,0,1];if(t=e.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(n=t[2],t=t[1],r=0;r<3;r++){var o=2*r;a[r]=parseInt(t.slice(o,o+2),16)}n&&(a[3]=parseInt(n,16)/255)}else if(t=e.match(/^#([a-f0-9]{3,4})$/i)){for(n=(t=t[1])[3],r=0;r<3;r++)a[r]=parseInt(t[r]+t[r],16);n&&(a[3]=parseInt(n+n,16)/255)}else if(t=e.match(/^rgba?\\(\\s*([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)(?=[\\s,])\\s*(?:,\\s*)?([+-]?\\d+)\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/)){for(r=0;r<3;r++)a[r]=parseInt(t[r+1],0);t[4]&&(t[5]?a[3]=.01*parseFloat(t[4]):a[3]=parseFloat(t[4]))}else{if(!(t=e.match(/^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*,?\\s*([+-]?[\\d\\.]+)\\%\\s*(?:[,|\\/]\\s*([+-]?[\\d\\.]+)(%?)\\s*)?\\)$/)))return(t=e.match(/^(\\w+)$/))?"transparent"===t[1]?[0,0,0,0]:B.call(U,t[1])?((a=U[t[1]])[3]=1,a):null:null;for(r=0;r<3;r++)a[r]=Math.round(2.55*parseFloat(t[r+1]));t[4]&&(t[5]?a[3]=.01*parseFloat(t[4]):a[3]=parseFloat(t[4]))}for(r=0;r<3;r++)a[r]=G(a[r],0,255);return a[3]=G(a[3],0,1),a},j.get.hsl=function(e){if(!e)return null;var t=e.match(/^hsla?\\(\\s*([+-]?(?:\\d{0,3}\\.)?\\d+)(?:deg)?\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*,?\\s*([+-]?[\\d\\.]+)%\\s*(?:[,|\\/]\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/);if(t){var r=parseFloat(t[4]);return[(parseFloat(t[1])%360+360)%360,G(parseFloat(t[2]),0,100),G(parseFloat(t[3]),0,100),G(isNaN(r)?1:r,0,1)]}return null},j.get.hwb=function(e){if(!e)return null;var t=e.match(/^hwb\\(\\s*([+-]?\\d{0,3}(?:\\.\\d+)?)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)\\s*)?\\)$/);if(t){var r=parseFloat(t[4]);return[(parseFloat(t[1])%360+360)%360,G(parseFloat(t[2]),0,100),G(parseFloat(t[3]),0,100),G(isNaN(r)?1:r,0,1)]}return null},j.to.hex=function(){var e=R(arguments);return"#"+z(e[0])+z(e[1])+z(e[2])+(e[3]<1?z(Math.round(255*e[3])):"")},j.to.rgb=function(){var e=R(arguments);return e.length<4||1===e[3]?"rgb("+Math.round(e[0])+", "+Math.round(e[1])+", "+Math.round(e[2])+")":"rgba("+Math.round(e[0])+", "+Math.round(e[1])+", "+Math.round(e[2])+", "+e[3]+")"},j.to.rgb.percent=function(){var e=R(arguments),t=Math.round(e[0]/255*100),r=Math.round(e[1]/255*100),n=Math.round(e[2]/255*100);return e.length<4||1===e[3]?"rgb("+t+"%, "+r+"%, "+n+"%)":"rgba("+t+"%, "+r+"%, "+n+"%, "+e[3]+")"},j.to.hsl=function(){var e=R(arguments);return e.length<4||1===e[3]?"hsl("+e[0]+", "+e[1]+"%, "+e[2]+"%)":"hsla("+e[0]+", "+e[1]+"%, "+e[2]+"%, "+e[3]+")"},j.to.hwb=function(){var e=R(arguments),t="";return e.length>=4&&1!==e[3]&&(t=", "+e[3]),"hwb("+e[0]+", "+e[1]+"%, "+e[2]+"%"+t+")"},j.to.keyword=function(e){return F[e.slice(0,3)]};var q=C.exports,H={exports:{}},V={"aliceblue":[240,248,255],"antiquewhite":[250,235,215],"aqua":[0,255,255],"aquamarine":[127,255,212],"azure":[240,255,255],"beige":[245,245,220],"bisque":[255,228,196],"black":[0,0,0],"blanchedalmond":[255,235,205],"blue":[0,0,255],"blueviolet":[138,43,226],"brown":[165,42,42],"burlywood":[222,184,135],"cadetblue":[95,158,160],"chartreuse":[127,255,0],"chocolate":[210,105,30],"coral":[255,127,80],"cornflowerblue":[100,149,237],"cornsilk":[255,248,220],"crimson":[220,20,60],"cyan":[0,255,255],"darkblue":[0,0,139],"darkcyan":[0,139,139],"darkgoldenrod":[184,134,11],"darkgray":[169,169,169],"darkgreen":[0,100,0],"darkgrey":[169,169,169],"darkkhaki":[189,183,107],"darkmagenta":[139,0,139],"darkolivegreen":[85,107,47],"darkorange":[255,140,0],"darkorchid":[153,50,204],"darkred":[139,0,0],"darksalmon":[233,150,122],"darkseagreen":[143,188,143],"darkslateblue":[72,61,139],"darkslategray":[47,79,79],"darkslategrey":[47,79,79],"darkturquoise":[0,206,209],"darkviolet":[148,0,211],"deeppink":[255,20,147],"deepskyblue":[0,191,255],"dimgray":[105,105,105],"dimgrey":[105,105,105],"dodgerblue":[30,144,255],"firebrick":[178,34,34],"floralwhite":[255,250,240],"forestgreen":[34,139,34],"fuchsia":[255,0,255],"gainsboro":[220,220,220],"ghostwhite":[248,248,255],"gold":[255,215,0],"goldenrod":[218,165,32],"gray":[128,128,128],"green":[0,128,0],"greenyellow":[173,255,47],"grey":[128,128,128],"honeydew":[240,255,240],"hotpink":[255,105,180],"indianred":[205,92,92],"indigo":[75,0,130],"ivory":[255,255,240],"khaki":[240,230,140],"lavender":[230,230,250],"lavenderblush":[255,240,245],"lawngreen":[124,252,0],"lemonchiffon":[255,250,205],"lightblue":[173,216,230],"lightcoral":[240,128,128],"lightcyan":[224,255,255],"lightgoldenrodyellow":[250,250,210],"lightgray":[211,211,211],"lightgreen":[144,238,144],"lightgrey":[211,211,211],"lightpink":[255,182,193],"lightsalmon":[255,160,122],"lightseagreen":[32,178,170],"lightskyblue":[135,206,250],"lightslategray":[119,136,153],"lightslategrey":[119,136,153],"lightsteelblue":[176,196,222],"lightyellow":[255,255,224],"lime":[0,255,0],"limegreen":[50,205,50],"linen":[250,240,230],"magenta":[255,0,255],"maroon":[128,0,0],"mediumaquamarine":[102,205,170],"mediumblue":[0,0,205],"mediumorchid":[186,85,211],"mediumpurple":[147,112,219],"mediumseagreen":[60,179,113],"mediumslateblue":[123,104,238],"mediumspringgreen":[0,250,154],"mediumturquoise":[72,209,204],"mediumvioletred":[199,21,133],"midnightblue":[25,25,112],"mintcream":[245,255,250],"mistyrose":[255,228,225],"moccasin":[255,228,181],"navajowhite":[255,222,173],"navy":[0,0,128],"oldlace":[253,245,230],"olive":[128,128,0],"olivedrab":[107,142,35],"orange":[255,165,0],"orangered":[255,69,0],"orchid":[218,112,214],"palegoldenrod":[238,232,170],"palegreen":[152,251,152],"paleturquoise":[175,238,238],"palevioletred":[219,112,147],"papayawhip":[255,239,213],"peachpuff":[255,218,185],"peru":[205,133,63],"pink":[255,192,203],"plum":[221,160,221],"powderblue":[176,224,230],"purple":[128,0,128],"rebeccapurple":[102,51,153],"red":[255,0,0],"rosybrown":[188,143,143],"royalblue":[65,105,225],"saddlebrown":[139,69,19],"salmon":[250,128,114],"sandybrown":[244,164,96],"seagreen":[46,139,87],"seashell":[255,245,238],"sienna":[160,82,45],"silver":[192,192,192],"skyblue":[135,206,235],"slateblue":[106,90,205],"slategray":[112,128,144],"slategrey":[112,128,144],"snow":[255,250,250],"springgreen":[0,255,127],"steelblue":[70,130,180],"tan":[210,180,140],"teal":[0,128,128],"thistle":[216,191,216],"tomato":[255,99,71],"turquoise":[64,224,208],"violet":[238,130,238],"wheat":[245,222,179],"white":[255,255,255],"whitesmoke":[245,245,245],"yellow":[255,255,0],"yellowgreen":[154,205,50]},$={};for(var Q in V)V.hasOwnProperty(Q)&&($[V[Q]]=Q);var K=H.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var Z in K)if(K.hasOwnProperty(Z)){if(!("channels"in K[Z]))throw new Error("missing channels property: "+Z);if(!("labels"in K[Z]))throw new Error("missing channel labels property: "+Z);if(K[Z].labels.length!==K[Z].channels)throw new Error("channel and label counts mismatch: "+Z);var X=K[Z].channels,J=K[Z].labels;delete K[Z].channels,delete K[Z].labels,Object.defineProperty(K[Z],"channels",{value:X}),Object.defineProperty(K[Z],"labels",{value:J})}K.rgb.hsl=function(e){var t,r,n=e[0]/255,a=e[1]/255,o=e[2]/255,s=Math.min(n,a,o),i=Math.max(n,a,o),c=i-s;return i===s?t=0:n===i?t=(a-o)/c:a===i?t=2+(o-n)/c:o===i&&(t=4+(n-a)/c),(t=Math.min(60*t,360))<0&&(t+=360),r=(s+i)/2,[t,100*(i===s?0:r<=.5?c/(i+s):c/(2-i-s)),100*r]},K.rgb.hsv=function(e){var t,r,n,a,o,s=e[0]/255,i=e[1]/255,c=e[2]/255,l=Math.max(s,i,c),u=l-Math.min(s,i,c),h=function(e){return(l-e)/6/u+.5};return 0===u?a=o=0:(o=u/l,t=h(s),r=h(i),n=h(c),s===l?a=n-r:i===l?a=1/3+t-n:c===l&&(a=2/3+r-t),a<0?a+=1:a>1&&(a-=1)),[360*a,100*o,100*l]},K.rgb.hwb=function(e){var t=e[0],r=e[1],n=e[2];return[K.rgb.hsl(e)[0],100*(1/255*Math.min(t,Math.min(r,n))),100*(n=1-1/255*Math.max(t,Math.max(r,n)))]},K.rgb.cmyk=function(e){var t,r=e[0]/255,n=e[1]/255,a=e[2]/255;return[100*((1-r-(t=Math.min(1-r,1-n,1-a)))/(1-t)||0),100*((1-n-t)/(1-t)||0),100*((1-a-t)/(1-t)||0),100*t]},K.rgb.keyword=function(e){var t=$[e];if(t)return t;var r,n,a,o=1/0;for(var s in V)if(V.hasOwnProperty(s)){var i=V[s],c=(n=e,a=i,Math.pow(n[0]-a[0],2)+Math.pow(n[1]-a[1],2)+Math.pow(n[2]-a[2],2));c<o&&(o=c,r=s)}return r},K.keyword.rgb=function(e){return V[e]},K.rgb.xyz=function(e){var t=e[0]/255,r=e[1]/255,n=e[2]/255;return[100*(.4124*(t=t>.04045?Math.pow((t+.055)/1.055,2.4):t/12.92)+.3576*(r=r>.04045?Math.pow((r+.055)/1.055,2.4):r/12.92)+.1805*(n=n>.04045?Math.pow((n+.055)/1.055,2.4):n/12.92)),100*(.2126*t+.7152*r+.0722*n),100*(.0193*t+.1192*r+.9505*n)]},K.rgb.lab=function(e){var t=K.rgb.xyz(e),r=t[0],n=t[1],a=t[2];return n/=100,a/=108.883,r=(r/=95.047)>.008856?Math.pow(r,1/3):7.787*r+16/116,[116*(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116)-16,500*(r-n),200*(n-(a=a>.008856?Math.pow(a,1/3):7.787*a+16/116))]},K.hsl.rgb=function(e){var t,r,n,a,o,s=e[0]/360,i=e[1]/100,c=e[2]/100;if(0===i)return[o=255*c,o,o];t=2*c-(r=c<.5?c*(1+i):c+i-c*i),a=[0,0,0];for(var l=0;l<3;l++)(n=s+1/3*-(l-1))<0&&n++,n>1&&n--,o=6*n<1?t+6*(r-t)*n:2*n<1?r:3*n<2?t+(r-t)*(2/3-n)*6:t,a[l]=255*o;return a},K.hsl.hsv=function(e){var t=e[0],r=e[1]/100,n=e[2]/100,a=r,o=Math.max(n,.01);return r*=(n*=2)<=1?n:2-n,a*=o<=1?o:2-o,[t,100*(0===n?2*a/(o+a):2*r/(n+r)),100*((n+r)/2)]},K.hsv.rgb=function(e){var t=e[0]/60,r=e[1]/100,n=e[2]/100,a=Math.floor(t)%6,o=t-Math.floor(t),s=255*n*(1-r),i=255*n*(1-r*o),c=255*n*(1-r*(1-o));switch(n*=255,a){case 0:return[n,c,s];case 1:return[i,n,s];case 2:return[s,n,c];case 3:return[s,i,n];case 4:return[c,s,n];case 5:return[n,s,i]}},K.hsv.hsl=function(e){var t,r,n,a=e[0],o=e[1]/100,s=e[2]/100,i=Math.max(s,.01);return n=(2-o)*s,r=o*i,[a,100*(r=(r/=(t=(2-o)*i)<=1?t:2-t)||0),100*(n/=2)]},K.hwb.rgb=function(e){var t,r,n,a,o,s,i,c=e[0]/360,l=e[1]/100,u=e[2]/100,h=l+u;switch(h>1&&(l/=h,u/=h),n=6*c-(t=Math.floor(6*c)),1&t&&(n=1-n),a=l+n*((r=1-u)-l),t){default:case 6:case 0:o=r,s=a,i=l;break;case 1:o=a,s=r,i=l;break;case 2:o=l,s=r,i=a;break;case 3:o=l,s=a,i=r;break;case 4:o=a,s=l,i=r;break;case 5:o=r,s=l,i=a}return[255*o,255*s,255*i]},K.cmyk.rgb=function(e){var t=e[0]/100,r=e[1]/100,n=e[2]/100,a=e[3]/100;return[255*(1-Math.min(1,t*(1-a)+a)),255*(1-Math.min(1,r*(1-a)+a)),255*(1-Math.min(1,n*(1-a)+a))]},K.xyz.rgb=function(e){var t,r,n,a=e[0]/100,o=e[1]/100,s=e[2]/100;return r=-.9689*a+1.8758*o+.0415*s,n=.0557*a+-.204*o+1.057*s,t=(t=3.2406*a+-1.5372*o+-.4986*s)>.0031308?1.055*Math.pow(t,1/2.4)-.055:12.92*t,r=r>.0031308?1.055*Math.pow(r,1/2.4)-.055:12.92*r,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,[255*(t=Math.min(Math.max(0,t),1)),255*(r=Math.min(Math.max(0,r),1)),255*(n=Math.min(Math.max(0,n),1))]},K.xyz.lab=function(e){var t=e[0],r=e[1],n=e[2];return r/=100,n/=108.883,t=(t/=95.047)>.008856?Math.pow(t,1/3):7.787*t+16/116,[116*(r=r>.008856?Math.pow(r,1/3):7.787*r+16/116)-16,500*(t-r),200*(r-(n=n>.008856?Math.pow(n,1/3):7.787*n+16/116))]},K.lab.xyz=function(e){var t,r,n,a=e[0];t=e[1]/500+(r=(a+16)/116),n=r-e[2]/200;var o=Math.pow(r,3),s=Math.pow(t,3),i=Math.pow(n,3);return r=o>.008856?o:(r-16/116)/7.787,t=s>.008856?s:(t-16/116)/7.787,n=i>.008856?i:(n-16/116)/7.787,[t*=95.047,r*=100,n*=108.883]},K.lab.lch=function(e){var t,r=e[0],n=e[1],a=e[2];return(t=360*Math.atan2(a,n)/2/Math.PI)<0&&(t+=360),[r,Math.sqrt(n*n+a*a),t]},K.lch.lab=function(e){var t,r=e[0],n=e[1];return t=e[2]/360*2*Math.PI,[r,n*Math.cos(t),n*Math.sin(t)]},K.rgb.ansi16=function(e){var t=e[0],r=e[1],n=e[2],a=1 in arguments?arguments[1]:K.rgb.hsv(e)[2];if(0===(a=Math.round(a/50)))return 30;var o=30+(Math.round(n/255)<<2|Math.round(r/255)<<1|Math.round(t/255));return 2===a&&(o+=60),o},K.hsv.ansi16=function(e){return K.rgb.ansi16(K.hsv.rgb(e),e[2])},K.rgb.ansi256=function(e){var t=e[0],r=e[1],n=e[2];return t===r&&r===n?t<8?16:t>248?231:Math.round((t-8)/247*24)+232:16+36*Math.round(t/255*5)+6*Math.round(r/255*5)+Math.round(n/255*5)},K.ansi16.rgb=function(e){var t=e%10;if(0===t||7===t)return e>50&&(t+=3.5),[t=t/10.5*255,t,t];var r=.5*(1+~~(e>50));return[(1&t)*r*255,(t>>1&1)*r*255,(t>>2&1)*r*255]},K.ansi256.rgb=function(e){if(e>=232){var t=10*(e-232)+8;return[t,t,t]}var r;return e-=16,[Math.floor(e/36)/5*255,Math.floor((r=e%36)/6)/5*255,r%6/5*255]},K.rgb.hex=function(e){var t=(((255&Math.round(e[0]))<<16)+((255&Math.round(e[1]))<<8)+(255&Math.round(e[2]))).toString(16).toUpperCase();return"000000".substring(t.length)+t},K.hex.rgb=function(e){var t=e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!t)return[0,0,0];var r=t[0];3===t[0].length&&(r=r.split("").map((function(e){return e+e})).join(""));var n=parseInt(r,16);return[n>>16&255,n>>8&255,255&n]},K.rgb.hcg=function(e){var t,r=e[0]/255,n=e[1]/255,a=e[2]/255,o=Math.max(Math.max(r,n),a),s=Math.min(Math.min(r,n),a),i=o-s;return t=i<=0?0:o===r?(n-a)/i%6:o===n?2+(a-r)/i:4+(r-n)/i+4,t/=6,[360*(t%=1),100*i,100*(i<1?s/(1-i):0)]},K.hsl.hcg=function(e){var t=e[1]/100,r=e[2]/100,n=1,a=0;return(n=r<.5?2*t*r:2*t*(1-r))<1&&(a=(r-.5*n)/(1-n)),[e[0],100*n,100*a]},K.hsv.hcg=function(e){var t=e[1]/100,r=e[2]/100,n=t*r,a=0;return n<1&&(a=(r-n)/(1-n)),[e[0],100*n,100*a]},K.hcg.rgb=function(e){var t=e[0]/360,r=e[1]/100,n=e[2]/100;if(0===r)return[255*n,255*n,255*n];var a,o=[0,0,0],s=t%1*6,i=s%1,c=1-i;switch(Math.floor(s)){case 0:o[0]=1,o[1]=i,o[2]=0;break;case 1:o[0]=c,o[1]=1,o[2]=0;break;case 2:o[0]=0,o[1]=1,o[2]=i;break;case 3:o[0]=0,o[1]=c,o[2]=1;break;case 4:o[0]=i,o[1]=0,o[2]=1;break;default:o[0]=1,o[1]=0,o[2]=c}return a=(1-r)*n,[255*(r*o[0]+a),255*(r*o[1]+a),255*(r*o[2]+a)]},K.hcg.hsv=function(e){var t=e[1]/100,r=t+e[2]/100*(1-t),n=0;return r>0&&(n=t/r),[e[0],100*n,100*r]},K.hcg.hsl=function(e){var t=e[1]/100,r=e[2]/100*(1-t)+.5*t,n=0;return r>0&&r<.5?n=t/(2*r):r>=.5&&r<1&&(n=t/(2*(1-r))),[e[0],100*n,100*r]},K.hcg.hwb=function(e){var t=e[1]/100,r=t+e[2]/100*(1-t);return[e[0],100*(r-t),100*(1-r)]},K.hwb.hcg=function(e){var t=e[1]/100,r=1-e[2]/100,n=r-t,a=0;return n<1&&(a=(r-n)/(1-n)),[e[0],100*n,100*a]},K.apple.rgb=function(e){return[e[0]/65535*255,e[1]/65535*255,e[2]/65535*255]},K.rgb.apple=function(e){return[e[0]/255*65535,e[1]/255*65535,e[2]/255*65535]},K.gray.rgb=function(e){return[e[0]/100*255,e[0]/100*255,e[0]/100*255]},K.gray.hsl=K.gray.hsv=function(e){return[0,0,e[0]]},K.gray.hwb=function(e){return[0,100,e[0]]},K.gray.cmyk=function(e){return[0,0,0,e[0]]},K.gray.lab=function(e){return[e[0],0,0]},K.gray.hex=function(e){var t=255&Math.round(e[0]/100*255),r=((t<<16)+(t<<8)+t).toString(16).toUpperCase();return"000000".substring(r.length)+r},K.rgb.gray=function(e){return[(e[0]+e[1]+e[2])/3/255*100]};var Y=H.exports,W=Y;function ee(e){var t=function(){for(var e={},t=Object.keys(W),r=t.length,n=0;n<r;n++)e[t[n]]={distance:-1,parent:null};return e}(),r=[e];for(t[e].distance=0;r.length;)for(var n=r.pop(),a=Object.keys(W[n]),o=a.length,s=0;s<o;s++){var i=a[s],c=t[i];-1===c.distance&&(c.distance=t[n].distance+1,c.parent=n,r.unshift(i))}return t}function te(e,t){return function(r){return t(e(r))}}function re(e,t){for(var r=[t[e].parent,e],n=W[t[e].parent][e],a=t[e].parent;t[a].parent;)r.unshift(t[a].parent),n=te(W[t[a].parent][a],n),a=t[a].parent;return n.conversion=r,n}var ne=Y,ae=function(e){for(var t=ee(e),r={},n=Object.keys(t),a=n.length,o=0;o<a;o++){var s=n[o];null!==t[s].parent&&(r[s]=re(s,t))}return r},oe={};Object.keys(ne).forEach((function(e){oe[e]={},Object.defineProperty(oe[e],"channels",{value:ne[e].channels}),Object.defineProperty(oe[e],"labels",{value:ne[e].labels});var t=ae(e);Object.keys(t).forEach((function(r){var n=t[r];oe[e][r]=function(e){var t=function(t){if(null==t)return t;arguments.length>1&&(t=Array.prototype.slice.call(arguments));var r=e(t);if("object"==typeof r)for(var n=r.length,a=0;a<n;a++)r[a]=Math.round(r[a]);return r};return"conversion"in e&&(t.conversion=e.conversion),t}(n),oe[e][r].raw=function(e){var t=function(t){return null==t?t:(arguments.length>1&&(t=Array.prototype.slice.call(arguments)),e(t))};return"conversion"in e&&(t.conversion=e.conversion),t}(n)}))}));var se=q,ie=oe,ce=[].slice,le=["keyword","gray","hex"],ue={};Object.keys(ie).forEach((function(e){ue[ce.call(ie[e].labels).sort().join("")]=e}));var he={};function fe(e,t){if(!(this instanceof fe))return new fe(e,t);if(t&&t in le&&(t=null),t&&!(t in ie))throw new Error("Unknown model: "+t);var r,n;if(null==e)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(e instanceof fe)this.model=e.model,this.color=e.color.slice(),this.valpha=e.valpha;else if("string"==typeof e){var a=se.get(e);if(null===a)throw new Error("Unable to parse color from string: "+e);this.model=a.model,n=ie[this.model].channels,this.color=a.value.slice(0,n),this.valpha="number"==typeof a.value[n]?a.value[n]:1}else if(e.length){this.model=t||"rgb",n=ie[this.model].channels;var o=ce.call(e,0,n);this.color=pe(o,n),this.valpha="number"==typeof e[n]?e[n]:1}else if("number"==typeof e)e&=16777215,this.model="rgb",this.color=[e>>16&255,e>>8&255,255&e],this.valpha=1;else{this.valpha=1;var s=Object.keys(e);"alpha"in e&&(s.splice(s.indexOf("alpha"),1),this.valpha="number"==typeof e.alpha?e.alpha:0);var i=s.sort().join("");if(!(i in ue))throw new Error("Unable to parse color from object: "+JSON.stringify(e));this.model=ue[i];var c=ie[this.model].labels,l=[];for(r=0;r<c.length;r++)l.push(e[c[r]]);this.color=pe(l)}if(he[this.model])for(n=ie[this.model].channels,r=0;r<n;r++){var u=he[this.model][r];u&&(this.color[r]=u(this.color[r]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}function de(e,t,r){return(e=Array.isArray(e)?e:[e]).forEach((function(e){(he[e]||(he[e]=[]))[t]=r})),e=e[0],function(n){var a;return arguments.length?(r&&(n=r(n)),(a=this[e]()).color[t]=n,a):(a=this[e]().color[t],r&&(a=r(a)),a)}}function me(e){return function(t){return Math.max(0,Math.min(e,t))}}function pe(e,t){for(var r=0;r<t;r++)"number"!=typeof e[r]&&(e[r]=0);return e}function be(e){return null==e}function ge(e){return"object"==typeof e&&!!e}function ye(e){return e/Math.PI*180}function _e(e){return Math.sign?Math.sign(e):0===(e=+e)||isNaN(e)?Number(e):e>0?1:-1}fe.prototype={toString:function(){return this.string()},toJSON:function(){return this[this.model]()},string:function(e){var t=this.model in se.to?this:this.rgb(),r=1===(t=t.round("number"==typeof e?e:1)).valpha?t.color:t.color.concat(this.valpha);return se.to[t.model](r)},percentString:function(e){var t=this.rgb().round("number"==typeof e?e:1),r=1===t.valpha?t.color:t.color.concat(this.valpha);return se.to.rgb.percent(r)},array:function(){return 1===this.valpha?this.color.slice():this.color.concat(this.valpha)},object:function(){for(var e={},t=ie[this.model].channels,r=ie[this.model].labels,n=0;n<t;n++)e[r[n]]=this.color[n];return 1!==this.valpha&&(e.alpha=this.valpha),e},unitArray:function(){var e=this.rgb().color;return e[0]/=255,e[1]/=255,e[2]/=255,1!==this.valpha&&e.push(this.valpha),e},unitObject:function(){var e=this.rgb().object();return e.r/=255,e.g/=255,e.b/=255,1!==this.valpha&&(e.alpha=this.valpha),e},round:function(e){return e=Math.max(e||0,0),new fe(this.color.map(function(e){return function(t){return function(e,t){return Number(e.toFixed(t))}(t,e)}}(e)).concat(this.valpha),this.model)},alpha:function(e){return arguments.length?new fe(this.color.concat(Math.max(0,Math.min(1,e))),this.model):this.valpha},red:de("rgb",0,me(255)),green:de("rgb",1,me(255)),blue:de("rgb",2,me(255)),hue:de(["hsl","hsv","hsl","hwb","hcg"],0,(function(e){return(e%360+360)%360})),saturationl:de("hsl",1,me(100)),lightness:de("hsl",2,me(100)),saturationv:de("hsv",1,me(100)),value:de("hsv",2,me(100)),chroma:de("hcg",1,me(100)),gray:de("hcg",2,me(100)),white:de("hwb",1,me(100)),wblack:de("hwb",2,me(100)),cyan:de("cmyk",0,me(100)),magenta:de("cmyk",1,me(100)),yellow:de("cmyk",2,me(100)),black:de("cmyk",3,me(100)),x:de("xyz",0,me(100)),y:de("xyz",1,me(100)),z:de("xyz",2,me(100)),l:de("lab",0,me(100)),a:de("lab",1),b:de("lab",2),keyword:function(e){return arguments.length?new fe(e):ie[this.model].keyword(this.color)},hex:function(e){return arguments.length?new fe(e):se.to.hex(this.rgb().round().color)},rgbNumber:function(){var e=this.rgb().color;return(255&e[0])<<16|(255&e[1])<<8|255&e[2]},luminosity:function(){for(var e=this.rgb().color,t=[],r=0;r<e.length;r++){var n=e[r]/255;t[r]=n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4)}return.2126*t[0]+.7152*t[1]+.0722*t[2]},contrast:function(e){var t=this.luminosity(),r=e.luminosity();return t>r?(t+.05)/(r+.05):(r+.05)/(t+.05)},level:function(e){var t=this.contrast(e);return t>=7.1?"AAA":t>=4.5?"AA":""},isDark:function(){var e=this.rgb().color;return(299*e[0]+587*e[1]+114*e[2])/1e3<128},isLight:function(){return!this.isDark()},negate:function(){for(var e=this.rgb(),t=0;t<3;t++)e.color[t]=255-e.color[t];return e},lighten:function(e){var t=this.hsl();return t.color[2]+=t.color[2]*e,t},darken:function(e){var t=this.hsl();return t.color[2]-=t.color[2]*e,t},saturate:function(e){var t=this.hsl();return t.color[1]+=t.color[1]*e,t},desaturate:function(e){var t=this.hsl();return t.color[1]-=t.color[1]*e,t},whiten:function(e){var t=this.hwb();return t.color[1]+=t.color[1]*e,t},blacken:function(e){var t=this.hwb();return t.color[2]+=t.color[2]*e,t},grayscale:function(){var e=this.rgb().color,t=.3*e[0]+.59*e[1]+.11*e[2];return fe.rgb(t,t,t)},fade:function(e){return this.alpha(this.valpha-this.valpha*e)},opaquer:function(e){return this.alpha(this.valpha+this.valpha*e)},rotate:function(e){var t=this.hsl(),r=t.color[0];return r=(r=(r+e)%360)<0?360+r:r,t.color[0]=r,t},mix:function(e,t){if(!e||!e.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof e);var r=e.rgb(),n=this.rgb(),a=void 0===t?.5:t,o=2*a-1,s=r.alpha()-n.alpha(),i=((o*s===-1?o:(o+s)/(1+o*s))+1)/2,c=1-i;return fe.rgb(i*r.red()+c*n.red(),i*r.green()+c*n.green(),i*r.blue()+c*n.blue(),r.alpha()*a+n.alpha()*(1-a))}},Object.keys(ie).forEach((function(e){if(-1===le.indexOf(e)){var t=ie[e].channels;fe.prototype[e]=function(){if(this.model===e)return new fe(this);if(arguments.length)return new fe(arguments,e);var r,n="number"==typeof arguments[t]?t:this.valpha;return new fe((r=ie[this.model][e].raw(this.color),Array.isArray(r)?r:[r]).concat(n),e)},fe[e]=function(r){return"number"==typeof r&&(r=pe(ce.call(arguments),t)),new fe(r,e)}}}));const Te=[1,1,1,1,2,2,3,0];function we(e){const t=e.length;let r="";for(let n=0;n<t;){let a=e[n++];if(128&a){let r=Te[a>>3&7];if(!(64&a)||!r||n+r>t)return null;for(a&=63>>r;r>0;r-=1){const t=e[n++];if(128!=(192&t))return null;a=a<<6|63&t}}r+=String.fromCharCode(a)}return r}new Array(3),new Array(3);const ve=[1/6378137,1/6378137,1/6356752.314245179],Oe=[1/40680631590769,1/40680631590769,1/40408299984661.445],Ae=new Array(3),Ie=new Array(3),Me=new Array(3);function xe(e,t){const r=Oe,n=function(e,t,r,n,a){const o=t[0],s=t[1],i=t[2],c=r[0],l=r[1],u=r[2],h=o*o*c*c,f=s*s*l*l,d=i*i*u*u,m=h+f+d,p=Math.sqrt(1/m),b=g(Ce,t,p);if(m<a)return isFinite(p)?b:void 0;const y=n[0],_=n[1],T=n[2],w=Se;w[0]=b[0]*y*2,w[1]=b[1]*_*2,w[2]=b[2]*T*2;let v,O,A,I,M,x,C,S,N,L,k,E=(1-p)*Le(t)/(.5*Le(w)),P=0;do{E-=P,A=1/(1+E*y),I=1/(1+E*_),M=1/(1+E*T),x=A*A,C=I*I,S=M*M,N=x*A,L=C*I,k=S*M,v=h*x+f*C+d*S-1,O=h*N*y+f*L*_+d*k*T;P=v/(-2*O)}while(Math.abs(v)>Ne);return e[0]=o*A,e[1]=s*I,e[2]=i*M,e}(Ae,t,ve,r,.1);let a=O(Ie,n,r);a=function(e,t){const r=t[0],n=t[1],a=t[2];let o=r*r+n*n+a*a;o>0&&(o=Math.sqrt(o),e[0]=t[0]/o,e[1]=t[1]/o,e[2]=t[2]/o);return e}(a,a);const o=v(Me,t,n),s=Math.atan2(a[1],a[0]),i=Math.asin(a[2]),c=_e(_(o,t))*Le(o);return e[0]=ye(s),e[1]=ye(i),e[2]=c,e}const Ce=new Array(3),Se=new Array(3),Ne=1e-12;function Le(e){return h(e)}function ke(e,t,r,n){r=r||0,n=n||r;const a=Math.abs(e-t);return a<=n||a<=r*Math.max(Math.abs(e),Math.abs(t))}function Ee(e,t){let r="";for(let n=0;n<4;n++){const a=e.getUint8(t+n);r+=String.fromCharCode(a)}return r}const Pe="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null;function Ue(e,t,r){const n=new Uint8Array(e,t,r);return Pe?JSON.parse(Pe.decode(n)):JSON.parse(we(n))}function Re(e,t,r){const n=new Uint8Array(e,t,r);return Pe?JSON.parse(Pe.decode(n)):JSON.parse(we(n))}function Be(e,t,r){return{offset:t,byteLength:r}}function Fe(e,t,r,n){const{byteOffset:a,componentType:o,type:s}=e,{ctor:i,type:c}=function(e){return Ge[e]}(o||"UNSIGNED_SHORT"),l=function(e){if(!e)return 1;return je[e]}(s);return{byteStride:0,byteOffset:a+r,itemSize:l,count:n*l,componentType:c,array:new i(t,r+a,n*l)}}function De(e,t,r,n){const a=Fe(e,t,r,n);return a.array.buffer.byteLength!==t.byteLength&&(a.array=a.array.slice()),a}const je={"SCALAR":1,"VEC2":2,"VEC3":3,"VEC4":4};const Ge={"BYTE":{ctor:Int8Array,type:5120,name:"Int8Array"},"UNSIGNED_BYTE":{ctor:Uint8Array,type:5121,name:"Uint8Array"},"SHORT":{ctor:Int16Array,type:5122,name:"Int16Array"},"UNSIGNED_SHORT":{ctor:Uint16Array,type:5123,name:"Uint16Array"},"INT":{ctor:Int32Array,type:5124,name:"Int32Array"},"UNSIGNED_INT":{ctor:Uint32Array,type:5125,name:"Uint32Array"},"FLOAT":{ctor:Float32Array,type:5126,name:"Float32Array"},"DOUBLE":{ctor:Float64Array,type:5126,name:"Float64Array"}};function ze(e){for(const t in Ge)if(e===Ge[t].ctor)return Ge[t].type;throw new Error("unrecognized ctor:"+e)}function qe(e,t,r,n){const a=e,o=t.length/3;for(let e=0;e<o;e++)a[3*e]=t[3*e]/65535*n[0]+r[0],a[3*e+1]=t[3*e+1]/65535*n[1]+r[1],a[3*e+2]=t[3*e+2]/65535*n[2]+r[2];return a}function He(e,t,r){const n=e.getUint32(12,!0),a=e.getUint32(16,!0),o=e.getUint32(20,!0),s=e.getUint32(24,!0),i=e.buffer;let c,l={},u={},h=null;n>0&&(l=Ue(i,t,n),t+=n),a>0&&(c=function(e,t,r){return{offset:t,byteLength:r}}(0,t,a),t+=a),o>0&&(u=Re(i,t,o),t+=o);const f=Be(0,t,s);return h=i.slice(f.offset,f.offset+f.byteLength),r.push(h),{featureTable:l,featureTableBin:c,batchTable:u,batchTableBin:h}}const Ve={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}},$e={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},Qe={},Ke={east:[],north:[],up:[],west:[],south:[],down:[]};let Ze=[],Xe=[],Je=[];const Ye=[0,0,0];!function(e,t){const r=Ve[e][t];let n;const a=e+t;Qe[a]?n=Qe[a]:(n=function(n,a,s){if(c=Ye,l=(i=n)[0],u=i[1],h=i[2],f=c[0],m=c[1],p=c[2],Math.abs(l-f)<=o*Math.max(1,Math.abs(l),Math.abs(f))&&Math.abs(u-m)<=o*Math.max(1,Math.abs(u),Math.abs(m))&&Math.abs(h-p)<=o*Math.max(1,Math.abs(h),Math.abs(p)))d(Ze,$e[e]),d(Xe,$e[t]),d(Je,$e[r]);else if(ke(n[0],0,1e-14)&&ke(n[1],0,1e-14)){const a=_e(n[2]);d(Ze,$e[e]),d(Xe,$e[t]),g(Xe,Xe,a),d(Je,$e[r]),g(Je,Je,a)}else{!function(e,t){b(t,e,Oe),y(t,t)}(n,Ke.up);const a=Ke.up,o=Ke.east;o[0]=-n[1],o[1]=n[0],o[2]=0,y(Ke.east,o),T(Ke.north,a,o),g(Ke.down,Ke.up,-1),g(Ke.west,Ke.east,-1),g(Ke.south,Ke.north,-1),Ze=Ke[e],Xe=Ke[t],Je=Ke[r]}var i,c,l,u,h,f,m,p;return s[0]=Ze[0],s[1]=Ze[1],s[2]=Ze[2],s[3]=0,s[4]=Xe[0],s[5]=Xe[1],s[6]=Xe[2],s[7]=0,s[8]=Je[0],s[9]=Je[1],s[10]=Je[2],s[11]=0,s[12]=n[0],s[13]=n[1],s[14]=n[2],s[15]=1,s},Qe[a]=n)}("east","north");const We={5120:Int8Array,5122:Int16Array,5124:Int32Array,5121:Uint8Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function et(e){for(const t in We)if(e===We[t])return+t;throw new Error("unrecognized ctor:"+e)}let tt=null;function rt(){return tt||(tt={"image/crn":n.crn&&n.crn(),"image/ktx2":n.ktx2&&n.ktx2(),"image/cttf":n.ktx2&&n.ktx2(),"draco":n.draco&&n.draco()}),tt}const{Ajax:nt,GLTFLoader:at}=a();class ot{constructor(e,t,r){this._requestImage=e,this._loaderCtor=t||at,this._supportedFormats=r,this._decoders=rt()}static createEmptyB3DM(){return{featureTable:null,batchTable:null,gltf:{}}}load(e,t,r=0,n=0,a){return t?(n||(n=t.byteLength),this._parse(e,t,r,n,a)):nt.getArrayBuffer(e,{}).then((t=>{const a=t.data;return n||(n=a.byteLength),this._parse(e,a,r,n)}))}_parse(e,t,r,n,a){const o=a&&a.maxTextureSize,s=this._readB3DM(t,r,n,e);if(s.error)return Promise.resolve(s);const i=e.substring(0,e.lastIndexOf("/"));let c;try{c=new this._loaderCtor(i,s.glb,{transferable:!0,requestImage:this._requestImage,decoders:this._decoders,supportedFormats:this._supportedFormats,maxTextureSize:o})}catch(e){return Promise.resolve({error:e})}return c.load({skipAttributeTransform:!1}).then((t=>{t.url=\`${sW}e}-${sW}r}-${sW}n}\`;const a=c.transferables;for(let e=0;e<s.transferables.length;e++)a.indexOf(s.transferables[e])<0&&a.push(s.transferables[e]);return{magic:"b3dm",count:s.count,transferables:a,featureTable:s.featureTable,batchTable:s.batchTable,batchTableBin:s.batchTableBin,gltf:t}}))}_readB3DM(e,t,r,n){const a=new DataView(e,t,r),o=a.getUint32(4,!0);if(1!==o){const e="Unsupported b3dm version: "+o+", url:"+n;return console.warn(e),{error:e}}if(a.getUint32(8,!0)!==a.byteLength){const e="Length in b3dm header is inconsistent with b3dm's byte length, url: "+n;return console.warn(e),{error:e}}let s,i=a.getUint32(12,!0),c=a.getUint32(16,!0),l=a.getUint32(20,!0),u=a.getUint32(24,!0),h=28+t;l>=570425344?(h-=8,s=i,l=c,u=0,i=0,c=0):u>=570425344&&(h-=4,s=l,l=i,u=c,i=0,c=0);const f=[e];let d,m,p;if(i>0?(d=Ue(e,h,i),h+=i,s=d.BATCH_LENGTH):d={"BATCH_LENGTH":s},c>0&&(h+=c),l>0&&(m=Re(e,h,l),h+=l,u>0)){const t=Be(0,h,u);p=e.slice(t.offset,t.offset+t.byteLength),h+=u,f.push(p)}const b=d.BATCH_LENGTH,g={};if(d&&d.BATCH_ID){g.BATCH_ID=De(d.BATCH_ID,e,undefined.offset,b);const t=g.BATCH_ID.array&&g.BATCH_ID.array.buffer;t&&f.indexOf(t)<0&&f.push(t)}return{count:s,transferables:f,featureTable:d,batchTable:m,batchTableBin:p,b3dm:g,glb:{buffer:e,byteOffset:h,byteLength:a.byteLength+a.byteOffset-h}}}_readBatchTable(){return null}}const{Ajax:st,GLTFLoader:it}=a();class ct{constructor(e,t,r,n){this._requestImage=e,this._loaderCtor=t||it,this._supportedFormats=r,this._decoders=rt(),this._maxTextureSize=n}load(e,t,r=0,n=0,a){return t?(n||(n=t.byteLength),this._parse(e,t,r,n,a)):st.getArrayBuffer(e,{}).then((t=>{const a=t.data;return n||(n=a.byteLength),this._parse(e,a,r,n)}))}_parse(e,t,r,n,a){return this._parseGLTF(e,t,r,n,a).then((({gltf:a,transferables:o})=>{const s=this._readI3DM(t,r,n,e);if(s.error)return Promise.resolve(s);for(let e=0;e<o.length;e++)-1===s.transferables.indexOf(o[e])&&s.transferables.push(o[e]);return delete a.transferables,Promise.resolve({magic:"i3dm",count:s.count,transferables:s.transferables,featureTable:s.featureTable,batchTable:s.batchTable,batchTableBin:s.batchTableBin,i3dm:s.i3dm,gltf:a})}))}_parseGLTF(e,t,r,n,a){const o=a&&a.maxTextureSize,s={transferable:!0,requestImage:this._requestImage,decoders:this._decoders,supportedFormats:this._supportedFormats,maxTextureSize:o},i=new DataView(t,r,n),c=32+i.getUint32(12,!0)+i.getUint32(16,!0)+i.getUint32(20,!0)+i.getUint32(24,!0);if(0===i.getUint32(28,!0)){let n=we(new Uint8Array(t,c+r,i.byteLength-c));-1==n.indexOf("://")&&(n=e.substring(0,e.lastIndexOf("/"))+"/"+n);return n.indexOf(".glb")>0?st.getArrayBuffer(n,{}).then((e=>this._createGLTFLoader(n,{buffer:e.data,byteOffset:0},s))):st.getJSON(n,{}).then((e=>this._createGLTFLoader(n,e,s)))}{const n={buffer:t,byteOffset:c+r,byteLength:i.byteLength-c};return this._createGLTFLoader(e,n,s)}}_createGLTFLoader(e,t,r){const n=e.substring(0,e.lastIndexOf("/")),a=new this._loaderCtor(n,t,r);return a.load({skipAttributeTransform:!0}).then((r=>{let n=0,o=0;return t.buffer&&(n=t.byteOffset||0,o=t.byteLength||0),r.url=\`${sW}e}-${sW}n}-${sW}o}\`,{transferables:a.transferables,gltf:r}}))}_readI3DM(e,t,r,n){const a=new DataView(e,t,r),o=a.getUint32(4,!0);if(1!==o){const e="Unsupported pnts version: "+o+", url:"+n;return console.warn(e),{error:e}}if(a.getUint32(8,!0)!==a.byteLength){const e="Length in pnts header is inconsistent with pnts's byte length, url: "+n;return console.warn(e),{error:e}}const s=[e],{featureTable:i,featureTableBin:c,batchTable:l,batchTableBin:u}=He(a,32+t,s),h={},f=i.INSTANCES_LENGTH;if(i.POSITION){const{byteOffset:t}=i.POSITION;h.POSITION={byteStride:0,byteOffset:0,itemSize:3,count:f,componentType:5126,array:new Float32Array(e,t+c.offset,3*f).slice()},s.push(h.POSITION.array.buffer)}else if(i.POSITION_QUANTIZED){const t=i.QUANTIZED_VOLUME_OFFSET,r=i.QUANTIZED_VOLUME_SCALE,{byteOffset:n}=i.POSITION_QUANTIZED;h.POSITION={byteStride:12,byteOffset:0,itemSize:3,count:f,componentType:5126,array:this._convertQuantizedPosition(new Uint16Array(e,n+c.offset,3*f),t,r)},s.push(h.POSITION.array.buffer)}if(i.BATCH_ID){h.BATCH_ID=De(i.BATCH_ID,e,c.offset,f);const t=h.BATCH_ID.array&&h.BATCH_ID.array.buffer;t&&s.indexOf(t)<0&&s.push(t)}if(i.NORMAL_UP){let{byteOffset:t}=i.NORMAL_UP;h.NORMAL_UP={byteStride:0,byteOffset:0,itemSize:3,count:f,componentType:5126,array:new Float32Array(e,t+c.offset,3*f).slice()},s.push(h.NORMAL_UP.array.buffer),t=i.NORMAL_RIGHT.byteOffset,h.NORMAL_RIGHT={byteStride:0,byteOffset:0,itemSize:3,count:f,componentType:5126,array:new Float32Array(e,t+c.offset,3*f).slice()},s.push(h.NORMAL_RIGHT.array.buffer)}else if(i.NORMAL_UP_OCT32P){let{byteOffset:t}=i.NORMAL_UP_OCT32P;h.NORMAL_UP={byteStride:0,byteOffset:0,itemSize:3,count:f,componentType:5126,array:this._decodeOCT32p(new Uint16Array(e,t+c.offset,2*f))},s.push(h.NORMAL_UP.array.buffer),t=i.NORMAL_RIGHT_OCT32P.byteOffset,h.NORMAL_RIGHT={byteStride:0,byteOffset:0,itemSize:3,count:f,componentType:5126,array:this._decodeOCT32p(new Uint16Array(e,t+c.offset,2*f))},s.push(h.NORMAL_RIGHT.array.buffer)}if(i.SCALE){const{byteOffset:t}=i.SCALE;h.SCALE={byteStride:0,byteOffset:0,itemSize:1,count:f,componentType:5126,array:new Float32Array(e,t+c.offset,f).slice()},s.push(h.SCALE.array.buffer)}else if(i.SCALE_NON_UNIFORM){const{byteOffset:t}=i.SCALE_NON_UNIFORM;h.SCALE_NON_UNIFORM={byteStride:0,byteOffset:0,itemSize:3,count:f,componentType:5126,array:new Float32Array(e,t+c.offset,3*f).slice()},s.push(h.SCALE_NON_UNIFORM.array.buffer)}return{count:f,batchTable:l,batchTableBin:u,featureTable:i,i3dm:h,transferables:s}}_decodeOCT32p(e){const t=e.length/2,r=new Float32Array(3*t),n=[];for(let a=0;a<t;a++)lt(n,e[2*a],e[2*a+1],65535),r[3*a]=n[0],r[3*a+1]=n[1],r[3*a+2]=n[2];return r}_convertQuantizedPosition(e,t,r){return qe(new Float32Array(e.length),e,t,r)}_readBatchTable(){return null}}function lt(e,t,r,n){if(e[0]=ut(t,n),e[1]=ut(r,n),e[2]=1-(Math.abs(e[0])+Math.abs(e[1])),e[2]<0){const t=e[0];e[0]=(1-Math.abs(e[1]))*ht(t),e[1]=(1-Math.abs(t))*ht(e[1])}return y(e,e)}function ut(e,t){return function(e,t,r){return e<t?t:e>r?r:e}(e,0,t=function(e,t){if(null!=e)return e;return t}(t,255))/t*2-1}function ht(e){return e<0?-1:1}const{Ajax:ft}=a();class dt{constructor(){}load(e,t,r=0,n=0){return t?(n||(n=t.byteLength),this._parse(e,t,r,n)):ft.getArrayBuffer(e,{}).then((t=>{const a=t.data;return n||(n=a.byteLength),this._parse(e,a,r,n)}))}_parse(e,t,r,n){return this._readPNTS(t,r,n,e).then((e=>e.error?e:{magic:"pnts",count:e.count,transferables:e.transferables,featureTable:e.featureTable,batchTable:e.batchTable,batchTableBin:e.batchTableBin,pnts:e.pnts}))}_readPNTS(e,t,r,n){const a=new DataView(e,t,r),o=a.getUint32(4,!0);if(1!==o){const e="Unsupported pnts version: "+o+", url:"+n;return console.warn(e),{error:e}}if(a.getUint32(8,!0)!==a.byteLength){const e="Length in pnts header is inconsistent with pnts's byte length, url: "+n;return console.warn(e),{error:e}}const s=[e],{featureTable:i,featureTableBin:c,batchTable:l,batchTableBin:u}=He(a,t+28,s),h=i.QUANTIZED_VOLUME_OFFSET,f=i.QUANTIZED_VOLUME_SCALE,d=i.POINTS_LENGTH;let m,p={};if(i.extensions&&i.extensions["3DTILES_draco_point_compression"]){p=i.extensions["3DTILES_draco_point_compression"],m=new DataView(e,p.byteOffset+c.offset,p.byteLength);const t={attributes:p.properties,useUniqueIDs:!1};return this._draco||(this._draco=rt().draco),this._draco(m,t).then((t=>{const r=t.attributes;!i.POSITION&&!i.POSITION_QUANTIZED||r.POSITION||r.POSITION_QUANTIZED||(r.POSITION=i.POSITION,r.POSITION_QUANTIZED=i.POSITION_QUANTIZED),!(i.RGB||i.RGBA||i.RGB565)||r.RGB||r.RGBA||r.RGB565||(r.RGB=i.RGB,r.RGBA=i.RGBA,r.RGB565=i.RGB565),!i.NORMAL&&!i.NORMAL_OCT16P||r.NORMAL||r.NORMAL_OCT16P||(r.NORMAL=i.NORMAL,r.NORMAL_OCT16P=i.NORMAL_OCT16P);const n=this._readAttributes(e,t.attributes,c.offset,d,s,h,f);if(t.attributes.BATCH_ID){const e=t.attributes.BATCH_ID.array;n.BATCH_ID={byteStride:0,byteOffset:0,itemSize:1,count:e.length,componentType:ze(e.constructor),array:e},s.push(e.buffer)}else if(i.BATCH_ID||Object.keys(l).length){i.BATCH_ID?n.BATCH_ID=De(i.BATCH_ID,e,c.offset,d):n.BATCH_ID=mt(d);const t=n.BATCH_ID.array&&n.BATCH_ID.array.buffer;t&&s.indexOf(t)<0&&s.push(t)}return{count:d,batchTable:l,batchTableBin:u,featureTable:i,pnts:n,transferables:s}}))}const b=this._readAttributes(e,i,c.offset,d,s,h,f);if(i.BATCH_ID||Object.keys(l).length){i.BATCH_ID?b.BATCH_ID=De(i.BATCH_ID,e,c.offset,d):b.BATCH_ID=mt(d);const t=b.BATCH_ID.array&&b.BATCH_ID.array.buffer;t&&s.indexOf(t)<0&&s.push(t)}return Promise.resolve({count:d,batchTable:l,batchTableBin:u,featureTable:i,pnts:b,transferables:s})}_readAttributes(e,t,r,n,a,o,s){const i={};if(t.POSITION){let{byteOffset:o,array:s}=t.POSITION;o=o||0;const c=s?0:r;if(!s){const t=e.slice(o+c,o+c+3*n*4);s=new Float32Array(t)}i.POSITION={byteStride:0,byteOffset:0,itemSize:3,count:n,componentType:5126,array:s},a.push(s.buffer)}else if(t.POSITION_QUANTIZED){let{byteOffset:c}=t.POSITION_QUANTIZED;const{array:l}=t.POSITION_QUANTIZED;c=c||0;const u=l?0:r;i.POSITION={byteStride:0,byteOffset:0,itemSize:3,count:n,componentType:5126,array:this._convertQuantizedPosition(l||new Uint16Array(e,c+u,3*n),o,s)},a.push(i.POSITION.array.buffer)}if(t.RGBA){let{byteOffset:o,array:s}=t.RGBA;o=o||0;const c=s?0:r;if(!s){const t=e.slice(o+c,o+c+4*n);s=new Uint8Array(t)}i.RGBA={byteStride:0,byteOffset:0,itemSize:4,count:n,componentType:5121,array:s},a.push(s.buffer)}else if(t.RGB){let{byteOffset:o,array:s}=t.RGB;o=o||0;const c=s?0:r;if(!s){const t=e.slice(o+c,o+c+3*n);s=new Uint8Array(t)}i.RGB={byteStride:0,byteOffset:0,itemSize:3,count:n,componentType:5121,array:s},a.push(s.buffer)}else if(t.RGB565){let{byteOffset:o,array:s}=t.RGB565;o=o||0;const c=s?0:r;if(!s){const t=e.slice(o+c,o+c+2*n);s=new Uint16Array(t)}i.RGB565={byteStride:0,byteOffset:0,itemSize:1,count:n,componentType:5123,array:s},a.push(s.buffer)}if(t.NORMAL){let{byteOffset:o,array:s}=t.NORMAL;o=o||0;const c=s?0:r;if(!s){const t=e.slice(o+c,o+c+3*n*4);s=new Float32Array(t)}i.NORMAL={byteStride:0,byteOffset:0,itemSize:3,count:n,componentType:5126,array:s},a.push(s.buffer)}else if(t.NORMAL_OCT16P){let{byteOffset:o,array:s}=t.NORMAL_OCT16P;o=o||0;const c=s?0:r;if(!s){const t=e.slice(o+c,o+c+2*n);s=new Uint8Array(t)}i.NORMAL_OCT16P={byteStride:0,byteOffset:0,itemSize:2,count:n,componentType:5121,array:s},a.push(s.buffer)}return i}_convertQuantizedPosition(e,t,r){return qe(new Float32Array(e.length),e,t,r)}_readBatchTable(){return null}}function mt(e){const t=(r=e)<256?Uint8Array:r<65536?Uint16Array:Uint32Array;var r;const n=new t(e);for(let t=0;t<e;t++)n[t]=t;return{byteStride:0,byteOffset:0,itemSize:1,count:e,componentType:ze(t),array:n}}const{Ajax:pt,GLTFLoader:bt}=a();class gt{constructor(e,t,r,n){this._supportedFormats=r,this._requestImage=e,this._loaderCtor=t||bt,this._maxTextureSize=n}load(e,t,r=0,n=0,a){return t?this._parse(e,t,r,n,a):pt.getArrayBuffer(e,{}).then((t=>{const a=t.data;return this._parse(e,a,r,n)}))}_parse(e,t,r,n,a){n||(n=t.byteLength);const o=this._readCMPT(t,e,r,n),s=[];for(let r=0;r<o.length;r++){let n;if("b3dm"===o[r].magic)n=new ot(this._requestImage,this._loaderCtor,this._supportedFormats);else if("i3dm"===o[r].magic)n=new ct(this._requestImage,this._loaderCtor,this._supportedFormats,this._maxTextureSize);else if("pnts"===o[r].magic)n=new dt;else{if("cmpt"!==o[r].magic){console.warn("Unsupported magic in CMPT tile:",o[r].magic);continue}n=new gt(this._requestImage,this._loaderCtor,this._supportedFormats,this._maxTextureSize)}s.push(n.load(e,t,o[r].offset,o[r].byteLength,a).then((e=>e)))}return Promise.all(s).then((e=>({magic:"cmpt",tiles:e})))}_readCMPT(e,t,r,n){const a=new DataView(e,r,n),o=a.getUint32(4,!0);if(1!==o){const e="Unsupported cmpt version: "+o+", url:"+t;return console.warn(e),{error:e}}if(16===a.byteLength)return[];const s=[],i=a.getUint32(12,!0);let c=16;for(let t=0;t<i;t++){const t=Ee(a,c),n=a.getUint32(c+8,!0);s.push({magic:t,buffer:e,offset:c+r,byteLength:n}),c+=n}return s}}const{GLTFLoader:yt}=a();function _t(e,t){if(e.scenes&&e.scenes.length)for(let r=0,n=e.scenes.length;r<n;r++){const n=e.scenes[r].nodes;for(let r=0,a=n.length;r<a;r++){const a=[];Mt(n[r],a,e,t)}}}const Tt=[],wt=[],vt=[],Ot=[0,0,0],At=function(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=1,e}([]),It=[1,1,1];function Mt(e,t,r,n){const a=t.slice(0);if(e.matrix)a.push(e.matrix);else if(e.rotation||e.translation||e.scale){const t=function(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}(Tt,e.translation||Ot),r=function(e,t){var r=t[0],n=t[1],a=t[2],o=t[3],s=r+r,i=n+n,c=a+a,l=r*s,u=n*s,h=n*i,f=a*s,d=a*i,m=a*c,p=o*s,b=o*i,g=o*c;return e[0]=1-h-m,e[1]=u+g,e[2]=f-b,e[3]=0,e[4]=u-g,e[5]=1-l-m,e[6]=d+p,e[7]=0,e[8]=f+b,e[9]=d-p,e[10]=1-l-h,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(wt,e.rotation||At),n=function(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}(vt,e.scale||It);c(n,r,n);const o=c([],t,n);a.push(o)}if(e.children&&e.children.length)for(let t=0,o=e.children.length;t<o;t++)Mt(e.children[t],a,r,n);if(void 0!==e.mesh){const t=e.mesh,o=r.meshes[t];if(o){const e=a.slice(0),s=o.primitives;for(let a=0,o=s.length;a<o;a++){const o=s[a];o&&(o.matrices=e,n(o,t,a,r))}}}}function xt(e,t){let{byteOffset:r,byteStride:n,count:a}=e;const{componentType:o,itemSize:s}=e,i=e.array.buffer,c=o?yt.getTypedArrayCtor(o):e.array.constructor;if(r=void 0===r?e.array.byteOffset:r,n=n||0,a=a||e.array.length/s,(!n||n===s*c.BYTES_PER_ELEMENT)&&r%c.BYTES_PER_ELEMENT===0){const e=new c(i,r,a*s);for(let n=0;n<a*s;n+=s){t(new c(e.buffer,r+n*c.BYTES_PER_ELEMENT,s),n/s)}return}const l=new Uint8Array(s*c.BYTES_PER_ELEMENT);n||(n=s*c.BYTES_PER_ELEMENT);for(let e=0;e<a;e++){const a=new Uint8Array(i,n*e+r,s*c.BYTES_PER_ELEMENT);l.set(a);t(new c(l.buffer),e),a.set(l)}}var Ct=kt("DXT1"),St=kt("DXT3"),Nt=kt("DXT5"),Lt=kt("DX10");function kt(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}var Et=x((function(e){var t,r,n=new Int32Array(e,0,31);if(542327876!==n[0])throw new Error("Invalid magic number in DDS header");if(4&!n[20])throw new Error("Unsupported format, must contain a FourCC code");var a=n[21];switch(a){case Ct:t=8,r="dxt1";break;case St:t=16,r="dxt3";break;case Nt:t=16,r="dxt5";break;case 116:r="rgba32f";break;case Lt:var o=new Uint32Array(e.slice(128,148));r=o[0];var s=o[1];if(o[2],o[3],o[4],3!==s||2!==r)throw new Error("Unsupported DX10 texture format "+r);r="rgba32f";break;default:throw new Error("Unsupported FourCC code: "+(i=a,String.fromCharCode(255&i,i>>8&255,i>>16&255,i>>24&255)))}var i;var c=n[2],l=1;131072&c&&(l=Math.max(1,n[7]));var u=!1;512&n[28]&&(u=!0);var h,f=n[4],d=n[3],m=n[1]+4,p=f,b=d,g=[];a===Lt&&(m+=20);if(u)for(var y=0;y<6;y++){if("rgba32f"!==r)throw new Error("Only RGBA32f cubemaps are supported");f=p,d=b;for(var _=Math.log(f)/Math.log(2)+1,T=0;T<_;T++)h=f*d*16,g.push({offset:m,length:h,shape:[f,d]}),T<l&&(m+=h),f=Math.floor(f/2),d=Math.floor(d/2)}else for(T=0;T<l;T++)h=Math.max(4,f)/4*Math.max(4,d)/4*t,g.push({offset:m,length:h,shape:[f,d]}),m+=h,f=Math.floor(f/2),d=Math.floor(d/2);return{shape:[p,b],images:g,format:r,flags:c,cubemap:u}})),Pt=Math.abs,Ut=Math.sin,Rt=Math.cos,Bt=Math.tan,Ft=Math.atan,Dt=Math.atan2,jt=Math.sqrt,Gt=Math.log,zt=Math.hypot,qt=Math.sinh,Ht=Math.cosh,Vt=1/0;function $t(e){var t,r,n,a,o,s,i=[],c=[],l=[],u=[];function h(e,t){for(var r,n=2*Rt(2*t),a=e.length-1,o=e[a],s=0;--a>=0;)r=n*o-s+e[a],s=o,o=r;return t+r*Ut(2*t)}function f(e,t,r){for(var n,a,o=Ut(t),s=Rt(t),i=qt(r),c=Ht(r),l=2*s*c,u=-2*o*i,h=e.length-1,f=e[h],d=0,m=0,p=0;--h>=0;)n=m,a=d,f=l*(m=f)-n-u*(d=p)+e[h],p=u*m-a+l*d;return[(l=o*c)*f-(u=s*i)*p,l*p+u*f]}e.es,o=a=(n=e.es/(1+jt(1-e.es)))/(2-n),i[0]=a*(2+a*(-2/3+a*(a*(116/45+a*(26/45+a*(-2854/675)))-2))),c[0]=a*(a*(2/3+a*(4/3+a*(-82/45+a*(32/45+a*(4642/4725)))))-2),o*=a,i[1]=o*(7/3+a*(a*(-227/45+a*(2704/315+a*(2323/945)))-1.6)),c[1]=o*(5/3+a*(-16/15+a*(-13/9+a*(904/315+a*(-1522/945))))),o*=a,i[2]=o*(56/15+a*(-136/35+a*(-1262/105+a*(73814/2835)))),c[2]=o*(-26/15+a*(34/21+a*(1.6+a*(-12686/2835)))),o*=a,i[3]=o*(4279/630+a*(-332/35+a*(-399572/14175))),c[3]=o*(1237/630+a*(a*(-24832/14175)-2.4)),o*=a,i[4]=o*(4174/315+a*(-144838/6237)),c[4]=o*(-734/315+a*(109598/31185)),o*=a,i[5]=o*(601676/22275),c[5]=o*(444337/155925),o=a*a,t=e.k0/(1+a)*(1+o*(1/4+o*(1/64+o/256))),l[0]=a*(a*(2/3+a*(-37/96+a*(1/360+a*(81/512+a*(-96199/604800)))))-.5),u[0]=a*(.5+a*(-2/3+a*(5/16+a*(41/180+a*(-127/288+a*(7891/37800)))))),l[1]=o*(-1/48+a*(-1/15+a*(437/1440+a*(-46/105+a*(1118711/3870720))))),u[1]=o*(13/48+a*(a*(557/1440+a*(281/630+a*(-1983433/1935360)))-.6)),o*=a,l[2]=o*(-17/480+a*(37/840+a*(209/4480+a*(-5569/90720)))),u[2]=o*(61/240+a*(-103/140+a*(15061/26880+a*(167603/181440)))),o*=a,l[3]=o*(-4397/161280+a*(11/504+a*(830251/7257600))),u[3]=o*(49561/161280+a*(-179/168+a*(6601661/7257600))),o*=a,l[4]=o*(-4583/161280+a*(108847/3991680)),u[4]=o*(34729/80640+a*(-3418889/1995840)),o*=a,l[5]=o*(-20648693/638668800),u[5]=.6650675310896665*o,s=h(c,e.phi0),r=-t*(s+function(e,t){var r,n=2*Rt(t),a=e.length-1,o=e[a],s=0;for(;--a>=0;)r=n*o-s+e[a],s=o,o=r;return Ut(t)*r}(u,2*s)),e.fwd=function(e,n){var a,o,s,i,l,d=e.phi,m=e.lam;d=h(c,d),a=Ut(d),o=Rt(d),i=Ut(m),s=Rt(m),d=Dt(a,s*o),m=Dt(i*o,zt(a,o*s)),m=function(e){var t=Pt(e);return t=function(e){var t=1+e,r=t-1;return 0===r?e:e*Gt(t)/r}(t*(1+t/(zt(1,t)+1))),e<0?-t:t}(Bt(m)),l=f(u,2*d,2*m),d+=l[0],m+=l[1],Pt(m)<=2.623395162778?(n.y=t*d+r,n.x=t*m):n.x=n.y=Vt},e.inv=function(e,n){var a,o,s,c,u,d=e.y,m=e.x;d=(d-r)/t,Pt(m/=t)<=2.623395162778?(d+=(u=f(l,2*d,2*m))[0],m+=u[1],m=Ft(qt(m)),a=Ut(d),o=Rt(d),c=Ut(m),s=Rt(m),m=Dt(c,s*o),d=Dt(a*s,zt(c,s*o)),n.phi=h(i,d),n.lam=m):n.phi=n.lam=Vt}}const Qt=Math.PI/180,Kt=6378137*Math.PI/180,Zt=85.0511287798,Xt={};function Jt(e,t,r,n){if("EPSG:3857"===r)return function(e,t){const r=Zt,n=t[0],a=Math.max(Math.min(r,t[1]),-85.0511287798);let o;o=0===a?0:Math.log(Math.tan((90+a)*Qt/2))/Qt;return e[0]=n*Kt,e[1]=o*Kt,e}(e,t);if(!r||"EPSG:9807"!==r.code&&"Traverse_Mercator"!==r.code){if("EPSG:4326"===r||"EPSG:4490"===r||"identity"===r)return Yt(e,t);if("baidu"===r)return Yt(e,t);throw new Error("unsupported projection:"+r)}{if(!(!n||4326===n.wkid))return function(e,t){return e[0]=t[0],e[1]=t[1],e}(e,t);const a=JSON.stringify(r);let o=Xt[a];return o||(o=Xt[a]=function(e){const t={a:er,es:tr,x0:be(e.falseEasting)?5e5:e.falseEasting,y0:be(e.falseNorthing)?0:e.falseNorthing,k0:e.scaleFactor||.9996,lam0:(e.centralMeridian||0)*Wt,phi0:(e.latitudeOfOrigin||0)*Wt,originLam0:e.startLongtitude||0,originPhi0:e.startLatitude||0};$t(t);const r={lam:0,phi:0},n={};let a=0,o=0;(t.originLam0||t.originPhi0)&&(r.lam=t.originLam0*Wt-t.lam0,r.phi=t.originPhi0*Wt,t.fwd(r,n),a=t.a*n.x+t.x0,o=t.a*n.y+t.y0);return{project:function(e,s){r.lam=e[0]*Wt-t.lam0,r.phi=e[1]*Wt,t.fwd(r,n);const i=t.a*n.x+t.x0-a,c=t.a*n.y+t.y0-o;return s[0]=i,s[1]=c,s}}}(r)),o.project(t,e)}}function Yt(e,t){return e[0]=t[0],e[1]=t[1],e}const Wt=.017453292519943295,er=6378137,tr=.0066943799901413165;const{Ajax:rr}=a(),nr=i([]),ar=rt().draco,or=rt().ktx2,sr={"pbrMetallicRoughness":{"baseColorFactor":[.5,.5,.5,1],"metallicFactor":0,"roughnessFactor":.5}},ir={"position":{name:"POSITION",accessor:{"componentType":5126,"type":"VEC3"}},"normal":{name:"NORMAL",accessor:{"componentType":5126,"type":"VEC3"}},"uv0":{name:"TEXCOORD_0",accessor:{"componentType":5126,"type":"VEC2"}},"color":{name:"COLOR_0",accessor:{"componentType":5121,"type":"VEC4"}},"uv-region":{name:"uvRegion",accessor:{"componentType":5123,"type":"VEC4"}},"feature-index":{name:"_BATCHID",accessor:{"componentType":5125,"type":"SCALAR"}},"faceRange":{name:"faceRange",accessor:{"componentType":5125,"type":"VEC2"}}};function cr(e,t,r,n,a,o){const s=[],c=[],l=[];for(let t=0;t<e.meshes.length;t++){const{geometry:r,material:n}=e.meshes[t],a=rr.getArrayBuffer(r.url,o);a.xhr.url=r.url,l.push(a.xhr);const i=a.then((e=>({buffer:e})));s.push(i);const u=[];if(br(n,u),u.length){const e=u.map((e=>{const t=rr.getArrayBuffer(e.url,o);return t.xhr.url=e.url,l.push(t.xhr),t.then((t=>t&&t.status?null:{buffer:t,mimeType:e.mimeType,format:e.format}))}));s.push(...e)}c[t]=u.length}const u=Promise.all(s).then((o=>{for(let e=0;e<o.length;e++)if(!o[e]||!o[e].buffer)return Promise.resolve(null);const s=[];let l=0;for(let e=0;e<c.length;e++){const t=c[e];s.push({geoBuffer:{data:o[l].buffer.data},textureBuffers:o.slice(l+1,t+l+1).map((e=>({data:e.buffer.data,mimeType:e.mimeType,format:e.format})))}),l+=1+t}const u=function(e,t,r,n,a,o){const s={asset:{generator:"i3s",version:"2.0"},extensions:{},scene:0,scenes:[{nodes:[]}],nodes:{},meshes:{},materials:[],skins:[],animations:null,textures:[],transferables:[]},c=[];for(let l=0;l<e.meshes.length;l++){let{material:u}=e.meshes[l];const{geometry:h}=e.meshes[l];let f;const d=t[l].geoBuffer.data;if(!d)continue;f=vr(d)?ur(s,l,h,d,e.transform,e.center,a,o):fr(s,l,h,d,e.transform,e.center,a,o),c.push(f),s.nodes[l]={mesh:l,nodeIndex:l,matrix:i([])},s.scenes[0].nodes[l]=s.nodes[l],u||(u=sr);const m=mr(l,s,u,t[l].textureBuffers,r,n);c.push(m)}return Promise.all(c).then((()=>({gltf:s,featureTable:{BATCH_LENGTH:0},transferables:s.transferables})))}(e,s,t,a,r,n);return u}));return u.xhr=l,u}const lr={"magFilter":9728,"minFilter":9728,"wrapR":33071,"wrapS":33071,"wrapT":33071};function ur(e,t,r,n,a,o,s,i){const c=r.info.compressedAttributes.attributes.reduce(((e,t,r)=>{const n=ir[t];if(!n)return e;return e[n.name||t]=r,e}),{});return ar(n,{attributes:c,metadatas:{"POSITION":[{name:"i3s-scale_x",type:"double"},{name:"i3s-scale_y",type:"double"}]},useUniqueIDs:!1,skipAttributeTransform:!1}).then((r=>dr(r,e,t,a,o,s,i)))}const hr={position:function(e,t,r){const n=3*e.vertexCount,a=new Float32Array(t,r,n);return e.position={array:a,componentType:5126,itemSize:3,count:n/3,meta:{"i3s-scale_x":1,"i3s-scale_y":1},type:"VEC3"},r+=4*n},normal:function(e,t,r){const n=3*e.vertexCount,a=new Float32Array(t,r,n);return e.normal={array:a,componentType:5126,itemSize:3,count:n/3,type:"VEC3"},r+=4*n},uv0:function(e,t,r){const n=2*e.vertexCount,a=new Float32Array(t,r,n);return e.uv0={array:a,componentType:5126,itemSize:2,count:n/2,type:"VEC2"},r+=4*n},color:function(e,t,r){const n=4*e.vertexCount,a=new Uint8Array(t,r,n);return e.color={array:a,componentType:5121,itemSize:4,count:n/4,type:"VEC4"},r+=n},featureId:function(e,t,r){return r+=8*e.featureCount},id:function(e,t,r){return r+=8*e.featureCount},faceRange:function(e,t,r){const n=2*e.featureCount,a=new Uint32Array(t,r,n);return e.faceRange={array:a,componentType:5125,itemSize:2,count:n/2,type:"VEC2"},r+=4*n},uvRegion:function(e,t,r){const n=4*e.vertexCount,a=new Uint16Array(t,r,n);return e["uv-region"]={array:a,componentType:5123,itemSize:4,count:n/4,type:"VEC4"},r+=2*n},region:function(e,t,r){const n=4*e.vertexCount,a=new Uint16Array(t,r,n);return e["uv-region"]={array:a,componentType:5123,itemSize:4,count:n/4,type:"VEC4"},r+=2*n}};function fr(e,t,r,n,a,o,s,i){const c={vertexCount:0},l=new DataView(n);try{let e=0;c.vertexCount=l.getUint32(e,1),e+=4,c.featureCount=l.getUint32(e,1),e+=4;const t=r.info.ordering?null:r.info;if(t){const r=[];for(const e in t)"offset"!==e&&""!==e&&r.push(e);for(let t=0;t<r.length;t++)hr[r[t]]?e=hr[r[t]](c,n,e):console.error("Unknown decoder for",r[t])}else{const t=r.info;let a=t.ordering,o=t.featureAttributeOrder;const s=null;s&&s.geometryData&&s.geometryData[0]&&s.geometryData[0].params;for(let t=0;t<a.length;t++){const r=hr[a[t]];r||console.log(a[t]),e=r(c,n,e)}for(let t=0;t<o.length;t++){const r=hr[o[t]];r||console.log(o[t]),e=r(c,n,e)}}}catch(e){}c.scale_x=1,c.scale_y=1;const u={};for(const e in c){const t=ir[e]&&ir[e].name;t&&(u[t]=c[e])}if(c.faceRange){const e=c.faceRange.array,t=e.length/2,r=(h=t)<=255?Uint8Array:h<=65535?Uint16Array:Uint32Array,n=new r(u.POSITION.array.length/3);for(let t=0;t<e.length-1;t+=2){const r=t/2,a=e[t],o=e[t+1];for(let e=a;e<=o;e++)n[3*e]=r,n[3*e+1]=r,n[3*e+2]=r}u._BATCHID={componentType:et(r),array:n,itemSize:1,count:n.length,type:"SCALAR"}}var h;return dr({attributes:u},e,t,a,o,s,i)}function dr(e,t,r,n,a,o,s){const i={attributes:e.attributes,material:r,indices:e.indices,mode:4};!function(e){const t=e.array,r=e.meta&&e.meta["i3s-scale_x"],n=e.meta&&e.meta["i3s-scale_y"];if(r&&n&&(1!==r||1!==n))for(let e=0;e<t.length;e+=3)t[e]*=r.value,t[e+1]*=n.value}(e.attributes.POSITION);const c=function(e,t,r,n,a){let o,s=[0,0,0,1];const i=[0,0],c=Jt([],r,n,a);c[2]=r[2];const u=t&&l(nr,t);return xt(e,(e=>(s[0]=e[0],s[1]=e[1],s[2]=e[2],u||(s=w(s,s,t)),r&&p(s,s,r),Jt(i,s,n,a),o=s[2],e[0]=i[0]-c[0],e[1]=i[1]-c[1],e[2]=o-c[2],e))),c}(e.attributes.POSITION,n,a,o,s);t.meshes[r]={primitives:[i],index:r},t.extensions.MAPTALKS_RTC={projCenter:c},t.extensions.CESIUM_RTC={rtcCoord:a};for(const r in e.attributes)wr(t.transferables,e.attributes[r].array.buffer);return e.indices&&wr(t.transferables,e.indices.array.buffer),i}function mr(e,t,r,n,a,o){const s=n.map((e=>function(e,t,r,n,a){if("dds"===t){const t=Et(e),n=t.images.map((t=>new Uint8Array(e,t.offset,t.length))),a="dxt1"===t.format?33777:33779;return Promise.resolve({image:{mipmap:n,width:t.shape[0],height:t.shape[1],mimeType:r},sampler:lr,format:a})}if("png"===t||"jpg"===t)return function(e,t){gr||(gr=new OffscreenCanvas(2,2),yr=gr.getContext("2d",{willReadFrequently:!0}));const r=new Blob([new Uint8Array(e)]);return createImageBitmap(r).then((e=>{let{width:r,height:n}=e;_r(r)||(r=Tr(r)),_r(n)||(n=Tr(n));const a=t;a&&(r=Math.min(a,r),n=Math.min(a,n)),gr.width=r,gr.height=n,yr.drawImage(e,0,0,r,n),e.close();const o=yr.getImageData(0,0,r,n);return{width:r,height:n,array:new Uint8Array(o.data)}})).catch((()=>({width:2,height:2,array:new Uint8Array(4)})))}(e,a).then((e=>{e.mimeType=r;return{image:e,sampler:lr,format:6408}}));if("ktx2"===t)return or(e,n).then((e=>(e.mimeType=r,{image:e,sampler:lr,format:e.format})));return null}(e.data,e.format,e.mimeType,a,o).then((e=>{if(e.image)if(e.image.array)wr(t.transferables,e.image.array.buffer);else if(e.image.mipmap)for(let r=0;r<e.image.mipmap.length;r++)wr(t.transferables,e.image.mipmap[r].buffer);return e}))));return Promise.all(s).then((n=>{pr(e,t,r,n)}))}function pr(e,t,r,n){const a=JSON.parse(JSON.stringify(r)),o=t.textures;n.ptr||(n.ptr=0);for(const e in r)r[e]&&r[e].url?(o.push(n[n.ptr++]),a[e]={index:o.length-1},void 0!==r[e].factor&&(a[e].scale=r[e].factor)):ge(r[e])&&(a[e]=pr(-1,t,r[e],n));return e>=0&&(t.materials[e]=a),a}function br(e,t){for(const r in e)e[r]&&e[r].url?t.push({url:e[r].url,mimeType:e[r].mimeType,format:e[r].format}):ge(e[r])&&br(e[r],t)}let gr,yr;function _r(e){return!(e&e-1)&&0!==e}function Tr(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}function wr(e,t){t&&(e.indexOf(t)>=0||e.push(t))}function vr(e){const t=new Uint8Array(e,0,5);return t[0]==="D".charCodeAt()&&t[1]==="R".charCodeAt()&&t[2]==="A".charCodeAt()&&t[3]==="C".charCodeAt()&&t[4]==="O".charCodeAt()}var Or="undefined"!=typeof Float32Array?Float32Array:Array;function Ar(e,t,r,n){return e[0]=t,e[1]=r,e[2]=n,e}var Ir=function(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e};!function(){var e=function(){var e=new Or(3);return Or!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}()}();const Mr=[];const xr=[],Cr=[],Sr=[],Nr=[],Lr=[],kr=[],Er=[];function Pr(e,t,r,n,a,o){Ar(Nr,e[3*t],e[3*t+1],e[3*t+2]),Ar(Lr,e[3*r],e[3*r+1],e[3*r+2]),Ar(kr,e[3*n],e[3*n+1],e[3*n+2]);const s=Ir(xr,kr,Lr),i=Ir(Cr,Nr,Lr),c=function(e,t,r){var n=t[0],a=t[1],o=t[2],s=r[0],i=r[1],c=r[2];return e[0]=a*c-o*i,e[1]=o*s-n*c,e[2]=n*i-a*s,e}(Sr,s,i);!function(e,t){var r=t[0],n=t[1],a=t[2],o=r*r+n*n+a*a;o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o)}(Er,c),a[3*t]=a[3*t]||0,a[3*r]=a[3*r]||0,a[3*n]=a[3*n]||0,a[3*t+1]=a[3*t+1]||0,a[3*r+1]=a[3*r+1]||0,a[3*n+1]=a[3*n+1]||0,a[3*t+2]=a[3*t+2]||0,a[3*r+2]=a[3*r+2]||0,a[3*n+2]=a[3*n+2]||0,a[3*t]+=Er[0],a[3*r]+=Er[0],a[3*n]+=Er[0],a[3*t+1]+=Er[1],a[3*r+1]+=Er[1],a[3*n+1]+=Er[1],a[3*t+2]+=Er[2],a[3*r+2]+=Er[2],a[3*n+2]+=Er[2],o[t]+=1,o[r]+=1,o[n]+=1}const{Ajax:Ur,GLTFLoader:Rr}=a(),Br=[1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1],Fr=[0,0,1,0,0,1,0,0,-1,0,0,0,0,0,0,1],Dr=2*Math.PI*6378137/360,jr="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null;let Gr,zr,qr=!1;if("undefined"!=typeof OffscreenCanvas){try{zr=new OffscreenCanvas(2,2).getContext("2d",{willReadFrequently:!0})}catch(e){}zr&&"undefined"!=typeof createImageBitmap&&(qr=!0)}const Hr=i([]),Vr=[0,0,0],$r=[],Qr=[],Kr=[],Zr=[],Xr={"POSITION":1,"TEXCOORD_0":1,"TEXCOORD_1":1,"NORMAL":1,"TANGENT":1},Jr={"TEXCOORD_0":1e-4,"TEXCOORD_1":1e-4};let Yr;class Wr{constructor(e,t,r,n){this.id=e,this.options=t,this._bindedRequestImage=(...e)=>this.requestImage.call(this,...e),this._uploader=r,this._requests={},n(null,{},[])}_createLoaders(e){this._b3dmLoader||(this._supportedFormats=e,this._pntsLoader=new dt,this._b3dmLoader=new ot(this._bindedRequestImage,Rr,e),this._i3dmLoader=new ct(this._bindedRequestImage,Rr,e))}requestImage(e,t){qr?fetch(e).then((e=>e.arrayBuffer())).then((e=>{const t=new self.Blob([new Uint8Array(e)]);return createImageBitmap(t)})).then((e=>{Gr.width=e.width,Gr.height=e.height,zr.drawImage(e,0,0);const r=zr.getImageData(0,0,Gr.width,Gr.height);e.close(),t(null,{width:e.width,height:e.height,data:new Uint8Array(r.data)})})):this._uploader("requestImage",{url:e},null,t)}loadTile(e,t){this._createLoaders(e.supportedFormats);const{service:r,url:n,arraybuffer:a}=e,o=r.fetchOptions||{};if(o.referrer=e.referrer,o.referrerPolicy=o.referrerPolicy||"origin",function(e){return e.indexOf("i3s:")>=0}(n)){const a=e.i3sInfo,s=r.maxTextureSize||0,i=cr(a,e.supportedFormats,this.options.projection,e.projection,s,o);return i.then((e=>{if(delete this._requests[n],!e)return void t({status:404,url:n,i3sInfo:a});if(!Object.keys(e.gltf.meshes).length)return void t({status:404,url:n,i3sInfo:a});e.gltf.url=n;const{transferables:o}=e;e.magic="b3dm",r.createNormalIfMissed&&this._createGLTFMissedAttrs(e.gltf),ln(r)&&this._compressAttrFloat32ToInt16(e.gltf),t(null,e,o)})),void(this._requests[n]=i.xhr)}if(a){delete this._requests[n];const r=Ee(new DataView(a),0);if("{"===r[0]||" "===r[0]||"<"===r[0]){const r=function(e,t,r){if(jr){const n=new Uint8Array(e,t,r);return jr.decode(n)}return we(new Uint8Array(e,t,r))}(a,0,a.byteLength),o=JSON.parse(r);o.accessors?this._read3DTile(o,n,e,"gltf",t):this._checkAndConvert(e.rootIdx,o,a,n,t)}else this._read3DTile(a,n,e,r,t)}else{let a=r.urlParams;a&&(a=(n.indexOf("?")>0?"&":"?")+a);const s=n.replace(/\\+/g,"%2B");let i=Ur.getArrayBuffer(s+(a||""),o);const c=i.xhr;i=i.then((r=>{delete this._requests[n],r&&r.status?t(r):(e.arraybuffer=r&&r.data,this.loadTile(e,t))})).catch((e=>{delete this._requests[n],t(e)})),this._requests[n]=c}}_read3DTile(e,t,r,n,a){n=n&&n.toLowerCase();const{service:o}=r;if("b3dm"===n){this._b3dmLoader.load(t,e,0,0,{maxTextureSize:o.maxTextureSize||0}).then((e=>{if(e.error)return void a(e);const{content:t,transferables:n}=this._processB3DM(e,r);o.createNormalIfMissed&&this._createGLTFMissedAttrs(t.gltf),ln(o)&&this._compressAttrFloat32ToInt16(t.gltf),a(null,t,n)})).catch((e=>{a(e)}))}else if("pnts"===n){const n=r.transform||Hr;this._pntsLoader.load(t,e).then((e=>{const{content:t,transferables:o}=this._loadPNTS(e,n,r.rootIdx);this._compressPNTSFloat32ToInt16(t),a(null,t,o)}))}else if("i3dm"===n){const n=r.transform||Hr;this._i3dmLoader.load(t,e,0,0,{maxTextureSize:o.maxTextureSize||0}).then((e=>{const{content:t,transferables:s}=this._loadI3DM(e,n,r.rootIdx);o.createNormalIfMissed&&this._createGLTFMissedAttrs(t.gltf),ln(o)&&this._compressAttrFloat32ToInt16(t.gltf),a(null,t,s)}))}else if("cmpt"===n){new gt(this._bindedRequestImage,Rr,this._supportedFormats,o.maxTextureSize||0).load(t,e,0,0,{maxTextureSize:o.maxTextureSize||0}).then((e=>{const{content:t,transferables:n}=this._processCMPT(e,r);this._createCMPTMissedAttrs(t,o),ln(o)&&this._compressCMPTContent(t),a(null,t,n)})).catch((e=>{a(e)}))}else if("gltf"===n){this._decoders||(this._decoders=rt());const n=t.substring(0,t.lastIndexOf("/")),s=e instanceof ArrayBuffer&&{buffer:e,byteOffset:0,byteLength:e.byteLength}||e;let i;try{i=new Rr(n,s,{transferable:!0,requestImage:this._bindedRequestImage,decoders:this._decoders,supportedFormats:this._supportedFormats,maxTextureSize:o.maxTextureSize||0})}catch(e){a(e)}i.load({skipAttributeTransform:!1}).then((e=>{e.url=t,this._processGLTF(e,null,r),o.createNormalIfMissed&&this._createGLTFMissedAttrs(e),ln(o)&&this._compressAttrFloat32ToInt16(e),a(null,{magic:"gltf",gltf:e},i.transferables)}))}else a(new Error("unsupported tile format: "+n))}_createCMPTMissedAttrs(e,t){e.content?e.content.forEach((e=>{this._createCMPTMissedAttrs(e,t)})):t.createNormalIfMissed&&this._createGLTFMissedAttrs(e.gltf)}_compressCMPTContent(e){e.content?e.content.forEach((e=>{this._compressCMPTContent(e)})):this._compressAttrFloat32ToInt16(e.gltf)}_createMissedAttrs(e,t){if(this._needCreateMissedAttrs(e,t)&&!e.attributes.NORMAL){const t=e.attributes.POSITION.array,r=t.length,n=this._is4326()?Yr.subarray(0,r):t,a=function(e,t,r){const n=r||[];n.setLength&&n.setLength(e.length);const a=Mr;a.length<e.length/3&&(a.length=e.length/3),a.fill(0,0,e.length/3);const o=void 0===t.length?t:t.length;for(let r=0;r<o/3;r++)void 0===t.length?Pr(e,3*r,3*r+1,3*r+2,n,a):Pr(e,t[3*r],t[3*r+1],t[3*r+2],n,a);for(let e=0;e<n.length;e+=3){const t=a[e/3];0!==t?(n[e]/=t,n[e+1]/=t,n[e+2]/=t):(n[e]=0,n[e+1]=0,n[e+2]=0)}return n}(n,e.indices.array,new Float32Array(n.length));e.attributes.NORMAL={array:a,byteLength:a.byteLength,byteOffset:0,byteStride:0,componentType:5126,count:a.length/3,itemSize:3,name:"NORMAL",type:"VEC3"}}}_compressAttrFloat32ToInt16(e){if(!e||!e.meshes||e.extensionsUsed&&e.extensionsUsed.indexOf("KHR_techniques_webgl")>-1)return;if(e.asset&&e.asset.sharePosition)return;const t=e.meshes;for(const e in t){t[e].primitives.forEach((e=>{e.compressed_int16_params={};const t=e.attributes;for(const r in t)if(Xr[r]&&t[r].array&&t[r].array instanceof Float32Array){let n=1;this._is4326()&&"POSITION"===r&&(n=Dr,e.compressed_int16_params.compressed_ratio=n);const a=on(t[r].array,n,t[r].min,t[r].max,r);if(!a)continue;const{array:o,range:s}=a;t[r].componentType=5124,t[r].array=o,e.compressed_int16_params[r]=s}}))}}_createGLTFMissedAttrs(e){if(!e||!e.meshes||e.extensionsUsed&&e.extensionsUsed.indexOf("KHR_techniques_webgl")>-1)return;if(e.asset&&e.asset.sharePosition)return;const t=e.meshes;for(const r in t){t[r].primitives.forEach((t=>{this._createMissedAttrs(t,e)}))}}_compressPNTSFloat32ToInt16(e){if(!e||!e.pnts)return;const t=e.pnts;e.compressed_int16_params={};for(const r in t)if(Xr[r]&&t[r].array&&t[r].array instanceof Float32Array){let n=1;this._is4326()&&"POSITION"===r&&(n=Dr,e.compressed_int16_params.compressed_ratio=n);const{array:a,range:o}=on(t[r].array,n,t[r].min,t[r].max,r);t[r].array=a,e.compressed_int16_params[r]=o}}_convertPageLoads(e){const t=[];for(let r=0;r<e.length;r++){const n=e[r];if(!n.childTile)continue;const a={boundingVolume:{sphere:[n.boundingSphere.center.x,n.boundingSphere.center.y,n.boundingSphere.center.z,n.boundingSphere.radius]},content:{uri:n.childTile},geometricError:n.boundingSphere.radius/n.rangeList*16,refine:"REPLACE"};t.push(a)}return t}_checkAndConvert(e,t,r,n,a){return t.capabilities,void a(null,t)}_processCMPT(e,t){const{tiles:r}=e,n={magic:"cmpt",content:[]},a=[];for(let e=0;e<r.length;e++){const{magic:o}=r[e];if("b3dm"===o){const{content:o,transferables:s}=this._processB3DM(r[e],t);nn(a,s),n.content.push(o)}else if("i3dm"===o){const{transform:o,rootIdx:s}=t,{content:i,transferables:c}=this._loadI3DM(r[e],o,s);nn(a,c),n.content.push(i)}else if("pnts"===o){const{transform:o,rootIdx:s}=t,{content:i,transferables:c}=this._loadPNTS(r[e],o,s);nn(a,c),n.content.push(i)}else if("cmpt"===o){const{content:o,transferables:s}=this._processCMPT(r[e],t);nn(a,s),n.content.push(o)}}return{content:n,transferables:a}}_processB3DM(e,t){const{gltf:r,transferables:n,featureTable:a}=e;return this._processGLTF(r,a,t),delete e.transferables,{content:e,transferables:n}}_processGLTF(e,t,r){const n=function(e){if(!e||!e.meshes)return!1;if(e.extensions&&e.extensions.KHR_techniques_webgl)return!0;const t="visited";let r=1;const n=[];for(const a in e.meshes){const o=e.meshes[a],{primitives:s}=o;if(s)for(let e=0;e<s.length;e++){const a=s[e].attributes&&s[e].attributes.POSITION;if(!a||!a.array)continue;a.array.buffer[t]||(a.array.buffer[t]=r++);const o=r-1+"-"+(a.byteOffset||0);if(n.indexOf(o)>=0)return!0;n.push(o)}}return!1}(e);this._markTextures(e);r.service.createNormalIfMissed||this._markUnlit(e),e.asset||(e.asset={}),n?(e.asset.sharePosition=!0,this._convertCoordinates(e,t,r.upAxis,r.transform)):this._projectCoordinates(e,t,r.upAxis,r.transform)}_loadI3DM(e,t,r){const{featureTable:n}=e,a=e.i3dm,o=n&&n.RTC_CENTER||[0,0,0],s=this.options.projection,i=t&&l(Hr,t),c={xmin:1/0,xmax:-1/0,ymin:1/0,ymax:-1/0,hmin:1/0,hmax:-1/0};tn(a.POSITION.array,3,o,Hr,c);const u=rn(c);t&&!i&&w(u,u,t);const h=this._getCoordiate(u),f=[];Jt(f,h,s),f[2]=h[2];const p=d([],u),b=[0,0,0],g=[0,0,0],y=[0,0],_=[1/0,1/0,1/0],T=[-1/0,-1/0,-1/0];xt(a.POSITION,(e=>{b[0]=e[0]+o[0],b[1]=e[1]+o[1],b[2]=e[2]+o[2],t&&!i&&w(b,b,t),0===A(b)?m(g,0,0,-6378137):xe(g,b),Jt(y,g,s),e[0]=y[0]-f[0],e[1]=y[1]-f[1],e[2]=g[2]-f[2],e[0]<_[0]&&(_[0]=e[0]),e[1]<_[1]&&(_[1]=e[1]),e[2]<_[2]&&(_[2]=e[2]),e[0]>T[0]&&(T[0]=e[0]),e[1]>T[1]&&(T[1]=e[1]),e[2]>T[2]&&(T[2]=e[2])})),a.POSITION.min=_,a.POSITION.max=T,t&&w(u,u,t),e.rtcCenter=p,e.rtcCoord=h,e.projCenter=f,e.rootIdx=r;const v=e.transferables;return delete e.transferables,{content:e,transferables:v}}_loadPNTS(e,t,r){const{featureTable:n}=e,a=e.pnts,o=n&&n.RTC_CENTER||[0,0,0],s=this.options.projection,i=t&&l(Hr,t),c={xmin:1/0,xmax:-1/0,ymin:1/0,ymax:-1/0,hmin:1/0,hmax:-1/0};tn(a.POSITION.array,3,o,t,c);const u=rn(c),h=this._getProjCenter(u),f=d([],u),p=[1/0,1/0,1/0],b=[-1/0,-1/0,-1/0];let g=[0,0,0,1];const y=[0,0,0],_=[0,0];xt(a.POSITION,(e=>(g[0]=e[0]+o[0],g[1]=e[1]+o[1],g[2]=e[2]+o[2],t&&!i&&(g=w(g,g,t)),0===A(g)?m(y,0,0,-6378137):xe(y,g),Jt(_,y,s),e[0]=_[0]-h[0],e[1]=_[1]-h[1],e[2]=y[2]-h[2],e[0]<p[0]&&(p[0]=e[0]),e[1]<p[1]&&(p[1]=e[1]),e[2]<p[2]&&(p[2]=e[2]),e[0]>b[0]&&(b[0]=e[0]),e[1]>b[1]&&(b[1]=e[1]),e[2]>b[2]&&(b[2]=e[2]),e))),a.POSITION.min=p,a.POSITION.max=b,t&&w(u,u,t);const T=this._getCoordiate(u);e.rtcCenter=f,e.projCenter=h,e.rtcCoord=T,e.rootIdx=r;const v=e.transferables;return delete e.transferables,{content:e,transferables:v}}_markTextures(e){if(!Array.isArray(e.textures))return;const t=e.textures;for(let e=0;e<t.length;e++){const r=t[e]&&t[e].image&&t[e].image.array;if(r&&r.length){const n=r[0],a=r[1],o=r[2],s=r[3];let i=!0;for(let e=4;e<r.length;e+=4)if(r[e]!==n||r[e+1]!==a||r[e+2]!==o||r[e+3]!==s){i=!1;break}i&&(t[e].image.color=[n/255,a/255,o/255,s/255],delete t[e].image.array)}}}_markUnlit(e){const t=e.meshes;for(const r in t){const n=t[r];if(!n)continue;const a=n.primitives;if(a)for(let t=0;t<a.length;t++){if(!a[t])continue;if(!a[t].attributes||a[t].attributes.NORMAL)continue;const r=a[t].material;if(!be(r)){const t=e.materials[r];if(!t)continue;t.extensions||(t.extensions={}),t.extensions.KHR_materials_unlit={}}}}}abortTileLoading(e,t){const r=this._requests[e.url];if(Array.isArray(r))for(let e=0;e<r.length;e++)r[e].abort();else r&&r.abort&&r.abort();delete this._requests[e.url],t(null)}_getModelCenter(e,t,r,n){const a=t&&t.RTC_CENTER||e.extensions&&e.extensions.CESIUM_RTC&&e.extensions.CESIUM_RTC.center;let o=Br;"X"===(r=r&&r.toUpperCase())?o=Fr:"Z"===r&&(o=Hr),e.extensions=e.extensions||{},e.extensions.CESIUM_RTC||(e.extensions.CESIUM_RTC={}),a&&(e.extensions.CESIUM_RTC.center=a),e.extensions.MAPTALKS_RTC={};const s={xmin:1/0,xmax:-1/0,ymin:1/0,ymax:-1/0,hmin:1/0,hmax:-1/0};_t(e,(e=>{if(!(e.attributes&&e.attributes.POSITION))return;const t=i($r);e.matrices&&an(t,e.matrices);const r=e.attributes.POSITION.array,l=e.attributes.POSITION.itemSize;c(t,o,t),n&&c(t,n,t),tn(r,l,a||Vr,t,s,e.compressUniforms)}));const l=rn(s);return{rtcCenter:a,modelCenter:l,upAxisTransform:o}}_convertCoordinates(e,t,r,n){const{modelCenter:a,upAxisTransform:o,rtcCenter:s}=this._getModelCenter(e,t,r),l=this._getProjCenter(a);e.extensions.MAPTALKS_RTC.projCenter=l,e.extensions.MAPTALKS_RTC.rtcCoord=e.extensions.CESIUM_RTC.rtcCoord=this._getCoordiate(a);const u=d([],a);n&&w(a,a,n),e.extensions.CESIUM_RTC.rtcCoord=this._getCoordiate(a),s||(_t(e,(e=>{if(e.attributes&&e.attributes.POSITION){const t=e.attributes.POSITION;if(t.array.buffer.projected&&t.array.buffer.projected[t.byteOffset])return;const r=i($r);e.matrices&&an(r,e.matrices),c(r,o,r);const n=function(e,t){var r=t[0],n=t[1],a=t[2],o=t[3],s=t[4],i=t[5],c=t[6],l=t[7],u=t[8],h=t[9],f=t[10],d=t[11],m=t[12],p=t[13],b=t[14],g=t[15],y=r*i-n*s,_=r*c-a*s,T=r*l-o*s,w=n*c-a*i,v=n*l-o*i,O=a*l-o*c,A=u*p-h*m,I=u*b-f*m,M=u*g-d*m,x=h*b-f*p,C=h*g-d*p,S=f*g-d*b,N=y*S-_*C+T*x+w*M-v*I+O*A;return N?(N=1/N,e[0]=(i*S-c*C+l*x)*N,e[1]=(a*C-n*S-o*x)*N,e[2]=(p*O-b*v+g*w)*N,e[3]=(f*v-h*O-d*w)*N,e[4]=(c*M-s*S-l*I)*N,e[5]=(r*S-a*M+o*I)*N,e[6]=(b*T-m*O-g*_)*N,e[7]=(u*O-f*T+d*_)*N,e[8]=(s*C-i*M+l*A)*N,e[9]=(n*M-r*C-o*A)*N,e[10]=(m*v-p*T+g*y)*N,e[11]=(h*T-u*v-d*y)*N,e[12]=(i*I-s*x-c*A)*N,e[13]=(r*x-n*I+a*A)*N,e[14]=(p*_-m*w-b*y)*N,e[15]=(u*w-h*_+f*y)*N,e):null}(Qr,r),a=[1/0,1/0,1/0],s=[-1/0,-1/0,-1/0];xt(t,(e=>{w(e,e,r),e[0]=e[0]-u[0],e[1]=e[1]-u[1],e[2]=e[2]-u[2],w(e,e,n),e[0]<a[0]&&(a[0]=e[0]),e[1]<a[1]&&(a[1]=e[1]),e[2]<a[2]&&(a[2]=e[2]),e[0]>s[0]&&(s[0]=e[0]),e[1]>s[1]&&(s[1]=e[1]),e[2]>s[2]&&(s[2]=e[2])})),t.min=a,t.max=s,t.array.buffer.projected||(t.array.buffer.projected={}),t.array.buffer.projected[t.byteOffset]=1}})),e.extensions.CESIUM_RTC.center=u)}_projectCoordinates(e,t,r,n){const{modelCenter:a,rtcCenter:o}=this._getModelCenter(e,t,r,n),s=this._getProjCenter(a);e.extensions.MAPTALKS_RTC.projCenter=s,e.extensions.MAPTALKS_RTC.rtcCoord=e.extensions.CESIUM_RTC.rtcCoord=this._getCoordiate(a),_t(e,(t=>{if(t.attributes&&t.attributes.POSITION){const a=this._needCreateMissedAttrs(t,e);if(a){const e=t.attributes.POSITION.array.length;(!Yr||Yr.length<e)&&(Yr=new Float32Array(e))}t.attributes.NORMAL&&this._transformNormalOrTangent(t.attributes.NORMAL,t.matrices,r),t.attributes.TANGENT&&this._transformNormalOrTangent(t.attributes.TANGENT,t.matrices,r);const{newPositions:s}=this._projVertices(t.attributes.POSITION,t.matrices,o,e.extensions.MAPTALKS_RTC,r,n,t.compressUniforms,a),{componentType:i}=t.attributes.POSITION;5126!==i&&(t.attributes.POSITION.array=new Float32Array(s))}}));for(const t in e.nodes){e.nodes[t].matrix=Hr}}_getProjCenter(e){const t=this.options.projection;"identity"===t?d(Kr,e):0===A(e)?m(Kr,0,0,-6378137):xe(Kr,e),Jt(Zr,Kr,t);const r=Kr[2],n=[];return n[0]=Zr[0],n[1]=Zr[1],n[2]=r,n}_transformNormalOrTangent(e,t,r){let n;n="Y"===r?Br:"X"===r?Fr:Hr;const a=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}([],n);if(an(a,t),l(a,Hr))return;const o=function(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}([],a),s=[];xt(e,(e=>(function(e,t,r){var n=t[0],a=t[1],o=t[2];e[0]=n*r[0]+a*r[3]+o*r[6],e[1]=n*r[1]+a*r[4]+o*r[7],e[2]=n*r[2]+a*r[5]+o*r[8]}(s,e,o),y(s,s),d(e,s),s)))}_projVertices(e,t,r,n,a,o,s,c){if(e.array.buffer.projected&&e.array.buffer.projected[e.byteOffset])return null;const u=i([]);an(u,t);const h=this.options.projection;a=a&&a.toUpperCase();const f=r;let d=null;"Y"===a?d=Br:"X"===a&&(d=Fr);let b=[0,0,0,1];const g=[0,0,0],y=[0,0],_=n.projCenter,T=Jt([],n.rtcCoord,"EPSG:3857"),v=o&&l(Hr,o),O=e.min=e.min||[],I=e.max=e.max||[];m(O,1/0,1/0,1/0),m(I,-1/0,-1/0,-1/0);const M=s||{},{decode_position_min:x,decode_position_normConstant:C}=M;let S=[0,0,0,0],N=1;x&&(S=x),C&&(N=C);const L=[];return xt(e,((t,r)=>{if(b[0]=t[0]*N+S[0],b[1]=t[1]*N+S[1],b[2]=t[2]*N+S[2],b=w(b,b,u),d&&(b=w(b,b,d)),f&&p(b,b,f),o&&!v&&(b=w(b,b,o)),0===A(b)?m(g,0,0,-6378137):xe(g,b),c){const e=Yr;Jt(y,g,h),e[3*r]=y[0]-T[0],e[3*r+1]=y[0]-T[1],e[3*r+2]=y[0]-T[2]}if(Jt(y,g,h),t instanceof Float32Array)t[0]=y[0]-_[0],t[1]=y[1]-_[1],t[2]=g[2]-_[2];else{const r=y[0]-_[0],n=y[1]-_[1],a=g[2]-_[2];5126!==e.componentType&&(L.push(r),L.push(n),L.push(a),L.push(t[3]))}return t[0]<O[0]&&(O[0]=t[0]),t[1]<O[1]&&(O[1]=t[1]),t[2]<O[2]&&(O[2]=t[2]),t[0]>I[0]&&(I[0]=t[0]),t[1]>I[1]&&(I[1]=t[1]),t[2]>I[2]&&(I[2]=t[2]),t})),e.array.buffer.projected||(e.array.buffer.projected={}),e.array.buffer.projected[e.byteOffset]=1,{projCenter:_,newPositions:L}}_getCoordiate(e){return 0===A(e)?m([],0,0,-6378137):xe([],e)}onRemove(){}_is4326(){return"EPSG:4326"===this.options.projection||"EPSG:4490"===this.options.projection}_needCreateMissedAttrs(e,t){if(!e.attributes.POSITION||function(e,t){const r=t.materials[e.material],n=r&&r.extensions&&r.extensions.KHR_materials_unlit;return n}(e,t))return!1;return!e.attributes.TANGENT}}const en=[];function tn(e,t,r,n,a,o){const s=o||{},{decode_position_min:i,decode_position_normConstant:c}=s;let l=[0,0,0,0],u=1;i&&(l=i),c&&(u=c);for(let o=0,s=e.length;o<s;o+=t){const{xmin:s,ymin:i,xmax:c,ymax:h,hmin:f,hmax:d}=a;m(en,e[o]*u+l[0],e[o+1]*u+l[1],e[o+2]*u+l[2]),w(en,en,n);const b=p(en,r,en);b[0]<s&&(a.xmin=b[0]),b[0]>c&&(a.xmax=b[0]),b[1]<i&&(a.ymin=b[1]),b[1]>h&&(a.ymax=b[1]),t>2&&(b[2]<f&&(a.hmin=b[2]),b[2]>d&&(a.hmax=b[2]))}}function rn(e){const{xmax:t,ymax:r,xmin:n,ymin:a,hmin:o,hmax:s}=e,i=[(n+t)/2,(a+r)/2,(o+s)/2];return t===-1/0&&(i[0]=0),r===-1/0&&(i[1]=0),s===-1/0&&(i[2]=0),isNaN(i[2])&&(i[2]=0),i}function nn(e,t){for(let r=0;r<t.length;r++)e.indexOf(t[r])<0&&e.push(t[r])}function an(e,t){const r=e;for(let e=t.length-1;e>=0;e--)c(r,t[e],r);return r}function on(e,t,r,n,a){if(t&&t>1)for(let r=0;r<e.length;r++)(r+1)%3!=0&&(e[r]*=t);let o,s;if(r&&n&&1===t)o=Math.min(...r),s=Math.max(...n);else{const{min:t,max:r}=function(e){let t=1/0,r=-1/0;for(let n=0;n<e.length;n++)e[n]>r&&(r=e[n]),e[n]<t&&(t=e[n]);return{min:t,max:r}}(e);o=t,s=r}return!function(e,t,r,n){for(let a=0;a<e.length;a++){const o=sn(cn(e[a],t,r),t,r);if(Math.abs(o-e[a])>Jr[n])return!1}return!0}(e,o,s,a)&&Jr[a]?null:function(e,t,r){const n=new Int16Array(e.length);for(let a=0;a<e.length;a++)n[a]=cn(e[a],t,r);return{array:n,range:[t,r]}}(e,o,s)}function sn(e,t,r){return((e>=32768?-(65536-e)/32768:e/32767)+1)*(r-t)/2+t}function cn(e,t,r){const n=2*(e-t)/(r-t)-1,a=Math.max(-1,Math.min(1,n));return a<0?32768*a:32767*a}function ln(e){return void 0===e.compressGeometry||e.compressGeometry}let un=0;class hn{constructor(e){this.workerId=e,this.workers={},this._callbacks={}}addLayer({actorId:e,mapId:t,layerId:r,params:n},a){if(this._getLayerById(t,r))return;const o=this._genKey(t,r),s=n.options;this.workers[o]=new Wr(r,s,((...t)=>this.send.call(this,e,...t)),a)}removeLayer({mapId:e,layerId:t},r){const n=this._getLayerById(e,t),a=this._genKey(e,t);delete this.workers[a],n&&n.onRemove(r)}loadTile({mapId:e,layerId:t,params:r},n){const a=this._getLayerById(e,t);a&&a.loadTile(r,n)}abortTileLoading({mapId:e,layerId:t,params:r},n){const a=this._getLayerById(e,t);a&&a.abortTileLoading(r,n)}receive(e){const t=e.callback,r=this._callbacks[t];delete this._callbacks[t],r&&e.error?r(new Error(e.error)):r&&r(null,e.data)}send(e,t,r,n,a){const o=a?\`${sW}e}-${sW}un++}\`:null;a&&(this._callbacks[o]=a),postMessage({type:"<request>",workerId:this.workerId,actorId:e,command:t,params:r,callback:String(o)},n||[])}_genKey(e,t){return\`${sW}e}-${sW}t}\`}_getLayerById(e,t){const r=this._genKey(e,t);return this.workers[r]}}e.initialize=function(){},e.onmessage=function(e,t){const r=e.data;this.dispatcher||(this.dispatcher=new hn(e.workerId)),"<response>"===e.type?this.dispatcher.workerId===e.workerId&&this.dispatcher.receive(e):this.dispatcher[r.command]({actorId:r.actorId,mapId:r.mapId,layerId:r.layerId,params:r.params},((e,r,n)=>{e&&404!==e.status&&204!==e.status&&console.error(e),e instanceof Error&&(e={message:e.message}),t(e,r,n)}))}}`;var lW={exports:{}},hW={exports:{}},cW=function(i){return!(!i||"string"==typeof i)&&(i instanceof Array||Array.isArray(i)||i.length>=0&&(i.splice instanceof Function||Object.getOwnPropertyDescriptor(i,i.length-1)&&"String"!==i.constructor.name))},uW=Array.prototype.concat,fW=Array.prototype.slice,dW=hW.exports=function(i){for(var g=[],m=0,_=i.length;m<_;m++){var b=i[m];cW(b)?g=uW.call(g,fW.call(b)):g.push(b)}return g};dW.wrap=function(i){return function(){return i(dW(arguments))}};var pW={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},gW=hW.exports,mW=Object.hasOwnProperty,AW=Object.create(null);for(var yW in pW)mW.call(pW,yW)&&(AW[pW[yW]]=yW);var _W=lW.exports={to:{},get:{}};function vW(i,g,m){return Math.min(Math.max(g,i),m)}function xW(i){var g=Math.round(i).toString(16).toUpperCase();return g.length<2?"0"+g:g}_W.get=function(i){var g,m;switch(i.substring(0,3).toLowerCase()){case"hsl":g=_W.get.hsl(i),m="hsl";break;case"hwb":g=_W.get.hwb(i),m="hwb";break;default:g=_W.get.rgb(i),m="rgb"}return g?{model:m,value:g}:null},_W.get.rgb=function(i){if(!i)return null;var g,m,_,b=[0,0,0,1];if(g=i.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)){for(_=g[2],g=g[1],m=0;m<3;m++){var T=2*m;b[m]=parseInt(g.slice(T,T+2),16)}_&&(b[3]=parseInt(_,16)/255)}else if(g=i.match(/^#([a-f0-9]{3,4})$/i)){for(_=(g=g[1])[3],m=0;m<3;m++)b[m]=parseInt(g[m]+g[m],16);_&&(b[3]=parseInt(_+_,16)/255)}else if(g=i.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)){for(m=0;m<3;m++)b[m]=parseInt(g[m+1],0);g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}else{if(!(g=i.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)))return(g=i.match(/^(\w+)$/))?"transparent"===g[1]?[0,0,0,0]:mW.call(pW,g[1])?((b=pW[g[1]])[3]=1,b):null:null;for(m=0;m<3;m++)b[m]=Math.round(2.55*parseFloat(g[m+1]));g[4]&&(b[3]=g[5]?.01*parseFloat(g[4]):parseFloat(g[4]))}for(m=0;m<3;m++)b[m]=vW(b[m],0,255);return b[3]=vW(b[3],0,1),b},_W.get.hsl=function(i){if(!i)return null;var g=i.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,vW(parseFloat(g[2]),0,100),vW(parseFloat(g[3]),0,100),vW(isNaN(m)?1:m,0,1)]}return null},_W.get.hwb=function(i){if(!i)return null;var g=i.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);if(g){var m=parseFloat(g[4]);return[(parseFloat(g[1])%360+360)%360,vW(parseFloat(g[2]),0,100),vW(parseFloat(g[3]),0,100),vW(isNaN(m)?1:m,0,1)]}return null},_W.to.hex=function(){var i=gW(arguments);return"#"+xW(i[0])+xW(i[1])+xW(i[2])+(i[3]<1?xW(Math.round(255*i[3])):"")},_W.to.rgb=function(){var i=gW(arguments);return i.length<4||1===i[3]?"rgb("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+")":"rgba("+Math.round(i[0])+", "+Math.round(i[1])+", "+Math.round(i[2])+", "+i[3]+")"},_W.to.rgb.percent=function(){var i=gW(arguments),g=Math.round(i[0]/255*100),m=Math.round(i[1]/255*100),_=Math.round(i[2]/255*100);return i.length<4||1===i[3]?"rgb("+g+"%, "+m+"%, "+_+"%)":"rgba("+g+"%, "+m+"%, "+_+"%, "+i[3]+")"},_W.to.hsl=function(){var i=gW(arguments);return i.length<4||1===i[3]?"hsl("+i[0]+", "+i[1]+"%, "+i[2]+"%)":"hsla("+i[0]+", "+i[1]+"%, "+i[2]+"%, "+i[3]+")"},_W.to.hwb=function(){var i=gW(arguments),g="";return i.length>=4&&1!==i[3]&&(g=", "+i[3]),"hwb("+i[0]+", "+i[1]+"%, "+i[2]+"%"+g+")"},_W.to.keyword=function(i){return AW[i.slice(0,3)]};var bW=lW.exports,wW={exports:{}},TW={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},SW={};for(var MW in TW)TW.hasOwnProperty(MW)&&(SW[TW[MW]]=MW);var CW=wW.exports={rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};for(var PW in CW)if(CW.hasOwnProperty(PW)){if(!("channels"in CW[PW]))throw new Error("missing channels property: "+PW);if(!("labels"in CW[PW]))throw new Error("missing channel labels property: "+PW);if(CW[PW].labels.length!==CW[PW].channels)throw new Error("channel and label counts mismatch: "+PW);var IW=CW[PW].channels,kW=CW[PW].labels;delete CW[PW].channels,delete CW[PW].labels,Object.defineProperty(CW[PW],"channels",{value:IW}),Object.defineProperty(CW[PW],"labels",{value:kW})}CW.rgb.hsl=function(i){var g,m,_=i[0]/255,b=i[1]/255,T=i[2]/255,P=Math.min(_,b,T),I=Math.max(_,b,T),H=I-P;return I===P?g=0:_===I?g=(b-T)/H:b===I?g=2+(T-_)/H:T===I&&(g=4+(_-b)/H),(g=Math.min(60*g,360))<0&&(g+=360),m=(P+I)/2,[g,100*(I===P?0:m<=.5?H/(I+P):H/(2-I-P)),100*m]},CW.rgb.hsv=function(i){var g,m,_,b,T,P=i[0]/255,I=i[1]/255,H=i[2]/255,W=Math.max(P,I,H),q=W-Math.min(P,I,H),$=function(i){return(W-i)/6/q+.5};return 0===q?b=T=0:(T=q/W,g=$(P),m=$(I),_=$(H),P===W?b=_-m:I===W?b=1/3+g-_:H===W&&(b=2/3+m-g),b<0?b+=1:b>1&&(b-=1)),[360*b,100*T,100*W]},CW.rgb.hwb=function(i){var g=i[0],m=i[1],_=i[2];return[CW.rgb.hsl(i)[0],1/255*Math.min(g,Math.min(m,_))*100,100*(_=1-1/255*Math.max(g,Math.max(m,_)))]},CW.rgb.cmyk=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255;return[100*((1-m-(g=Math.min(1-m,1-_,1-b)))/(1-g)||0),100*((1-_-g)/(1-g)||0),100*((1-b-g)/(1-g)||0),100*g]},CW.rgb.keyword=function(i){var g=SW[i];if(g)return g;var m,_,b,T=1/0;for(var P in TW)if(TW.hasOwnProperty(P)){var I=(_=i,b=TW[P],Math.pow(_[0]-b[0],2)+Math.pow(_[1]-b[1],2)+Math.pow(_[2]-b[2],2));I<T&&(T=I,m=P)}return m},CW.keyword.rgb=function(i){return TW[i]},CW.rgb.xyz=function(i){var g=i[0]/255,m=i[1]/255,_=i[2]/255;return[100*(.4124*(g=g>.04045?Math.pow((g+.055)/1.055,2.4):g/12.92)+.3576*(m=m>.04045?Math.pow((m+.055)/1.055,2.4):m/12.92)+.1805*(_=_>.04045?Math.pow((_+.055)/1.055,2.4):_/12.92)),100*(.2126*g+.7152*m+.0722*_),100*(.0193*g+.1192*m+.9505*_)]},CW.rgb.lab=function(i){var g=CW.rgb.xyz(i),m=g[0],_=g[1],b=g[2];return _/=100,b/=108.883,m=(m/=95.047)>.008856?Math.pow(m,1/3):7.787*m+16/116,[116*(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116)-16,500*(m-_),200*(_-(b=b>.008856?Math.pow(b,1/3):7.787*b+16/116))]},CW.hsl.rgb=function(i){var g,m,_,b,T,P=i[0]/360,I=i[1]/100,H=i[2]/100;if(0===I)return[T=255*H,T,T];g=2*H-(m=H<.5?H*(1+I):H+I-H*I),b=[0,0,0];for(var W=0;W<3;W++)(_=P+1/3*-(W-1))<0&&_++,_>1&&_--,b[W]=255*(T=6*_<1?g+6*(m-g)*_:2*_<1?m:3*_<2?g+(m-g)*(2/3-_)*6:g);return b},CW.hsl.hsv=function(i){var g=i[0],m=i[1]/100,_=i[2]/100,b=m,T=Math.max(_,.01);return m*=(_*=2)<=1?_:2-_,b*=T<=1?T:2-T,[g,100*(0===_?2*b/(T+b):2*m/(_+m)),(_+m)/2*100]},CW.hsv.rgb=function(i){var g=i[0]/60,m=i[1]/100,_=i[2]/100,b=Math.floor(g)%6,T=g-Math.floor(g),P=255*_*(1-m),I=255*_*(1-m*T),H=255*_*(1-m*(1-T));switch(_*=255,b){case 0:return[_,H,P];case 1:return[I,_,P];case 2:return[P,_,H];case 3:return[P,I,_];case 4:return[H,P,_];case 5:return[_,P,I]}},CW.hsv.hsl=function(i){var g,m,_,b=i[0],T=i[1]/100,P=i[2]/100,I=Math.max(P,.01);return _=(2-T)*P,m=T*I,[b,100*(m=(m/=(g=(2-T)*I)<=1?g:2-g)||0),100*(_/=2)]},CW.hwb.rgb=function(i){var g,m,_,b,T,P,I,H=i[0]/360,W=i[1]/100,q=i[2]/100,$=W+q;switch($>1&&(W/=$,q/=$),_=6*H-(g=Math.floor(6*H)),1&g&&(_=1-_),b=W+_*((m=1-q)-W),g){default:case 6:case 0:T=m,P=b,I=W;break;case 1:T=b,P=m,I=W;break;case 2:T=W,P=m,I=b;break;case 3:T=W,P=b,I=m;break;case 4:T=b,P=W,I=m;break;case 5:T=m,P=W,I=b}return[255*T,255*P,255*I]},CW.cmyk.rgb=function(i){var g=i[1]/100,m=i[2]/100,_=i[3]/100;return[255*(1-Math.min(1,i[0]/100*(1-_)+_)),255*(1-Math.min(1,g*(1-_)+_)),255*(1-Math.min(1,m*(1-_)+_))]},CW.xyz.rgb=function(i){var g,m,_,b=i[0]/100,T=i[1]/100,P=i[2]/100;return m=-.9689*b+1.8758*T+.0415*P,_=.0557*b+-.204*T+1.057*P,g=(g=3.2406*b+-1.5372*T+-.4986*P)>.0031308?1.055*Math.pow(g,1/2.4)-.055:12.92*g,m=m>.0031308?1.055*Math.pow(m,1/2.4)-.055:12.92*m,_=_>.0031308?1.055*Math.pow(_,1/2.4)-.055:12.92*_,[255*(g=Math.min(Math.max(0,g),1)),255*(m=Math.min(Math.max(0,m),1)),255*(_=Math.min(Math.max(0,_),1))]},CW.xyz.lab=function(i){var g=i[0],m=i[1],_=i[2];return m/=100,_/=108.883,g=(g/=95.047)>.008856?Math.pow(g,1/3):7.787*g+16/116,[116*(m=m>.008856?Math.pow(m,1/3):7.787*m+16/116)-16,500*(g-m),200*(m-(_=_>.008856?Math.pow(_,1/3):7.787*_+16/116))]},CW.lab.xyz=function(i){var g,m,_;g=i[1]/500+(m=(i[0]+16)/116),_=m-i[2]/200;var b=Math.pow(m,3),T=Math.pow(g,3),P=Math.pow(_,3);return m=b>.008856?b:(m-16/116)/7.787,g=T>.008856?T:(g-16/116)/7.787,_=P>.008856?P:(_-16/116)/7.787,[g*=95.047,m*=100,_*=108.883]},CW.lab.lch=function(i){var g,m=i[0],_=i[1],b=i[2];return(g=360*Math.atan2(b,_)/2/Math.PI)<0&&(g+=360),[m,Math.sqrt(_*_+b*b),g]},CW.lch.lab=function(i){var g,m=i[1];return g=i[2]/360*2*Math.PI,[i[0],m*Math.cos(g),m*Math.sin(g)]},CW.rgb.ansi16=function(i){var g=i[0],m=i[1],_=i[2],b=1 in arguments?arguments[1]:CW.rgb.hsv(i)[2];if(0===(b=Math.round(b/50)))return 30;var T=30+(Math.round(_/255)<<2|Math.round(m/255)<<1|Math.round(g/255));return 2===b&&(T+=60),T},CW.hsv.ansi16=function(i){return CW.rgb.ansi16(CW.hsv.rgb(i),i[2])},CW.rgb.ansi256=function(i){var g=i[0],m=i[1],_=i[2];return g===m&&m===_?g<8?16:g>248?231:Math.round((g-8)/247*24)+232:16+36*Math.round(g/255*5)+6*Math.round(m/255*5)+Math.round(_/255*5)},CW.ansi16.rgb=function(i){var g=i%10;if(0===g||7===g)return i>50&&(g+=3.5),[g=g/10.5*255,g,g];var m=.5*(1+~~(i>50));return[(1&g)*m*255,(g>>1&1)*m*255,(g>>2&1)*m*255]},CW.ansi256.rgb=function(i){if(i>=232){var g=10*(i-232)+8;return[g,g,g]}var m;return i-=16,[Math.floor(i/36)/5*255,Math.floor((m=i%36)/6)/5*255,m%6/5*255]},CW.rgb.hex=function(i){var g=(((255&Math.round(i[0]))<<16)+((255&Math.round(i[1]))<<8)+(255&Math.round(i[2]))).toString(16).toUpperCase();return"000000".substring(g.length)+g},CW.hex.rgb=function(i){var g=i.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!g)return[0,0,0];var m=g[0];3===g[0].length&&(m=m.split("").map((function(i){return i+i})).join(""));var _=parseInt(m,16);return[_>>16&255,_>>8&255,255&_]},CW.rgb.hcg=function(i){var g,m=i[0]/255,_=i[1]/255,b=i[2]/255,T=Math.max(Math.max(m,_),b),P=Math.min(Math.min(m,_),b),I=T-P;return g=I<=0?0:T===m?(_-b)/I%6:T===_?2+(b-m)/I:4+(m-_)/I+4,g/=6,[360*(g%=1),100*I,100*(I<1?P/(1-I):0)]},CW.hsl.hcg=function(i){var g,m=i[1]/100,_=i[2]/100,b=0;return(g=_<.5?2*m*_:2*m*(1-_))<1&&(b=(_-.5*g)/(1-g)),[i[0],100*g,100*b]},CW.hsv.hcg=function(i){var g=i[2]/100,m=i[1]/100*g,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},CW.hcg.rgb=function(i){var g=i[1]/100,m=i[2]/100;if(0===g)return[255*m,255*m,255*m];var _,b=[0,0,0],T=i[0]/360%1*6,P=T%1,I=1-P;switch(Math.floor(T)){case 0:b[0]=1,b[1]=P,b[2]=0;break;case 1:b[0]=I,b[1]=1,b[2]=0;break;case 2:b[0]=0,b[1]=1,b[2]=P;break;case 3:b[0]=0,b[1]=I,b[2]=1;break;case 4:b[0]=P,b[1]=0,b[2]=1;break;default:b[0]=1,b[1]=0,b[2]=I}return[255*(g*b[0]+(_=(1-g)*m)),255*(g*b[1]+_),255*(g*b[2]+_)]},CW.hcg.hsv=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g),_=0;return m>0&&(_=g/m),[i[0],100*_,100*m]},CW.hcg.hsl=function(i){var g=i[1]/100,m=i[2]/100*(1-g)+.5*g,_=0;return m>0&&m<.5?_=g/(2*m):m>=.5&&m<1&&(_=g/(2*(1-m))),[i[0],100*_,100*m]},CW.hcg.hwb=function(i){var g=i[1]/100,m=g+i[2]/100*(1-g);return[i[0],100*(m-g),100*(1-m)]},CW.hwb.hcg=function(i){var g=1-i[2]/100,m=g-i[1]/100,_=0;return m<1&&(_=(g-m)/(1-m)),[i[0],100*m,100*_]},CW.apple.rgb=function(i){return[i[0]/65535*255,i[1]/65535*255,i[2]/65535*255]},CW.rgb.apple=function(i){return[i[0]/255*65535,i[1]/255*65535,i[2]/255*65535]},CW.gray.rgb=function(i){return[i[0]/100*255,i[0]/100*255,i[0]/100*255]},CW.gray.hsl=CW.gray.hsv=function(i){return[0,0,i[0]]},CW.gray.hwb=function(i){return[0,100,i[0]]},CW.gray.cmyk=function(i){return[0,0,0,i[0]]},CW.gray.lab=function(i){return[i[0],0,0]},CW.gray.hex=function(i){var g=255&Math.round(i[0]/100*255),m=((g<<16)+(g<<8)+g).toString(16).toUpperCase();return"000000".substring(m.length)+m},CW.rgb.gray=function(i){return[(i[0]+i[1]+i[2])/3/255*100]};var OW=wW.exports,EW=OW;function RW(i,g){return function(m){return g(i(m))}}function LW(i,g){for(var m=[g[i].parent,i],_=EW[g[i].parent][i],b=g[i].parent;g[b].parent;)m.unshift(g[b].parent),_=RW(EW[g[b].parent][b],_),b=g[b].parent;return _.conversion=m,_}var DW=OW,FW=function(i){for(var g=function(i){var g=function(){for(var i={},g=Object.keys(EW),m=g.length,_=0;_<m;_++)i[g[_]]={distance:-1,parent:null};return i}(),m=[i];for(g[i].distance=0;m.length;)for(var _=m.pop(),b=Object.keys(EW[_]),T=b.length,P=0;P<T;P++){var I=b[P],H=g[I];-1===H.distance&&(H.distance=g[_].distance+1,H.parent=_,m.unshift(I))}return g}(i),m={},_=Object.keys(g),b=_.length,T=0;T<b;T++){var P=_[T];null!==g[P].parent&&(m[P]=LW(P,g))}return m},NW={};Object.keys(DW).forEach((function(i){NW[i]={},Object.defineProperty(NW[i],"channels",{value:DW[i].channels}),Object.defineProperty(NW[i],"labels",{value:DW[i].labels});var g=FW(i);Object.keys(g).forEach((function(m){var _=g[m];NW[i][m]=function(i){var g=function(g){if(null==g)return g;arguments.length>1&&(g=Array.prototype.slice.call(arguments));var m=i(g);if("object"==typeof m)for(var _=m.length,b=0;b<_;b++)m[b]=Math.round(m[b]);return m};return"conversion"in i&&(g.conversion=i.conversion),g}(_),NW[i][m].raw=function(i){var g=function(g){return null==g?g:(arguments.length>1&&(g=Array.prototype.slice.call(arguments)),i(g))};return"conversion"in i&&(g.conversion=i.conversion),g}(_)}))}));var HW=bW,BW=NW,zW=[].slice,VW=["keyword","gray","hex"],UW={};Object.keys(BW).forEach((function(i){UW[zW.call(BW[i].labels).sort().join("")]=i}));var GW={};function jW(i,g){if(!(this instanceof jW))return new jW(i,g);if(g&&g in VW&&(g=null),g&&!(g in BW))throw new Error("Unknown model: "+g);var m,_;if(null==i)this.model="rgb",this.color=[0,0,0],this.valpha=1;else if(i instanceof jW)this.model=i.model,this.color=i.color.slice(),this.valpha=i.valpha;else if("string"==typeof i){var b=HW.get(i);if(null===b)throw new Error("Unable to parse color from string: "+i);this.model=b.model,this.color=b.value.slice(0,_=BW[this.model].channels),this.valpha="number"==typeof b.value[_]?b.value[_]:1}else if(i.length){this.model=g||"rgb";var T=zW.call(i,0,_=BW[this.model].channels);this.color=XW(T,_),this.valpha="number"==typeof i[_]?i[_]:1}else if("number"==typeof i)i&=16777215,this.model="rgb",this.color=[i>>16&255,i>>8&255,255&i],this.valpha=1;else{this.valpha=1;var P=Object.keys(i);"alpha"in i&&(P.splice(P.indexOf("alpha"),1),this.valpha="number"==typeof i.alpha?i.alpha:0);var I=P.sort().join("");if(!(I in UW))throw new Error("Unable to parse color from object: "+JSON.stringify(i));this.model=UW[I];var H=BW[this.model].labels,W=[];for(m=0;m<H.length;m++)W.push(i[H[m]]);this.color=XW(W)}if(GW[this.model])for(_=BW[this.model].channels,m=0;m<_;m++){var q=GW[this.model][m];q&&(this.color[m]=q(this.color[m]))}this.valpha=Math.max(0,Math.min(1,this.valpha)),Object.freeze&&Object.freeze(this)}function WW(i,g,m){return(i=Array.isArray(i)?i:[i]).forEach((function(i){(GW[i]||(GW[i]=[]))[g]=m})),i=i[0],function(_){var b;return arguments.length?(m&&(_=m(_)),(b=this[i]()).color[g]=_,b):(b=this[i]().color[g],m&&(b=m(b)),b)}}function qW(i){return function(g){return Math.max(0,Math.min(i,g))}}function XW(i,g){for(var m=0;m<g;m++)"number"!=typeof i[m]&&(i[m]=0);return i}jW.prototype={toString:function(){return this.string()},toJSON:function(){return this[this.model]()},string:function(i){var g=this.model in HW.to?this:this.rgb(),m=1===(g=g.round("number"==typeof i?i:1)).valpha?g.color:g.color.concat(this.valpha);return HW.to[g.model](m)},percentString:function(i){var g=this.rgb().round("number"==typeof i?i:1),m=1===g.valpha?g.color:g.color.concat(this.valpha);return HW.to.rgb.percent(m)},array:function(){return 1===this.valpha?this.color.slice():this.color.concat(this.valpha)},object:function(){for(var i={},g=BW[this.model].channels,m=BW[this.model].labels,_=0;_<g;_++)i[m[_]]=this.color[_];return 1!==this.valpha&&(i.alpha=this.valpha),i},unitArray:function(){var i=this.rgb().color;return i[0]/=255,i[1]/=255,i[2]/=255,1!==this.valpha&&i.push(this.valpha),i},unitObject:function(){var i=this.rgb().object();return i.r/=255,i.g/=255,i.b/=255,1!==this.valpha&&(i.alpha=this.valpha),i},round:function(i){return i=Math.max(i||0,0),new jW(this.color.map(function(i){return function(g){return function(i,g){return Number(i.toFixed(g))}(g,i)}}(i)).concat(this.valpha),this.model)},alpha:function(i){return arguments.length?new jW(this.color.concat(Math.max(0,Math.min(1,i))),this.model):this.valpha},red:WW("rgb",0,qW(255)),green:WW("rgb",1,qW(255)),blue:WW("rgb",2,qW(255)),hue:WW(["hsl","hsv","hsl","hwb","hcg"],0,(function(i){return(i%360+360)%360})),saturationl:WW("hsl",1,qW(100)),lightness:WW("hsl",2,qW(100)),saturationv:WW("hsv",1,qW(100)),value:WW("hsv",2,qW(100)),chroma:WW("hcg",1,qW(100)),gray:WW("hcg",2,qW(100)),white:WW("hwb",1,qW(100)),wblack:WW("hwb",2,qW(100)),cyan:WW("cmyk",0,qW(100)),magenta:WW("cmyk",1,qW(100)),yellow:WW("cmyk",2,qW(100)),black:WW("cmyk",3,qW(100)),x:WW("xyz",0,qW(100)),y:WW("xyz",1,qW(100)),z:WW("xyz",2,qW(100)),l:WW("lab",0,qW(100)),a:WW("lab",1),b:WW("lab",2),keyword:function(i){return arguments.length?new jW(i):BW[this.model].keyword(this.color)},hex:function(i){return arguments.length?new jW(i):HW.to.hex(this.rgb().round().color)},rgbNumber:function(){var i=this.rgb().color;return(255&i[0])<<16|(255&i[1])<<8|255&i[2]},luminosity:function(){for(var i=this.rgb().color,g=[],m=0;m<i.length;m++){var _=i[m]/255;g[m]=_<=.03928?_/12.92:Math.pow((_+.055)/1.055,2.4)}return.2126*g[0]+.7152*g[1]+.0722*g[2]},contrast:function(i){var g=this.luminosity(),m=i.luminosity();return g>m?(g+.05)/(m+.05):(m+.05)/(g+.05)},level:function(i){var g=this.contrast(i);return g>=7.1?"AAA":g>=4.5?"AA":""},isDark:function(){var i=this.rgb().color;return(299*i[0]+587*i[1]+114*i[2])/1e3<128},isLight:function(){return!this.isDark()},negate:function(){for(var i=this.rgb(),g=0;g<3;g++)i.color[g]=255-i.color[g];return i},lighten:function(i){var g=this.hsl();return g.color[2]+=g.color[2]*i,g},darken:function(i){var g=this.hsl();return g.color[2]-=g.color[2]*i,g},saturate:function(i){var g=this.hsl();return g.color[1]+=g.color[1]*i,g},desaturate:function(i){var g=this.hsl();return g.color[1]-=g.color[1]*i,g},whiten:function(i){var g=this.hwb();return g.color[1]+=g.color[1]*i,g},blacken:function(i){var g=this.hwb();return g.color[2]+=g.color[2]*i,g},grayscale:function(){var i=this.rgb().color,g=.3*i[0]+.59*i[1]+.11*i[2];return jW.rgb(g,g,g)},fade:function(i){return this.alpha(this.valpha-this.valpha*i)},opaquer:function(i){return this.alpha(this.valpha+this.valpha*i)},rotate:function(i){var g=this.hsl(),m=g.color[0];return m=(m=(m+i)%360)<0?360+m:m,g.color[0]=m,g},mix:function(i,g){if(!i||!i.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof i);var m=i.rgb(),_=this.rgb(),b=void 0===g?.5:g,T=2*b-1,P=m.alpha()-_.alpha(),I=((T*P===-1?T:(T+P)/(1+T*P))+1)/2,H=1-I;return jW.rgb(I*m.red()+H*_.red(),I*m.green()+H*_.green(),I*m.blue()+H*_.blue(),m.alpha()*b+_.alpha()*(1-b))}},Object.keys(BW).forEach((function(i){if(-1===VW.indexOf(i)){var g=BW[i].channels;jW.prototype[i]=function(){if(this.model===i)return new jW(this);if(arguments.length)return new jW(arguments,i);var m,_="number"==typeof arguments[g]?g:this.valpha;return new jW((m=BW[this.model][i].raw(this.color),Array.isArray(m)?m:[m]).concat(_),i)},jW[i]=function(m){return"number"==typeof m&&(m=XW(zW.call(arguments),g)),new jW(m,i)}}}));var ZW=function(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}(jW);function $W(i){return null==i}function YW(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];for(const g in m)i[g]=m[g]}return i}function QW(i){return null!=i&&("function"==typeof i||null!==i.constructor&&i.constructor===Function)}function JW(i){return"object"==typeof i&&!!i}function KW(i){return"number"==typeof i&&!isNaN(i)}function eq(i){return i*Math.PI/180}function tq(i){return i/Math.PI*180}function nq(i){let g=document.createElement("a");return g.href=i,i=g.href,g=null,i}function rq(i){return Math.sign?Math.sign(i):0===(i=+i)||isNaN(i)?Number(i):i>0?1:-1}const iq=[1,1,1,1,2,2,3,0];function oq(i){const g=i.length;let m="";for(let _=0;_<g;){let b=i[_++];if(128&b){let m=iq[b>>3&7];if(!(64&b)||!m||_+m>g)return null;for(b&=63>>m;m>0;m-=1){const g=i[_++];if(128!=(192&g))return null;b=b<<6|63&g}}m+=String.fromCharCode(b)}return m}function sq(i,g,m){return i[3*m]=g[0],i[3*m+1]=g[1],i[3*m+2]=g[2],i}function aq(i){return i.flat?i.flat(1/0):i.reduce(((i,g)=>i.concat(g)),[])}function lq(i){return i<256?Uint8Array:i<65536?Uint16Array:Uint32Array}function hq(i){return 0===i.indexOf("data:")}function cq(i){const g=i.indexOf("base64,"),m=i.substring(g+7),_=window.atob(m),b=_.length,T=new Uint8Array(b);for(let i=0;i<b;i++)T[i]=_.charCodeAt(i);return T.buffer}function uq(i){for(let g=1;g<arguments.length;g++){const m=arguments[g];if(m)for(let g=0,_=m.length;g<_;g++)i.push(m[g])}return i.length}const fq={};function dq(i,g){if(!Array.isArray(g)){g=fq[g]=fq[g]||ZW(g).array().map((i=>i/255))}for(let m=0;m<g.length;m++)i[m]=g[m];return 3===g.length&&(i[3]=1),i}var pq=Object.freeze({__proto__:null,base64URLToArrayBuffer:cq,extend:YW,flatArr:aq,getAbsoluteURL:nq,getBatchIdArrayType:lq,isBase64:hq,isFunction:QW,isNil:$W,isNumber:KW,isObject:JW,normalizeColor:dq,pushIn:uq,setColumn3:sq,sign:rq,stringFromUTF8Array:oq,toDegree:tq,toRadian:eq});function gq(i){return-1===i.indexOf("http://")&&-1===i.indexOf("https://")&&-1===i.indexOf("file://")}function mq(i){return(i=i||{}).referrerPolicy=i.referrerPolicy||"origin",i.referrer=window&&window.location.href,i}const Aq=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")},yq=Aq(),_q=yq.gl_trans__coders=yq.gl_trans__coders||{};
/*!
   * @maptalks/gl v0.110.0
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.com
   */function vq(){return Aq().maptalks_gltf_loader}_q.inject=function(i){const g=i.toString(),m=g.indexOf("{")+1,_=g.substring(0,m),b=yq.gl_trans__coders=yq.gl_trans__coders||{};let T=`${_}\n    const _____getGlobal = ${Aq.toString()};\n    const g___lobals = _____getGlobal()\n    const tran_____scoders = g___lobals['gl_trans__coders'] = g___lobals['gl_trans__coders'] || {};`;for(const i in b)"inject"!==i&&"getTranscoder"!==i&&"registerTranscoder"!==i&&(T+='tran_____scoders["'+i+'"] ='+b[i].toString()+"\n;");return T+="\n("+Aq().maptalks_gltf_loader_bundle.toString()+")({});\n",T+="\n"+g.substring(_.length),T},_q.registerTranscoder=function(i,g){_q[i]=g},_q.getTranscoder=function(i){return _q[i]};const xq="undefined"==typeof document?null:document.createElement("canvas");class ze extends Um.Actor{constructor(i,g,m){super(i),this.mapId=g,this._supportNPOT=m}initialize(i){i(null)}loadTile(i,g,m){let _=null;g&&g.arraybuffer&&(_=[g.arraybuffer]);this.send({mapId:this.mapId,layerId:i,command:"loadTile",params:g},_,m)}abortTileLoading(i,g,m){this.broadcast({mapId:this.mapId,layerId:i,command:"abortTileLoading",params:{url:g}},null,m)}addLayer(i,g,m){this.broadcast({actorId:this.actorId,mapId:this.mapId,layerId:i,command:"addLayer",params:{options:g}},null,m)}removeLayer(i,g){this.broadcast({mapId:this.mapId,layerId:i,command:"removeLayer"},null,g)}requestImage({url:i},g){const m=new Image;m.onload=()=>{if(!this.isActive())return;if(!xq)return void g(new Error("There is no canvas to draw image!"));const i=this._supportNPOT?m:function(i){if(bq(i.width)&&bq(i.height))return i;let g=i.width,m=i.height;bq(g)||(g=wq(g)),bq(m)||(m=wq(m));const _=document.createElement("canvas");_.width=g,_.height=m,_.getContext("2d").drawImage(i,0,0,g,m);const b=i.src,T=b.lastIndexOf("/")+1,P=b.substring(T);return console.warn(`Texture(${P})'s size is not power of two, resize from (${i.width}, ${i.height}) to (${g}, ${m})`),_}(m);xq.width=i.width,xq.height=i.height;const _=xq.getContext("2d",{willReadFrequently:!0});_.drawImage(i,0,0,i.width,i.height);const b=_.getImageData(0,0,i.width,i.height),T={width:i.width,height:i.height,data:new Uint8Array(b.data)};g(null,T,[T.data.buffer])},m.onerror=function(i){g(i)},m.src=i}}function bq(i){return!(i&i-1)&&0!==i}function wq(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}const{GLTFLoader:Tq}=vq();function Sq(i,g){if(i.scenes&&i.scenes.length)for(let m=0,_=i.scenes.length;m<_;m++){const _=i.scenes[m].nodes;for(let m=0,b=_.length;m<b;m++){Eq(_[m],[],i,g)}}}const Mq=[],Cq=[],Pq=[],Iq=[0,0,0],kq=$y([]),Oq=[1,1,1];function Eq(i,g,m,_){const b=g.slice(0);if(i.matrix)b.push(i.matrix);else if(i.rotation||i.translation||i.scale){const g=wA(Mq,i.translation||Iq),m=EA(Cq,i.rotation||kq),_=TA(Pq,i.scale||Oq);_A(_,m,_);const T=_A([],g,_);b.push(T)}if(i.children&&i.children.length)for(let g=0,T=i.children.length;g<T;g++)Eq(i.children[g],b,m,_);if(void 0!==i.mesh){const g=i.mesh,T=m.meshes[g];if(T){const i=b.slice(0),P=T.primitives;for(let b=0,T=P.length;b<T;b++){const T=P[b];T&&(T.matrices=i,_(T,g,b,m))}}}}function Rq(i,g,m){let{byteOffset:_,byteStride:b}=g;const{componentType:T,itemSize:P}=g,I=g.array.buffer,H=T?Tq.getTypedArrayCtor(T):g.array.constructor;if(_=void 0===_?g.array.byteOffset:_,b=b||0,!b||b===P*H.BYTES_PER_ELEMENT&&_%H.BYTES_PER_ELEMENT===0){const g=new H(I,_+m*P*H.BYTES_PER_ELEMENT,P);return i.set(g),i}b||(b=P*H.BYTES_PER_ELEMENT);const W=new Uint8Array(I,b*m+_,P*H.BYTES_PER_ELEMENT);return new Uint8Array(i.buffer).set(W),i}function Lq(i,g,m,_){i[4*g]=m[_],i[4*g+1]=m[_+4],i[4*g+2]=m[_+8],i[4*g+3]=m[_+12]}var Dq="#include <gl2_vert>\n\nconst float SHIFT_RIGHT_11 = 1.0 / 2048.0;\n\nconst float SHIFT_RIGHT_5 = 1.0 / 32.0;\n\nconst float SHIFT_LEFT_11 = 2048.0;\n\nconst float SHIFT_LEFT_5 = 32.0;\n\nconst float NORMALIZE_6 = 1.0 / 64.0;\n\nconst float NORMALIZE_5 = 1.0 / 32.0;\n\n\n\n#ifdef HAS_POSITION\n\n    attribute vec3 POSITION;\n\n#endif\n\n\n\n#if defined(HAS_RGB)\n\n    attribute vec3 RGB;\n\n#elif defined(HAS_RGBA)\n\n    attribute vec4 RGBA;\n\n#elif defined(HAS_RGB565)\n\n    attribute float RGB565;\n\n#endif\n\n\n\nuniform vec4 pointColor;\n\nuniform float pointSize;\n\n\n\nuniform mat4 projViewModelMatrix;\n\nuniform float pointOpacity;\n\n\n\nvarying vec4 vColor;\n\n\n\n#ifdef HAS_NORMAL\n\n    #ifdef HAS_NORMAL_OCT16P\n\n        attribute vec2 NORMAL_OCT16P;\n\n        float signNotZero(float value) {\n\n            return value >= 0.0 ? 1.0 : -1.0;\n\n        }\n\n        vec2 signNotZero(vec2 value) {\n\n            return vec2(signNotZero(value.x), signNotZero(value.y));\n\n        }\n\n        vec3 octDecode(vec2 encoded, float range) {\n\n            if (encoded.x == 0.0 && encoded.y == 0.0) {\n\n                return vec3(0.0, 0.0, 0.0);\n\n            }\n\n            encoded = encoded / range * 2.0 - 1.0;\n\n            vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n\n            if (v.z < 0.0) {\n\n                v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n\n            }\n\n            return normalize(v);\n\n        }\n\n        vec3 octDecode(vec2 encoded) {\n\n            return octDecode(encoded, 255.0);\n\n        }\n\n    #else\n\n        attribute vec3 NORMAL;\n\n    #endif\n\n    uniform vec3 lightDir;\n\n    uniform mat3 modelNormalMatrix;\n\n    uniform mat4 positionMatrix;\n\n    float getLambertDiffuse(vec3 lightDir, vec3 normal) {\n\n        return max(dot(-lightDir, normal), 0.0);\n\n    }\n\n#endif\n\n#ifdef PICKING_MODE\n\n    #include <fbo_picking_vert>\n\n#endif\n\n#include <draco_decode_vert>\n\nvoid main() {\n\n    #ifdef HAS_POSITION\n\n        vec3 localPos = decode_getPosition(POSITION);\n\n    #endif\n\n    gl_Position = projViewModelMatrix * vec4(localPos, 1.0);\n\n    gl_PointSize = pointSize;\n\n\n\n    #ifdef PICKING_MODE\n\n        fbo_picking_setData(gl_Position.w, true);\n\n    #else\n\n        #if defined(HAS_RGB)\n\n            vColor = vec4(RGB / 255.0, 1.0) * pointOpacity;\n\n        #elif defined(HAS_RGBA)\n\n            vColor = RGBA / 255.0 * pointOpacity;\n\n        #elif defined(HAS_RGB565)\n\n            float compressed = RGB565;\n\n            float r = floor(compressed * SHIFT_RIGHT_11);\n\n            compressed -= r * SHIFT_LEFT_11;\n\n            float g = floor(compressed * SHIFT_RIGHT_5);\n\n            compressed -= g * SHIFT_LEFT_5;\n\n            float b = compressed;\n\n            vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5);\n\n            vColor = vec4(rgb, 1.0);\n\n        #else\n\n            vColor = pointColor;\n\n        #endif\n\n\n\n        #ifdef HAS_NORMAL\n\n            mat3 positionNormalMatrix = mat3(positionMatrix);\n\n            mat3 normalMatrix = modelNormalMatrix * positionNormalMatrix;\n\n            #ifdef HAS_NORMAL_OCT16P\n\n                vec3 localNormal = octDecode(NORMAL_OCT16P);\n\n            #else\n\n                vec3 localNormal = NORMAL;\n\n            #endif\n\n            vec3 normal = normalize(normalMatrix * localNormal);\n\n            float colorStrength = getLambertDiffuse(lightDir, normal);\n\n            colorStrength = max(colorStrength, 0.5);\n\n            vColor *= colorStrength;\n\n        #endif\n\n    #endif\n\n\n\n\n\n\n\n\n\n}\n\n";const Fq=new Array(3),Nq=new Array(3),Hq=[40680631590769,40680631590769,40408299984661.445];function Bq(i,g,m,_){const b=Hq,T=Math.cos(m);Fq[0]=T*Math.cos(g),Fq[1]=T*Math.sin(g),Fq[2]=Math.sin(m),Yq(Fq,Fq),$A(Nq,b,Fq);const P=Math.sqrt(ry(Fq,Nq));var I,H,W;return(I=Nq)[0]=(H=Nq)[0]/(W=P),I[1]=H[1]/W,I[2]=H[2]/W,QA(Fq,Fq,_),XA(i,Nq,Fq)}const zq=[1/6378137,1/6378137,1/6356752.314245179],Vq=[1/40680631590769,1/40680631590769,1/40408299984661.445],Uq=new Array(3),Gq=new Array(3),jq=new Array(3);function Wq(i,g){const m=Vq,_=function(i,g,m,_){const b=g[0],T=g[1],P=g[2],I=m[0],H=m[1],W=m[2],q=b*b*I*I,$=T*T*H*H,ye=P*P*W*W,Re=q+$+ye,Be=Math.sqrt(1/Re),Ge=QA(qq,g,Be);if(Re<.1)return isFinite(Be)?Ge:void 0;const je=_[0],Xe=_[1],Ze=_[2],Ye=Xq;Ye[0]=Ge[0]*je*2,Ye[1]=Ge[1]*Xe*2,Ye[2]=Ge[2]*Ze*2;let Qe,Je,Ke,et,tt,at,ht,gt,yt,vt,xt,bt=(1-Be)*$q(g)/(.5*$q(Ye)),Tt=0;do{bt-=Tt,Ke=1/(1+bt*je),et=1/(1+bt*Xe),tt=1/(1+bt*Ze),at=Ke*Ke,ht=et*et,gt=tt*tt,yt=at*Ke,vt=ht*et,xt=gt*tt,Qe=q*at+$*ht+ye*gt-1,Je=q*yt*je+$*vt*Xe+ye*xt*Ze,Tt=Qe/(-2*Je)}while(Math.abs(Qe)>Zq);return i[0]=b*Ke,i[1]=T*et,i[2]=P*tt,i}(Uq,g,zq,m);let b=uy(Gq,_,m);b=Yq(b,b);const T=cy(jq,g,_),P=Math.atan2(b[1],b[0]),I=Math.asin(b[2]),H=rq(ry(T,g))*$q(T);return i[0]=tq(P),i[1]=tq(I),i[2]=H,i}const qq=new Array(3),Xq=new Array(3),Zq=1e-12;function $q(i){return GA(i)}function Yq(i,g){const m=g[0],_=g[1],b=g[2];let T=m*m+_*_+b*b;return T>0&&(T=Math.sqrt(T),i[0]=g[0]/T,i[1]=g[1]/T,i[2]=g[2]/T),i}function Qq(i,g){return $A(g,i,Vq),ny(g,g)}function Jq(i,g){const m=i[0],_=i[1],b=Math.cos(_),T=b*Math.cos(m),P=b*Math.sin(m),I=Math.sin(_);return g.x=T,g.y=P,g.z=I,ny(g,g)}var Kq=Object.freeze({__proto__:null,cartesian3ToDegree:Wq,geodeticSurfaceNormal:Qq,geodeticSurfaceNormalCartographic:Jq,normalizeCartesian:Yq,radianToCartesian3:Bq});function eX(i,g,m,_){m=m||0,_=_||m;const b=Math.abs(i-g);return b<=_||b<=m*Math.max(Math.abs(i),Math.abs(g))}function tX(i,g){let m="";for(let _=0;_<4;_++){const b=i.getUint8(g+_);m+=String.fromCharCode(b)}return m}const nX="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null;function rX(i,g,m){const _=new Uint8Array(i,g,m);return nX?JSON.parse(nX.decode(_)):JSON.parse(oq(_))}function iX(i,g,m){const _=new Uint8Array(i,g,m);return nX?JSON.parse(nX.decode(_)):JSON.parse(oq(_))}function oX(i,g,m){return{offset:g,byteLength:m}}function sX(i,g,m,_){const{byteOffset:b,componentType:T,type:P}=i,{ctor:I,type:H}=fX(T||"UNSIGNED_SHORT"),W=cX(P);return{byteStride:0,byteOffset:b+m,itemSize:W,count:_*W,componentType:H,array:new I(g,m+b,_*W)}}function aX(i,g,m,_){const b=sX(i,g,m,_);return b.array.buffer.byteLength!==g.byteLength&&(b.array=b.array.slice()),b}function lX(i,g,m,_){const{byteOffset:b,componentType:T,type:P}=i,{ctor:I}=fX(T||"UNSIGNED_SHORT"),H=cX(P),W=new I(g,b,m*H);return 1===H?W[_]:W.subarray(_*H,_*H+H)}const hX={SCALAR:1,VEC2:2,VEC3:3,VEC4:4};function cX(i){return i?hX[i]:1}const uX={BYTE:{ctor:Int8Array,type:5120,name:"Int8Array"},UNSIGNED_BYTE:{ctor:Uint8Array,type:5121,name:"Uint8Array"},SHORT:{ctor:Int16Array,type:5122,name:"Int16Array"},UNSIGNED_SHORT:{ctor:Uint16Array,type:5123,name:"Uint16Array"},INT:{ctor:Int32Array,type:5124,name:"Int32Array"},UNSIGNED_INT:{ctor:Uint32Array,type:5125,name:"Uint32Array"},FLOAT:{ctor:Float32Array,type:5126,name:"Float32Array"},DOUBLE:{ctor:Float64Array,type:5126,name:"Float64Array"}};function fX(i){return uX[i]}function dX(i){for(const g in uX)if(i===uX[g].ctor)return uX[g].type;throw new Error("unrecognized ctor:"+i)}function pX(i,g,m,_){const b=i,T=g.length/3;for(let i=0;i<T;i++)b[3*i]=g[3*i]/65535*_[0]+m[0],b[3*i+1]=g[3*i+1]/65535*_[1]+m[1],b[3*i+2]=g[3*i+2]/65535*_[2]+m[2];return b}function gX(i,g,m){const _=i.getUint32(12,!0),b=i.getUint32(16,!0),T=i.getUint32(20,!0),P=i.getUint32(24,!0),I=i.buffer;let H,W={},q={},$=null;_>0&&(W=rX(I,g,_),g+=_),b>0&&(H=function(i,g,m){return{offset:g,byteLength:m}}(0,g,b),g+=b),T>0&&(q=iX(I,g,T),g+=T);const ye=oX(0,g,P);return $=I.slice(ye.offset,ye.offset+ye.byteLength),m.push($),{featureTable:W,featureTableBin:H,batchTable:q,batchTableBin:$}}const mX={up:{south:"east",north:"west",west:"south",east:"north"},down:{south:"west",north:"east",west:"north",east:"south"},south:{up:"west",down:"east",west:"down",east:"up"},north:{up:"east",down:"west",west:"up",east:"down"},west:{up:"north",down:"south",north:"down",south:"up"},east:{up:"south",down:"north",north:"up",south:"down"}},AX={north:[-1,0,0],east:[0,1,0],up:[0,0,1],south:[1,0,0],west:[0,-1,0],down:[0,0,-1]},yX={},_X={east:[],north:[],up:[],west:[],south:[],down:[]};let vX=[],xX=[],bX=[];const wX=[0,0,0];function TX(i,g,m){return m[0]=i[0],m[1]=i[1],m[2]=i[2],m[3]=i[3],m[4]=i[4],m[5]=i[5],m[6]=i[6],m[7]=i[7],m[8]=i[8],m[9]=i[9],m[10]=i[10],m[11]=i[11],m[12]=g[0],m[13]=g[1],m[14]=g[2],m[15]=i[15],m}const SX=function(i,g){const m=mX[i][g];let _;const b=i+g;return yX[b]?_=yX[b]:(_=function(_,b,T){if(hy(_,wX))WA(vX,AX[i]),WA(xX,AX[g]),WA(bX,AX[m]);else if(eX(_[0],0,1e-14)&&eX(_[1],0,1e-14)){const b=rq(_[2]);WA(vX,AX[i]),WA(xX,AX[g]),QA(xX,xX,b),WA(bX,AX[m]),QA(bX,bX,b)}else{Qq(_,_X.up);const b=_X.up,T=_X.east;T[0]=-_[1],T[1]=_[0],T[2]=0,ny(_X.east,T),iy(_X.north,b,T),QA(_X.down,_X.up,-1),QA(_X.west,_X.east,-1),QA(_X.south,_X.north,-1),vX=_X[i],xX=_X[g],bX=_X[m]}return T[0]=vX[0],T[1]=vX[1],T[2]=vX[2],T[3]=0,T[4]=xX[0],T[5]=xX[1],T[6]=xX[2],T[7]=0,T[8]=bX[0],T[9]=bX[1],T[10]=bX[2],T[11]=0,T[12]=_[0],T[13]=_[1],T[14]=_[2],T[15]=1,T},yX[b]=_),_}("east","north"),MX=[],CX=[],PX=[],IX=[],kX=[],OX=[],EX=[],RX={x:0,y:0},LX={x:0,y:0},DX=Math.PI/180;let FX;const NX={width:100,height:10};let HX=!1;try{new OffscreenCanvas(1,1).getContext("2d").fillText("hello",0,0),HX=!0}catch($D){HX=!1}class ar{constructor(i,g={}){if(!Array.isArray(i))return void console.error("colors is not array");if(i.length<2)return void console.error("colors.length should >1");this.colors=i;let m=1/0,_=-1/0;for(let g=0,b=i.length;g<b;g++){const b=i[g][0];m=Math.min(b,m),_=Math.max(b,_)}this.min=m,this.max=_,this.valueOffset=this.max-this.min,this.options=Object.assign({},NX,g),this._initImgData()}getImageData(){return this.imgData}_initImgData(){const i=function(){if(!FX){const{width:i,height:g}=NX;HX?FX=new OffscreenCanvas(i,g):(FX=document.createElement("canvas"),FX.width=i,FX.height=g)}return FX}(),{width:g,height:m}=this.options;i.width=g,i.height=m;const _=i.getContext("2d");_.clearRect(0,0,i.width,i.height);const b=_.createLinearGradient(0,0,i.width,0),{colors:T,valueOffset:P}=this;for(let i=0,g=T.length;i<g;i++){const[g,m]=T[i];b.addColorStop((g-this.min)/P,m)}_.fillStyle=b,_.fillRect(0,0,i.width,i.height),this.imgData=_.getImageData(0,0,i.width,i.height)}getColor(i){i=Math.max(this.min,i);const g=((i=Math.min(i,this.max))-this.min)/this.valueOffset;let m=Math.round(g*this.imgData.width);m=Math.min(m,this.imgData.width-1);const _=4*m;return[this.imgData.data[_],this.imgData.data[_+1],this.imgData.data[_+2],this.imgData.data[_+3]]}}var BX;function zX(i){return null==i}function VX(i){return!zX(i)}function UX(i){return""===i}function GX(i,g){var m,_,b;if(KX(i)){var T,P=i.stops&&"object"==typeof i.stops[0][0],I=P||VX(i.property),H=P||!I,W=i.type||g||"exponential";if("exponential"===W)T=qX;else if("interval"===W)T=WX;else if("categorical"===W)T=jX;else if("identity"===W)T=$X;else if("color-interpolate"===W)T=ZX;else{if("calculate-expression"!==W)throw new Error('Unknown function type "'+W+'"');T=YX}if(P){var q={},$=[];for(let g=0;g<i.stops.length;g++){var ye=i.stops[g];void 0===q[ye[0].zoom]&&(q[ye[0].zoom]={zoom:ye[0].zoom,type:i.type,property:i.property,default:i.default,stops:[]}),q[ye[0].zoom].stops.push([ye[0].value,ye[1]])}for(let i in q)$.push([q[i].zoom,GX(q[i])]);m=function(g,m){const _=qX({stops:$,base:i.base},g)(g,m);return"function"==typeof _?_(g,m):_},_=!1,b=!1}else H?(m=function(g){const m=T(i,g);return"function"==typeof m?m(g):m},_=!0,b=!1):(m=function(g,m){const _=T(i,m?m[i.property]:null);return"function"==typeof _?_(g,m):_},_=!1,b=!0)}else m=function(){return i},_=!0,b=!0;return m.isZoomConstant=b,m.isFeatureConstant=_,m}function jX(i,g){for(let m=0;m<i.stops.length;m++)if(g===i.stops[m][0])return i.stops[m][1];return i.default}function WX(i,g){for(var m=0;m<i.stops.length&&!(g<i.stops[m][0]);m++);return i.stops[Math.max(m-1,0)][1]}function qX(i,g){for(var m=VX(i.base)&&!UX(i.base)?i.base:1,_=0;!(_>=i.stops.length||g<=i.stops[_][0]);)_++;return 0===_?i.stops[_][1]:_===i.stops.length?i.stops[_-1][1]:QX(g,m,i.stops[_-1][0],i.stops[_][0],i.stops[_-1][1],i.stops[_][1])}"function"==typeof Map&&(BX=new Map);const XX={width:100,height:1};function ZX(i,g){const m=i.stops;if(m&&m.length>1){let i;if(BX){const g=JSON.stringify(m);if(!BX.has(g)){const i=new ar(m,XX);BX.set(g,i)}i=BX.get(g)}else i=new ar(m,XX);const[_,b,T,P]=i.getColor(g);return[_/255,b/255,T/255,P/255]}return m&&1===m.length?m[0][1]:null}function $X(i,g){return _=i.default,VX(m=g)?m:VX(_)?_:VX(b)?b:null;var m,_,b}function YX(i,g){const m=String(i.property),_=i.expression,b=g;function T(g){return zX(g)||UX(g)||isNaN(g)?i.default:g}if(!VX(g)||UX(g)||isNaN(g)||g<0)return T(i.default);{const g=function i(g,m,_){const b=Number(_),T=String(m);return Array.isArray(g)?g.map((g=>i(g,T,b))):g===T?b:g}(_,m,b);return T(function g(m){if(!Array.isArray(m)){if("number"==typeof m)return m;throw new Error("Invalid expression format")}{const _=m[0];if(!["+","-","*","/"].includes(_))throw new Error(`Unknown operator: ${_}`);const b=m.slice(1).map((i=>g(i)));switch(_){case"+":return b.reduce(((i,g)=>i+g),0);case"-":return b.reduce(((i,g)=>i-g));case"*":return b.reduce(((i,g)=>i*g),1);case"/":return b.some((i=>0===i))?i.default:b.reduce(((i,g)=>i/g));default:throw new Error(`Unsupported operator: ${_}`)}}}(g))}}function QX(i,g,m,_,b,T){return"function"==typeof b?function(){var P=b.apply(void 0,arguments),I=T.apply(void 0,arguments);return QX(i,g,m,_,P,I)}:b.length?function(i,g,m,_,b,T){var P=[];for(let I=0;I<b.length;I++)P[I]=JX(i,g,m,_,b[I],T[I]);return P}(i,g,m,_,b,T):JX(i,g,m,_,b,T)}function JX(i,g,m,_,b,T){var P,I=_-m,H=i-m;return b*(1-(P=1===g?H/I:(Math.pow(g,H)-1)/(Math.pow(g,I)-1)))+T*P}function KX(i){return i&&"object"==typeof i&&(i.stops||i.property&&"identity"===i.type||i.expression&&"calculate-expression"===i.type)}function eZ(i){return tZ(i,"exponential")}function tZ(i,g){if(!KX(i))return function(){return i};let m=!0,_=!0;const b=(i=JSON.parse(JSON.stringify(i))).stops;if(b)for(let i=0;i<b.length;i++)if(KX(b[i][1])){const T=tZ(b[i][1],g);m=m&&T.isZoomConstant,_=_&&T.isFeatureConstant,b[i]=[b[i][0],T]}const T=GX(i,g);return T.isZoomConstant=m&&T.isZoomConstant,T.isFeatureConstant=_&&T.isFeatureConstant,T}const{getTextureMagFilter:nZ,getTextureMinFilter:rZ,getTextureWrap:iZ,getMaterialType:oZ,getMaterialFormat:sZ,getPrimitive:aZ,getUniqueREGLBuffer:lZ,getArrayType:hZ}=wP.REGLHelper,cZ=[1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1],uZ=[0,0,1,0,0,1,0,0,-1,0,0,0,0,0,0,1],{loginIBLResOnCanvas:fZ,logoutIBLResOnCanvas:dZ,getIBLResOnCanvas:pZ,getPBRUniforms:gZ}=wP.pbr.PBRUtils,mZ={factor:0,units:0},AZ=[1,1,1,1],yZ=[0,0,0],_Z={specularStrength:0,materialShininess:1},vZ=[1,1,1],xZ=mA([]),bZ=[0,0,0],wZ=[0,0],TZ=[],SZ=i=>i.material instanceof wP.PhongMaterial,MZ=i=>i.material instanceof wP.pbr.StandardMaterial,CZ=[],PZ=new pl(0,0),IZ=new un(0,0),kZ=new un(0,0),OZ=new un(0,0),EZ=[],RZ=[],LZ=[],DZ=[],FZ=[],NZ=[],HZ=[],BZ=[],zZ=[],VZ=[],UZ=[],GZ=[],jZ=[],WZ=[],qZ={POSITION:"POSITION",NORMAL:"NORMAL",TEXCOORD_0:"TEXCOORD_0",TEXCOORD_1:"TEXCOORD_1",COLOR_0:"COLOR_0",TANGENT:"TANGENT",_BATCHID:"_BATCHID"},XZ=[0,1,1,2,2,3,3,0,0,4,1,5,2,6,3,7,4,5,5,6,6,7,7,4],ZZ=function(i){const g=2*Math.PI/i,m=[],_=[];for(let _=0;_<=i;_++){const i=1*Math.cos(g*_),b=1*Math.sin(g*_),T=0;m[3*_]=i,m[3*_+1]=b,m[3*_+2]=T}for(let _=i;_<=200;_++){const i=1*Math.cos(g*_),b=1*Math.sin(g*_);m[3*_]=0,m[3*_+1]=i,m[3*_+2]=b}for(let i=200;i<=300;i++){const _=1*Math.cos(g*i),b=1*Math.sin(g*i),T=0;m[3*i]=_,m[3*i+1]=T,m[3*i+2]=b}const b=m.length/3-1;for(let i=0;i<b;i++)99!==i&&199!==i&&(_[2*i]=i,_[2*i+1]=i+1);return m.push(0,0,0),m.push(1,0,0),m.push(0,1,0),m.push(0,0,1),_.push(b+1,b+2),_.push(b+1,b+3),_.push(b+1,b+4),{vertices:m,indices:_}}(100),$Z=[0,0,0,1],YZ=[1,1,1];class Tn{constructor(i,g){this._layer=g,this._canvas=g.getRenderer().canvas,this.pickingFBO=g.getRenderer().pickingFBO,this._regl=i,this._renderer=new wP.Renderer(i),this._loading={},this._modelMeshes={},this._pntsMeshes={},this._i3dmMeshes={},this._cmptMeshes={},this._cachedGLTF={},this._modelScene=new wP.Scene,this._pntsScene=new wP.Scene,this._i3dmScene=new wP.Scene,this._boxScene=new wP.Scene,this._resLoader=new wP.ResourceLoader(i.texture(2)),this._bindedListener=(...i)=>this._onResourceLoad.call(this,...i),this._khrTechniqueWebglManager=new wP.KHRTechniquesWebglManager(this._regl,this._getExtraCommandProps(),this._resLoader);const m=this.getMap();this._heightScale=m.altitudeToPoint(100,m.getGLRes())/100}getI3DMMeshes(){return this._i3dmMeshes}getPNTSMeshes(){return this._pntsMeshes}getB3DMMeshes(){return this._modelMeshes}getPaintedMeshes(){return this._paintedMeshes}getMap(){return this._layer.getMap()}paint(i,g,m){const _=m&&m.renderTarget,b=m&&m.sceneFilter,T=this.getMap();if(!i.length||!T)return null;const P=this._getUniformValues(),I=T.projViewMatrix,H=[],W=[],q=[],$=[],ye=[];for(let g=0,_=i.length;g<_;g++){const _=i[g].data.node;let b=this._getMesh(_);if(!b)continue;const T=this._layer._getNodeService(_._rootIdx),P=T.debugNodes,Re=T.heightOffset||0,Be=T.coordOffset||wZ;this._cmptMeshes[_.id]&&(b=this._cmptMeshes[_.id],b=aq(b));let Ge=T.polygonOffset||mZ;QW(Ge)&&(Ge=Ge()),Array.isArray(b)||(H[0]=b,b=H);for(let H=0,je=b.length;H<je;H++){if(!b[H]||!b[H].isValid||!b[H].isValid())continue;const je=b[H].properties.magic;if(b[H].properties.heightOffset===Re&&b[H].properties.coordOffset[0]===Be[0]&&b[H].properties.coordOffset[1]===Be[1]||(this._updateMeshLocalTransform(b[H]),b[H]._originLocalTransform=gA([],b[H].localTransform)),b[H]._node=_,"b3dm"===je){if(b[H].getBoundingBox&&!qj(I,b[H].getBoundingBox()))continue;const{batchIdData:i,batchIdMap:g}=b[H].geometry.properties;if(i&&g){const i=b[H].properties.node._rootIdx;this._highlighted&&this._highlighted[i]?WE.highlightMesh(this._regl,b[H],this._highlighted[i],this._highlightTimestamp,g):this._highlighted&&this._highlighted[i]||WE.highlightMesh(this._regl,b[H],null,this._highlightTimestamp,g),WE.showOnly(this._regl,b[H],this._showOnlys&&this._showOnlys[i],this._showOnlyTimeStamp,g)}if(P&&P.length&&P.indexOf(b[H]._node.id)<0)continue;m&&m.bloom&&b[H].properties.hlBloomMesh&&(b[H].properties.hlBloomMesh.properties.depthFunc="always",q.push(b[H].properties.hlBloomMesh)),q.push(b[H])}else"pnts"===je?$.push(b[H]):"i3dm"===je&&ye.push(b[H]);b[H].properties.isLeaf=i[g].leave,b[H].properties.branchRootId=i[g].branchRootId;const Xe=255-i[g].selectionDepth;b[H].properties.selectionDepth=Xe,b[H].properties.polygonOffset=Ge;const Ze=void 0===T.cullFace||!!T.cullFace;b[H].properties.cullFace=Ze;const Ye=b[H].properties.hlBloomMesh;if(Ye){const m=Ye.properties;m.branchRootId=i[g].branchRootId,m.selectionDepth=Xe,m.polygonOffset=Ge,m.cullFace=Ze}i[g].leave||W.push(b[H]),this._updateMaskDefines(b[H]),this._updateServiceMatrix(b[H],_)}}let Re=0;const Be=this._khrTechniqueWebglManager.getExcludeFilter();Jk.setIncludeUniformValues(P,m),Re+=this._callShader(this._phongShader,P,[b,SZ,Be],_,W,q,ye),Re+=this._callShader(this._standardShader,P,[b,MZ,Be],_,W,q,ye),this._khrTechniqueWebglManager.forEachShader(((i,g,m)=>{const T=this._getUniformValues(m);Re+=this._callShader(i,T,[b,g],_,W,q,ye)})),this._pntsScene.setMeshes($);const Ge=this._getPntsUniforms();return Re+=this._renderer.render(this._pntsShader,Ge,this._pntsScene,_&&_.fbo),this._paintedMeshes={pntsMeshes:$,i3dmMeshes:ye,b3dmMeshes:q},this._boxScene.setMeshes(g),this._renderer.render(this._edgeShader,P,this._boxScene,_&&_.fbo),Re}prepareRender(i){this._prepareShaders(i)}_prepareShaders(i){i&&i.states&&i.states.includesChanged&&(this._standardShader.dispose(),delete this._standardShader,this._phongShader.dispose(),delete this._phongShader),this._createShaders(i)}_callShader(i,g,m,_,b,T,P){i.filter=m.filter((i=>!!i)),g.stencilEnable=!1,g.cullFace="back";const I=_&&_.fbo;let H=0;const W=[],q=[];let $=!1,ye=T[0]&&T[0].properties.branchRootId;for(let m=0;m<T.length;m++){const{branchRootId:_}=T[m].properties;_!==ye&&($?(q.length&&(H+=this._drawBranchMeshes(i,g,I,!1,q),q.length=0),H+=this._drawBranchMeshes(i,g,I,$,W)):uq(q,W),ye=_,$=!1,W.length=0),W.push(T[m]),T[m].properties.selectionDepth<255&&($=!0),m===T.length-1&&($||(uq(q,W),W.length=0),q.length&&(H+=this._drawBranchMeshes(i,g,I,!1,q)),H+=this._drawBranchMeshes(i,g,I,$,W))}return this._modelScene.setMeshes(T.filter((i=>i.properties.isLeaf))),this._i3dmScene.setMeshes(P),H+=this._renderer.render(i,g,this._i3dmScene,_&&_.fbo),H}_drawBranchMeshes(i,g,m,_,b){return b.length?(this._modelScene.setMeshes(b),g.stencilEnable=!1,_&&(this._clearStencil(m),g.stencilEnable=!1,g.cullFace="front",this._renderer.render(i,g,this._modelScene,m),g.cullFace="back",g.stencilEnable=!0),this._renderer.render(i,g,this._modelScene,m)):0}_clearStencil(i){this._regl.clear({stencil:255,framebuffer:i})}getCurrentB3DMMeshes(){return this._modelScene.getMeshes()}getCurrentI3DMMeshes(){return this._i3dmScene.getMeshes()}_sort(i,g){return g._node._cameraDistance-i._node._cameraDistance}deleteTile(i){const g=i.node;g._boxMesh&&(g._boxMesh.geometry.dispose(),g._boxMesh.dispose(),delete g._boxMesh);this._disposeMesh(g.id)}_disposeMesh(i){const g=this._modelMeshes[i]||this._pntsMeshes[i]||this._i3dmMeshes[i]||this._cmptMeshes[i]||this._loading[i];this._cmptMeshes[i]?this._disposeCMPT(i):g&&(this._deleteOne(g),delete this._modelMeshes[i],delete this._pntsMeshes[i],delete this._i3dmMeshes[i],delete this._loading[i])}_disposeCMPT(i){let g=this._cmptMeshes[i];g=aq(g);for(let i=0;i<g.length;i++){const{id:m}=g[i].properties;this._disposeMesh(m)}delete this._cmptMeshes[i]}_deleteOne(i){if(Array.isArray(i))for(let g=0,m=i.length;g<m;g++)this._deleteOne(i[g]);else{WE.showOnly(this._regl,i),WE.highlightMesh(this._regl,i);const g=i.geometry.properties.url;if(g){const m=this._cachedGLTF[g];m&&m.refMeshes&&(m.refMeshes.delete(i.uuid),m.refMeshes.size||(m.geometry.dispose(),m.material.dispose(),delete this._cachedGLTF[g]))}else i.geometry.dispose(),i.material&&i.material.dispose();i.dispose()}}remove(){const i=this._layer;dZ(i.getRenderer().canvas,i.getMap());for(const i in this._cmptMeshes)this._disposeCMPT(i);this._cmptMeshes={};for(const i in this._modelMeshes)this._disposeMesh(i);this._modelMeshes={};for(const i in this._pntsMeshes)this._disposeMesh(i);this._pntsMeshes={};for(const i in this._i3dmMeshes)this._disposeMesh(i);this._i3dmMeshes={};for(const i in this._loading)this._disposeMesh(i);this._loading={},this._phongShader&&(this._phongShader.dispose(),delete this._phongShader),this._standardShader&&(this._standardShader.dispose(),delete this._standardShader),this._pntsShader&&(this._pntsShader.dispose(),delete this._pntsShader),this._edgeShader&&(this._edgeShader.dispose(),delete this._edgeShader),this._khrTechniqueWebglManager.dispose(),this.picking&&this.picking.dispose()}_getMesh(i){return this._modelMeshes[i.id]||this._pntsMeshes[i.id]||this._i3dmMeshes[i.id]||this._cmptMeshes[i.id]}has(i){return this._getMesh(i)||this._loading[i.id]}_updateMeshLocalTransform(i){const g=i.properties.magic;"b3dm"===g?this._updateB3DMLocalMatrix(i):"i3dm"===g?this._updateI3DMLocalTransform(i):"pnts"===g&&this._updatePNTSLocalTransform(i)}createPntsMesh(i,g,m,_){if(this._pntsMeshes[g]){const i=this._pntsMeshes[g];return console.warn(`pnts mesh with id(${g}) was already created.`),_(null,{id:g,mesh:i}),i}const{pnts:b,featureTable:T,rootIdx:P,compressed_int16_params:I}=i,H=T.POINTS_LENGTH;b.BATCH_ID||(b.BATCH_ID=new Uint8Array(H),b.BATCH_ID.fill(0));const W=new wP.Geometry(b,null,H,{static:!0,primitive:"points",positionAttribute:"POSITION",pickingIdAttribute:"BATCH_ID"});W.generateBuffers(this._regl);const q={};b.POSITION?q.HAS_POSITION=1:b.POSITION_QUANTIZED&&(q.HAS_POSITION_QUANTIZED=1),b.RGB?q.HAS_RGB=1:b.RGBA?q.HAS_RGBA=1:b.RGB565&&(q.HAS_RGB565=1),(b.NORMAL||b.NORMAL_OCT16P)&&(q.HAS_NORMAL=1,b.NORMAL_OCT16P&&(q.HAS_NORMAL_OCT16P=1)),this._setCompressedInt16Defines(q,I),i.featureTable.CONSTANT_RGBA&&(i.featureTable.CONSTANT_RGBA=i.featureTable.CONSTANT_RGBA.map((i=>i/255)));const{rtcCenter:$,rtcCoord:ye,projCenter:Re}=i,Be=this._layer._getNodeService(P),Ge=new wP.Mesh(W);Ge.properties.magic="pnts",Ge.properties.id=g,Ge.properties.node=m,Ge.properties.count=H,Ge.properties.batchTable=i.batchTable,Ge.properties.batchTableBin=i.batchTableBin,Ge.properties.serviceIndex=P,Ge.properties.rtcCoord=ye,Ge.properties.rtcCenter=$,Ge.properties.projCenter=Re,Ge.setDefines(q),Ge.setFunctionUniform("pointColor",(function(){return i.featureTable.CONSTANT_RGBA?i.featureTable.CONSTANT_RGBA:Be&&Be.pointColor||[1,1,1,1]}));const je=this.getMap();let Xe=null,Ze=null;Ge.setFunctionUniform("pointSize",(function(){if(!Be)return 2;if(KX(Be.pointSize)){const i=JSON.stringify(Be.pointSize);return i!==Xe&&(Ze=eZ(Be.pointSize),Xe=i),Ze(je.getZoom())}return Be.pointSize||2}));let Ye=null,Qe=null;return Ge.setFunctionUniform("pointOpacity",(function(){if(!Be)return 1;if(KX(Be.pointOpacity)){const i=JSON.stringify(Be.pointOpacity);return i!==Ye&&(Qe=eZ(Be.pointOpacity),Ye=i),Qe(je.getZoom())}return Be.pointOpacity||1})),this._setCompressedInt16Uniforms(Ge,I),this._updatePNTSLocalTransform(Ge),Ge._originLocalTransform=gA([],Ge.localTransform),this._pntsMeshes[g]=Ge,_(null,{id:g,mesh:[Ge]}),[Ge]}_updatePNTSLocalTransform(i){const g=i.localTransform||[],{rtcCoord:m,node:_,projCenter:b}=i.properties;this._getB3DMTransform(g,m,b,_._rootIdx),i.setLocalTransform(g)}createI3DMMesh(i,g,m,_){if(this._i3dmMeshes[g]){const i=this._i3dmMeshes[g];return console.warn(`i3dm mesh with id(${g}) was already created.`),this._loading[g]||_(null,{id:g,mesh:i}),i}const b=this._layer._getNodeService(m._rootIdx),T=this._getUpAxisTransform(m._upAxis),{i3dm:P,featureTable:I,gltf:H,batchTable:W,batchTableBin:q,count:$}=i,ye=I.INSTANCES_LENGTH,{rtcCenter:Re,rtcCoord:Be,projCenter:Ge}=i,je=this._computeProjectedTransform(DZ,m,Re,Be);TX(je,bZ,je);const Xe=kA(FZ,je);S_(Xe,Xe);const Ze=PA(NZ,je),Ye=TA(HZ,Ze),Qe=this._getI3DMTileTransform(BZ,Ge,m),Je=this._getProjScale(UZ),Ke=this._getDistanceScale(GZ,Be),et=fy(jZ,Ke,Je),tt=TA(WZ,et),{POSITION:at,NORMAL_UP:ht,NORMAL_RIGHT:gt,SCALE:yt,SCALE_NON_UNIFORM:vt}=P,xt={instance_vectorA:new Float32Array(4*ye),instance_vectorB:new Float32Array(4*ye),instance_vectorC:new Float32Array(4*ye),aPickingId:new Uint16Array(ye)};for(let i=0;i<ye;i++)xt.aPickingId[i]=i;const bt=new Float32Array(3),Tt=new Float32Array(3),Mt=[],Pt=new Float32Array(1),It=new Float32Array(3),Et=[],Lt=[],Dt=[],Ft=[];!function(i,g){let{byteOffset:m,byteStride:_,count:b}=i;const{componentType:T,itemSize:P}=i,I=i.array.buffer,H=T?Tq.getTypedArrayCtor(T):i.array.constructor;if(m=void 0===m?i.array.byteOffset:m,_=_||0,b=b||i.array.length/P,(!_||_===P*H.BYTES_PER_ELEMENT)&&m%H.BYTES_PER_ELEMENT===0){const i=new H(I,m,b*P);for(let _=0;_<b*P;_+=P)g(new H(i.buffer,m+_*H.BYTES_PER_ELEMENT,P),_/P);return}const W=new Uint8Array(P*H.BYTES_PER_ELEMENT);_||(_=P*H.BYTES_PER_ELEMENT);for(let i=0;i<b;i++){const b=new Uint8Array(I,_*i+m,P*H.BYTES_PER_ELEMENT);W.set(b),g(new H(W.buffer),i),b.set(W)}}(at,((i,g)=>{ht?(Rq(Tt,gt,g),Rq(bt,ht,g),iy(Mt,Tt,bt),ny(Mt,Mt),sq(Et,Tt,0),sq(Et,bt,1),sq(Et,Mt,2),i_(Lt,Et),S_(Lt,Lt),Qy(Lt,Xe,Lt)):$y(Lt),yt?(Rq(Pt,yt,g),qA(Dt,Pt[0],Pt[0],Pt[0])):vt?(Rq(It,vt,g),qA(Dt,...It)):qA(Dt,1,1,1),OA(Ft,Lt,i,Dt),Lq(xt.instance_vectorA,g,Ft,0),Lq(xt.instance_vectorB,g,Ft,1),Lq(xt.instance_vectorC,g,Ft,2)}));const Ht={};for(const i in xt)Ht[i]={buffer:this._regl.buffer({dimension:xt[i].length/ye,data:xt[i],name:i}),divisor:1};const Bt=b.shader||"pbr";let zt=0,Vt=!0;const Ut=[],Gt=[];return Sq(H,((i,_,b,P)=>{const H=this._processGLTF(i,_,b,P,m,!0,Bt,Gt),{geometry:Xe,material:Ze}=H;Ze&&!Ze.isReady()&&(Vt=!1,zt++);const Je=new wP.InstancedMesh(Ht,ye,Xe,Ze);H.refMeshes||(H.refMeshes=new Set,H.refMeshes.add(Je.uuid)),Je.properties.magic="i3dm",Je.properties.id=g,Je.properties.count=$,Je.properties.batchTable=W,Je.properties.batchTableBin=q,Je.properties.serviceIndex=m._rootIdx,Je.properties.rtcCoord=Be,Je.properties.rtcCenter=Re,Je.properties.projCenter=Ge,Je.properties.node=m;const Ke=this._getGLTFMeshDefines(i,Xe,Ze,m._rootIdx,P);i.compressed_int16_params&&this._setCompressedInt16Uniforms(Je,i.compressed_int16_params),this._setWEB3DDecodeUniforms(Je,i.attributes);const et=mA([]);if(i.matrices&&i.matrices.length)for(let g=0;g<i.matrices.length;g++)_A(et,et,i.matrices[g]);_A(et,T,et),_A(et,tt,et),_A(et,I.EAST_NORTH_UP||ht?Ye:je,et),Je.setPositionMatrix(et),this._updateI3DMLocalTransform(Je,Qe),Je.setDefines(Ke),Je.properties.polygonOffset={offset:0,factor:0},Ut.push(Je),delete i.attributes,Je._originLocalTransform=gA([],Je.localTransform)})),QZ(Gt),Vt?(this._i3dmMeshes[g]=Ut,_(null,{id:g,mesh:Ut})):(this._loading[g]={meshes:Ut,count:zt},Ut._callback=_),Ut}_updateI3DMLocalTransform(i,g){const{rtcCoord:m,node:_,projCenter:b}=i.properties;g||(g=this._getI3DMTileTransform(BZ,b,_));const T=this._layer._getNodeService(_._rootIdx),P=i.localTransform||[];if(T.coordOffset){_A(P,this._computeCoordOffsetMatrix(DZ,_._rootIdx,m),g)}else gA(P,g);i.setLocalTransform(P),i.properties.heightOffset=T.heightOffset||0,i.properties.coordOffset=T.coordOffset&&T.coordOffset.slice(0)||wZ}_getI3DMTileTransform(i,g,m){TA(i,this._getProjScale(UZ));const _=this._getCenterTranslation(RZ,g,m._rootIdx);return _A(i,wA(zZ,_),i),i}createB3DMMesh(i,g,m,_){if(i.gltf&&(i.gltf.transferables=null),this._modelMeshes[g]||this._loading[g]){const i=this._modelMeshes[g];return console.warn(`mesh with id(${g}) was already created.`),this._loading[g]||_(null,{id:g,mesh:i}),i}let b;if(m.maxExtent){const i=new Pl(m.maxExtent).convertTo((i=>this._pointToPrj(i)));b=[i.xmin,i.ymin,i.xmax,i.ymax]}const T=i.gltf,{projCenter:P}=T.extensions.MAPTALKS_RTC,{rtcCoord:I,center:H}=T.extensions.CESIUM_RTC,W=T.asset.sharePosition,q=this._getUpAxisTransform(m._upAxis),$=this._getB3DMTileTransform(BZ,W,I,H,P,m),ye=this._layer._getNodeService(m._rootIdx);let Re=ye.shader||"pbr";if(ye.unlit)Re="phong";else if(T.materials)for(let i=0;i<T.materials.length;i++)if(T.materials[i]&&T.materials[i].extensions&&T.materials[i].extensions.KHR_materials_unlit){Re="phong";break}const Be=[],Ge=[];let je=0,Xe=!0;return Sq(T,((_,T,Ze,Ye)=>{const Qe=this._processGLTF(_,T,Ze,Ye,m,!1,Re,Be),{geometry:Je,material:Ke}=Qe;Ke&&!Ke.isReady()&&(Xe=!1,je++);const et=new wP.Mesh(Je,Ke);Qe.refMeshes||(Qe.refMeshes=new Set,Qe.refMeshes.add(et.uuid)),et.properties.magic="b3dm",et.properties.id=g,et.properties.node=m,i.batchTable&&(et.properties.batchTable=i.batchTable,et.properties.batchTableBin=i.batchTableBin),et.properties.count=i.featureTable&&i.featureTable.BATCH_LENGTH||0,et.properties.serviceIndex=m._rootIdx;const tt=this._getGLTFMeshDefines(_,Je,Ke,m._rootIdx,Ye);et.setDefines(tt);const at=_.compressUniforms;if(at)for(const i in at)et.setUniform(i,at[i]);_.compressed_int16_params&&this._setCompressedInt16Uniforms(et,_.compressed_int16_params),this._setWEB3DDecodeUniforms(et,_.attributes),b&&(tt.USE_MAX_EXTENT=1,et.setUniform("maxPrjExtent",b)),et.hasFunctionUniform("polygonOpacity")||et.setFunctionUniform("polygonOpacity",(function(){return KW(ye.opacity)?ye.opacity:1})),et.hasFunctionUniform("polygonFill")||et.setFunctionUniform("polygonFill",(function(){return dq([],ye.polygonFill||AZ)})),et.material.hasFunctionUniform("hsv")||et.material.setFunctionUniform("hsv",(function(){return ye.hsv||yZ}));const ht=mA([]);if(W&&_.matrices&&_.matrices.length)for(let i=0;i<_.matrices.length;i++)_A(ht,ht,_.matrices[i]);W&&_A(ht,q,ht),et.properties.node=m,et.properties.projCenter=P,et.properties.nodeMatrix=ht,et.properties.isSharedPosition=W,et.properties.rtcCoord=I,et.properties.rtcCenter=H,this._updateB3DMLocalMatrix(et,$),Ge.push(et),delete _.attributes,et._originLocalTransform=gA([],et.localTransform)})),QZ(Be),Xe?(this._modelMeshes[g]=Ge,_(null,{id:g,mesh:Ge})):(this._loading[g]={meshes:Ge,count:je},Ge._callback=_),Ge}_createBoxMesh(i){const g=this._layer._getNodeBox(i.id);if(!g||i._boxMesh)return;let m,_,b,T;if(g.obbox)m=g.boxPosition,_=XZ,b=g.boxCenter,T=YZ;else if(g.sphereBox){const i=g.sphereBox[1];m=ZZ.vertices,_=ZZ.indices,b=g.sphereBox[0],T=[i,i,i]}const P=new wP.Geometry({POSITION:m},_,0,{primitive:"lines",positionAttribute:"POSITION"}),I=new wP.Mesh(P,new wP.Material({lineColor:[.8,.8,.1,1],lineOpacity:1})),H=[];OA(H,$Z,b,T),I.localTransform=H,I._originLocalTransform=gA([],H),I.properties.node=i,i._boxMesh=I}_deleteBoxMesh(i){i._boxMesh&&(i._boxMesh.geometry.dispose(),i._boxMesh.dispose(),delete i._boxMesh)}_setCompressedInt16Uniforms(i,g){g.POSITION&&i.setUniform("compressedPositionRange",g.POSITION),g.TEXCOORD_0&&i.setUniform("compressedTexcoordRange_0",g.TEXCOORD_0),g.TEXCOORD_1&&i.setUniform("compressedTexcoordRange_1",g.TEXCOORD_0),g.NORMAL&&i.setUniform("compressedNormalRange",g.NORMAL),g.TANGENT&&i.setUniform("compressedTangentRange",g.TANGENT),g.compressed_ratio&&i.setUniform("compressed_ratio",g.compressed_ratio)}_updateB3DMLocalMatrix(i,g){const{isSharedPosition:m,rtcCoord:_,rtcCenter:b,projCenter:T,nodeMatrix:P,node:I}=i.properties;g||(g=this._getB3DMTileTransform(g||BZ,m,_,b,T,I));const H=i.localTransform||mA([]);_A(H,g,P);const W=this._layer._getNodeService(I._rootIdx);if(W.coordOffset){_A(H,this._computeCoordOffsetMatrix(DZ,I._rootIdx,_),H)}i.setLocalTransform(H),i.properties.heightOffset=W.heightOffset||0,i.properties.coordOffset=W.coordOffset&&W.coordOffset.slice(0)||wZ}_getB3DMTileTransform(i,g,m,_,b,T){if(g){const g=this._getDistanceScale(GZ,m),b=TA(LZ,g);_A(i,this._computeProjectedTransform(DZ,T,_,m),b)}else this._getB3DMTransform(i,m,b,T._rootIdx);return i}_setWEB3DDecodeUniforms(i,g){if(g&&g.TEXCOORD_0&&g.TEXCOORD_0.extensions&&g.TEXCOORD_0.extensions.WEB3D_quantized_attributes){i.setUniform("decodeMatrix",g.TEXCOORD_0.extensions.WEB3D_quantized_attributes.decodeMatrix)}}_computeProjectedTransform(i,g,m,_){const b=this.getMap(),T=this._layer._getNodeService(g._rootIdx).heightOffset||0,P=g.matrix?gA(i,g.matrix):mA(i);m&&TX(P,oy(CZ,m,P),P);const I=function(i,g,m,_,b,T,P){g=WA(MX,g);const I=Bq(MX,g[0]*DX,g[1]*DX,g[2]),H=CA(CX,m),W=_.ellipsoid;let q;q=0===gy(H)?qA(PX,0,0,-6378137):Wq(PX,H),RX.x=q[0],RX.y=q[1];const $=_.project(RX,LX);IX[0]=$.x/b,IX[1]=$.y/b,IX[2]=(q[2]+P)*T;const ye=SX(I,W,kX);return TX(function(i,g,m){const _=i[0],b=i[1],T=i[2],P=i[4],I=i[5],H=i[6],W=i[8],q=i[9],$=i[10],ye=g[0],Re=g[1],Be=g[2],Ge=g[3],je=g[4],Xe=g[5],Ze=g[6],Ye=g[7],Qe=g[8],Je=b*ye+I*Re+q*Be,Ke=T*ye+H*Re+$*Be,et=_*Ge+P*je+W*Xe,tt=b*Ge+I*je+q*Xe,at=T*Ge+H*je+$*Xe,ht=_*Ze+P*Ye+W*Qe,gt=b*Ze+I*Ye+q*Qe,yt=T*Ze+H*Ye+$*Qe;return m[0]=_*ye+P*Re+W*Be,m[1]=Je,m[2]=Ke,m[3]=0,m[4]=et,m[5]=tt,m[6]=at,m[7]=0,m[8]=ht,m[9]=gt,m[10]=yt,m[11]=0,m[12]=i[12],m[13]=i[13],m[14]=i[14],m[15]=i[15],m}(yA(OX,ye),sA(EX,m),i),IX,i),i}(P,_,P,b.getProjection(),b.getGLRes(),this._heightScale,T),H=function(i,g){return qA(i,g[12],g[13],g[14]),i}(RZ,I);let W=this._layer.options.offset;if(QW(W)){const i=this._layer._getNodeBox(g.id).boxCoord;W=W.call(this._layer,i)}return qA(EZ,W[0],W[1],0),cy(H,H,EZ),TX(I,H,I),I}_computeCoordOffsetMatrix(i,g,m){const _=this._layer._getNodeService(g);if(!_.coordOffset)return null;const b=this.getMap(),T=b.getGLRes();PZ.set(m[0],m[1]);const P=b.coordToPointAtRes(PZ,T,kZ),I=_.coordOffset,H=PZ.set(m[0]+I[0],m[1]+I[1]),W=b.coordToPointAtRes(H,T,OZ);return wA(i,qA(EZ,W.x-P.x,W.y-P.y,(I[2]||0)*this._heightScale))}createCMPTMesh(i,g,m,_){if(this._cmptMeshes[g]){const i=this._cmptMeshes[g];return console.warn(`mesh with id(${g}) was already created.`),_(null,{id:g,mesh:i}),i}const{content:b}=i,T=[];for(let i=0;i<b.length;i++){const{magic:_}=b[i],P=g+"."+i;"b3dm"===_?this.createB3DMMesh(b[i],P,m,((i,{mesh:g})=>{T.push(g)})):"i3dm"===_?this.createI3DMMesh(b[i],P,m,((i,{mesh:g})=>{T.push(g)})):"pnts"===_?this.createPntsMesh(b[i],P,m,((i,{mesh:g})=>{T.push(g)})):"cmpt"===_&&this.createCMPTMesh(b[i],P,m,((i,{mesh:g})=>{T.push(g)}))}return this._cmptMeshes[g]=T,_(null,{id:g,mesh:T}),T}_getGLTFMeshDefines(i,g,m,_,b){const T=("phong"===(this._layer._getNodeService(_).shader||"pbr")?this._phongShader:this._standardShader).getGeometryDefines(g);return b.asset&&"S3M"===b.asset.generator&&this._appendS3MDefines(T,g),g.data.uvRegion&&(T.HAS_I3S_UVREGION=1),g.data[g.desc.normalAttribute]&&(T.VertexNormal=1),g.data[g.desc.color0Attribute]&&(T.VertexColor=1),g.data[g.desc.uv0Attribute]&&(T.TexCoord=1),g.data[g.desc.textureCoordMatrixAttribute]&&(T.HAS_TextureCoordMatrix=1),m.get("uTexture")&&(T.COMPUTE_TEXCOORD=1),m.get("uTexture2")&&(T.TexCoord2=1),"MESHOPT"===this._layer._vertexCompressionType&&(T.MeshOPT_Compress=1),this.hasIBL()&&(T.HAS_IBL_LIGHTING=1),i.attributes&&i.attributes.TEXCOORD_0&&"WEB3D_quantized_attributes"===i.attributes.TEXCOORD_0.extensions&&(T.HAS_WEB3D_quantized_attributes_TEXCOORD=1),T.HAS_MIN_ALTITUDE=1,this._setCompressedInt16Defines(T,i.compressed_int16_params),YW(T,i.compressDefines),T}_setCompressedInt16Defines(i,g){g&&Object.keys(g).length>0&&(i.HAS_COMPRESSED_INT16=1,g.POSITION&&(i.HAS_COMPRESSED_INT16_POSITION=1),g.TEXCOORD_0&&(i.HAS_COMPRESSED_INT16_TEXCOORD_0=1),g.TEXCOORD_1&&(i.HAS_COMPRESSED_INT16_TEXCOORD_1=1),g.NORMAL&&(i.HAS_COMPRESSED_INT16_NORMAL=1),g.TANGENT&&(i.HAS_COMPRESSED_INT16_TANGENT=1),g.compressed_ratio&&(i.HAS_COMPRESSED_INT16_RATIO=1))}_updateMaskDefines(i){const g=this._layer.getRenderer();g&&g.updateMaskDefines(i)}_appendS3MDefines(i,g){g.data.aNormal&&(i.VertexNormal=1),g.data.instanceId&&(i.Instance=1),g.data.aTexCoord0&&(i.TexCoord=1),g.data.aColor&&(i.VertexColor=1),g.data.aTexCoord1&&(i.TexCoord2=1),g.data.uv2&&(i.InstanceBim=1)}_processGLTF(i,g,m,_,b,T,P,I){let H=!1;_.asset&&"S3M"===_.asset.generator&&(H=!0,_.extensions=_.extensions||{});const W=_.url+"-"+g+"-"+m;if(this._cachedGLTF[W])return this._cachedGLTF[W];let q,$;I.push(i);const ye=_.materials&&_.materials[i.material],Re=_.extensions&&_.extensions.KHR_techniques_webgl,Be=this._layer._getNodeService(b._rootIdx);if(Re&&ye.extensions&&ye.extensions.KHR_techniques_webgl){if(this.getMap().getRenderer().isWebGPU())throw new Error("3dtiles with KHR_techniques_webgl extension is not supported in webgpu");const g=this._createTechniqueMesh(i,_,T,H);q=g.material,$=g.geometry,Be.fillEmptyDataInMissingAttribute&&($.desc.fillEmptyDataInMissingAttribute=!0)}else{$=this._createGeometry(i,T,qZ);q=this._createMaterial(i.material,_,P,Be.material||_Z,I,Be)}q&&(q.setFunctionUniform("alphaTest",(function(){const i=Be.alphaTest;return $W(i)?.1:i})),q.setFunctionUniform("environmentExposure",(()=>{const i=Be.ambientLight;let g=Be.environmentExposure;const m=this.getMap().getLightManager(),_=m&&m.getAmbientLight();if(i&&(!_||_.color)&&void 0===g){g=i[0]/(_&&_.color?_.color[0]:.2)}return g||1}))),q&&!q.isReady()?q._nodeId=b.id:q||(q=new wP.PhongMaterial({baseColorFactor:[1,1,1,1]}));const Ge={geometry:$,material:q};return $.properties.url=W,this._cachedGLTF[W]=Ge,Ge}_createTechniqueMesh(i,g,m,_){const{geometry:b,material:T}=this._khrTechniqueWebglManager.createMesh(i,g,m,_);return{geometry:b,material:T}}_createGeometry(i,g,m){const _=i.attributes,b="COLOR_0";let T=_._BATCHID&&_._BATCHID.array;if(T&&T.byteOffset&&(T=new T.constructor(T)),_[b]){const i=_[b].array||_[b];if(i instanceof Float32Array){const g=new Uint8Array(i.length);for(let m=0;m<g.length;m++)g[m]=Math.round(255*i[m]);_[b].array?(_[b].array=g,_[b].componentType=5121):_[b]=g}}const P=this.getMap().getRenderer().isWebGPU(),I={};let H=0,W=0;for(const i in _){const g=m[i]||i,b=g===m.POSITION;if(b&&(H=_[i].itemSize),P){const g=_[i].array,m=wP.Geometry.padGPUBufferAlignment(_[i].array,_[i].count);if(g!==m){b&&(H+=1),_[i].array=m,_[i].byteLength=m.byteLength,_[i].itemSize+=1;const g=_[i].type;_[i].type=g.substring(0,g.length-1)+_[i].itemSize}}const T=lZ(this._regl,_[i],{dimension:_[i].itemSize,name:i});I[g]=YW({},_[i]),I[g].buffer=T,I[g].type=hZ(I[g].array),delete I[g].array,g===m.POSITION&&(I[g].array=_[i].array,W=_[i].array.length/3)}const q=m._BATCHID;if(!I[q]&&!g){const i=new Uint8Array(W);I[q]=i}const $=i.indices?i.indices.array?i.indices.array.slice():i.indices:null,ye=new wP.Geometry(I,$,0,{positionSize:H,positionAttribute:m.POSITION,normalAttribute:m.NORMAL,uv0Attribute:m.TEXCOORD_0,uv1Attribute:m.TEXCOORD_1,color0Attribute:m.COLOR_0,tangentAttribute:m.TANGENT,pickingIdAttribute:m._BATCHID,primitive:void 0===i.mode?"triangles":aZ(i.mode)});return T&&$&&(ye.properties.batchIdData=T,ye.properties.batchIdMap=function(i,g){if(!g)return null;const m=new Map;for(let _=0;_<g.length;_++){const b=g[_],T=i[b];let P=m.get(T);P||(P=[],m.set(T,P)),P.push(b)}return m}(T,$)),ye.generateBuffers(this._regl,{excludeElementsInVAO:g}),ye}_getB3DMTransform(i,g,m,_){const b=mA(i),T=this._getProjScale(vZ);return this._getCenterTranslation(RZ,m,_),vA(b,b,RZ),xA(b,b,T),b}_getCenterTranslation(i,g,m){const _=this._heightScale;PZ.x=g[0],PZ.y=g[1];const b=this._prjToPoint(PZ);let T=this._layer.options.offset;QW(T)&&(T=T.call(this._layer,PZ));const P=this._layer._getNodeService(m).heightOffset||0;return qA(i,b.x-T[0],b.y-T[1],_*g[2]+_*P),i}_updateServiceMatrix(i,g){const m=this._layer._getServiceTransform(VZ,g);i.localTransform=_A(i.localTransform,m,i._originLocalTransform)}_getDistanceScale(i,g){const m=this.getMap();PZ.x=g[0],PZ.y=g[1];const _=m.distanceToPointAtRes(100,100,m.getGLRes(),PZ);return qA(i,_.x/100,_.y/100,this._heightScale),i}_createShaders(i){if(this._standardShader)return;const g=[],m=[];this._pntsShader=new wP.MeshShader({vert:Dq,frag:"#define SHADER_NAME PNTS\n\nprecision mediump float;\n\n\n\nuniform float layerOpacity;\n\nvarying vec4 vColor;\n\n\n\nvoid main() {\n\n    vec2 circCoord = 2.0 * gl_PointCoord - 1.0;\n\n    if (dot(circCoord, circCoord) > 1.0) {\n\n        discard;\n\n    } else {\n\n        gl_FragColor = vColor;\n\n    }\n\n    #ifdef HAS_LAYER_OPACITY\n\n        gl_FragColor *= layerOpacity;\n\n    #endif\n\n}\n\n",uniforms:[{name:"projViewModelMatrix",type:"function",fn:(i,g)=>_A(m,g.projViewMatrix,g.modelMatrix)},{name:"modelNormalMatrix",type:"function",fn:(i,m)=>sA(g,m.modelMatrix)}],extraCommandProps:{viewport:{x:0,y:0,width:()=>this._canvas?this._canvas.width:1,height:()=>this._canvas?this._canvas.height:1},blend:{enable:!0,func:{src:"one",dst:"one minus src alpha"},equation:"add"},depth:{enable:!0,func:"<"}}});const _={},b=[];Jk.fillIncludes(_,b,i);const T=this._getExtraCommandProps();this._phongShader=new wP.PhongShader({uniforms:b,defines:_,extraCommandProps:T}),this._standardShader=new wP.pbr.StandardShader({uniforms:b,defines:_,extraCommandProps:T}),this._edgeShader=new wP.EdgeShader({extraCommandProps:{viewport:{x:0,y:0,width:()=>this._canvas?this._canvas.width:1,height:()=>this._canvas?this._canvas.height:1},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"},equation:"add"}}});const P=this._layer;fZ(P.getRenderer().canvas,this._regl,P.getMap()),this.picking=new wP.FBORayPicking(this._renderer,{vert:"#include <gl2_vert>\n\n#define SHADER_NAME GEO_3DTILES_PICKING\n\n\n\nattribute vec3 aPosition;\n\n\n\n#if defined(HAS_COLOR)\n\n    attribute vec4 aColor;\n\n#endif\n\n#if defined(HAS_COLOR0)\n\n    #if COLOR0_SIZE == 3\n\n        attribute vec3 aColor0;\n\n        varying vec3 vColor0;\n\n    #else\n\n        attribute vec4 aColor0;\n\n        varying vec4 vColor0;\n\n    #endif\n\n#endif\n\n\n\n\n\nuniform mat4 modelMatrix;\n\nuniform mat4 modelViewMatrix;\n\nuniform mat4 positionMatrix;\n\nuniform mat4 projMatrix;\n\n\n\n#include <line_extrusion_vert>\n\n#include <get_output>\n\n\n\n#include <fbo_picking_vert>\n\nvoid main() {\n\n    mat4 localPositionMatrix = getPositionMatrix();\n\n    vec4 localVertex = getPosition(aPosition);\n\n\n\n    vec4 position = localPositionMatrix * localVertex;\n\n    vec4 viewVertex = modelViewMatrix * position;\n\n\n\n    #ifdef HAS_MASK_EXTENT\n\n        gl_Position = projMatrix * getMaskPosition(position, modelMatrix);\n\n    #else\n\n        gl_Position = projMatrix * viewVertex;\n\n    #endif\n\n\n\n    float alpha = 1.0;\n\n    #if defined(HAS_COLOR)\n\n        alpha *= aColor.a;\n\n    #endif\n\n    #if defined(HAS_COLOR0) && COLOR0_SIZE == 4\n\n        alpha *= aColor0.a;\n\n    #endif\n\n\n\n    fbo_picking_setData(gl_Position.w, alpha != 0.0);\n\n\n\n\n\n}\n\n",extraCommandProps:T,uniforms:this._standardShader.uniforms,defines:{PICKING_MODE:1,ENABLE_PICKING:1,HAS_PICKING_ID:1}},this.pickingFBO,this.getMap()),this._pntsPicking=new wP.FBORayPicking(this._renderer,{vert:Dq,extraCommandProps:T,uniforms:this._pntsShader.uniforms,defines:{PICKING_MODE:1,ENABLE_PICKING:1,HAS_PICKING_ID:1}},this.pickingFBO,this.getMap())}_getExtraCommandProps(){return{viewport:{x:0,y:0,width:()=>this._canvas?this._canvas.width:1,height:()=>this._canvas?this._canvas.height:1},cull:{enable:(i,g)=>g.meshProperties.cullFace,face:(i,g)=>g.cullFace||"back"},stencil:{enable:(i,g)=>g.stencilEnable,func:{cmp:"<=",ref:(i,g)=>g.meshProperties.selectionDepth},op:{fail:"keep",zfail:"keep",zpass:"replace"}},depth:{enable:!0,func:(i,g)=>g.meshProperties.depthFunc||"<="},blend:{enable:!0,func:{src:1,dst:"one minus src alpha"},equation:"add"},polygonOffset:{enable:!0,offset:(i,g)=>g.meshProperties.polygonOffset}}}_getPntsUniforms(i){const g=this.getMap(),m=g.getLightManager(),_=(m&&m.getDirectionalLight()||{}).direction||[1,1,-1],b=i&&i.pointOpacity||1;let T=this._layer.options.opacity;return T=$W(T)?1:T,{projViewMatrix:g.projViewMatrix,pointOpacity:b,lightDir:ny(TZ,_),layerOpacity:T}}_getUniformValues(){const i=this.getMap(),g=this._layer,m=g.getRenderer().canvas,{iblTexes:_,dfgLUT:b}=pZ(m),T=gZ(i,_,b),P=this._layer.getRenderer().getMaskUniforms();T.minAltitude=g.options.altitude||0;let I=g.options.opacity;return I=$W(I)?1:I,T.layerOpacity=I,YW(T,{czm_lightDirectionEC:T.light0_viewDirection,lightSpecular:[1,1,1],viewMatrix:i.viewMatrix,projMatrix:i.projMatrix,projViewMatrix:i.projViewMatrix,outSize:[m.width,m.height],polygonFill:[1,1,1,1],polygonOpacity:1}),T.ambientColor||(T.ambientColor=[.2,.2,.2]),YW(T,P),T}_createMaterial(i,g,m,_,b,T){const P=g.materials&&g.materials[i];if(!P||!P.baseColorTexture&&!P.pbrMetallicRoughness)return null;const I=YW({},_);if(P.baseColorTexture){const i=g.textures[P.baseColorTexture.index];let m;i&&!i.image.color&&(m=this._getTexture(i,b)),I.baseColorFactor=i&&i.image.color||P.baseColorFactor||[1,1,1,1],m&&(I.baseColorTexture=m)}else{if(P.normalTexture){const i=this._getTexture(g.textures[P.normalTexture.index],b);if(i){const g=P.normalTexture.scale||1;I.normalTexture=i,I.normalMapFactor=g}}if(P.occlusionTexture){const i=this._getTexture(g.textures[P.occlusionTexture.index],b);if(i){const g=P.occlusionTexture.strength||1;I.occlusionTexture=i,I.occlusionFactor=g}}if(P.emissiveTexture){const i=this._getTexture(g.textures[P.emissiveTexture.index],b);i&&(I.emissiveTexture=i)}P.emissiveFactor&&(I.emissiveFactor=P.emissiveFactor);const i=P.pbrMetallicRoughness;if(i){if(i.baseColorFactor&&(I.baseColorFactor=i.baseColorFactor),i.baseColorTexture&&void 0!==i.baseColorTexture.index){const m=g.textures[i.baseColorTexture.index];if(m&&m.image&&m.image.color)I.baseColorFactor=I.baseColorFactor?My(I.baseColorFactor,I.baseColorFactor,m.image.color):m.image.color;else{const i=this._getTexture(m,b);i&&(I.baseColorTexture=i,I.baseColorTexture.getREGLTexture(this._regl))}}if($W(i.metallicFactor)||(I.metallicFactor=i.metallicFactor),$W(i.roughnessFactor)||(I.roughnessFactor=i.roughnessFactor),P.metallicRoughnessTexture){const i=this._getTexture(g.textures[P.metallicRoughnessTexture.index],b);i&&(I.metallicRoughnessTexture=i)}}}if(P.s3mMaterial)return new wP.Material(I);if(T.unlit||P.extensions&&P.extensions.KHR_materials_unlit){const i=new wP.PhongMaterial(I);return i.unlit=void 0===T.unlit||!!T.unlit,i}let H=new wP.pbr.StandardMaterial(I);"phong"===m&&(H=wP.PhongMaterial.convertFrom(H));const W=P.pbrMetallicRoughness,q=W&&W.baseColorTexture&&W.baseColorTexture.extensions;return q&&q.KHR_texture_transform&&(H.set("khr_offset",q.KHR_texture_transform.offset||[0,0]),H.set("khr_rotation",q.KHR_texture_transform.rotation||0),H.set("khr_scale",q.KHR_texture_transform.scale||[1,1])),H.doubleSided=!(!T.doubleSided&&!P.doubleSided),H.once("complete",this._bindedListener),H}_getTexture(i,g){if(!i)return null;const m={type:i.type?oZ(i.type):"uint8",format:i.format?sZ(i.format):"rgba",flipY:!!i.flipY},_=i.image;if(g.push(_),_.array?m.data=_.array:_.mipmap&&(m.mipmap=_.mipmap),!m.data&&!m.mipmap)return null;if(m.width=_.width,m.height=_.height,m.mipmap&&(m.width<4||m.height<4))return null;const b=i.sampler||i.texture&&i.texture.sampler;return b&&(b.magFilter&&(m.mag=nZ(b.magFilter)),b.minFilter&&(m.min=rZ(b.minFilter)),b.wrapS&&(m.wrapS=iZ(b.wrapS)),b.wrapT&&(m.wrapT=iZ(b.wrapT))),new wP.Texture2D(m,this._resLoader)}_onResourceLoad({target:i}){const g=i._nodeId,m=this._loading[g];if(m.count--,!m.count){const i=m.meshes;this._modelMeshes[g]=i,delete this._loading[g];const _=i._callback;delete i._callback,_(null,{mesh:m.meshes,id:g})}}_getProjScale(i){const g=1/this.getMap().getGLRes(),m=this._heightScale;return i[0]=i[1]=g,i[2]=m,i}_coordToPoint(i){return this._layer._coordToPoint(i)}_pointToPrj(i){const g=this.getMap();return g.getGLZoom?g._pointToPrj(i,g.getGLZoom()):g._pointToPrjAtRes(i,g.getGLRes())}_prjToPoint(i){const g=this.getMap();return g.getGLZoom?g._prjToPoint(i,g.getGLZoom()):g._prjToPointAtRes(i,g.getGLRes(),IZ)}_getUpAxisTransform(i){return"Y"===i?cZ:"X"===i?uZ:xZ}pick(i,g,m=3){const _=this._layer;if(!_||!_.options.picking)return[];if(!this.pickingFBO||!this.picking)return[];const b=[],T=this._getUniformValues(),P=this._pickMesh(this.picking,T,this._modelScene,i,g,m);P&&b.push(P);const I=this._pickMesh(this.picking,T,this._i3dmScene,i,g,m);I&&b.push(I);const H=this._getPntsUniforms(),W=this._pickMesh(this._pntsPicking,H,this._pntsScene,i,g,m);return W&&b.push(W),b}_pickMesh(i,g,m,_,b,T){if(!m.getMeshes().length)return null;const P=this._layer,I=this.getMap();i.render(m.getMeshes().filter((i=>!i.bloom)),g,!0);let H={};i.getRenderedMeshes().length&&(H=i.pick(_,b,T,g,{viewMatrix:I.viewMatrix,projMatrix:I.projMatrix,returnPoint:P.options.pickingPoint}));const{meshId:W,pickingId:q,point:$,coordinate:ye}=H,Re=(0===W||W)&&i.getMeshAt(W);if(!Re||!Re.geometry)return null;const Be=Re.properties;$&&$.length&&($[0]=Math.round(1e5*$[0])/1e5,$[1]=Math.round(1e5*$[1])/1e5,$[2]=Math.round(1e5*$[2])/1e5);const Ge={batchId:q},je=P.options.services,Xe=je&&je[Re.properties.serviceIndex];if(Xe&&Xe.debug&&(Ge.debugInfo=Be),Be&&Be.batchTable){const{batchTable:i,batchTableBin:g,count:m}=Be,_=q;for(const b in i)Ge[b]=void 0!==i[b].byteOffset?lX(i[b],g,m,_):i[b][_]}return{service:Re.properties.serviceIndex,data:Ge,point:$,coordinate:ye}}highlight(i){this._highlighted=i;const g=this._layer.getRenderer();this._highlightTimestamp=g.getFrameTimestamp(),g.setToRedraw(!0)}cancelAllHighlight(){this._highlighted=null;const i=this._layer.getRenderer();this._highlightTimestamp=i.getFrameTimestamp(),i.setToRedraw(!0)}showOnly(i){this._showOnlys=i;const g=this._layer.getRenderer();this._showOnlyTimeStamp=g.getFrameTimestamp(),g.setToRedraw(!0)}cancelShowOnly(){this._showOnlys=null;const i=this._layer.getRenderer();this._showOnlyTimeStamp=i.getFrameTimestamp(),i.setToRedraw(!0)}_getCurrentBatchIDs(){if(!this._paintedMeshes)return[];const i={},g=[];for(const m in this._paintedMeshes){const _=this._paintedMeshes[m];if(_)for(let m=0;m<_.length;m++){const b=_[m],T=b&&b.geometry;if(!b||!T)continue;const P=b.properties.serviceIndex;i[P]||(i[P]=new Set);const I=T.properties.batchIdData;if(I)for(let m=0;m<I.length;m++)i[P].has(I[m])||(g.push({id:I[m],service:P}),i[P].add(I[m]))}}return g}hasIBL(){const i=this.getMap().getLightManager();return!(!i||!i.getAmbientResource())}}function QZ(i){for(let g=0;g<i.length;g++)i[g]&&(i[g].array&&(i[g].array=null),i[g].mipmap&&(i[g].mipmap=null),i[g].indices&&(i[g].indices=null))}function JZ(i,g){if(g)for(let m=0;m<g.length;m++)i[g[m].id||g[m].index]=g[m]}const KZ=[];class vn{constructor(i,g,m,_,b){this._layer=_,this._url=i,this._rootIdx=g,this._fnFetchNodepages=b,this._version=m.version,i.indexOf("i3s:tileset:")<0?(this._index=this._version<=1.6?"root":0,m.version=this._version):(this._index=i.substring(12),this._version>1.6&&(this._index=parseInt(this._index))),this._url=i,this._nodeCache=m}load(){const i=this._nodeCache,g=i.layerScene.baseUrl;if(this._version<=1.6)return i[this._index]&&i[this._index].lodSelection?(this._nodeJSON=i[this._index],this._loadNode()):new Promise((m=>{let _=g+"/nodes/"+this._index;i.layerScene.eslpk&&(_+="/3dNodeIndexDocument.json"),this._fnFetchNodepages(this._rootIdx,_,(()=>{this._nodeJSON=i[this._index],m(this._loadNode())}))}));if(this._version>=1.7){if(i[this._index])return this._nodeJSON=i[this._index],this._loadNode();const m=Math.floor(this._index/i.nodesPerPage);return new Promise((_=>{let b=g+"/nodepages/"+m;i.layerScene.eslpk&&(b+=".json"),this._fnFetchNodepages(this._rootIdx,b,(()=>{this._nodeJSON=i[this._index],_(this._loadNode())}))}))}return null}getTileset(){return this._tileset}getChildrenURL(){return this._childrenURL}_loadNode(){const i=this._nodeCache,g=i.layerScene.baseUrl,m=this._nodeJSON.children,_=[],b={};if(m)for(let T=0;T<m.length;T++)if(this._version<=1.6){const P=m[T].id;if(i[P])continue;const I=P;b[I]||(b[I]=new Promise((m=>{let _=g+"/nodes/"+I;i.layerScene.eslpk&&(_+="/3dNodeIndexDocument.json"),this._fnFetchNodepages(this._rootIdx,_,(()=>{m()}))})),_.push(b[I]))}else{const P=m[T];if(i[P])continue;const I=Math.floor(P/i.nodesPerPage);b[I]||(b[I]=new Promise((m=>{let _=g+"/nodepages/"+I;i.layerScene.eslpk&&(_+=".json"),this._fnFetchNodepages(this._rootIdx,_,(()=>{m()}))})),_.push(b[I]))}return _.length?Promise.all(_).then((()=>this._loadContent())):this._loadContent()}_loadContent(){return Promise.resolve(this._createTileset())}_fillCache(i){JZ(this._nodeCache,i)}_createTileset(){return{asset:{i3s:!0,version:"1.0",gltfUpAxis:"Z"},geometricError:Number.MAX_VALUE,root:this._convertNode(this._nodeJSON,!0)}}_convertNode(i){const g=this._layer.getRenderer(),m=this._nodeCache.projection,_=!m||m&&4326===m.wkid,b=this._version,T=this._nodeCache,P=i,I=P.obb,H=P.mbs,W={};let q;if(H)q=qA([],H[0],H[1],H[2]),_||(q=g._tileCoordToLngLat(q,q)),q=e$([],q[0],q[1],q[2]),W.sphere=[...q,H[3]];else if(I){q=qA([],I.center[0],I.center[1],I.center[2]),_||(q=g._tileCoordToLngLat(q,q)),q=e$([],q[0],q[1],q[2]);const i=function(i,g,m){const _=fA([],m);return _[0]=_[0]*g[0],_[1]=_[1]*g[0],_[2]=_[2]*g[0],_[3]=_[3]*g[1],_[4]=_[4]*g[1],_[5]=_[5]*g[1],_[6]=_[6]*g[2],_[7]=_[7]*g[2],_[8]=_[8]*g[2],[...i,..._]}(q,I.halfSize,I.quaternion);qA(KZ,i[3]+i[6]+i[9],i[4]+i[7]+i[10],i[5]+i[8]+i[11]);const m=gy(KZ);W.sphere=[...q,m]}let $=1/0,ye=0;if(P.mbs?ye=P.mbs[3]:P.obb&&(ye=Math.max(Math.max(P.obb.halfSize[0],P.obb.halfSize[1]),P.obb.halfSize[2])),void 0!==P.lodThreshold)"maxScreenThresholdSQ"===T.lodSelectionMetricType?$=ye/(Math.sqrt(P.lodThreshold)/(.25*Math.PI)):console.error("Unsupported lodSelectionMetricType in Layer");else if(void 0!==P.lodSelection)for(let i=0;i<P.lodSelection.length;i++)"maxScreenThreshold"===P.lodSelection[i].metricType&&($=ye/P.lodSelection[i].maxError);($===1/0||isNaN($))&&($=1e5);const Re=16*$,Be=mA([]),Ge=P.children;let je;if(Ge){je=[];const i=this._nodeCache;for(let g=0;g<Ge.length;g++){const m=b<=1.6?Ge[g].id:Ge[g];if(!i[m]){je=null;break}je.push(this._convertNode(i[m]))}}const Xe={refine:"REPLACE",boundingVolume:W,transform:Be,geometricError:Re};return b<=1.6?i.lodSelection?i.geometryData&&(Xe.content={uri:"i3s:mesh:"+(i.id||i.index)}):Xe.content={uri:"i3s:tileset:"+(i.id||i.index)}:Ge&&Ge.length&&!je?Xe.content={uri:"i3s:tileset:"+(i.id||i.index)}:P.mesh&&(Xe.content={uri:"i3s:mesh:"+(i.id||i.index)}),je&&je.length&&(Xe.children=je),Xe}getJSON(){return this._nodeJSON}}function e$(i,g,m,_){return Bq(i,eq(g),eq(m),_)}const t$=!!_q.ktx2,n$=mA([]),r$=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const i=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(i instanceof WebAssembly.Module)return new WebAssembly.Instance(i)instanceof WebAssembly.Instance}}catch(i){}return!1})();function i$(i){return i.indexOf("i3s:mesh")>=0}function o$(i,g,m,_,b){const T=g.layerScene.eslpk,P=function(i,g){const m=g.substring(9);return i>=1.7?parseInt(m):m}(g.version,i),I=g[P],H=g.layerScene.baseUrl,W=[];let q=!1;const $=n$;let ye,Re;if(g.version<=1.6){if(!I.geometryData)return null;const i=I.geometryData.length;if(!i)return null;let m=H+`/nodes/${I.id}/`+I.geometryData[i-1].href;T&&(m+=".bin");const _={geometry:{url:m,info:g.layerScene.store.defaultGeometrySchema}};let b=I.textureData&&I.textureData[0]&&I.textureData[0].href;if(b){const i=g.layerScene.store.textureEncoding[0];let m;m="image/jpeg"===i?"jpg":"png",T&&(b+="."+m);_.material={pbrMetallicRoughness:{baseColorTexture:{url:H+`/nodes/${I.id}/`+b,factor:1,format:m,mimeType:i},metallicFactor:0}}}W.push(_)}else{ye=I.mesh.geometry,Re=I.mesh.material;const i=(g.layerScene.store||{}).textureEncoding,P=g.layerScene.geometryDefinitions[ye.definition],{geometryBuffers:$}=P;q=_&&2===$.length;let Be=H+`/nodes/${ye.resource}/geometries/`+(_q.draco&&q?1:0);T&&(Be+=".bin");const Ge={geometry:{url:Be,info:_q.draco&&q?$[1]:$[0]}};if(b&&r$&&q&&!_q.draco)throw new Error("Must import @maptalks/transcoder.draco to load i3s draco compressed geometry");const je=g.layerScene.materialDefinitions;let Xe,Ze=0;Re&&(Ze=je[Re.definition]),Xe=je?function(i,g,m,_,b,T,P){const I=JSON.parse(JSON.stringify(g));return s$(i,I,m,_,b,T,P),I}(i,Ze,g.layerScene.textureSetDefinitions,H,Re.resource,m,g.layerScene.eslpk):{pbrMetallicRoughness:{metallicFactor:0}},Ge.material=Xe,W.push(Ge)}return{dracoCompression:q,meshes:W,nodeIndex:P,center:I.obb&&I.obb.center||I.mbs&&[I.mbs[0],I.mbs[1],I.mbs[2]],transform:$}}function s$(i,g,m,_,b,T,P){for(const I in g)if(g[I]&&g[I].textureSetDefinitionId>=0){const H=m[g[I].textureSetDefinitionId],W="images/"+H.formats[0].format,q=l$(H.formats,T,i),$={url:_+`/nodes/${b}/textures/${q.name}`,factor:void 0===g[I].factor?1:g[I].factor,format:q.format,mimeType:W};if(P){let i="";switch(q.format){case"dds":i="bin.dds";break;case"jpg":case"png":i=q.format}$.url+="."+i}g[I]=$}else JW(g[I])&&s$(i,g[I],m,_,b,T,P)}const a$={"image/jpeg":"jpg","image/jpg":"jpg","image/png":"jpg","image/vnd-ms.dds":"dds","image/ktx":"jpg"};function l$(i,g,m){if(m&&m.length){const g=m[m.length-1],_=a$[g];if(_){for(let g=0,m=i.length;g<m;g++)if(i[g].format===_)return i[g]}else console.error("i3s not find texture format type from:",a$,"current textureEncoding:",g)}for(let m=0;m<=i.length;m++){const _=i[m].format;if("dds"===_&&g.hasExtension("WEBGL_compressed_texture_s3tc"))return i[m];if("jpg"===_||"png"===_)return i[m];if("ktx2"===_&&t$)return i[m]}return null}const{Ajax:h$}=vq(),c$=new pl(0,0),u$=new pl(0,0),f$=new Set,d$=[],p$=new class{constructor(i,g){this.max=i,this.currentSize=0,this.data=new Map,this.onRemove=g}reset(i){if(this.data){const g=this.data.keys();for(const m of g){const g=this.data.get(m);i&&i!==g.renderer||this._remove(m,g)}}return i||(this.data=new Map,this.currentSize=0),this}clear(i){this.reset(i)}add(i,g){if(!g)return this;if(g.node&&g.node.memorySize&&(this.currentSize+=g.node.memorySize),this.has(i)){const m=this.data.get(i);m&&m.node&&m.node.memorySize&&(this.currentSize-=m.node.memorySize),this.data.delete(i),this.data.set(i,g)}else this.data.set(i,g);return this}shrink(){if(this.currentSize>this.max){let i=!1;const g=this.data.keys();let m=g.next();for(;this.currentSize>this.max&&void 0!==m.value;){!i&&this.data.get(m.value).current&&(i=!0,console.warn(`current maxGPUMemory(${this.max/1024/1024}) for Geo3DTilesLayer is not enough, one or more current tiles will be discarded.`));const _=this.getAndRemove(m.value);_&&this.onRemove(_),m=g.next()}}}has(i){return this.data.has(i)}keys(){const i=new Array(this.data.size);let g=0;const m=this.data.keys();for(const _ of m)i[g++]=_;return i}getAndRemove(i){if(!this.has(i))return null;const g=this.data.get(i);return g.node&&g.node.memorySize&&(this.currentSize-=g.node.memorySize),this.data.delete(i),g}get(i){if(!this.has(i))return null;const g=this.data.get(i);return this.data.delete(i),this.data.set(i,g),g}remove(i){if(!this.has(i))return this;const g=this.data.get(i);return this._remove(i,g),this}_remove(i,g){g.node&&g.node.memorySize&&(this.currentSize-=g.node.memorySize),this.data.delete(i),this.onRemove(g)}setMaxSize(i){return this.max=i,this.shrink(),this}getMemorySize(){let i=0;const g=this.data.values();for(const m of g){const g=m&&m.node;g&&g.memorySize&&(i+=g.memorySize)}return i}markAll(i,g){const m=this.data.values();for(const _ of m)i&&_.renderer!==i||(_.current=g)}}(1024*($t.mobile?32:1024)*1024,(i=>{const g=i.renderer;delete i.renderer,g.deleteTile(i)}));let g$=0;class zn extends(uO(Ck(Om.LayerAbstractRenderer))){constructor(i){super(i);const g=1024*i.options.maxGPUMemory*1024;g>p$.max&&p$.setMaxSize(g),this.tileCache=p$,g$++,this.tilesLoading={},this._requests={},this._modelQueue=[],this._fnFetchNodepages=(...i)=>this._fetchI3DNodepages.call(this,...i)}getAnalysisMeshes(){if(!this.painter)return d$;const i=this.painter.getPaintedMeshes();if(!i)return d$;const g=[],{b3dmMeshes:m,pntsMeshes:_,i3dmMeshes:b}=i;return m.length&&uq(g,m.filter((i=>!(!i||!i.geometry)))),_.length&&uq(g,_.filter((i=>!(!i||!i.geometry)))),b.length&&uq(g,b.filter((i=>!(!i||!i.geometry)))),g}needToRedraw(){return!!this.getMap().isInteracting()||!!this._modelQueue.length||super.needToRedraw()}getFrameTimestamp(){return this._timestamp}drawOnInteracting(i,g,m){this.draw(g,m)}draw(i,g){this._timestamp=i;const m=this.prepareCanvas();if(m&&!m.intersects(this.canvasExtent2D))return void this.completeRender();const{root:_,tiles:b}=this.layer.getTiles();if(!b||!b.length)return void this.completeRender();this.painter.prepareRender(g),this._consumeI3SQueue(),this._consumeModelQueue(g);const{selectedTiles:T,requests:P}=this._selectTiles(_,b);P.length&&this.loadTiles(P),this._drawTiles(T,g),this._abortUnusedTiles(),P.length||this.completeRender()}_selectTiles(i,g){let m=[];this._markTiles();let _=0;const b=this._getLoadLimit(),T={};let P=!1,I=!1;for(let i=0;i<g.length;i++){const b=g[i],H=b.node;if(T[H.id])continue;T[H.id]=1;let W=!1;const q=this.getCachedTile(H.id);(this._isLoadingTile(H.id)?(_++,W=I=!0,this.tilesLoading[H.id].current=!0):q?(this.getTileOpacity(q)<1&&(W=I=!0),P=!0,b.selected=!0,b.data=q):this.painter.has(H)||(W=I=!0,m.push(H)),W)&&((this._selectParentTile(b)||this._selectChildTile(b).length)&&(P=!0))}const H=P?this._sortTiles(i):[];if(m.length>1&&(m.sort(m$),b)){const i=b-_;m=i>0?m.slice(0,i):[]}return{loading:I,requests:m,selectedTiles:H}}_sortTiles(i){const g=[];let m,_;const b=[i],T=[];for(;b.length>0||T.length>0;){if(T.length>0){const i=T[T.length-1];if(i._stackLength===b.length){T.pop(),i===m&&(i.leave=!0),i.branchRootId=_,g.push(i),0===T.length&&(_=null);continue}}const i=b.pop(),P=i.children;if(i.selected)if("add"===i.node.refine)i.leave=!0,i.selectionDepth=T.length,i.branchRootId=_,g.push(i);else{if(i.selectionDepth=T.length,m=i,0===P.length){i.leave=!0,i.branchRootId=_,g.push(i);continue}0===T.length&&(_=i.node.id),T.push(i),i._stackLength=b.length}for(let i=0;i<P.length;i++)b.push(P[i])}return g}_selectParentTile(i){if(!i.parent)return null;let g=i.parent;for(;g&&g.level>=0;){const i=g.node.id;if(this.tileCache.has(i))return g.selected=!0,g.data=this.tileCache.get(i),g;g=g.parent}return null}_selectChildTile(i){const g=[];if(!i.node.children||!i.node.children.length)return g;const m=i._level+1,_=[i.node];for(;_.length>0;){const b=_.pop().children;for(let T=0,P=b.length;T<P;T++){if((!b[T].content||!b[T].content.url)&&b[T].children&&b[T].children.length){_.push(b[T]);continue}const P=b[T].id;if(this.tileCache.has(P)){const m=this.layer._createCandidate(b[T],i);m.selected=!0,m.data=this.tileCache.get(P),i.children.push(m),g.push(m)}else b[T]._level<=m&&_.push(b[T])}}return g}_drawTiles(i,g){this.tileCache.markAll(this,!1);const m=[];for(let g=0,_=i.length;g<_;g++){const _=i[g].data;_.current=!0,_.renderer=this,this.tileCache.add(i[g].node.id,_);const b=_.node,T=this.layer._getNodeService(b._rootIdx);b._boxMesh&&T.debug&&!Array.isArray(T.debug)&&m.push(b._boxMesh)}const _=this.layer.options.services;for(let i=0;i<_.length;i++){const g=_[i],b=Array.isArray(g.debug)&&g.debug;if(b)for(const i of b){const g=this.layer._getNodeBox(i),_=g&&g.node;_&&_._boxMesh&&m.push(_._boxMesh)}}const b={tiles:i};this.onDrawTileStart(b);const T=this.painter.paint(i,m,g);this.layer.fire("drawtiles",{count:T}),this.onDrawTileEnd(b),T&&this.layer.fire("canvasisdirty",{renderCount:T}),this.tileCache.shrink()}onDrawTileStart(){}onDrawTileEnd(){}loadTiles(i){for(let g=0,m=i.length;g<m;g++){const m=i[g];this.tilesLoading[m.id]={current:!0,node:m},this.loadTile(m)}}loadTile(i){let g=i.content.url;if(hq(g)){const m=cq(g);return this._loadTileContent(g,m,i),null}if(function(i){return i.indexOf("i3s:tileset")>=0}(g)){const m=i._rootIdx;return new vn(g,m,this._i3sNodeCache[m],this.layer,this._fnFetchNodepages).load().then((m=>{this.onTilesetLoad(m,i,g)}))}return i&&gq(g)&&!i$(g)&&(g=i.baseUrl+g),this._loadTileContent(g,null,i),null}_loadTileContent(i,g,m){let _=this._supportedFormats;_||(_=wP.Util.getSupportedFormats(this.gl||this.device),this._supportedFormats=_);const b=this.layer._getNodeService(m._rootIdx);b.isSuperMapiServer&&(i=function(i,g){const m=i.substring(g.length).split("/"),_=[];for(let i=0;i<m.length;i++)_.push(encodeURIComponent(m[i]));return g+_.join("/")}(i,m.baseUrl));const T={url:this.layer.getTileUrl(i,this.layer._roots[m._rootIdx]),arraybuffer:g,rootIdx:m._rootIdx,upAxis:m._upAxis,transform:m.matrix,supportedFormats:_};if(i$(i)){const g=this._i3sNodeCache[m._rootIdx];if(T.projection=g.projection,T.i3sInfo=o$(i,g,this.regl||this.device,this.layer.options.enableI3SCompressedGeometry,this.layer.options.forceI3SCompressedGeometry),!T.i3sInfo)return void this.onTileError({status:404},m,i)}T.service=YW({},b),b.offset&&delete T.service.offset,T.referrer=window&&window.location.href,this.workerConn.loadTile(this.layer.getId(),T,((g,_)=>{if(g)return void this.onTileError(g,m,i);const{magic:b}=_;"b3dm"===b||"pnts"===b||"i3dm"===b||"cmpt"===b||"gltf"===b?this._modelQueue.push({data:_,tile:m}):this.onTilesetLoad(_,m,i)}))}_createBoxMesh(i){this.painter&&this.painter._createBoxMesh(i)}_deleteBoxMesh(i){this.painter&&this.painter._deleteBoxMesh(i)}_consumeModelQueue(){const i=this.getMap(),g=this.layer.options.meshLimitPerFrame;let m=0;for(;this._modelQueue.length&&(m<g||!i.isInteracting());){const{data:i,tile:g}=this._modelQueue.shift(),{magic:_}=i;"b3dm"===_||"gltf"===_?this.painter.createB3DMMesh(i,g.id,g,((m,{mesh:_})=>{this._onMeshCreated(i,g,m,_)})):"pnts"===_?this.painter.createPntsMesh(i,g.id,g,((m,{mesh:_})=>{this._onMeshCreated(i,g,m,_)})):"i3dm"===_?this.painter.createI3DMMesh(i,g.id,g,((m,{mesh:_})=>{this._onMeshCreated(i,g,m,_)})):"cmpt"===_&&this.painter.createCMPTMesh(i,g.id,g,((m,{mesh:_})=>{this._onMeshCreated(i,g,m,_)})),m++}}_onMeshCreated(i,g,m,_){if(this._enableLayerOpacity(_),m)this.onTileError(m,g);else{const m=this._getMeshSize(_);g.memorySize=m,this.onTileLoad(i,g)}}_enableLayerOpacity(i){if(Array.isArray(i)){for(let g=0;g<i.length;g++)if(i[g])if(Array.isArray(i[g]))this._enableLayerOpacity(i[g]);else{const m=i[g].defines||{};m.HAS_LAYER_OPACITY=1,i[g].setDefines(m)}}else if(i)if(Array.isArray(i))this._enableLayerOpacity(i);else{const g=i.defines||{};g.HAS_LAYER_OPACITY=1,i.setDefines(g)}}_getMeshSize(i){let g=0;if(Array.isArray(i))for(let m=0;m<i.length;m++)i[m]&&(g+=this._getMeshSize(i[m]));else i&&(g+=i.getMemorySize());return g}onTileLoad(i,g){this.layer&&(delete this.tilesLoading[g.id],this.layer.onTileLoad(i,g),this._addTileToCache(g),this.setToRedraw(),this.layer.fire("tileload",{node:g}))}onTilesetLoad(i,g,m){this.layer&&(this.layer._vertexCompressionType=i.extensions&&i.extensions["s3m:VertexCompressionType"],i.capabilities||i.layers&&i.layers[0]&&i.layers[0].capabilities?this._parseI3SSceneLayer(i,g,m):(delete this.tilesLoading[g.id],this.layer.onTilesetLoad(i,g,m)))}onTileError(i,g,m){if(!this.layer)return;const _=m||g.content.url,b=i&&i.message||i;i&&(404===i.status||204===i.status)||f$.has(b)||(console.warn("failed to load 3d tile: "+_),console.warn(i),f$.add(b)),delete this.tilesLoading[g.id],(!this.layer.options.onlyCacheNoContentTileWhenError||i&&!Po.isNoContentHttpCode(i.status))&&this._addErrorToCache(g,i),this.layer.fire("tileerror",{node:g,error:i})}getCachedTile(i){return this.tileCache.get(i)}getShadowMeshes(){if(!this.painter)return[];const i=[],g=this.painter.getCurrentB3DMMeshes();for(const m in g)g[m]&&g[m].isValid&&g[m].isValid()&&i.push(g[m]);const m=this.painter.getCurrentI3DMMeshes();for(const g in m)m[g]&&m[g].isValid&&m[g].isValid()&&i.push(m[g]);return i}_addErrorToCache(i,g){const m={loadTime:Po.now(),current:!0,error:g,node:i};m.renderer=this,this.tileCache.add(i.id,m)}_addTileToCache(i){const g={loadTime:Po.now(),current:!0,node:i};g.renderer=this,this.tileCache.add(i.id,g)}abortTileLoading(i){if(!i||!this.workerConn)return;const g=i.node.content.url;this.workerConn.abortTileLoading(this.layer.getId(),g),delete this._requests[g]}_markTiles(){if(this.tilesLoading)for(const i in this.tilesLoading)this.tilesLoading[i].current=!1}deleteTile(i){this.painter.deleteTile(i)}initContext(){super.initContext();const i=this.layer,{regl:g,reglGL:m,device:_}=this.context;this.regl=g,this.device=_,this.gl=m;const b=g||_;this.prepareWorker(),this.canvas.pickingFBO=this.canvas.pickingFBO||b.framebuffer(this.canvas.width,this.canvas.height),this.pickingFBO=this.canvas.pickingFBO||b.framebuffer(this.canvas.width,this.canvas.height),this.painter=new Tn(b,i),this.layer._resumeHighlights(),this.layer.fire("contextcreate",{regl:g,device:_})}prepareWorker(){const i=this.getMap();this.workerConn||(this.workerConn=new ze("@maptalks/3dtiles",i.id,wP.Util.supportNPOT(this.regl||this.device)));const g=this.workerConn;if(!g.isActive())return;let m=this.layer.options||{};m=YW({},m),delete m.offset;const _=i.options.spatialReference;m.projection=_&&_.coordType||_&&_.projection||i.getSpatialReference().getProjection().code;const b=this.layer.getId();g.addLayer(b,m,(i=>{if(i)throw i;this.layer&&(this.ready=!0,this.layer.fire("workerready"))}))}onRemove(){this.painter&&this.painter.remove(),this.pickingFBO&&(this.canvas.pickingFBO||this.pickingFBO.destroy(),delete this.pickingFBO),this.workerConn&&(this.workerConn.removeLayer(this.layer.getId(),(i=>{if(i)throw i})),this.workerConn.remove(),delete this.workerConn),g$--,g$||p$.reset(),this.clear(),delete this.tileCache,delete this.gl,delete this.regl,super.onRemove()}clear(){this._abortUnusedTiles(!0),this.tileCache.reset(this),this.tilesLoading={},super.clear()}getTileOpacity(){return 1}getStencilValue(){return 0}_abortUnusedTiles(i){this._preRetireTime||(this._preRetireTime=Date.now());const g=Date.now();if(!i&&g-this._preRetireTime<this.layer.options.retireInterval)return;this._preRetireTime=g;const m=[];for(const g in this.tilesLoading){const _=this.tilesLoading[g];!i&&_.current||(m.push(g),this.abortTileLoading(_))}for(let i=0;i<m.length;i++)delete this.tilesLoading[m[i]]}_getLoadLimit(){return this.getMap().isInteracting()?this.layer.options.loadingLimitOnInteracting:this.layer.options.loadingLimit}_createGLContext(i,g){const m=["webgl","experimental-webgl"];let _=null;for(let b=0;b<m.length;++b){try{_=i.getContext(m[b],g)}catch(i){}if(_)break}return _}_isLoadingTile(i){return!!this.tilesLoading[i]}getI3DMMeshes(){return this.painter.getI3DMMeshes()}getPNTSMeshes(){return this.painter.getPNTSMeshes()}getB3DMMeshes(){return this.painter.getB3DMMeshes()}readBatchData(i,g,m){return sX(i,g,0,m)}_consumeI3SQueue(){if(!this._i3sRequests)return;const i=this.layer.options.i3sNodepageLimitPerFrame||Number.MAX_VALUE;let g=0;const m=[];for(const _ in this._i3sRequests){const b=this._i3sRequests[_];if("pending"===b.status)continue;b.status="pending";const T=b.rootIdx,P=mq(this.layer._getNodeService(T).fetchOptions);if(m.push(h$.getJSON(_,P).then((i=>{delete this._i3sRequests[_];const g=this._i3sNodeCache[T];if(g){i.nodes?JZ(g,i.nodes):(g[i.id]=i,JZ(g,i.children));for(let i=0;i<b.length;i++)b[i]();this.setToRedraw()}else this.setToRedraw()}))),g++,g>=i)break}m.length&&Promise.all(m)}_fetchI3DNodepages(i,g,m){this._i3sRequests||(this._i3sRequests={}),this._i3sRequests[g]=this._i3sRequests[g]||[],this._i3sRequests[g].rootIdx=i,this._i3sRequests[g].push(m),this.setToRedraw()}_parseI3SSceneLayer(i,g,m){this._i3sNodeCache||(this._i3sNodeCache=[]);const _=g._rootIdx;this._i3sNodeCache[_]||(this._i3sNodeCache[_]={});const b=this._i3sNodeCache[_],T=this.layer._getNodeService(_);i.layers&&(i=i.layers[0],"/"!==m[m.length-1]&&(m+="/"),m+="layers/0"),b.version=+(T.i3sVersion||i.store.version),!i.spatialReference||i.spatialReference.wkid&&4326===i.spatialReference.wkid||console.warn("i3s has a spatialReference other than 4326.",i.spatialReference),i.spatialReference&&4490===i.spatialReference.wkid&&(console.warn("i3s spatialReference is 4490,auto set spatialReference to 4326,This may cause some location issues, please ensure that your service is 4326"),i.spatialReference.wkid=4326),b.projection=i.spatialReference,function(i,g,m,_,b,T,P){if(!T.layerScene){T.layerScene=g,T.nodesPerPage=g.nodePages&&g.nodePages.nodesPerPage||64,T.lodSelectionMetricType=g.nodePages&&g.nodePages.lodSelectionMetricType;let i=b;if(T.layerScene.eslpk=i.indexOf("3dSceneLayer.json")>=0,i.endsWith(".json")){const g=b.lastIndexOf("/");i=g<0?"./":b.substring(0,g)}T.layerScene.baseUrl=function(i){return i.split("?")[0]}(i)}return new vn(b,m,T,i,P).load()}(this.layer,i,_,0,m,b,this._fnFetchNodepages).then((i=>{this.onTilesetLoad(i,g,m)}))}pick(i,g,m){if(!this.painter)return[];const _=this.pickingFBO,{width:b,height:T}=this.canvas;return!this.pickingFBO||_.width===b&&_.height===T||_.resize(b,T),this.painter.pick(i,g,m&&m.tolerance)}highlight(i){if(this._highlighted||(this._highlighted=[]),Array.isArray(i))for(let g=0;g<i.length;g++){const m=i[g].service||0;let _=this._highlighted[m];_||(_=this._highlighted[m]=new Map),_.set(i[g].id,i[g])}else{const g=i.service||0;let m=this._highlighted[g];m||(m=this._highlighted[g]=new Map),m.set(i.id,i)}this.painter.highlight(this._highlighted)}cancelHighlight(i,g){if(!this._highlighted)return;const m=this._highlighted[i];if(m){if(Array.isArray(g))for(let i=0;i<g.length;i++)m.delete(g[i]);else m.delete(g);m.size||(this._highlighted[i]=null),this.painter.highlight(this._highlighted)}}cancelAllHighlight(){delete this._highlighted,this.painter.cancelAllHighlight()}showOnly(i){if(this._showOnlys||(this._showOnlys=[]),Array.isArray(i))for(let g=0;g<i.length;g++){const m=i[g].service||0;let _=this._showOnlys[m];_||(_=this._showOnlys[m]=new Map),_.set(i[g].id,i[g])}else{const g=i.service||0;let m=this._showOnlys[g];m||(m=this._showOnlys[g]=new Map),m.set(i.id,i)}this.painter.showOnly(this._showOnlys)}cancelShowOnly(){delete this._showOnlys,this.painter.cancelShowOnly()}_getCurrentBatchIDs(){return this.painter?this.painter._getCurrentBatchIDs():[]}_tileCoordToLngLat(i,g){const m=this.getMap();if("identity"===m.getProjection().code.toLowerCase()){const m=this._getCoordProjection();return c$.set(g[0],g[1]),m.unproject(c$,u$),i[0]=u$.x,i[1]=u$.y,i}return c$.set(g[0],g[1]),m.getProjection().unproject(c$,u$),i[0]=u$.x,i[1]=u$.y,i}_lngLatToIdentityCoord(i,g){const m=this._getCoordProjection();return c$.set(g[0],g[1]),m.project(c$,u$),i[0]=u$.x,i[1]=u$.y,i}_identityCoordToLngLat(i,g){const m=this._getCoordProjection();return c$.set(g[0],g[1]),m.unproject(c$,u$),i[0]=u$.x,i[1]=u$.y,i}_getCoordProjection(){const i=this.getMap().options.spatialReference.coordType;if(!i)throw new Error("Missing coordType in map spatialReference.");return this._centerProjection||(this._centerProjection=uu.getProjectionInstance(i)),this._centerProjection}}function m$(i,g){return i._cameraDistance-g._cameraDistance}function A$(i,g,m){return i[0]=g[m],i[1]=g[m+3],i[2]=g[m+6],i}const y$=[],_$=[],v$=[],x$=[],b$=[],w$=2*Math.PI;class Xn{constructor(i,g,m,_){this.west=i,this.south=g,this.east=m,this.north=_}static contains(i,g){let m=g[0];const _=g[1],b=i.west;let T=i.east;return T<b&&(T+=w$,m<0&&(m+=w$)),(m>b||eX(m,b,1e-14))&&(m<T||eX(m,T,1e-14))&&_>=i.south&&_<=i.north}static southwest(i,g){return g[0]=i.west,g[1]=i.south,g[2]=0,g}static northeast(i,g){return g[0]=i.east,g[1]=i.north,g[2]=0,g}static southeast(i,g){return g[0]=i.east,g[1]=i.south,g[2]=0,g}static northwest(i,g){return g[0]=i.west,g[1]=i.north,g[2]=0,g}}const T$=[0,0,1];function S$(i,g){return Bq(g,i[0],i[1],i[2])}class eo{constructor(i,g){this.normal=WA([],i),this.distance=g}static fromPointNormal(i,g,m){const _=-ry(g,i);return WA(m.normal,g),m.distance=_,m}}const M$=[],C$=[],P$=[],I$=[],k$=[],O$=[],E$=[],R$=[],L$=[],D$=[],F$=new eo([1,0,0],0),N$=[];class po{constructor(i){this.southwestCornerCartesian=[],this.northeastCornerCartesian=[],this.westNormal=[],this.eastNormal=[],this.southNormal=[],this.northNormal=[],this.rectangle=new Xn(...i),this.minimumHeight=i[4],this.maximumHeight=i[5],this.computeBox(this.rectangle)}distanceToCamera(i,g){let m=0;if(!Xn.contains(this.rectangle,g)){const g=this.northeastCornerCartesian,_=this.westNormal,b=this.southNormal,T=this.eastNormal,P=this.northNormal,I=ZA(N$,i,this.southwestCornerCartesian),H=ry(I,_),W=ry(I,b),q=ZA(N$,i,g),$=ry(q,T),ye=ry(q,P);H>0?m+=H*H:$>0&&(m+=$*$),W>0?m+=W*W:ye>0&&(m+=ye*ye)}const _=g[2],b=this.minimumHeight,T=this.maximumHeight;if(_>T){const i=_-T;m+=i*i}else if(_<b){const i=b-_;m+=i*i}return Math.sqrt(m)}computeBox(i){const g=this;S$(Xn.southwest(i,C$),g.southwestCornerCartesian),S$(Xn.northeast(i,C$),g.northeastCornerCartesian),M$[0]=i.west,M$[1]=.5*(i.south+i.north),M$[2]=0;const m=S$(M$,P$),_=iy(k$,m,T$);ny(g.westNormal,_),M$[0]=i.east;const b=S$(M$,R$),T=iy(k$,T$,b);ny(g.eastNormal,T);const P=ZA(k$,m,b),I=ny(I$,P),H=i.south;let W;if(H>0){M$[0]=.5*(i.west+i.east),M$[1]=H;const m=S$(M$,L$);WA(D$,I);const _=eo.fromPointNormal(g.southwestCornerCartesian,g.westNormal,F$);H$(L$,D$,_,g.southwestCornerCartesian),W=Qq(m,O$)}else W=Jq(Xn.southeast(i,C$),O$);const q=iy(E$,W,P);ny(g.southNormal,q);const $=i.north;let ye;if($<0){M$[0]=.5*(i.west+i.east),M$[1]=$;const m=S$(M$,L$);QA(D$,I,-1);const _=eo.fromPointNormal(g.northeastCornerCartesian,g.eastNormal,F$);H$(L$,D$,_,g.northeastCornerCartesian),ye=Qq(m,O$)}else ye=Jq(Xn.northwest(i,C$),O$);const Re=iy(E$,P,ye);ny(g.northNormal,Re)}}function H$(i,g,m,_){const b=i,T=g,P=m.normal,I=ry(P,T);if(Math.abs(I)<1e-15)return;const H=(-m.distance-ry(P,b))/I;return H<0?void 0:XA(_=QA(_,T,H),b,_)}function B$(i){return[i.xmin,i.ymin,i.xmax,i.ymax]}const z$=Yo,V$={services:[],maxGPUMemory:$t.mobile?32:1536,retireInterval:2e3,loadingLimitOnInteracting:5,loadingLimit:10,debug:!1,meshLimitPerFrame:1,i3sNodepageLimitPerFrame:1,enableI3SCompressedGeometry:!0,forceI3SCompressedGeometry:!0,onlyCacheNoContentTileWhenError:!0,picking:!0,pickingPoint:!0,geometryEvents:!1,alwaysShowTopTiles:!0,antialias:!1,offset:[0,0],renderer:"gl",forceRenderOnZooming:!0,forceRenderOnRotating:!0,forceRenderOnMoving:!0,optionalExtensions:["ANGLE_instanced_arrays","OES_element_index_uint","OES_standard_derivatives","OES_vertex_array_object","OES_texture_half_float","OES_texture_half_float_linear","OES_texture_float","OES_texture_float_linear","WEBGL_depth_texture","EXT_shader_texture_lod","WEBGL_compressed_texture_astc","WEBGL_compressed_texture_etc","WEBGL_compressed_texture_etc1","WEBGL_compressed_texture_pvrtc","WEBGL_compressed_texture_s3tc","WEBGL_compressed_texture_s3tc_srgb"]},U$=[0,0,0],G$=[0,0,0],j$=[0,0,0],W$=[0,0,0],q$=[0,0,0],X$=[0,0,0],Z$=[0,0,0],$$=[1,1,1],Y$=[1,1,1],Q$=[0,0,0,0],J$=[],K$=new pl(0,0),eY=new un(0,0),tY=[0,0,0,0,0,0,0,0,0],nY=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],rY=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],iY=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],oY=new un(0,0),sY=mA([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),aY=[0,0],lY=[0,0,0],hY=[1,1,1],cY=[0,0,0],uY=[0,0,0],fY=[0,0,0,0],dY=[1,1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1];class Vo extends(WO(Fu)){static fromJSON(i){return i&&"Geo3DTilesLayer"===i.type?new Vo(i.id,i.options):null}static getEnuTransform(i,g=[1,1,1],m=[0,0,0]){const _=Bq([],i[0]*Math.PI/180,i[1]*Math.PI/180,i[2]||0),b=SX(_,null,[]),T=OA([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],o_([0,0,0,0],...m),[0,0,0],g);return _A(T,b,T)}constructor(i,g){super(i,g),this.isGeo3DTilesLayer=!0,this._initRoots(),this._nodeBoxes=[]}_initRoots(){const i=this.options.services.map((i=>i.url));this._rootMap=this._rootMap||{},this._roots=this._roots||[];for(let g=0;g<i.length;g++){const m=i[g];let _=this._rootMap[m];void 0===_&&(_=this._rootMap[m]=this._roots.length),this._roots[_]=mY(m,_,this.options.services[g])}this.fire("rootready",{roots:this._roots.slice(0)})}showService(i){return this.updateService(i,{visible:!0}),this}hideService(i){return this.updateService(i,{visible:!1}),this}setToRedraw(){return this._setToRedraw(),this}addService(i){return this.options.services=this.options.services||[],this.options.services.push(i),this._initRoots(),this._setToRedraw(),this}updateService(i,g){if(!g)return this;const m=this.options.services;let _=!1;m&&m[i]&&(_=!(_Y(m[i].coordOffset,g.coordOffset)&&_Y(m[i].heightOffset,g.heightOffset)&&_Y(m[i].scale,g.scale)&&_Y(m[i].rotation,g.rotation)),YW(m[i],g));const b=this._roots&&this._roots[this._rootMap[m[i].url]];return b&&($W(g.visible)||(b.visible=g.visible),_&&b.version++),this._setToRedraw(),this}removeService(i){const g=this.options.services;if(g&&g[i]){const m=g[i].url,_=this._rootMap[m];this._roots[_]&&(this._roots[_]=null),delete this._rootMap[m],g.splice(i,1)}return this._setToRedraw(),this}getTileUrl(i,g){const m=g&&g.service&&g.service.subdomains;if(m&&g.domainKey){const _=m.length;if(_){const b=[...i].reduce(((i,g)=>i+g.charCodeAt(0)),0)%_;return i.replace(g.domainKey,m[b])}}return i}getExtent(i){if(!i&&0!==i){const i=new Pl;for(let g=0;g<this._roots.length;g++){const m=this._roots[g];if(m&&m.boundingVolume){const g=this.boundingVolumeToExtent(m);i._combine(g)}}return i}const g=this._roots[i];return g&&g.boundingVolume?this.boundingVolumeToExtent(g):null}boundingVolumeToExtent(i){const g=i.boundingVolume._centerTransformed?sY:i.matrix,m=this.getMap(),_="identity"===m.getProjection().code.toLowerCase(),b=this.getRenderer();if(i.boundingVolume.region){const g=i.boundingVolume.region;return new Pl(tq(g[0]),tq(g[1]),tq(g[2]),tq(g[3]))}if(i.boundingVolume.sphere){const T=i.boundingVolume.sphere,P=Wq([],oy([0,0,0],T,g));_&&b._lngLatToIdentityCoord(P,P);const I=T[3],H=m.locate(P,-I,I),W=m.locate(P,I,-I);return new Pl(H,W)}if(i.boundingVolume.box){const T=i.boundingVolume.box,P=oy([0,0,0],T,g),I=new pl(Wq([],P));_&&b._lngLatToIdentityCoord(I,I);const H=T.slice(3);cA(H,sA([0,0,0,0,0,0,0,0,0],i.matrix),H);const W=GA(H.slice(0,3)),q=GA(H.slice(3,6)),$=GA(H.slice(6,9)),ye=Math.max(W,q,$),Re=m.locate(I,-ye,ye),Be=m.locate(I,ye,-ye);return new Pl(Re,Be)}return null}getRootTiles(){return this._roots}getTiles(){const i=this.getRenderer();if(!i.ready)return this._setToRedraw(),{tiles:J$};const g=this.getMap(),m=g.cameraPosition,_=g.pointAtResToDistance(m[2],0,g.getGLRes()),b=this._getCameraLonLat(m);this._cameraLocation=this._cameraLocation||[0,0,0],qA(this._cameraLocation,eq(b.x),eq(b.y),_),this._cameraCartesian3=Bq(this._cameraCartesian3||[],this._cameraLocation[0],this._cameraLocation[1],this._cameraLocation[2]),this._fovDenominator=2*Math.tan(.5*eq(g.getFov()));const T=g.projViewMatrix;let P;if(g.getPitch()<=80){const i=g.getExtent(),m=i.getWidth()/2,_=i.getHeight()/2;i.xmin-=m,i.ymin-=_,i.xmax+=m,i.ymax+=_,P=B$(i)}const I=(this.getMasks()||[]).filter((i=>i&&i instanceof ClipOutsideMask));I.forEach((i=>{if(!i.maskGeoJSON&&i.toGeoJSON)try{i.maskGeoJSON=i.toGeoJSON();const g=i.getExtent();i.maskGeoJSON.bbox=B$(g)}catch(i){console.error(i)}}));const H={children:[],level:-1};let W=H;const q=[];for(let g=0;g<this._roots.length;g++){const m=this._roots[g];if(!m||!m.visible)continue;const _=m.service,b=[m],H=this._getRootMaxExtent(g);for(;b.length>0;){const g=b.pop();for(g.id||this._initNode(g);W.level>=g._level;)W=W.parent;const m=this._isVisible(g,H,T,P,I);if(g.service=_,!(m===vY.VISIBLE||m!==vY.OUT_OF_FRUSTUM&&this.options.alwaysShowTopTiles&&yY(g))){let i=W;for(;i&&!i.content;)i=i.parent;m===vY.SCREEN_ERROR_TOO_SMALL&&i&&i.content&&this._addCandidateNode(q,i);continue}g._cameraDistance<1/0&&this._updateParentDistance(g);const $=this._createCandidate(g,W);W.children.push($);const ye=g.children,Re=ye&&ye.length,Be=$.content;if(Be&&(!Re||m===vY.SCREEN_ERROR_TOO_SMALL)&&this._addCandidateNode(q,$),m!==vY.SCREEN_ERROR_TOO_SMALL&&Re){Be&&"add"===g.refine&&this._addCandidateNode(q,$),W=$;const m=ye[0].parent;let _=!1;for(let T=0,P=ye.length;T<P;T++){if(m){const g=i.getCachedTile(ye[T].id);if(g&&g.error&&404!==g.error.status)continue;_=!0}else{_=!0,ye[T].parent=g,ye[T]._upAxis=g._upAxis,ye[T].baseUrl=g.baseUrl;const i=ye[T].content&&(ye[T].content.url||ye[T].content.uri);i&&(hq(i)||i.indexOf("i3s:")>=0?ye[T].baseUrl=g.baseUrl:gq(i)?ye[T].content.url=g.baseUrl+i:ye[T].baseUrl=i.substring(0,i.lastIndexOf("/")+1))}b.push(ye[T])}!_&&Be&&this._addCandidateNode(q,$)}}}return{root:H,tiles:q}}_addCandidateNode(i,g){const{viewerRequestVolume:m,matrix:_}=g.node;m&&!function(i,g,m,_){if(m.region){const g=m.region;if(i[0]>=g[0]&&i[0]<=g[2]&&i[1]>=g[1]&&i[1]<=g[3])return!0}else{if(m.sphere)return pY(m,g,_)<=0;if(m.box)return 0===gY(m,g,_)}return!1}(this._cameraLocation,this._cameraCartesian3,m,_)||i.push(g)}_createCandidate(i,g){return{id:i.id,node:i,children:[],level:i._level,parent:g,content:i.content&&i.content.url}}_initNode(i){const g=this.getId();i.id=g+":"+Po.GUID(),i.matrix=i.transform||mA([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),i._empty=this._isEmpty(i),i.parent&&(function(i){return i.content&&i.content.uri&&i.content.uri.indexOf("i3s:")>=0}(i)||(i.matrix=_A(i.matrix,i.parent.matrix,i.matrix)),i._rootIdx=i.parent._rootIdx,void 0===i._level&&(i._level=i.parent._level+1),i.maxExtent=i.parent.maxExtent),i.refine=i.refine&&i.refine.toLowerCase()||"replace",i.content&&!i.content.url&&i.content.uri&&(i.content.url=i.content.uri)}_getNodeService(i){return this._roots[i].service}_offsetBoundingVolume(i){const g=i.boundingVolume;if(!g||g._centerTransformed&&!this._offsetChanged(i))return;const m=this._getNodeService(i._rootIdx),_=m.heightOffset||0,b=this.options.offset,T=QW(b)||b[0]||b[1],P=m.coordOffset||aY;if(!Array.isArray(P))throw new Error("service.coordOffset must be an array");if(!g._centerTransformed&&(!i.boundingVolume||!_&&BA(i.matrix,sY)&&!T&&P===aY))return;g.box&&g.region&&delete g.region;const{region:I,box:H,sphere:W}=g;if(g.coordOffset=[P[0],P[1]],g.heightOffset=_,I){g.originalVolume||(g.originalVolume=I.slice(0));const i=g.originalVolume,m=this._offsetCenter([tq(i[0]),tq(i[1])]);I[0]=eq(m.x+P[0]),I[1]=eq(m.y+P[1]);const b=this._offsetCenter([tq(i[2]),tq(i[3])]);I[2]=eq(b.x+P[0]),I[3]=eq(b.y+P[1]),I[4]=i[4]+_+(P[2]||0),I[5]=i[5]+_+(P[2]||0)}else if(H||W){g.originalVolume||(g.originalVolume=(H||W).slice(0));const m=H||W,b=oy(U$,g.originalVolume,i.matrix),T=Wq(G$,b),I=this._offsetCenter([T[0]+P[0],T[1]+P[1]]);T[0]=I.x,T[1]=I.y,T[2]+=_+(P[2]||0),Bq(m,eq(T[0]),eq(T[1]),T[2])}g._centerTransformed=!0;try{i.extent=this.boundingVolumeToExtent(i)}catch(i){console.error(i)}}_offsetChanged(i){const g=i.boundingVolume,m=this._getNodeService(i._rootIdx),_=m.coordOffset||aY;return g.coordOffset[0]!==_[0]||g.coordOffset[1]!==_[1]||g.heightOffset!==(m.heightOffset||0)}_isEmpty(i){return void 0===i.geometricError||!i.boundingVolume}_updateParentDistance(i){let g=i.parent;for(;g&&g._empty&&!(g._cameraDistance<=i._cameraDistance);)g._cameraDistance=i._cameraDistance,g=i.parent}onTileLoad(i,g){if(i.children&&(!g.children||!g.children.length)){g.children=i.children;const m=g.content.url;g.baseUrl=m.substring(0,m.lastIndexOf("/")+1),this._setToRedraw()}}onTilesetLoad(i,g,m){if(!i)return void console.warn("invalid tileset at : "+m);const _=(i.asset&&i.asset.gltfUpAxis||g&&g._upAxis||"Y").toUpperCase();i.root.baseUrl=m.substring(0,m.lastIndexOf("/")+1);const b=m.indexOf("realspace/")>-1;0===g._level&&i.asset&&i.asset.s3mType&&b&&(i.root.baseUrl+="data/path/");const T=i.asset.i3s;if(i.root._upAxis=_,g){const m=g.boundingVolume,_=g._notLoaded;_&&delete g._notLoaded,YW(g,i.root),g.refine=g.refine&&g.refine.toLowerCase()||"replace",m&&(g.boundingVolume=m);let b=i.root.transform;if(_){const i=this._getNodeService(g._rootIdx);i.ecefTransform&&(b=_A([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i.ecefTransform,b||sY))}b&&(g.parent?T||(g.matrix=_A([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],g.parent.matrix,b)):g.matrix=_A([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],g.matrix,b)),delete g.content,i.root.content&&(g.content=i.root.content),g._empty=this._isEmpty(g);const P=g.content&&(g.content.url||g.content.uri);P&&g.content.uri&&(g.content.url=g.content.uri,delete g.content.uri),!T&&P&&!hq(P)&&gq(P)&&(g.content.url=g.baseUrl+P),i.root&&!g.parent&&this._updateRootCenter(g)}this._setToRedraw(),this.fire("loadtileset",{tileset:i,index:g&&g._rootIdx,url:m})}_isTileInMasks(i,g,m){if(!i.extent||!z$)return!0;const _=i.extent;if(fY[0]=_.xmin,fY[1]=_.ymin,fY[2]=_.xmax,fY[3]=_.ymax,g&&!z$.bboxIntersect(fY,g))return!1;if(m.length){for(let i=0,g=m.length;i<g;i++){const g=m[i].maskGeoJSON;if(!g||!g.bbox||z$.bboxInMask(fY,g))return!0}return!1}return!0}_isVisible(i,g,m,_,b){if(!this._isTileInMasks(i,_,b))return vY.OUT_OF_FRUSTUM;if(i._cameraDistance=1/0,0===i._level||i._empty)return this._updateRootCenter(i),vY.VISIBLE;if(this._offsetBoundingVolume(i),!this._isTileInFrustum(i,g,m))return vY.OUT_OF_FRUSTUM;if(0===i.geometricError)return vY.VISIBLE;let T=this._getNodeService(i._rootIdx).maximumScreenSpaceError;null==T&&(T=16);let P=this._getScreenSpaceError(i);return 0===P&&i.parent&&(P=.5*(i.parent._error||0)),P>=T?vY.VISIBLE:vY.SCREEN_ERROR_TOO_SMALL}_coordToPoint(i,g){g||(g=new un(0,0));const m=this.getMap();return m.coordToPointAtRes(i,m.getGLRes(),g)}_isTileInFrustum(i,g,m){const _=i.id;let b=this._nodeBoxes[_];const{boundingVolume:T}=i,P=T.region,I=T.box,H=T.sphere,W=this._getRootNode(i._rootIdx),q=this.getRenderer();return b&&b.version===W.version||(P?b=this._nodeBoxes[_]=this._createRegionBox(i):I?b=this._nodeBoxes[_]=this._createBBox(i):H&&(b=this._nodeBoxes[_]=this._createSphere(i)),b.version=W.version,i._boxMesh&&(q._deleteBoxMesh(i._boxMesh),delete i._boxMesh)),this._getNodeService(i._rootIdx).debug&&(this._nodeBoxes[_].node=i,q._createBoxMesh(i)),b.obbox?function(i,g){rW(i);for(var m=0;m<6;m++)if(!nW(Gj[m],g))return!1;return!0}(m,b.obbox):!!H&&function(i,g){rW(i);for(var m=g[0],_=-g[1],b=0;b<6;b++)if(oW(Gj[b],m)<_)return!1;return!0}(m,b.sphereBox)}_createRegionBox(i){const g=this.getMap(),m=g.getGLRes(),_=i.boundingVolume.region;let{ws:b,en:T}=function(i){const g=i[2],m=i[3],_=i[5],b=Bq([],i[0],i[1],i[4]),T=Bq([],g,m,_);return{ws:Wq(b,b),en:Wq(T,T)}}(_);b=new pl(b),T=new pl(T);const P=g.coordToPointAtRes(b,m);P.z=g.altitudeToPoint(b.z,m);const I=g.coordToPointAtRes(T,m);I.z=g.altitudeToPoint(T.z,m);const H=[I.x,P.y,I.z,I.x,I.y,I.z,P.x,I.y,I.z,P.x,P.y,I.z,I.x,P.y,P.z,I.x,I.y,P.z,P.x,I.y,P.z,P.x,P.y,P.z],W=[(H[0]+H[18])/2,(H[1]+H[19])/2,(H[2]+H[20])/2],q=this._getRootNode(i._rootIdx);i!==q||q._bboxCenter||(q._bboxCenter=W);const $=this._getServiceTransform([],i),ye=BA(sY,$);if(!ye){oy(W,W,$);const i=U$;for(let g=0;g<H.length;g+=3){let m=qA(i,H[g],H[g+1],H[g+2]);ye||(m=oy(m,m,$)),H[g]=m[0],H[g+1]=m[1],H[g+2]=m[2]}}const Re=g.pointAtResToCoord(new un(W),m);Re.z=(b.z+T.z)/2;const Be=this._generateOBBox(H,W);for(let i=0;i<H.length;i++)H[i]-=W[i%3];return{obbox:Be,boxPosition:H,boxCenter:W,boxCoord:Re}}_createBBox(i){const g=this.getRenderer(),m=this.getMap(),_="identity"===m.getProjection().code.toLowerCase(),b=m.getGLRes(),{boxCenter:T,boxCoord:P}=this._calBoxCenter(i),I=i.boundingVolume.box,H=function(i,g,m,_,b,T,P,I,H,W,q,$,ye){return i[0]=g||0,i[1]=T||0,i[2]=W||0,i[3]=0,i[4]=m||0,i[5]=P||0,i[6]=q||0,i[7]=0,i[8]=_||0,i[9]=I||0,i[10]=$||0,i[11]=0,i[12]=b||0,i[13]=H||0,i[14]=ye||0,i[15]=1,i}([],(W=this._createHalfAxes(I,i.matrix))[0],W[3],W[6],(q=I)[0],W[1],W[4],W[7],q[1],W[2],W[5],W[8],q[2]);var W,q;const $=this._getServiceTransform([],i),ye=BA(sY,$);ye||oy(T,T,$);const Re=[],Be=U$;for(let i=0;i<dY.length;i+=3){Be[0]=dY[i],Be[1]=dY[i+1],Be[2]=dY[i+2],oy(Be,Be,H),Wq(Be,Be),_&&g._lngLatToIdentityCoord(Be,Be);const T=K$.set(Be[0],Be[1],Be[2]);m.coordToPointAtRes(T,b,eY);let P=qA(Be,eY.x,eY.y,m.altitudeToPoint(T.z,b));ye||(P=oy(P,P,$)),Re[i]=P[0],Re[i+1]=P[1],Re[i+2]=P[2]}const Ge=this._generateOBBox(Re,T);for(let i=0;i<Re.length;i++)Re[i]-=T[i%3];return{obbox:Ge,boxPosition:Re,boxCenter:T,boxCoord:P}}_createSphere(i){const g=this.getMap(),m=this.getRenderer(),_="identity"===g.getProjection().code.toLowerCase(),b=i.boundingVolume.sphere;let T=U$;0===b[0]&&0===b[1]&&0===b[2]?T=[0,0,-6378137]:Wq(T,b),_&&m._lngLatToIdentityCoord(T,T);const P=new pl(T),I=this._coordToPoint(P,eY).toArray();I[2]=g.altitudeToPoint(P.z,g.getGLRes());const H=this._getBoxScale(P);return{boxCenter:I,boxCoord:P,sphereBox:[I,b[3]*H[2]]}}_generateOBBox(i,g){const m=AY(q$,i,0,1,4,5),_=AY(X$,i,0,3,4,7),b=AY(Z$,i,0,1,2,3);return[...g,...cy(U$,m,g),...cy(G$,_,g),...cy(j$,b,g)]}_calBoxCenter(i){const g=this.getMap(),m=this.getRenderer(),_="identity"===g.getProjection().code.toLowerCase(),b=g.getGLRes(),T=i.boundingVolume.box.slice(0,3);Wq(T,T),_&&m._lngLatToIdentityCoord(T,T);const P=new pl(T),I=g.coordToPointAtRes(P,b);return{boxCenter:[I.x,I.y,g.altitudeToPoint(P.z,b)],boxCoord:P}}_getServiceTransform(i,g){const m=this._getRootNode(g._rootIdx),_=this._getNodeService(g._rootIdx),b=m._bboxCenter,T=wA(nY,qA(U$,-b[0],-b[1],-b[2])),P=wA(rY,b),I=o_(Q$,..._.rotation||lY),H=_.scale;let W;W=Array.isArray(H)?qA(cY,H[0],H[1],H[2]):H&&qA(cY,H,H,H)||hY;return i=_A(i,OA(iY,I,uY,W),T),_A(i,P,i)}_updateRootCenter(i){const g=this._getNodeService(i._rootIdx);if(!i.boundingVolume||this._equalsOffsets(i,g))return;const m=i.boundingVolume.region,_=i.boundingVolume.sphere;let b=null;i.boundingVolume.box?b=this._updateRootBBoxCenter(i).boxCenter:m?b=this._updateRootRegionCenter(i).boxCenter:_&&(b=this._createSphere(i).boxCenter);const T=g.heightOffset||0,P=g.coordOffset||[0,0];i._originCoordOffset=[P[0]||0,P[1]||0],i._originHeightOffset=T,i._bboxCenter=b}_equalsOffsets(i,g){if(!i._originCoordOffset)return!1;const m=g.coordOffset||aY;return i._originCoordOffset[0]===m[0]&&i._originCoordOffset[1]===m[1]&&i._originHeightOffset===(g.heightOffset||0)}_updateRootRegionCenter(i){return this._offsetBoundingVolume(i),this._createRegionBox(i)}_updateRootBBoxCenter(i){return this._offsetBoundingVolume(i),this._calBoxCenter(i)}_createHalfAxes(i,g){let m=i.slice(3,12);return m=cA(m,sA(tY,g),m),m}_getBoxScale(i){const g=this.getMap(),m=g.distanceToPointAtRes(100,100,g.getGLRes(),i);let _;return _=g.altitudeToPoint?g.altitudeToPoint(100,g.getGLRes())/100:m.y/100,qA($$,m.x/100*1.01,m.y/100*1.01,_),$$}_offsetCenter(i){Array.isArray(i)&&(i=new pl(i));let g=this.options.offset;if(QW(g)&&(g=g.call(this,Array.isArray(i)?new pl(i):i)),g[0]||g[1]){const m=this.getMap(),_=m.getGLRes(),b=m.coordToPointAtRes(i,_);return eY.set(g[0],g[1]),b._sub(eY),m.pointAtResToCoord(b,_)}return i}_getRootNode(i){return this._roots[i]}_getRootMaxExtent(i){const g=this._getNodeService(i).maxExtent;if(!g)return null;const m=this._roots[i];return m.maxExtent||(m.maxExtent=new Pl(g).convertTo((i=>this._coordToPoint(i)))),m.maxExtent}_getScreenSpaceError(i){const g=this._fovDenominator,m=i.geometricError;if(0===m)return i._error=0,0;const _=this._getNodeService(i._rootIdx);let b=_.scale||1;if(Array.isArray(b)&&(b=GA(b)),_.ecefTransform){const i=PA(Y$,_.ecefTransform);b*=gy(i)}const T=this.getMap();let P;i.boundingVolume.region?P=function(i,g,m){return i._tileRegion||(i._tileRegion=new po(i.boundingVolume.region)),i._tileRegion.distanceToCamera(g,m)}(i,this._cameraCartesian3,this._cameraLocation):i.boundingVolume.sphere?P=pY(i.boundingVolume,this._cameraCartesian3):i.boundingVolume.box&&(P=gY(i.boundingVolume,this._cameraCartesian3));const I=Math.max(Math.abs(P),1e-7),H=m*b*T.height/(I*g);return i._cameraDistance=P,i._error=H,H}_setToRedraw(){const i=this.getRenderer();i&&i.setToRedraw()}_getNodeBox(i){return this._nodeBoxes[i]}identify(i,g={}){const m=this.getMap(),_=this.getRenderer();if(!m||!_)return[];Array.isArray(i)&&(i=new pl(i));const b=m.coordToContainerPoint(i);return this.identifyAtPoint(b,g)}identifyAtPoint(i,g={}){const m=[];if(!g.excludeMasks){const _=this.identifyMask(i,g);_&&_.length&&uq(m,_)}const _=this.getMap(),b=this.getRenderer();if(!_||!b)return[];const T=_.getDevicePixelRatio();return uq(m,b.pick(i.x*T,i.y*T,g)),g&&g.filter&&!g.excludeMasks?m.filter((i=>g.filter(i))):m}getCurrentBatchIDs(){const i=this.getMap(),g=this.getRenderer();return i&&g?g._getCurrentBatchIDs():[]}highlight(i){const g=this.getRenderer();return Array.isArray(i)||(i=[i]),g?(g.highlight(i),this):(this._highlighted||(this._highlighted=[]),this._highlighted.push(i),this)}_resumeHighlights(){if(this._highlighted){for(let i=0;i<this._highlighted.length;i++)this.highlight(this._highlighted[i]);delete this._highlighted}}cancelHighlight(i,g){const m=this.getRenderer();return m?(m.cancelHighlight(i,g),this):this}cancelAllHighlight(){const i=this.getRenderer();return i?(i.cancelAllHighlight(),this):this}showOnly(i){const g=this.getRenderer();return g?(g.showOnly(i),this):(this._showOnlys||(this._showOnlys=[]),this._showOnlys.push(i),this)}_resumeShowOnly(){if(this._showOnlys){for(let i=0;i<this._showOnlys.length;i++)this.showOnly(this._showOnlys[i]);delete this._showOnlys}}cancelShowOnly(i){const g=this.getRenderer();return g?(g.cancelShowOnly(i),this):this}setServiceOpacity(i,g){const m=this.options.services[i];return m&&(m.opacity=g),this.getRenderer()?(this._setToRedraw(),this):this}setServiceDebug(i,g){const m=this.options.services[i];return m&&(m.debug=g),this.getRenderer()?(this._setToRedraw(),this):this}_getCameraLonLat(i){const g=this.getMap(),m=g.getGLRes();oY.set(i[0],i[1]);const _=g.pointAtResToCoord(oY,m);return"identity"===g.getProjection().code.toLowerCase()?(G$[0]=_.x,G$[1]=_.y,this.getRenderer()._identityCoordToLngLat(U$,G$),_.set(U$[0],U$[1]),_):_}toJSON(){return{type:this.getJSONType(),id:this.getId(),options:this.config()}}}function pY(i,g,m){let _=i.sphere;m&&(_=oy([0,0,0],_,m));const b=dy(_,g),T=i.sphere[3];return b<T?0:b-T}function gY(i,g,m){const _=i.box;let b=qA(U$,_[0],_[1],_[2]);return m&&(b=oy([0,0,0],b,m)),function(i,g,m){return Math.sqrt(function(i,g,m){const _=ZA(y$,m,i),b=A$(_$,g,0),T=A$(v$,g,1),P=A$(x$,g,2),I=gy(b),H=gy(T),W=gy(P);ny(b,b),ny(T,T),ny(P,P);const q=b$;q[0]=ry(_,b),q[1]=ry(_,T),q[2]=ry(_,P);let $,ye=0;return q[0]<-I?($=q[0]+I,ye+=$*$):q[0]>I&&($=q[0]-I,ye+=$*$),q[1]<-H?($=q[1]+H,ye+=$*$):q[1]>H&&($=q[1]-H,ye+=$*$),q[2]<-W?($=q[2]+W,ye+=$*$):q[2]>W&&($=q[2]-W,ye+=$*$),ye}(i,g,m))}(b,aA(tY,_[3],_[4],_[5],_[6],_[7],_[8],_[9],_[10],_[11]),g)}function mY(i,g,m){const _=(i=nq(i)).indexOf("{s}")>=0?"{s}":i.indexOf("%7Bs%7D")>=0?"%7Bs%7D":null;return{version:0,_empty:!0,service:m,visible:!!$W(m.visible)||m.visible,baseUrl:i.substring(0,i.lastIndexOf("/"))+"/",content:{url:i},refine:"replace",matrix:mA([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),_rootIdx:g,_level:0,_notLoaded:!0,domainKey:_}}function AY(i,g,m,_,b,T){const P=qA(U$,g[3*m],g[3*m+1],g[3*m+2]),I=qA(G$,g[3*_],g[3*_+1],g[3*_+2]),H=qA(j$,g[3*b],g[3*b+1],g[3*b+2]),W=qA(W$,g[3*T],g[3*T+1],g[3*T+2]);return i[0]=(P[0]+I[0]+H[0]+W[0])/4,i[1]=(P[1]+I[1]+H[1]+W[1])/4,i[2]=(P[2]+I[2]+H[2]+W[2])/4,i}function yY(i){if(!i.content||i.hasParentContent)return!1;let g=i.parent;if(g&&(g.content||g.hasParentContent))return i.hasParentContent||(i.hasParentContent=!0),!1;for(;g;){if(g.content||g.hasParentContent)return i.hasParentContent||(i.hasParentContent=!0),!1;g=g.parent}return!0}function _Y(i,g){return Array.isArray(i)&&Array.isArray(g)?2===i.length?J_(i,g):ly(i,g):i===g}var vY;Vo.mergeOptions(V$),Vo.registerRenderer("gl",zn),Vo.registerJSONType("Geo3DTilesLayer"),function(i){i[i.OUT_OF_FRUSTUM=0]="OUT_OF_FRUSTUM",i[i.SCREEN_ERROR_TOO_SMALL=1]="SCREEN_ERROR_TOO_SMALL",i[i.VISIBLE=2]="VISIBLE"}(vY||(vY={}));let xY=null;function bY(){return xY||(xY={"image/crn":_q.crn&&_q.crn(),"image/ktx2":_q.ktx2&&_q.ktx2(),"image/cttf":_q.ktx2&&_q.ktx2(),draco:_q.draco&&_q.draco()}),xY}const{Ajax:wY,GLTFLoader:TY}=vq();class ns{constructor(i,g,m){this._requestImage=i,this._loaderCtor=g||TY,this._supportedFormats=m,this._decoders=bY()}static createEmptyB3DM(){return{featureTable:null,batchTable:null,gltf:{}}}load(i,g,m=0,_=0,b){return g?(_||(_=g.byteLength),this._parse(i,g,m,_,b)):wY.getArrayBuffer(i,{}).then((g=>{const b=g.data;return _||(_=b.byteLength),this._parse(i,b,m,_)}))}_parse(i,g,m,_,b){const T=b&&b.maxTextureSize,P=this._readB3DM(g,m,_,i);if(P.error)return Promise.resolve(P);const I=i.substring(0,i.lastIndexOf("/"));let H;try{H=new this._loaderCtor(I,P.glb,{transferable:!0,requestImage:this._requestImage,decoders:this._decoders,supportedFormats:this._supportedFormats,maxTextureSize:T})}catch(i){return Promise.resolve({error:i})}return H.load({skipAttributeTransform:!1}).then((g=>{g.url=`${i}-${m}-${_}`;const b=H.transferables;for(let i=0;i<P.transferables.length;i++)b.indexOf(P.transferables[i])<0&&b.push(P.transferables[i]);return{magic:"b3dm",count:P.count,transferables:b,featureTable:P.featureTable,batchTable:P.batchTable,batchTableBin:P.batchTableBin,gltf:g}}))}_readB3DM(i,g,m,_){const b=new DataView(i,g,m),T=b.getUint32(4,!0);if(1!==T){const i="Unsupported b3dm version: "+T+", url:"+_;return console.warn(i),{error:i}}if(b.getUint32(8,!0)!==b.byteLength){const i="Length in b3dm header is inconsistent with b3dm's byte length, url: "+_;return console.warn(i),{error:i}}let P,I=b.getUint32(12,!0),H=b.getUint32(16,!0),W=b.getUint32(20,!0),q=b.getUint32(24,!0),$=28+g;W>=570425344?($-=8,P=I,W=H,q=0,I=0,H=0):q>=570425344&&($-=4,P=W,W=I,q=H,I=0,H=0);const ye=[i];let Re,Be,Ge;if(I>0?(Re=rX(i,$,I),$+=I,P=Re.BATCH_LENGTH):Re={BATCH_LENGTH:P},H>0&&($+=H),W>0&&(Be=iX(i,$,W),$+=W,q>0)){const g=oX(0,$,q);Ge=i.slice(g.offset,g.offset+g.byteLength),$+=q,ye.push(Ge)}const je=Re.BATCH_LENGTH,Xe={};if(Re&&Re.BATCH_ID){Xe.BATCH_ID=aX(Re.BATCH_ID,i,(void 0).offset,je);const g=Xe.BATCH_ID.array&&Xe.BATCH_ID.array.buffer;g&&ye.indexOf(g)<0&&ye.push(g)}return{count:P,transferables:ye,featureTable:Re,batchTable:Be,batchTableBin:Ge,b3dm:Xe,glb:{buffer:i,byteOffset:$,byteLength:b.byteLength+b.byteOffset-$}}}_readBatchTable(){return null}}const{Ajax:SY,GLTFLoader:MY}=vq();class as{constructor(i,g,m,_){this._requestImage=i,this._loaderCtor=g||MY,this._supportedFormats=m,this._decoders=bY(),this._maxTextureSize=_}load(i,g,m=0,_=0,b){return g?(_||(_=g.byteLength),this._parse(i,g,m,_,b)):SY.getArrayBuffer(i,{}).then((g=>{const b=g.data;return _||(_=b.byteLength),this._parse(i,b,m,_)}))}_parse(i,g,m,_,b){return this._parseGLTF(i,g,m,_,b).then((({gltf:b,transferables:T})=>{const P=this._readI3DM(g,m,_,i);if(P.error)return Promise.resolve(P);for(let i=0;i<T.length;i++)-1===P.transferables.indexOf(T[i])&&P.transferables.push(T[i]);return delete b.transferables,Promise.resolve({magic:"i3dm",count:P.count,transferables:P.transferables,featureTable:P.featureTable,batchTable:P.batchTable,batchTableBin:P.batchTableBin,i3dm:P.i3dm,gltf:b})}))}_parseGLTF(i,g,m,_,b){const T={transferable:!0,requestImage:this._requestImage,decoders:this._decoders,supportedFormats:this._supportedFormats,maxTextureSize:b&&b.maxTextureSize},P=new DataView(g,m,_),I=32+P.getUint32(12,!0)+P.getUint32(16,!0)+P.getUint32(20,!0)+P.getUint32(24,!0);if(0===P.getUint32(28,!0)){let _=oq(new Uint8Array(g,I+m,P.byteLength-I));return-1==_.indexOf("://")&&(_=i.substring(0,i.lastIndexOf("/"))+"/"+_),_.indexOf(".glb")>0?SY.getArrayBuffer(_,{}).then((i=>this._createGLTFLoader(_,{buffer:i.data,byteOffset:0},T))):SY.getJSON(_,{}).then((i=>this._createGLTFLoader(_,i,T)))}return this._createGLTFLoader(i,{buffer:g,byteOffset:I+m,byteLength:P.byteLength-I},T)}_createGLTFLoader(i,g,m){const _=i.substring(0,i.lastIndexOf("/")),b=new this._loaderCtor(_,g,m);return b.load({skipAttributeTransform:!0}).then((m=>{let _=0,T=0;return g.buffer&&(_=g.byteOffset||0,T=g.byteLength||0),m.url=`${i}-${_}-${T}`,{transferables:b.transferables,gltf:m}}))}_readI3DM(i,g,m,_){const b=new DataView(i,g,m),T=b.getUint32(4,!0);if(1!==T){const i="Unsupported pnts version: "+T+", url:"+_;return console.warn(i),{error:i}}if(b.getUint32(8,!0)!==b.byteLength){const i="Length in pnts header is inconsistent with pnts's byte length, url: "+_;return console.warn(i),{error:i}}const P=[i],{featureTable:I,featureTableBin:H,batchTable:W,batchTableBin:q}=gX(b,32+g,P),$={},ye=I.INSTANCES_LENGTH;if(I.POSITION){const{byteOffset:g}=I.POSITION;$.POSITION={byteStride:0,byteOffset:0,itemSize:3,count:ye,componentType:5126,array:new Float32Array(i,g+H.offset,3*ye).slice()},P.push($.POSITION.array.buffer)}else if(I.POSITION_QUANTIZED){const g=I.QUANTIZED_VOLUME_OFFSET,m=I.QUANTIZED_VOLUME_SCALE,{byteOffset:_}=I.POSITION_QUANTIZED;$.POSITION={byteStride:12,byteOffset:0,itemSize:3,count:ye,componentType:5126,array:this._convertQuantizedPosition(new Uint16Array(i,_+H.offset,3*ye),g,m)},P.push($.POSITION.array.buffer)}if(I.BATCH_ID){$.BATCH_ID=aX(I.BATCH_ID,i,H.offset,ye);const g=$.BATCH_ID.array&&$.BATCH_ID.array.buffer;g&&P.indexOf(g)<0&&P.push(g)}if(I.NORMAL_UP){let{byteOffset:g}=I.NORMAL_UP;$.NORMAL_UP={byteStride:0,byteOffset:0,itemSize:3,count:ye,componentType:5126,array:new Float32Array(i,g+H.offset,3*ye).slice()},P.push($.NORMAL_UP.array.buffer),g=I.NORMAL_RIGHT.byteOffset,$.NORMAL_RIGHT={byteStride:0,byteOffset:0,itemSize:3,count:ye,componentType:5126,array:new Float32Array(i,g+H.offset,3*ye).slice()},P.push($.NORMAL_RIGHT.array.buffer)}else if(I.NORMAL_UP_OCT32P){let{byteOffset:g}=I.NORMAL_UP_OCT32P;$.NORMAL_UP={byteStride:0,byteOffset:0,itemSize:3,count:ye,componentType:5126,array:this._decodeOCT32p(new Uint16Array(i,g+H.offset,2*ye))},P.push($.NORMAL_UP.array.buffer),g=I.NORMAL_RIGHT_OCT32P.byteOffset,$.NORMAL_RIGHT={byteStride:0,byteOffset:0,itemSize:3,count:ye,componentType:5126,array:this._decodeOCT32p(new Uint16Array(i,g+H.offset,2*ye))},P.push($.NORMAL_RIGHT.array.buffer)}if(I.SCALE){const{byteOffset:g}=I.SCALE;$.SCALE={byteStride:0,byteOffset:0,itemSize:1,count:ye,componentType:5126,array:new Float32Array(i,g+H.offset,ye).slice()},P.push($.SCALE.array.buffer)}else if(I.SCALE_NON_UNIFORM){const{byteOffset:g}=I.SCALE_NON_UNIFORM;$.SCALE_NON_UNIFORM={byteStride:0,byteOffset:0,itemSize:3,count:ye,componentType:5126,array:new Float32Array(i,g+H.offset,3*ye).slice()},P.push($.SCALE_NON_UNIFORM.array.buffer)}return{count:ye,batchTable:W,batchTableBin:q,featureTable:I,i3dm:$,transferables:P}}_decodeOCT32p(i){const g=i.length/2,m=new Float32Array(3*g),_=[];for(let b=0;b<g;b++)CY(_,i[2*b],i[2*b+1],65535),m[3*b]=_[0],m[3*b+1]=_[1],m[3*b+2]=_[2];return m}_convertQuantizedPosition(i,g,m){return pX(new Float32Array(i.length),i,g,m)}_readBatchTable(){return null}}function CY(i,g,m,_){if(i[0]=PY(g,_),i[1]=PY(m,_),i[2]=1-(Math.abs(i[0])+Math.abs(i[1])),i[2]<0){const g=i[0];i[0]=(1-Math.abs(i[1]))*IY(g),i[1]=(1-Math.abs(g))*IY(i[1])}return ny(i,i)}function PY(i,g){return function(i,g,m){return i<0?0:i>m?m:i}(i,0,g=function(i){return null!=i?i:255}(g))/g*2-1}function IY(i){return i<0?-1:1}const{Ajax:kY}=vq();class us{constructor(){}load(i,g,m=0,_=0){return g?(_||(_=g.byteLength),this._parse(i,g,m,_)):kY.getArrayBuffer(i,{}).then((g=>{const b=g.data;return _||(_=b.byteLength),this._parse(i,b,m,_)}))}_parse(i,g,m,_){return this._readPNTS(g,m,_,i).then((i=>i.error?i:{magic:"pnts",count:i.count,transferables:i.transferables,featureTable:i.featureTable,batchTable:i.batchTable,batchTableBin:i.batchTableBin,pnts:i.pnts}))}_readPNTS(i,g,m,_){const b=new DataView(i,g,m),T=b.getUint32(4,!0);if(1!==T){const i="Unsupported pnts version: "+T+", url:"+_;return console.warn(i),{error:i}}if(b.getUint32(8,!0)!==b.byteLength){const i="Length in pnts header is inconsistent with pnts's byte length, url: "+_;return console.warn(i),{error:i}}const P=[i],{featureTable:I,featureTableBin:H,batchTable:W,batchTableBin:q}=gX(b,g+28,P),$=I.QUANTIZED_VOLUME_OFFSET,ye=I.QUANTIZED_VOLUME_SCALE,Re=I.POINTS_LENGTH;let Be,Ge={};if(I.extensions&&I.extensions["3DTILES_draco_point_compression"]){Ge=I.extensions["3DTILES_draco_point_compression"],Be=new DataView(i,Ge.byteOffset+H.offset,Ge.byteLength);const g={attributes:Ge.properties,useUniqueIDs:!1};return this._draco||(this._draco=bY().draco),this._draco(Be,g).then((g=>{const m=g.attributes;!I.POSITION&&!I.POSITION_QUANTIZED||m.POSITION||m.POSITION_QUANTIZED||(m.POSITION=I.POSITION,m.POSITION_QUANTIZED=I.POSITION_QUANTIZED),!(I.RGB||I.RGBA||I.RGB565)||m.RGB||m.RGBA||m.RGB565||(m.RGB=I.RGB,m.RGBA=I.RGBA,m.RGB565=I.RGB565),!I.NORMAL&&!I.NORMAL_OCT16P||m.NORMAL||m.NORMAL_OCT16P||(m.NORMAL=I.NORMAL,m.NORMAL_OCT16P=I.NORMAL_OCT16P);const _=this._readAttributes(i,g.attributes,H.offset,Re,P,$,ye);if(g.attributes.BATCH_ID){const i=g.attributes.BATCH_ID.array;_.BATCH_ID={byteStride:0,byteOffset:0,itemSize:1,count:i.length,componentType:dX(i.constructor),array:i},P.push(i.buffer)}else if(I.BATCH_ID||Object.keys(W).length){_.BATCH_ID=I.BATCH_ID?aX(I.BATCH_ID,i,H.offset,Re):OY(Re);const g=_.BATCH_ID.array&&_.BATCH_ID.array.buffer;g&&P.indexOf(g)<0&&P.push(g)}return{count:Re,batchTable:W,batchTableBin:q,featureTable:I,pnts:_,transferables:P}}))}const je=this._readAttributes(i,I,H.offset,Re,P,$,ye);if(I.BATCH_ID||Object.keys(W).length){je.BATCH_ID=I.BATCH_ID?aX(I.BATCH_ID,i,H.offset,Re):OY(Re);const g=je.BATCH_ID.array&&je.BATCH_ID.array.buffer;g&&P.indexOf(g)<0&&P.push(g)}return Promise.resolve({count:Re,batchTable:W,batchTableBin:q,featureTable:I,pnts:je,transferables:P})}_readAttributes(i,g,m,_,b,T,P){const I={};if(g.POSITION){let{byteOffset:T,array:P}=g.POSITION;T=T||0;const H=P?0:m;if(!P){const g=i.slice(T+H,T+H+3*_*4);P=new Float32Array(g)}I.POSITION={byteStride:0,byteOffset:0,itemSize:3,count:_,componentType:5126,array:P},b.push(P.buffer)}else if(g.POSITION_QUANTIZED){let{byteOffset:H}=g.POSITION_QUANTIZED;const{array:W}=g.POSITION_QUANTIZED;H=H||0;I.POSITION={byteStride:0,byteOffset:0,itemSize:3,count:_,componentType:5126,array:this._convertQuantizedPosition(W||new Uint16Array(i,H+(W?0:m),3*_),T,P)},b.push(I.POSITION.array.buffer)}if(g.RGBA){let{byteOffset:T,array:P}=g.RGBA;T=T||0;const H=P?0:m;if(!P){const g=i.slice(T+H,T+H+4*_);P=new Uint8Array(g)}I.RGBA={byteStride:0,byteOffset:0,itemSize:4,count:_,componentType:5121,array:P},b.push(P.buffer)}else if(g.RGB){let{byteOffset:T,array:P}=g.RGB;T=T||0;const H=P?0:m;if(!P){const g=i.slice(T+H,T+H+3*_);P=new Uint8Array(g)}I.RGB={byteStride:0,byteOffset:0,itemSize:3,count:_,componentType:5121,array:P},b.push(P.buffer)}else if(g.RGB565){let{byteOffset:T,array:P}=g.RGB565;T=T||0;const H=P?0:m;if(!P){const g=i.slice(T+H,T+H+2*_);P=new Uint16Array(g)}I.RGB565={byteStride:0,byteOffset:0,itemSize:1,count:_,componentType:5123,array:P},b.push(P.buffer)}if(g.NORMAL){let{byteOffset:T,array:P}=g.NORMAL;T=T||0;const H=P?0:m;if(!P){const g=i.slice(T+H,T+H+3*_*4);P=new Float32Array(g)}I.NORMAL={byteStride:0,byteOffset:0,itemSize:3,count:_,componentType:5126,array:P},b.push(P.buffer)}else if(g.NORMAL_OCT16P){let{byteOffset:T,array:P}=g.NORMAL_OCT16P;T=T||0;const H=P?0:m;if(!P){const g=i.slice(T+H,T+H+2*_);P=new Uint8Array(g)}I.NORMAL_OCT16P={byteStride:0,byteOffset:0,itemSize:2,count:_,componentType:5121,array:P},b.push(P.buffer)}return I}_convertQuantizedPosition(i,g,m){return pX(new Float32Array(i.length),i,g,m)}_readBatchTable(){return null}}function OY(i){const g=lq(i),m=new g(i);for(let g=0;g<i;g++)m[g]=g;return{byteStride:0,byteOffset:0,itemSize:1,count:i,componentType:dX(g),array:m}}const{Ajax:EY,GLTFLoader:RY}=vq();class gs{constructor(i,g,m,_){this._supportedFormats=m,this._requestImage=i,this._loaderCtor=g||RY,this._maxTextureSize=_}load(i,g,m=0,_=0,b){return g?this._parse(i,g,m,_,b):EY.getArrayBuffer(i,{}).then((g=>this._parse(i,g.data,m,_)))}_parse(i,g,m,_,b){_||(_=g.byteLength);const T=this._readCMPT(g,i,m,_),P=[];for(let m=0;m<T.length;m++){let _;if("b3dm"===T[m].magic)_=new ns(this._requestImage,this._loaderCtor,this._supportedFormats);else if("i3dm"===T[m].magic)_=new as(this._requestImage,this._loaderCtor,this._supportedFormats,this._maxTextureSize);else if("pnts"===T[m].magic)_=new us;else{if("cmpt"!==T[m].magic){console.warn("Unsupported magic in CMPT tile:",T[m].magic);continue}_=new gs(this._requestImage,this._loaderCtor,this._supportedFormats,this._maxTextureSize)}P.push(_.load(i,g,T[m].offset,T[m].byteLength,b).then((i=>i)))}return Promise.all(P).then((i=>({magic:"cmpt",tiles:i})))}_readCMPT(i,g,m,_){const b=new DataView(i,m,_),T=b.getUint32(4,!0);if(1!==T){const i="Unsupported cmpt version: "+T+", url:"+g;return console.warn(i),{error:i}}if(16===b.byteLength)return[];const P=[],I=b.getUint32(12,!0);let H=16;for(let g=0;g<I;g++){const g=tX(b,H),_=b.getUint32(H+8,!0);P.push({magic:g,buffer:i,offset:H+m,byteLength:_}),H+=_}return P}}if(rx){const i=Uu.VERSION;if(i.indexOf("1.0.0-beta")>=0||i.indexOf("1.0.0-alpha")>=0){Os("@maptalks/3dtiles",rx.inject(aW))}else Os("@maptalks/3dtiles",(function(){return rx.inject(aW)}))}else Os("@maptalks/3dtiles",aW);"undefined"!=typeof console&&console.log("@maptalks/3dtiles v0.106.6");
/*!
   * @maptalks/gltf-layer v0.106.0
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.org
   */
const LY='function(e){\n/*!\n     * @maptalks/gl v0.110.0\n     * LICENSE : UNLICENSED\n     * (c) 2016-2025 maptalks.com\n     */\nconst t=function(){if("undefined"!=typeof undefinedThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof undefined)return global;throw new Error("unable to locate global object")},r=t(),n=r.gl_trans__coders=r.gl_trans__coders||{};n.inject=function(e){const n=e.toString(),a=n.indexOf("{")+1,o=n.substring(0,a),s=r.gl_trans__coders=r.gl_trans__coders||{};let c=`${o}\\n    const _____getGlobal = ${t.toString()};\\n    const g___lobals = _____getGlobal()\\n    const tran_____scoders = g___lobals[\'gl_trans__coders\'] = g___lobals[\'gl_trans__coders\'] || {};`;for(const e in s)"inject"!==e&&"getTranscoder"!==e&&"registerTranscoder"!==e&&(c+=\'tran_____scoders["\'+e+\'"] =\'+s[e].toString()+"\\n;");return c+="\\n("+t().maptalks_gltf_loader_bundle.toString()+")({});\\n",c+="\\n"+n.substring(o.length),c},n.registerTranscoder=function(e,t){n[e]=t},n.getTranscoder=function(e){return n[e]};const a=t().maptalks_gltf_loader,o={"image/crn":n.crn&&n.crn(),"image/ktx2":n.ktx2&&n.ktx2(),"image/cttf":n.ktx2&&n.ktx2(),"draco":n.draco&&n.draco()};let s;const c={};function l(e,t,r){return new a.GLTFLoader(e,t,r).load({skipAttributeTransform:!0})}function i(e,t,r,n){const s=t.lastIndexOf("/"),c=t.slice(0,s);n&&(t=n(t));const i=(...t)=>d.call(this,e,...t);return function(e,t){return a.Ajax.getArrayBuffer(e,t)}(t,r).then((e=>{if(e.message)return e;const s=e.data;return new DataView(s,s.byteOffset,s.byteLength).getUint32(4,!0)>2?function(e,t){return a.Ajax.getJSON(e,t)}(t,r).then((e=>e.message?e:l(c,e,{requestImage:i,decoders:o,transferable:!0,fetchOptions:r,urlModifier:n}))):l(c,{buffer:e.data,byteOffset:0},{requestImage:i,decoders:o,transferable:!0,fetchOptions:r,urlModifier:n})}))}function d(e,t,r,n){e?c[t]?c[t].push(n):(c[t]=[n],self.postMessage({type:"<request>",command:"sendImageData",actorId:e,workerId:s,params:t})):function(e,t){const r=new Image;r.onload=()=>{if(!f)return void t(new Error("There is no canvas to draw image!"));f.width=r.width,f.height=r.height;const e=f.getContext("2d");e.drawImage(r,0,0,r.width,r.height);const n=e.getImageData(0,0,r.width,r.height),a={width:r.width,height:r.height,data:new Uint8Array(n.data)};t(null,a,[a.data.buffer])},r.onerror=function(e){t(e)},r.src=e}(t,n)}const f="undefined"==typeof document?null:document.createElement("canvas");e.loadGLTF=i,e.onmessage=function(e){const t=e.data,r=t.url;if("addLayer"===t.command||"removeLayer"===t.command)s=e.workerId,self.postMessage({type:"<response>",actorId:t.actorId,workerId:s,params:"ok"});else if(r)!function(e){const t=e.data,r=e.callback,n=e.actorId,a=t.url,o=t.fetchOptions||{};o.referrerPolicy=o.referrerPolicy||"origin",o.referrer=t.referrer,i(n,a,o).then((e=>{e.message?self.postMessage({callback:r,error:e}):self.postMessage({callback:r,data:e},e.transferables)})).catch((e=>{self.postMessage({callback:r,error:e})})),c.receive=r}(e);else if(t.imageUrl){const e=c[t.imageUrl];if(delete c[t.imageUrl],e)for(let r=0;r<e.length;r++)e[r](null,t.result)}}}';function DY(i){return null==i}function FY(i){return!DY(i)}function NY(i,g){if(!i||!g)return null;let m=g;if(Array.isArray(g)){if(!Po.isNumber(g[0]))return null;m=new pl(g)}const _=i.coordinateToPointAtRes(m,i.getGLRes()),b=i.altitudeToPoint(m.z||0,i.getGLRes());return[_.x,_.y,b]}function HY(i,g){return Math.abs(i)*Math.sign(g)}function BY(i,g,m){const _=ql.Measurer.getInstance().measureLenBetween(i,g);let b=m.count;b&&m.snapToEndVertexes&&(b-=1);const T=b>0?_/b:m.gapLength+m.bboxWidth,P=Math.floor(_/T),I=[],H=m.rotateAlongLine+function(i,g,m){const _=m.getGLRes(),b=m.coordinateToPointAtRes(i,_),T=m.coordinateToPointAtRes(g,_);return Po.computeDegree(T.x,T.y,b.x,b.y)/Math.PI*180}(i,g,m.map);if(P>=1){const b=0,W=P;if(m.snapToEndVertexes)for(let m=b;m<=W;m++){const b={coordinates:zY(i,g,T*m/_),scale:[1,1,1],rotation:[0,0,H]};I.push(b)}else for(let m=b+1;m<=W;m++){const b={coordinates:zY(i,g,T*(m-.5)/_),scale:[1,1,1],rotation:[0,0,H]};I.push(b)}if(m.scaleEndModel){const m=(_-T*P)/T,b={coordinates:zY(i,g,(T*P+(_-T*P)/2)/_),scale:[m,1,1],rotation:[0,0,H]};I.push(b)}}else if(m.scaleEndModel){const m=_/T,b={coordinates:zY(i,g,.5),scale:[m,1,1],rotation:[0,0,H]};I.push(b)}return I}function zY(i,g,m){const _=VY(i.x,g.x,m),b=VY(i.y,g.y,m);return new pl(_,b)}function VY(i,g,m){return i+m*(g-i)}const UY={},GY="undefined"==typeof document?null:document.createElement("canvas");let jY=class v extends Um.Actor{constructor(i,g){super(i),this.mapId=g.getMap().id,this._layer=g}loadGLTF(i){const g=function(i){let g=document.createElement("a");return g.href=i,i=g.href,g=null,i}(i),m={url:g,referrer:window&&window.location.href,fetchOptions:this._layer.options.fetchOptions};return new Promise(((i,g)=>{this.send(m,null,((m,_)=>{m?g(m):i(_)}))}))}sendImageData(i,g){!function(i,g){const m=new Image;m.onload=()=>{if(!GY)return void g(new Error("There is no canvas to draw image!"));GY.width=m.width,GY.height=m.height;const i=GY.getContext("2d");i.drawImage(m,0,0,m.width,m.height);const _=i.getImageData(0,0,m.width,m.height),b={width:m.width,height:m.height,data:new Uint8Array(_.data)};g(null,b)},m.onerror=function(i){g(i)},m.src=i}(i,((m,_)=>{m||this.isActive()&&g(null,{result:_,imageUrl:i})}))}addLayer(i,g,m){this.broadcast({actorId:this.actorId,mapId:this.mapId,layerId:i,command:"addLayer",params:{options:g}},null,m)}removeLayer(i,g,m){this.broadcast({mapId:this.mapId,layerId:i,command:"removeLayer"},null,m)}};
/*!
   * @maptalks/gl v0.110.0
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.com
   */const WY=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")},qY=WY(),XY=qY.gl_trans__coders=qY.gl_trans__coders||{};XY.inject=function(i){const g=i.toString(),m=g.indexOf("{")+1,_=g.substring(0,m),b=qY.gl_trans__coders=qY.gl_trans__coders||{};let T=`${_}\n    const _____getGlobal = ${WY.toString()};\n    const g___lobals = _____getGlobal()\n    const tran_____scoders = g___lobals['gl_trans__coders'] = g___lobals['gl_trans__coders'] || {};`;for(const i in b)"inject"!==i&&"getTranscoder"!==i&&"registerTranscoder"!==i&&(T+='tran_____scoders["'+i+'"] ='+b[i].toString()+"\n;");return T+="\n("+WY().maptalks_gltf_loader_bundle.toString()+")({});\n",T+="\n"+g.substring(_.length),T},XY.registerTranscoder=function(i,g){XY[i]=g},XY.getTranscoder=function(i){return XY[i]};const ZY=WY().maptalks_gltf_loader,$Y={"image/crn":XY.crn&&XY.crn(),"image/ktx2":XY.ktx2&&XY.ktx2(),"image/cttf":XY.ktx2&&XY.ktx2(),draco:XY.draco&&XY.draco()},YY={};function QY(i,g,m){return new ZY.GLTFLoader(i,g,m).load({skipAttributeTransform:!0})}function JY(i,g,m,_){const b=g.lastIndexOf("/"),T=g.slice(0,b);_&&(g=_(g));const P=(...g)=>KY.call(this,i,...g);return function(i,g){return ZY.Ajax.getArrayBuffer(i,g)}(g,m).then((i=>{if(i.message)return i;const b=i.data;return new DataView(b,b.byteOffset,b.byteLength).getUint32(4,!0)>2?function(i,g){return ZY.Ajax.getJSON(i,g)}(g,m).then((i=>i.message?i:QY(T,i,{requestImage:P,decoders:$Y,transferable:!0,fetchOptions:m,urlModifier:_}))):QY(T,{buffer:i.data,byteOffset:0},{requestImage:P,decoders:$Y,transferable:!0,fetchOptions:m,urlModifier:_})}))}function KY(i,g,m,_){i?YY[g]?YY[g].push(_):(YY[g]=[_],self.postMessage({type:"<request>",command:"sendImageData",actorId:i,workerId:void 0,params:g})):function(i,g){const m=new Image;m.onload=()=>{if(!eQ)return void g(new Error("There is no canvas to draw image!"));eQ.width=m.width,eQ.height=m.height;const i=eQ.getContext("2d");i.drawImage(m,0,0,m.width,m.height);const _=i.getImageData(0,0,m.width,m.height),b={width:m.width,height:m.height,data:new Uint8Array(_.data)};g(null,b,[b.data.buffer])},m.onerror=function(i){g(i)},m.src=i}(g,_)}const eQ="undefined"==typeof document?null:document.createElement("canvas"),tQ=[],nQ=[],rQ=[],iQ=[],oQ=[1,1,1],sQ=[],aQ=[],lQ=[1,1,1],hQ=[],cQ=new wP.BoundingBox,uQ=function(i,g){const m=[];return m[0]=i[0],m[1]=i[1],m[2]=i[2],m[3]=0,m[4]=i[3],m[5]=i[4],m[6]=i[5],m[7]=0,m[8]=i[6],m[9]=i[7],m[10]=i[8],m[11]=0,m[12]=g[0],m[13]=g[1],m[14]=g[2],m[15]=1,m}(function(i){const g=Math.cos(i),m=Math.sin(i),_=[];return _[0]=1,_[1]=0,_[2]=0,_[3]=0,_[4]=g,_[5]=m,_[6]=0,_[7]=-m,_[8]=g,_}(.5*Math.PI),[0,0,0]),fQ=new un(0,0),dQ=[186/255,186/255,186/255,1],pQ={lightAmbient:[1,1,1],lightDiffuse:[1,1,1],lightSpecular:[1,1,1],lightDirection:[1,1,1]},gQ=new Set(["url","translationX","translationY","translationZ","rotationX","rotationY","rotationZ","scaleX","scaleY","scaleZ","anchorZ","markerPixelHeight","modelHeight"]),mQ=[1,1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1],AQ=[0,1,1,2,2,3,3,0,0,4,1,5,2,6,3,7,4,5,5,6,6,7,7,4],yQ=[.8,.8,.1,1];class lt extends yf{constructor(i,g){const m=Po.extend({},g),_=m.symbol;super(i,m),this.options.symbol=_,this._loaded=!1,this._modelMatrix=mA([]),this._type="gltfmarker",this._dirty=!0,this._dirtyMarkerBBox=!0,this._defaultTRS={get translation(){return[0,0,0]},get rotation(){return[0,0,0]},get scale(){return[1,1,1]}},this._updateTRSMatrix()}static parseJSONData(i){const g=lt.fromJSON(i);return g.setZoomOnAdded(i.zoomOnAdded),g}static fromJSON(i){return new lt(i.coordinates,i.options)}static getGLTFAnchorsAlongLineString(i,g,m,_){const b=[];for(let T=0;T<i.length-1;T++){const P=BY(i[T],i[T+1],{map:m,bboxWidth:g,gapLength:_.gapLength||0,count:_.count,rotateAlongLine:_.rotateAlongLine,snapToEndVertexes:_.snapToEndVertexes,scaleEndModel:_.scaleEndModel});Po.pushIn(b,P)}return b}static combineGLTFBoundingBox(i){const g=[];for(let m=0;m<i.length;m++){const _=i[m].getBoundingBox();g.push([_.min,_.max])}const m=g[0];if(!m)return null;const _=WA([],m[0]),b=WA([],m[1]);for(let i=1;i<g.length;i++){const m=g[i],T=WA([],m[0]),P=WA([],m[1]);T[0]<_[0]&&(_[0]=T[0]),T[1]<_[1]&&(_[1]=T[1]),T[2]<_[2]&&(_[2]=T[2]),P[0]>b[0]&&(b[0]=P[0]),P[1]>b[1]&&(b[1]=P[1]),P[2]>b[2]&&(b[2]=P[2])}return{min:_,max:b}}setTransformOrigin(i){this._transformOrigin=i}getTransformOrigin(){return this._transformOrigin||this.getCenter()}getMeshes(i,g,m){let _=[];const b=this.getMap();if(g&&(this.regl=g),this.getLayer().isVisible()&&this.isVisible()&&this._getOpacity()){if(!this._meshes)return this._loginGLTF(i,g),_;let T=this.isAnimated()||this._getMarkerPixelHeight()&&b.isZooming()||this._dirtyMarkerBBox||"multigltfmarker"===this.getGLTFMarkerType()&&this._dirty||"effectmarker"===this.getGLTFMarkerType();if(!T){const i=this._modelMatrix;gA(sQ,i),this._updateTRSMatrix(),T=!BA(i,sQ)}T&&this._updateMeshMatrix(this._meshes,m),_=this._meshes.filter((i=>!!(qj(b.projViewMatrix,i.getBoundingBox())||i instanceof wP.InstancedMesh)&&(this._updateUniforms(i,m),this._updateDefines(i),!0))),this._setDirty(!1)}return _}getGLTFJSON(){return this._gltfData}getAllMeshes(){return this._meshes}_getGLTFData(){return this._gltfData}_setGLTFData(i){this._gltfData=i}_setPropInExternSymbol(i,g){this._externSymbol=this._externSymbol||{},this._externSymbol[i]=g,"uniforms"===i&&(this._uniformDirty=!0)}setUrl(i){return this.updateSymbol({url:i}),this}setSymbol(i){const g=this.getUrl();super.setSymbol(i);const m=this.getShader(),_=this._gltfManager;_&&i.url!==g&&(_.logoutGLTF(g),this._login=!1,this._setLoadState(!1),delete this._meshes),this._shader&&this._shader!==m&&this._updateGeometries(_,this.regl),this._shader=m,this._uniformDirty=!0,this._dirty=!0}getCenter(){const i=this.getMap();if(!i)return null;const g=NY(i,super.getCenter()||this.getCoordinates());if(!g)return null;const m=this._getTranslationPoint(),_=new un([g[0]+m[0],g[1]+m[1],g[2]+m[2]]),b=i.getGLRes(),T=i.pointAtResToCoord(_,b);return T.z=_.z/i.altitudeToPoint(100,b)*100,T}getPointZ(){const i=this.getCoordinates(),g=this.getMap();return g&&i?g.altitudeToPoint(i.z||0,g.getGLRes()):null}getUrl(){const i=this._getInternalSymbol();return i&&i.url||"pyramid"}addTo(i){if(this.getLayer())throw new Error("GLTFMarker cannot be added to two or more layers at the same time.");return i.addGeometry(this),this}_loginGLTF(i,g){const m=this.getUrl();if(this._gltfManager=i,!this._login){const g=this.getLayer().getRenderer();i.loginGLTF(m,((...i)=>g._requestor.apply(g,i))),this._login=!0}const _=i.getGLTF(m);_&&!_.then&&(this._setLoadState(!0),this._createMeshes(_,i,g))}_updateUniforms(i,g){"effectmarker"===this.getGLTFMarkerType()?this.updateUV(g):"glowmarker"===this.getGLTFMarkerType()&&this._updateTime();const m=this.getUniforms();if(m&&this.isDirty()&&this._isUniformsDirty())for(const g in m)this._uniformNodeIndex&&FY(this._uniformNodeIndex[g])?Number(i.properties.nodeIndex)===this._uniformNodeIndex[g]&&i.setUniform(g,m[g]):i.setUniform(g,m[g]);this._isTransparent()&&(i.transparent=!0),i.setUniform("uPickingId",this._getPickingId()),i.properties.isAnimated=this.isAnimated()}_updateDefines(i){const g=this.getShader(),m=i.getDefines();let _=!1;if("pbr"===g||"pbr-lite"===g){const i=this.getLayer(),{iblTexes:g}=wP.pbr.PBRUtils.getIBLResOnCanvas(i.getRenderer().canvas);g?m.HAS_IBL_LIGHTING||(m.HAS_IBL_LIGHTING=1,_=!0):m.HAS_IBL_LIGHTING&&(_=!0,delete m.HAS_IBL_LIGHTING)}_&&i.setDefines(m);const b=this.getLayer().getRenderer();b&&b.updateMaskDefines(i)}_updateGeometries(i){const g=this.getUrl(),m=this._meshes;i&&m&&(i.isSimpleModel(g)?this._updateMaterials(m):i.getGLTF(g)&&(m.forEach((i=>{this._updateUniforms(i)})),this._updateMaterials(m)))}_updateMaterials(i){const g=this.getShader();i.forEach((i=>{const m=this._buildMaterial(i.properties.geometryResource);"wireframe"===g?(i.properties.geometryResource&&!i.properties.geometryResource.copyGeometry&&i.properties.geometryResource.copyEdgeGeometry(),i.geometry=i.properties.geometryResource.copyGeometry):i.geometry=i.properties.geometryResource.geometry,i.material=m}))}_updateMeshMatrix(i,g){qA(oQ,1,1,1);const m=mA(sQ),_=this.isAnimated();this._updateTRSMatrix();const b=this.getModelMatrix(),{nodeMatrixMap:T,skinMap:P}=this._updateAnimation(g);this._calSpatialScale(oQ);let I=0;i.forEach((i=>{const g=i.properties.geometryResource.nodeIndex,H=T[g],W=_&&H?H:i.nodeMatrix;xA(m,b,oQ),_A(m,m,uQ),i._nodeMatrix=i._nodeMatrix||mA([]);const q=_A(hQ,i._nodeMatrix,W);i instanceof wP.InstancedMesh?(i.positionMatrix=_A(i.positionMatrix,m,q),i.localTransform=this._getCenterMatrix(),this._updateInstancedMeshData(i)):i.localTransform=_A(i.localTransform,m,q);const $=i.geometry.boundingBox.copy(cQ);$.transform(i.positionMatrix,i.localTransform);const ye=this._calAnchorTranslation($);if(Math.abs(ye)>Math.abs(I)&&(I=ye),_){const m=P[g];m&&(i.material.set("skinAnimation",1),i.material.set("jointTextureSize",m.jointTextureSize),i.material.set("numJoints",m.numJoints),i.material.set("jointTexture",m.jointTexture));const _=i.geometry.properties.morphWeights;_&&this._fillMorphWeights(_,i.material)}else i.material.set("skinAnimation",0)}));const H=this._getBoundingBoxMesh();if(H&&(xA(m,b,oQ),_A(m,m,uQ),this._bboxMesh.localTransform=_A(this._bboxMesh.localTransform,m,this._bboxMesh._originLocalTransform)),0!==I){qA(aQ,0,0,I);const g=wA(sQ,aQ);i.forEach((i=>{if(i instanceof wP.InstancedMesh)i.positionMatrix=_A(i.positionMatrix,g,i.positionMatrix),this._updateInstancedMeshData(i);else{const m=_A(i.localTransform,g,i.localTransform);i.localTransform=m}})),H&&(this._bboxMesh.localTransform=_A(this._bboxMesh.localTransform,g,this._bboxMesh.localTransform))}i.forEach((i=>{i instanceof wP.InstancedMesh&&this._updateInstancedMeshData(i)})),this.fire("updatematrix",{target:this})}getBoundingBoxCenter(){const i=this._gltfModelBBox,g=this.getMap();if(!i||!this._bboxMesh||!g)return null;const m=g.getGLRes(),{min:_,max:b}=i,T=XA([],_,b);QA(T,T,.5),oy(T,T,this._bboxMesh.localTransform);const P=new un(T),I=g.pointAtResToCoordinate(P,m);return I.z=100/g.altitudeToPoint(100,m)*T[2],I}getBoundingBoxWidth(i){const g=this._gltfModelBBox;if(!g)return 0;let m=0;"x"===i?m=0:"y"===i?m=2:"z"===i&&(m=1);const{min:_,max:b}=g,T=this._getScale()[m];return(b[m]-_[m])*T}getAxisXWidth(){return this.getBoundingBoxWidth("x")}getAxisYWidth(){return this.getBoundingBoxWidth("y")}getAxisZWidth(){return this.getBoundingBoxWidth("z")}_calSpatialScale(i){const g=this.getMap(),m=g.getGLRes(),_=g.altitudeToPoint(100,m);return i[0]*=_/100,i[1]*=_/100,i[2]*=_/100,i}_calModelHeightScale(i,g){return this.gltfPack.calModelHeightScale(i,g)}_calFixSizeScale(i,g){const m=this._gltfModelBBox;if(!g||g<0||!m)return i;const _=this.getMap(),b=Math.abs(m.max[1]-m.min[1]),T=_.altitudeToPoint(b,_.getGLRes()),P=g*_.getGLScale()/T;return qA(i,P,P,P)}getCurrentPixelHeight(){const i=this.getBoundingBox();return Math.abs(i.max[2]-i.min[2])/this.getMap().getGLScale()}getFitTranslate(i){const g=this._gltfModelBBox,m=qA(i,(g.min[0]+g.max[0])/2,(g.min[1]+g.max[1])/2,(g.min[2]+g.max[2])/2);return QA(m,m,-1)}_calAnchorTranslation(i){const g=this.getSymbol(),m=g&&g.anchorZ||"center";let _=0;const b=i.max[2]-i.min[2];return"bottom"===m?_=b/2:"top"===m&&(_=-b/2),_}_updateAnimation(i){const g=this.isAnimated(),m=this._hasGLTFAnimations(),_={},b=this._getSkinMap();if(i&&g&&this.gltfPack&&m){const g=this._getCurrentAnimation();if(FY(g)){this._setAnimationStartTime(i);const m=this._getAnimationStartTime(),T=this.isAnimationLooped(),P=this.getAnimationSpeed(),I=this.getSymbol(),H=I&&I.animationNodes;for(let I=0;I<g.length;I++)this.gltfPack.updateAnimation(i,T,P,g[I],m,_,b,H)}else console.warn("animation specified does not exist!")}return{nodeMatrixMap:_,skinMap:b}}_createMeshes(i,g,m){const _=this.getUrl();this._setGLTFData(i.json),this._prepareMeshes(_,g,m),this._updateGeometries(g,m),this.createdBygltfmarker||(this.fire("load",{data:i.json}),this.fire("setUrl-debug"),this._fireEvent("meshcreate",{url:_}))}_prepareMeshes(i,g,m){const _=[],b=this.getShader(),T=g.getGLTF(i);if(T&&T.resources){if(!T.resources.length)return void this._fireEvent("modelerror",{url:i,info:"there are no geomtries in the gltf model"});this.gltfPack=T.gltfPack,T.resources.forEach((i=>{const g=this._prepareMesh(i,b,m);_.push(g)}))}this._meshes=_,this._gltfModelBBox=this._calGLTFModelBBox(),this._checkSize(this._meshes),this.fire("createscene-debug",{meshes:this._meshes})}_checkSize(i){this._updateMeshMatrix(i);const g=this.getBoundingBox();if(!g)return;const m=this.getMap(),{max:_,min:b}=g;GA([_[0]-b[0],_[1]-b[1],_[2]-b[2]])/m.getGLScale()<20&&(console.warn("Model's size on screen is too small, try to increase its symbol.scaleX/Y/Z"),this.fire("smallonscreen"))}_getBoundingBoxMesh(){if(this._bboxMesh)return this._bboxMesh.material.set("lineColor",this._bboxLineColor||yQ),this._bboxMesh.material.set("lineOpacity",this._bboxLineOpacity||1),this._bboxMesh;const i=this._gltfModelBBox;if(!i)return null;const{min:g,max:m}=i;mQ[0]=m[0],mQ[1]=g[1],mQ[2]=m[2],mQ[3]=m[0],mQ[4]=m[1],mQ[5]=m[2],mQ[6]=g[0],mQ[7]=m[1],mQ[8]=m[2],mQ[9]=g[0],mQ[10]=g[1],mQ[11]=m[2],mQ[12]=m[0],mQ[13]=g[1],mQ[14]=g[2],mQ[15]=m[0],mQ[16]=m[1],mQ[17]=g[2],mQ[18]=g[0],mQ[19]=m[1],mQ[20]=g[2],mQ[21]=g[0],mQ[22]=g[1],mQ[23]=g[2];const _=new wP.Geometry({POSITION:mQ},AQ,0,{primitive:"lines",positionAttribute:"POSITION"});_.generateBuffers(this.regl);const b=new wP.Mesh(_,new wP.Material({lineColor:this._bboxLineColor||yQ,lineOpacity:this._bboxLineOpacity||1}));return this._bboxMesh=b,this._bboxMesh._originLocalTransform=gA([],b.localTransform),b}showBoundingBox(i){this.options.showDebugBoundingBox=!0,this._bboxLineColor=i&&i.lineColor,this._bboxLineOpacity=i&&i.lineOpacity,this._dirty=!0}hideBoundingBox(){this.options.showDebugBoundingBox=!1,this._dirty=!0}getBoundingBox(){const i=this._meshes;if(!i||!i.length)return null;if(!this._dirtyMarkerBBox)return this._markerBBox;"multigltfmarker"===this.getGLTFMarkerType()&&i.forEach((i=>{this._updateInstancedMeshData(i),i.updateBoundingBox()}));const g=i[0].getBoundingBox(),m=WA([],g[0]),_=WA([],g[1]);for(let g=1;g<i.length;g++){const b=i[g].getBoundingBox(),T=WA([],b[0]),P=WA([],b[1]);T[0]<m[0]&&(m[0]=T[0]),T[1]<m[1]&&(m[1]=T[1]),T[2]<m[2]&&(m[2]=T[2]),P[0]>_[0]&&(_[0]=P[0]),P[1]>_[1]&&(_[1]=P[1]),P[2]>_[2]&&(_[2]=P[2])}const b={min:m,max:_};return this._markerBBox=b,"multigltfmarker"===this.getGLTFMarkerType()?this._data.length&&(this._dirtyMarkerBBox=!1):this._dirtyMarkerBBox=!1,b}_calGLTFModelBBox(){return this.gltfPack.getGLTFBBox()}_prepareMesh(i,g,m){const _=this._buildMesh(i,g,m),b=_.getDefines();return _ instanceof wP.InstancedMesh?(b.HAS_PICKING_ID=1,b.HAS_INSTANCE_COLOR=1):b.HAS_PICKING_ID=2,_.geometry.data.COLOR_0&&(b.HAS_COLOR0=1),b.HAS_MIN_ALTITUDE=1,b.HAS_LAYER_OPACITY=1,_.setDefines(b),_}_buildMesh(i,g,m){const _=this.getGLTFMarkerType();let b=null;const T=this._buildMaterial(i);let P=i.geometry;if("wireframe"===g&&(i.copyEdgeGeometry(),P=i.copyGeometry),m?P.generateBuffers(m):(this._noBuffersGeometries=this._noBuffersGeometries||[],this._noBuffersGeometries.push(P)),"multigltfmarker"===_){this._updateAttributeMatrix();const i=this._getInstanceAttributesData(mA(iQ)),g=this._getNoBloomDataCount();b=new wP.InstancedMesh(i.attributesData,g,P,T),b.setUniform("instance",1),m?b.generateInstancedBuffers(m):(this._noBuffersMeshes=this._noBuffersMeshes||[],this._noBuffersMeshes.push(b))}else b=new wP.Mesh(P,T),b.setUniform("instance",0);b.nodeMatrix=gA([],i.nodeMatrix),b.properties.geometryResource=i,b.properties.nodeIndex=i.nodeIndex,this.isBloom()&&(b.bloom=1),b.transparent=this._isTransparent(),"BLEND"===i.extraInfo.alphaMode&&(b.transparent=!0),b.properties.pickingId=this._getPickingId(),this._setPolygonFill(b);const I=this.getLayer();return Object.defineProperty(b.uniforms,"minAltitude",{enumerable:!0,get:()=>I.options.altitude||0}),b}_buildMaterial(i){let g=null;const m=this.getShader(),_=this.getUniforms()||{},b=i.materialInfo||{},T=this.getLayer().getRenderer();if("phong"===m)if("pbrSpecularGlossiness"===b.name)g=new wP.PhongSpecularGlossinessMaterial(b);else{for(const i in pQ)_[i]=_[i]||pQ[i];g=new wP.PhongMaterial(b)}else if("pbr"===m){if(g="pbrSpecularGlossiness"===b.name?new wP.pbr.StandardSpecularGlossinessMaterial(b):new wP.pbr.StandardMaterial(b),T.regl&&!wP.pbr.PBRUtils.isSupported(T.regl)){g=wP.PhongMaterial.convertFrom(g);for(const i in pQ)_[i]=_[i]||pQ[i]}}else g="pbr-lite"===m?new wP.StandardLiteMaterial(b):new wP.Material(b);const P=this.getSymbol(),I=P&&P.doubleSided;FY(I)&&(g.doubleSided=I);for(const i in _)g.set(i,_[i]);return i.morphWeights&&this._fillMorphWeights(i.morphWeights,g),i.skin&&g.set("skinAnimation",0),g}_fillMorphWeights(i,g){const m=g.get("morphWeights1")||[],_=g.get("morphWeights2")||[];for(let g=0;g<4;g++)m[g]=i[g]||0,_[g]=i[g+4]||0;g.set("morphWeights1",m),g.set("morphWeights2",_)}_setPolygonFill(i){const g=this.getSymbol();g&&g.uniforms?(i.setUniform("polygonFill",g.uniforms.polygonFill||dQ),i.setUniform("polygonOpacity",void 0===g.uniforms.polygonOpacity?1:g.uniforms.polygonOpacity),i.setUniform("lineColor",g.uniforms.lineColor||dQ),i.setUniform("lineOpacity",void 0===g.uniforms.lineOpacity?1:g.uniforms.lineOpacity)):(i.setUniform("polygonFill",dQ),i.setUniform("polygonOpacity",1),i.setUniform("lineColor",dQ),i.setUniform("lineOpacity",1))}_getMarkerContainerExtent(){const i=this.getLayer();if(!i)return null;const g=i.getMap();if(!g)return null;const m=this.getBoundingBox();if(!m)return null;const _=m.min,b=m.max,T=wy(nQ,(_[0]+b[0])/2,(_[1]+b[1])/2,_[2],1),P=wy(rQ,(_[0]+b[0])/2,(_[1]+b[1])/2,b[2],1),I=Fy(T,T,g.projViewMatrix),H=Fy(P,P,g.projViewMatrix),W=(I[0]/I[3]+1)*g.width/2,q=(1-I[1]/I[3])*g.height/2,$=(H[0]/H[3]+1)*g.width/2,ye=(1-H[1]/H[3])*g.height/2,Re=Math.min(W,$),Be=Math.max(W,$),Ge=Math.min(q,ye),je=Math.max(q,ye);return new Pl({xmin:Re,ymin:Ge,xmax:Be,ymax:je})}onAdd(){const i=this.getLayer().getMap();if(i&&!FY(this._zoomOnAdded)){const g=i.getZoom();this._zoomOnAdded=g}}onRemove(){this._deleteTRSState()}remove(){const i=this.getUrl();if(this._gltfManager&&(delete this._meshes,this._gltfManager.logoutGLTF(i),delete this._gltfManager),this._skinMap){for(const i in this._skinMap)this._skinMap[i]&&this._skinMap[i].jointTexture&&this._skinMap[i].jointTexture.destroy();delete this._skinMap}this._bboxMesh&&(this._bboxMesh.geometry.dispose(),this._bboxMesh.dispose(),delete this._bboxMesh),this._meshes&&this._meshes.forEach((i=>{i.dispose(),i.properties.bloomMesh&&(i.properties.bloomMesh.dispose(),delete i.properties.bloomMesh)})),this._login=!1,delete this._gltfData,delete this.gltfPack,super.remove()}show(){return super.updateSymbol({visible:!0}),this}hide(){super.updateSymbol({visible:!1})}setBloom(i){return this.updateSymbol({bloom:i}),this}isBloom(){const i=this._getInternalSymbol();return i&&i.bloom}setCastShadow(i){return super.updateSymbol({shadow:i}),this}isCastShadow(){const i=this._getInternalSymbol();return i&&(i.shadow||void 0===i.shadow)}outlineNodes(i){const g=this._meshes;return g?(g.forEach((g=>{i.indexOf(g.properties.nodeIndex)>-1&&(g.properties.outline=!0)})),this._dirty=!0,this):this}outline(){this.updateSymbol({outline:!0});const i=this._meshes;return i?(i.forEach((i=>{i.properties.outline=!0})),this._dirty=!0,this):this}cancelOutline(i){this.updateSymbol({outline:!1});const g=this._meshes;return g?(g.forEach((g=>{i?i.indexOf(g.properties.nodeIndex)>-1&&(g.properties.outline=!1):g.properties.outline=!1})),this._dirty=!0,this):this}isOutline(){const i=this._getInternalSymbol();return!(!i||!FY(i.outline))&&i.outline}isVisible(){const i=this._getInternalSymbol();return!i||!FY(i.visible)||i.visible}setCoordinates(i){return super.setCoordinates(i),this._dirty=!0,this._dirtyMarkerBBox=!0,this}copy(){const i=this.toJSON(),g=lt.fromJSON(i);return g.setZoomOnAdded(this._zoomOnAdded),g}setShader(i){return super.updateSymbol({shader:i}),this}getShader(){const i=this._getInternalSymbol();return i&&i.shader||"pbr"}setUniforms(i){return super.updateSymbol({uniforms:i}),this._uniformDirty=!0,this}getUniforms(){const i=this._getInternalSymbol();return i&&i.uniforms}setUniform(i,g,m){const _=this.getUniforms()||{};return _[i]=g,super.updateSymbol({uniforms:_}),this._uniformDirty=!0,this._uniformNodeIndex=this._uniformNodeIndex||{},this._uniformNodeIndex[i]=m,this}getUniform(i){const g=this._getInternalSymbol();return g&&g.uniforms&&g.uniforms[i]}isAnimated(){const i=this._getInternalSymbol();return i&&i.animation&&this._gltfData&&this._gltfData.animations}isDashAnimated(){const i=this._getInternalSymbol();return i&&i.uniforms&&i.uniforms.dashEnabled&&i.uniforms.dashAnimate}setAnimation(i){return super.updateSymbol({animation:i}),delete this._startAnimationTime,this}setAnimationLoop(i){return super.updateSymbol({loop:i}),delete this._startAnimationTime,this._dirty=!0,this}isAnimationLooped(){const i=this._getInternalSymbol();return i&&i.loop}getAnimationSpeed(){const i=this._getInternalSymbol();return i&&FY(i.speed)?i.speed:1}setAnimationSpeed(i){return super.updateSymbol({speed:i}),this}_getPosition(i){const g=this.getMap();return g?NY(g,i||this.getCoordinates()):null}setTRS(i,g,m){const _=i||this._defaultTRS.translation;return this.updateSymbol({translationX:_[0],translationY:_[1],translationZ:_[2],rotationX:g[0],rotationY:g[1],rotationZ:g[2],scaleX:m[0],scaleY:m[1],scaleZ:m[2]}),this}_getWorldTranslation(){const i=this._getTranslationPoint(),g=this._getPosition();return g?XA(i,i,g):i}updateSymbol(i){for(const g in i)if("bloom"===g&&this._meshes&&this._meshes.forEach((m=>{m.bloom=+!!i[g]})),gQ.has(g)){this._dirtyMarkerBBox=!0;break}return super.updateSymbol(i)}setTranslation(i,g,m){return this.updateSymbol({translationX:i,translationY:g,translationZ:m}),this}setRotation(i,g,m){return this.updateSymbol({rotationX:i,rotationY:g,rotationZ:m}),this}rotateAround(i,g){const m=this.getMap();if(!m)return;const _=m.getGLRes();let b=this.getCoordinates();const T=m.coordinateToPointAtRes(b,_),P=m.coordinateToPointAtRes(i,_),I=T.x-P.x,H=T.y-P.y,W=180*Math.atan2(H,I)/Math.PI+g,q=Math.sqrt(I*I+H*H),$=Math.PI*W/180,ye=q*Math.cos($)+P.x,Re=q*Math.sin($)+P.y;fQ.set(ye,Re),b=m.pointAtResToCoordinate(fQ,_),this.setCoordinates(b),this.updateSymbol({rotationZ:W})}setScale(i,g,m){return this.updateSymbol({scaleX:i,scaleY:g,scaleZ:m}),this}getTranslation(){const i=this._getInternalSymbol();return qA(this._defaultTRS.translation,i&&i.translationX||0,i&&i.translationY||0,i&&i.translationZ||0)}_getTranslationPoint(){const i=this.getTranslation();return this.getMap()?this._translationToWorldPoint(i):this._defaultTRS.translation}_translationToWorldPoint(i){const g=this.getMap(),m=g.distanceToPointAtRes(i[0],i[1],g.getGLRes(),fQ),_=g.altitudeToPoint(i[2],g.getGLRes());return qA(aQ,HY(m.x,i[0]),HY(m.y,i[1]),HY(_,i[2]))}getRotation(){const i=this._getInternalSymbol();return qA(this._defaultTRS.rotation,i&&i.rotationX||0,i&&i.rotationY||0,i&&i.rotationZ||0)}getScale(){const i=this._getInternalSymbol();if(!i)return qA(this._defaultTRS.scale,1,1,1);const g=Po.isNil(i.scaleX)?1:i.scaleX,m=Po.isNil(i.scaleY)?1:i.scaleY,_=Po.isNil(i.scaleZ)?1:i.scaleZ;return qA(this._defaultTRS.scale,g,m,_)}_getScale(){const i=this.getScale();if(this._gltfModelBBox){const g=this._getMarkerPixelHeight(),m=this.getModelHeight();if(g&&g>0){const m=this._calFixSizeScale(lQ,g);return $A(m,m,i)}if(m){const g=this._calModelHeightScale(lQ,m);return $A(g,g,i)}}return i}cancelMarkerPixelHeight(){return this.updateSymbol({markerPixelHeight:null})}setAnchorZ(i){return this.updateSymbol({anchorZ:i}),this}getAnchorZ(){const i=this._getInternalSymbol();return i&&i.anchorZ||"bottom"}_setExternSymbol(i){return this._dirty=!0,super._setExternSymbol(i)}_loadFunctionTypes(i){return CL(i,(()=>{const i=this.getMap();return i?[i.getZoom()]:null}))}_prepareSymbol(i){super._prepareSymbol(i);const g=this._loadFunctionTypes(i);return g&&g.uniforms&&(g.uniforms=this._loadFunctionTypes(i.uniforms)),delete this._hasFuncDefinition,g}hasFunctionDefinition(){if(FY(this._hasFuncDefinition))return this._hasFuncDefinition;const i=this._getInternalSymbol();return this._hasFuncDefinition=TL(i)||i&&i.uniforms&&TL(i.uniforms),this._hasFuncDefinition}setModelMatrix(i){const g=CA(this._defaultTRS.translation,i),m=kA(this._defaultTRS.rotation,i),_=PA(this._defaultTRS.scale,i);return this.setTranslation(g[0],g[1],g[2]),this.setRotation(m[0],m[1],m[2]),this.setScale(_[0],_[1],_[2]),this}getModelMatrix(){return this._modelMatrix}_updateTRSMatrix(){const i=this._getWorldTranslation(),g=this.getRotation(),m=o_(tQ,g[0],g[1],g[2]),_=this._getScale();this._modelMatrix=OA(this._modelMatrix,m,i,_)}isDirty(){return this._dirty}_setDirty(i){return this._dirty=i,this}_toJSONObject(){const i=this.toJSON();return i.zoomOnAdded=this._zoomOnAdded,i}toJSON(){const i=JSON.parse(JSON.stringify({coordinates:this.getCoordinates(),options:this.options||{},type:"GLTFMarker"})),g=this.getId();Po.isNil(g)||(i.options.id=g);const m=this.getProperties();m&&(i.options.properties=JSON.parse(JSON.stringify(m)));const _=this.getSymbol();return _&&(i.options.symbol=JSON.parse(JSON.stringify(_))),i}setZoomOnAdded(i){this._zoomOnAdded=i}getZoomOnAdded(){return this._zoomOnAdded}_isTransparent(){return this._getOpacity()<1}_getOpacity(){const i=this.getUniforms(),g=this.getShader();return"pbr"===g||"phong"===g?i&&FY(i.polygonOpacity)?i.polygonOpacity:1:"wireframe"===g&&i&&FY(i.lineOpacity)?i.lineOpacity:1}_setLoadState(i){this._loaded=i}isLoaded(){return this._loaded}getGLTFMarkerType(){return this._type}_setPickingId(i){this._pickingId=i}_getPickingId(){return this._pickingId}getCount(){return 1}getContainerExtent(){return this._getMarkerContainerExtent()}getGLTFAsset(){return this._gltfData&&this._gltfData.asset}openInfoWindow(i){this._gltfData?super.openInfoWindow(i):this.once("load",(()=>{super.openInfoWindow(i)}))}getAnimations(){if(!this._gltfData)return null;const i=this._gltfData,g=i.animations?i.animations.map(((i,g)=>({name:FY(i.name)?i.name:g}))):null;return g?g.map(((i,g)=>i.name||g)):null}getCurrentAnimation(){const i=this._getInternalSymbol();return i&&i.animationName}_getCurrentAnimation(){const i=this.getAnimations();if(!i)return null;let g=this.getCurrentAnimation();if(!FY(g))return i.slice(0,1);const m=[];g=Array.isArray(g)?g:[g];for(let _=0;_<g.length;_++)i.indexOf(g[_])>-1&&m.push(g[_]);return m.length?m:null}setCurrentAnimation(i){this.updateSymbol({animationName:i})}_setAnimationStartTime(i){FY(this._startAnimationTime)||(this._startAnimationTime=i)}_getAnimationStartTime(){return this._startAnimationTime||0}_getSkinMap(){return this._skinMap=this._skinMap||{},this._skinMap}_getMarkerPixelHeight(){const i=this._getInternalSymbol();return i&&i.markerPixelHeight}setModelHeight(i){return this.updateSymbol({modelHeight:i}),this}getModelHeight(){const i=this._getInternalSymbol();return i&&i.modelHeight}getGLTFBBox(){return this._gltfModelBBox}zoomTo(i={animation:!0},g){const m=this.getBoundingBox(),_=this.getMap();if(!_||!m)return;const{min:b,max:T}=m;fQ.set((b[0]+T[0])/2,(b[1]+T[1])/2);const P=_.getGLRes(),I=_.pointAtResToCoordinate(fQ,P);return I.z=(b[2]+T[2])/2/_.altitudeToPoint(1,P),this._zoomTo(I,i,g)}_zoomTo(i,g,m){const _=this.getMap(),b=g.pitch||_.getPitch(),T=g.bearing||_.getBearing(),P=g.duration||500,I=g.easing||"linear",H=this._getFitZoomByBoundingBox(g.heightOffset||0)+(g.zoomOffset||0);return g.animation||void 0===g.animation?_.animateTo({center:i,zoom:H,bearing:T,pitch:b},{duration:P,easing:I},m):_.setView({center:i,zoom:H,bearing:T,pitch:b}),this}_getFitZoomByBoundingBox(i){const g=this.getMap(),m=g.getGLRes(),_=g.distanceToPointAtRes(100,0,m).x/100,b=this.getBoundingBox(),{min:T,max:P}=b,I=P[2]/g.altitudeToPoint(1,m)+i,H=g.getFitZoomForAltitude(I*_);fQ.set(T[0],T[1]);const W=g.pointAtResToCoordinate(fQ,g.getGLRes());fQ.set(P[0],P[1]);const q=g.pointAtResToCoordinate(fQ,g.getGLRes()),$=new Pl(W,q),ye=g.getFitZoom($);return H<ye?H:ye}_isUniformsDirty(){return this._uniformDirty}_resetUniformsDirty(){this._uniformDirty=!1}setAnimationTimeframe(i){const g=this._getAnimationStartTime(),m=this._getSkinMap();this.gltfPack.updateAnimation(i,this.isAnimationLooped(),this.getAnimationSpeed(),g,{},m)}_deleteTRSState(){delete this._markerBBox,delete this._zoomOnAdded}_hasGLTFAnimations(){return"effectmarker"!==this.getGLTFMarkerType()&&"glowmarker"!==this.getGLTFMarkerType()}_onEvent(i,g){const m=this.getLayer();if(!m)return;const _=m.getId();this._pickingParams=i.gltfPickingInfo&&i.gltfPickingInfo[_]||{},super._onEvent(i,g)}_fireEvent(i,g){for(const i in this._pickingParams)g[i]=this._pickingParams[i];delete this._pickingParams,super._fireEvent(i,g)}_getOutlineMeshes(){let i=[];return this._meshes&&this.isVisible()&&this._getOpacity()?this.isOutline&&this.isOutline()?this._meshes:(i=this._meshes.filter((i=>i.properties.outline)),i):i}highlightNodes(i){const g=this._meshes;g?this._highlightForMeshes(i,g):this.once("load",(()=>{this._highlightForMeshes(i,this._meshes)}),this)}_highlightForMeshes(i,g){i.forEach((i=>{g.forEach((g=>{g.properties.nodeIndex===i.nodeIndex&&this._highlightMesh(g,i.color,i.opacity,i.bloom)}))})),this._dirty=!0}highlight(i){const{color:g,opacity:m,bloom:_}=i,b=this._meshes;b?(b.forEach((i=>{this._highlightMesh(i,g,m,_)})),this._dirty=!0):this.once("load",(()=>{this._meshes.forEach((i=>{this._highlightMesh(i,g,m,_)})),this._dirty=!0}),this)}_highlightMesh(i,g,m,_){i.properties.polygonFill||(i.properties.polygonFill=i.getUniform("polygonFill")||dQ),i.properties.polygonOpacity||(i.properties.polygonOpacity=i.getUniform("polygonOpacity")||1),i.setUniform("polygonFill",g||dQ),i.setUniform("polygonOpacity",m||1),i.bloom=_}_cancelHighlight(){if(this._highlighted)if(Array.isArray(this._highlighted)){const i=this._highlighted.map((i=>i.nodeIndex));this.cancelHighlight(i)}else this.cancelHighlight(this._highlighted.nodeIndex)}cancelHighlight(i){const g=this.getLayer();if(!g)return;const m=g.getRenderer();if(!m)return;let _=this._meshes;if(_){if(i){let g=i;Array.isArray(g)||(g=[g]),_=_.filter((i=>g.indexOf(i.properties.nodeIndex)>-1))}_.forEach((i=>{const{polygonFill:g,polygonOpacity:m}=i.properties;i.setUniform("polygonFill",g),i.setUniform("polygonOpacity",m),i.bloom=!1})),m.setToRedraw()}}setNodeTRS(i,g={}){const m=this._meshes;if(!m)return;const _=g.translation||this._defaultTRS.translation,b=g.rotation||this._defaultTRS.rotation,T=o_(tQ,b[0],b[1],b[2]),P=g.scale||this._defaultTRS.scale;return m.forEach((g=>{g.properties.nodeIndex===i&&(g._nodeMatrix=OA(g._nodeMatrix||[],T,_,P))})),this._updateMeshMatrix(m),this._dirty=!0,this}}lt.mergeOptions({symbol:null}),lt.registerJSONType("GLTFMarker");const _Q=[1,1,1,1],vQ=[],xQ=[],bQ=[1,1,1],wQ=new pl(0,0),TQ=[1,1,1],SQ=[1,1,1];class ft extends lt{constructor(i,g){super(null,g),this._data=i||[],this._attributeMatrixs=[],this._centerPosition=[0,0,0],this._centerMatrix=mA([]),this._type="multigltfmarker",this._bloomMeshes=[]}static fromJSON(i){return new ft(i.data,i.options)}setCoordinates(i){if(!Array.isArray(i)){const g=this.getCenter(),m=i.sub(g);for(let i=0;i<this._data.length;i++)this._data[i].coordinates instanceof pl?this._data[i].coordinates=this._data[i].coordinates.add(m):(this._data[i].coordinates[0]+=m.x,this._data[i].coordinates[1]+=m.y);return this._dirty=!0,this}return this._coordinates=Array.isArray(i[0])?i.map((i=>new pl(i))):i,this.updateAllData("coordinates",this._coordinates),this._dirty=!0,this}getCoordinates(i){if(i&&this._data&&this._data.length){return this._data[i.index].coordinates}return null}addData(i){this._data||(this._data=[]),this._data.push(i);const g=this.getLayer();return g&&g._updateMarkerMap(),this._dirty=!0,this}removeData(i){this._data.splice(i,1),this._attributeMatrixs&&this._attributeMatrixs.splice(i,1);const g=this.getLayer();return g&&g._updateMarkerMap(),this._dirty=!0,this}getData(i){return this._data[i]}updateData(i,g,m){return this._data[i][g]=m,this._dirty=!0,this}getAllData(){return this._data}updateAllData(i,g){for(let m=0;m<this._data.length;m++)this.updateData(m,i,g[m]);return this}removeAllData(){this._data&&(this._data=[],this._attributeMatrixs=[],this._dirty=!0)}_updateAttributeMatrix(){const i=this.getMap();if(this._data&&i){this._calCenter(),this._attributeMatrixs=this._attributeMatrixs||[];for(let i=0;i<this._data.length;i++)if(!1!==this._data[i].visible){const g=this._updateItemAttributeMatrix(i);this._attributeMatrixs[i]=g}}}openInfoWindow(i){let g=null;g=FY(i)&&this._data[i]?this._data[i].coordinates:this.getCenter(),super.openInfoWindow(g)}getCenter(){let i=0,g=0,m=0,_=0;for(let b=0,T=this._data.length;b<T;b++){let T=this._data[b].coordinates;T instanceof pl&&(T=T.toArray()),i+=T[0],g+=T[1],m+=T[2]||0,_++}return 0===_?null:wQ.set(i/_,g/_,m/_)}getMap(){return super.getMap()||this._layer&&this._layer.getMap()}_setLayer(i){this._layer=i}getLayer(){return super.getLayer()||this._layer}_calCenter(){const i=this.getMap(),g=this.getCenter();if(!g)return;this._centerPosition=NY(i,g);const m=o_(xQ,0,0,0);OA(this._centerMatrix,m,this._centerPosition,bQ)}_updateItemAttributeMatrix(i){const g=this._data[i],m=this._getPosition(g.coordinates);if(!m)return null;const _=cy(vQ,m,this._centerPosition),b=this._translationToWorldPoint(g.translation||this._defaultTRS.translation),T=XA(vQ,b||this._defaultTRS.translation,_||this._defaultTRS.translation),P=g.rotation||this._defaultTRS.rotation,I=this._getDataItemScale(i),H=o_(xQ,P[0]||0,P[1]||0,P[2]||0);return OA(this._attributeMatrixs[i]||[],H,T,I)}_getDataItemScale(i){const g=this._data[i],{modelHeight:m,markerPixelHeight:_}=g,b=g.scale||this._defaultTRS.scale;if(this._gltfModelBBox){if(_&&_>0){const i=this._calFixSizeScale(TQ,_);return $A(i,i,b)}if(m){const i=this._calModelHeightScale(TQ,m);return $A(i,i,b)}}return b}_setLoadState(i){if(super._setLoadState(i),this._data)for(let g=0;g<this._data.length;g++){const m=this._data[g];m.target&&m.target instanceof lt&&m.target._setLoadState(i)}}_updateTRSMatrix(){super._updateTRSMatrix(),this._updateAttributeMatrix()}_updateInstanceAttributesData(){this._attributesData={instance_vectorA:[],instance_vectorB:[],instance_vectorC:[],instance_color:[],aPickingId:[],aOutline:[],highlight_color:[],aBloom:[]},this._bloomAttributeData={instance_vectorA:[],instance_vectorB:[],instance_vectorC:[],instance_color:[],aPickingId:[],aOutline:[],highlight_color:[],aBloom:[]};for(let i=0;i<this._attributeMatrixs.length;i++){let g=this._attributesData;this._data[i].bloom&&(g=this._bloomAttributeData);const m=this._attributeMatrixs[i],_=g.instance_vectorA.length/4;this._setDataForAttributes(g,"instance_vectorA",_,m,0),this._setDataForAttributes(g,"instance_vectorB",_,m,1),this._setDataForAttributes(g,"instance_vectorC",_,m,2);const b=this._data[i].color||_Q,T=this._data[i].highlightColor||_Q;g.instance_color[4*_]=b[0],g.instance_color[4*_+1]=b[1],g.instance_color[4*_+2]=b[2],g.instance_color[4*_+3]=b[3],g.aPickingId[_]=this._getPickingId()+i,g.aOutline[_]=this._data[i].outline?1:0,g.highlight_color[4*_]=T[0],g.highlight_color[4*_+1]=T[1],g.highlight_color[4*_+2]=T[2],g.highlight_color[4*_+3]=T[3],g.aBloom[_]=this._data[i].bloom?1:0}return{attributesData:this._attributesData,bloomAttributesData:this._bloomAttributeData}}_updateInstancedMeshData(i){const{attributesData:g,bloomAttributesData:m}=this._getInstanceAttributesData();for(const m in g)i.updateInstancedData(m,g[m]);if(this.regl?i.generateInstancedBuffers(this.regl):(this._noBuffersMeshes=this._noBuffersMeshes||[],this._noBuffersMeshes.push(i)),i.instanceCount=this._attributesData.instance_vectorA.length/4,this._hasBloom()){const g=m,_=g.aBloom.length;i.properties.bloomMesh=i.properties.bloomMesh||new wP.InstancedMesh(g,_,i.geometry,i.material);const b=i.properties.bloomMesh;b.positionMatrix=i.positionMatrix,b.localTransform=i.localTransform;for(const i in g)b.updateInstancedData(i,g[i]);b.generateInstancedBuffers(this.regl);const T=i.getDefines();b.setDefines(T),b.uniforms=i.uniforms,b.bloom=1,b.instanceCount=_}else i.properties.bloomMesh&&(i.properties.bloomMesh.dispose(),delete i.properties.bloomMesh)}_setDataForBloomAttributes(i,g,m,_){this._bloomAttributeData[i]&&m&&(this._bloomAttributeData[i][4*g]=m[_],this._bloomAttributeData[i][4*g+1]=m[_+4],this._bloomAttributeData[i][4*g+2]=m[_+8],this._bloomAttributeData[i][4*g+3]=m[_+12])}_hasBloom(){return this._bloomAttributeData&&this._bloomAttributeData.aBloom.length}_setDataForAttributes(i,g,m,_,b){i[g]&&_&&(i[g][4*m]=_[b],i[g][4*m+1]=_[b+4],i[g][4*m+2]=_[b+8],i[g][4*m+3]=_[b+12])}_getInstanceAttributesData(i){return!this._dirty&&this._attributesData?{attributesData:this._attributesData,bloomAttributesData:this._bloomAttributeData}:this._updateInstanceAttributesData(i)}_getCenterMatrix(){return this._centerMatrix}getCount(){return this._data.length}_getBloomDataCount(){return this._updateAttributeMatrix(),this._bloomAttributeData?this._bloomAttributeData.aBloom.length:0}_getNoBloomDataCount(){return this.getCount()-this._getBloomDataCount()}toJSON(){const i=JSON.parse(JSON.stringify({data:this._data,options:this.options,type:"MultiGLTFMarker"})),g=this.getProperties();return i.options&&(i.options.properties=g),i}getIndexByPickingId(i){return i-this._getPickingId()}outline(i){return FY(i)&&this.updateData(i,"outline",!0),this}cancelOutline(i){return FY(i)&&this.updateData(i,"outline",!1),this}isOutline(){if(!this._data||!this._data.length)return!1;for(let i=0;i<this._data.length;i++)if(this._data[i].outline)return!0;return!1}_isTransparent(){const i=this.getAllData();for(let g=0;g<i.length;g++){const m=i[g].color;if(m&&m[3]<1)return!0}return!1}highlightNodes(i,g){const m=this._meshes;if(!m)return;const _=this._data[i];_&&(g.forEach((i=>{m.forEach((g=>{if(g.properties.nodeIndex===i.nodeIndex){const{color:m,opacity:b,bloom:T}=i;_.highlightColor=m||SQ,_.highlightColor[3]=b||1,_.highlightBloom=T;const P=g.getDefines();P.HAS_INSTANCE_HIGHLIGHT=1,g.setDefines(P)}}))})),this._dirty=!0)}highlight(i,g){const{color:m,opacity:_,bloom:b}=g,T=this._meshes;if(!T)return;const P=this._data[i];P&&(P.highlightColor=m||SQ,P.highlightColor[3]=_||1,P.highlightBloom=b,T.forEach((i=>{const g=i.getDefines();g.HAS_INSTANCE_HIGHLIGHT=1,i.setDefines(g)})),this._dirty=!0)}cancelHighlight(i,g){let m=this._meshes;if(!m)return;const _=this._data[i];if(_){if(g){let i=g;Array.isArray(i)||(i=[i]),m=m.filter((g=>i.indexOf(g.properties.nodeIndex)>-1))}m.forEach((i=>{const g=i.getDefines();delete g.HAS_INSTANCE_HIGHLIGHT,i.setDefines(g),_.highlightColor=SQ,_.highlightColor[3]=1,_.highlightBloom=0})),this._dirty=!0}}zoomAt(i,g={animation:!0,zoomOffset:0},m){const _=this._data[i];if(!_)throw new Error("data item is not exist");const b=new pl(_.coordinates);return this._zoomTo(b,g,m)}}ft.registerJSONType("MultiGLTFMarker");const MQ=wP.ShaderLib.get("mesh_picking_vert"),CQ=wP.WgslShaderLib.get("mesh_picking").vert,PQ=[],IQ=[],kQ=["points","lines","line strip","line loop"];class St extends(uO(Ck(Om.OverlayLayerGLRenderer))){constructor(i){super(i),this._shaderList={},this._renderMarkerList=[],this._multigltfmarker={}}onAdd(){super.onAdd(),this.prepareWorker()}draw(i,g){this.prepareCanvas(),this._renderScene(g,i)}drawOnInteracting(i,g,m){this._renderScene(m,g)}_renderScene(i,g){this._drawContext=i,this._currentFrameTime=g;let m=0;this._updateLightUniforms(i),this._toRenderMeshes={},this._updateShaderList(i);const _=this._prepareRenderUniforms(i);this._prepareRenderMeshes(g);const b=i&&i.renderTarget?i.renderTarget.fbo:null;let T=0;for(const g in this._shaderList){if("pointline"===g)continue;if(i){const{newShader:m,uniforms:b}=this._updateShader(i,g);this._shaderList[g].shader=m,Po.extend(_,b)}const P=this._createSceneByShader(g),I=this._shaderList[g].shader;I.filter=i&&i.sceneFilter||null,T+=this.renderer.render(I,_,P,b),m++}const P=this._createSceneByShader("pointline");if(P.getMeshes().length){_.pointSize=this.layer.options.pointSize||1;const g=this._shaderList.pointline.shader;g.filter=i&&i.sceneFilter||null,T+=this.renderer.render(g,_,P,b),m++}this._renderBBox(_,b),T&&this.layer.fire("canvasisdirty",{renderCount:T}),this._needRefreshPicking=!0,this.completeRender(),this.layer.fire("rendercomplete-debug",{count:m})}_renderBBox(i,g){this._bboxScene||(this._bboxScene=new wP.Scene);const m=this.layer.getGeometries(),_=[];for(let i=0;i<m.length;i++){if(!m[i].options.showDebugBoundingBox)continue;const g=m[i]._getBoundingBoxMesh();g&&_.push(g)}_.length&&(this._bboxScene.setMeshes(_),this.renderer.render(this._shaderList.wireframe.shader,i,this._bboxScene,g))}_createDataItem(i){const g=i.getUniform("polygonFill")||[1,1,1,1],m=i.getUniform("polygonOpacity")||1;return g[3]=m,{coordinates:i.getCoordinates(),translation:i.getTranslation(),rotation:i.getRotation(),scale:i.getScale(),visible:i.isVisible(),color:g,bloom:i.isBloom(),outline:i.isOutline(),modelHeight:i.getModelHeight(),markerPixelHeight:i._getMarkerPixelHeight(),anchorZ:i.getAnchorZ(),pickingId:i._getPickingId(),target:i}}_markerToMultiGLTFMarker(i){const g=this._createDataItem(i),m=new ft([g],{symbol:{url:i.getUrl(),shader:i.getShader(),shadow:i.isCastShadow()}});return m._markerList=m._markerList||[],i._converted=!0,m._markerList.push(i),m._setLayer(i.getLayer()),m}_clearMultiGLTFMarker(){for(const i in this._multigltfmarker)this._multigltfmarker[i].removeAllData()}_setRenderMeshes(i,g){const m=i.getMeshes(this._gltfManager,this.regl,g),_=i.getShader();if(m.length){this._renderMarkerList.push(i),this._toRenderMeshes[_]=this._toRenderMeshes[_]||[],Po.pushIn(this._toRenderMeshes[_],m);for(let i=0;i<m.length;i++)m[i].properties.bloomMesh&&this._toRenderMeshes[_].push(m[i].properties.bloomMesh)}}_prepareRenderMeshes(i){this._renderMarkerList.length=0;const g=this.layer.getGeometries();this._isDirty()&&this._clearMultiGLTFMarker();for(let m=0;m<g.length;m++){const _=g[m],b=_.getUrl();if(_ instanceof ft||_.isAnimated()||!_._converted)this._setRenderMeshes(_,i);else if(this._isDirty()){const i=`${b}_${_.getShader()}_${_.isCastShadow()?1:0}`;this._multigltfmarker[i]?this._multigltfmarker[i].addData(this._createDataItem(_)):this._multigltfmarker[i]=this._markerToMultiGLTFMarker(_)}}for(const g in this._multigltfmarker){const m=this._multigltfmarker[g];m.createdBygltfmarker=!0,this._setRenderMeshes(m,i)}}_prepareRenderUniforms(){const i={};this._uniforms.outSize=[this.canvas.width,this.canvas.height],this._uniforms.halton=[0,0];i.layerOpacity=this.canvas.gl&&this.canvas.gl.wrap?this.layer.options.opacity||0:1,Po.extend(i,this._uniforms);const g=this.getMaskUniforms();return Po.extend(i,g),i}_createSceneByShader(i){const g=[],m=[];if("pointline"===i){for(const i in this._toRenderMeshes)"wireframe"!==i&&this._toRenderMeshes[i].forEach((i=>{kQ.indexOf(i.geometry.desc.primitive)>-1&&g.push(i)}));const i=new wP.Scene(g);return i.sortMeshes(this._uniforms.cameraPosition),i}for(const g in this._toRenderMeshes){g===i&&this._toRenderMeshes[g].forEach((g=>{(kQ.indexOf(g.geometry.desc.primitive)<0||"wireframe"===i)&&m.push(g)}))}const _=this._triangleScene=this._triangleScene||new wP.Scene;return _.setMeshes(m),_.sortMeshes(this._uniforms.cameraPosition),_}needToRedraw(){return!!super.needToRedraw()||this._isDirty()}_isDirty(){const i=this.layer.getGeometries();for(let g=0;g<i.length;g++)if(this._renderMarkerList.indexOf(i[g])>-1&&(i[g].isDirty()||i[g].isAnimated()))return!0;return!1}onRemove(){this.workerConn&&(this.workerConn.removeLayer(this.layer.getId(),(i=>{if(i)throw i})),this.workerConn.remove(),delete this.workerConn),super.onRemove()}hitDetect(){return!1}initContext(){super.initContext();const{regl:i,device:g,reglGL:m}=this.context,_=i||g;this.regl=i||g,this.gl=m,this.device=i||g;this.canvas.pickingFBO=this.canvas.pickingFBO||_.framebuffer({colorFormat:g?"bgra8unorm":"rgba",depthStencil:!0,width:this.canvas.width,height:this.canvas.height}),this.pickingFBO=this.canvas.pickingFBO,this._gltfManager=_.gltfManager=_.gltfManager||this._createGLTFManager(),this._initRenderer(),this._noBuffersMeshes&&this._noBuffersMeshes.forEach((i=>{i.generateInstancedBuffers(this.regl)})),this._noBuffersGeometries&&this._noBuffersGeometries.forEach((i=>{i.generateBuffers(this.regl)})),this.layer.fire("contextcreate",{regl:i,device:g})}getGLTFManager(){return this._gltfManager}_createGLTFManager(){return new wP.GLTFManager(this.regl)}_initRenderer(){const i=this.layer.getMap(),g=new wP.Renderer(this.regl);this.renderer=g,this._uniforms={projMatrix:i.projMatrix,projViewMatrix:i.projViewMatrix,viewMatrix:i.viewMatrix,cameraPosition:i.cameraPosition,altitudeScale:1},wP.pbr.PBRUtils.loginIBLResOnCanvas(this.canvas,this.regl,i);const m=[],_=[];this._picking=new wP.FBORayPicking(g,{name:"gltf-picking",vert:MQ,wgslVert:CQ,uniforms:[{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A(m,g.projViewMatrix,g.modelMatrix)}},{name:"modelViewMatrix",type:"function",fn:function(i,g){return _A(_,g.viewMatrix,g.modelMatrix)}}]},this.pickingFBO,i)}prepareWorker(){this.workerConn||(this.workerConn=new jY("@maptalks/gltf-layer",this.layer));const i=this.workerConn;if(!i.isActive())return;const g=this.layer.options||{},m=this.layer.getId();i.addLayer(m,{markerType:g.markerTypes,pointSize:g.pointSize},(i=>{if(i)throw i;this.layer&&(this.ready=!0,this.layer.fire("workerready"))}))}_requestor(i){let g;if(this.layer.getURLModifier()){g=JY(null,i,this.layer.options.fetchOptions,(i=>{const g=this.layer.getURLModifier();return g?g(i):i}))}else g=this.workerConn.loadGLTF(i);return g.then((i=>(this.setToRedraw(),this._needRetireFrames=!0,i))).catch((g=>{console.error(g),this.layer.fire("modelerror",{type:"modelerror",url:i,info:g})}))}_updateShaderList(i){const g=UY;for(const m in g){if(this._shaderList[m])continue;const _=g[m];this._registerShader(i,_.name,_.type,_.config)}}_registerShader(i,g,m,_){this.viewport||(this.viewport={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1}),_.extraCommandProps||(_.extraCommandProps={});const b={};i&&this._fillIncludes(b,PQ,i);const T=Po.extend({},_);T.extraCommandProps=Po.extend({},_.extraCommandProps),T.extraCommandProps.viewport=this.viewport,T.uniforms=Po.extend([],_.uniforms,PQ),T.defines=Po.extend({},T.defines,b),m.indexOf(".")>-1?(m=m.split("."),this._shaderList[g]={shader:new wP[m[0]][m[1]](T),type:m}):this._shaderList[g]={shader:new wP[m](T),type:m}}remove(){this._disposePBRResource();const i=this._shaderList;for(const g in i)i[g].shader.dispose();this.extentShader&&this.extentShader.dispose(),super.remove()}resizeCanvas(i){super.resizeCanvas(i),this.pickingFBO&&this.pickingFBO.resize(this.canvas.width,this.canvas.height),this.layer.fire("resizecanvas",{size:i})}getFrameTimestamp(){return this._currentFrameTime}getFrameContext(){return this._drawContext}needRetireFrames(){return this._needRetireFrames}_fillIncludes(i,g,m){const _=m&&m.includes;if(_)for(const b in _)_[b]&&(m[b].uniformDeclares&&(g.length=0,g.push(...m[b].uniformDeclares)),m[b].defines&&Po.extend(i,m[b].defines))}_setIncludeUniformValues(i,g){const m=g&&g.includes;if(m)for(const _ in m)m[_]&&g[_].renderUniforms&&Po.extend(i,g[_].renderUniforms)}_updateShader(i,g){const{shader:m,type:_}=this._shaderList[g];let b=null;const T={};if(this._setIncludeUniformValues(T,i),i.states.includesChanged){const g={};this._fillIncludes(g,PQ,i);const T={vert:m.vert,frag:m.frag,uniforms:m.uniforms,extraCommandProps:m.extraCommandProps};T.defines=g,T.uniforms=Po.extend([],T.uniforms,PQ),b=Array.isArray(_)?new wP[_[0]][_[1]](T):new wP[_](T),m.dispose()}else b=m;return{uniforms:T,newShader:b}}_setUniformsForAnalysis(i,g,m){if(i.viewshed){for(const g in i.viewshed.renderUniforms)m[g]=i.viewshed.renderUniforms[g];Po.extend(g.shaderDefines,i.viewshed.defines)}if(i.floodAnalysis){for(const g in i.floodAnalysis.renderUniforms)m[g]=i.floodAnalysis.renderUniforms[g];Po.extend(g.shaderDefines,i.floodAnalysis.defines)}return m}getShadowMeshes(){const i=[];if(!this.layer||!this.layer.isVisible()||!this._toRenderMeshes)return i;const g=this.layer.getGeometries();for(let m=0;m<g.length;m++)if(g[m].isCastShadow()&&g[m].isVisible()&&g[m]._getOpacity()&&!g[m]._converted){Po.pushIn(i,g[m]._meshes||[])}for(const g in this._multigltfmarker){const m=this._multigltfmarker[g];if(m.isCastShadow()&&m.isVisible()&&m._getOpacity()){Po.pushIn(i,m._meshes||[])}}return i}_getToRenderMeshes(){const i=[];if(!this._toRenderMeshes||!Object.keys(this._toRenderMeshes).length)return i;for(const g in this._toRenderMeshes)Po.pushIn(i,this._toRenderMeshes[g]);return i}getAnalysisMeshes(){return this._getToRenderMeshes()}getRayCastData(i){const g=this.layer.getGeometries();for(let m=0;m<g.length;m++){const _=g[m]._meshes;if(_&&_.indexOf(i)>-1)return g[m]}return null}drawOutline(i){this.extentShader||(this.extentShader=new wP.MeshShader({vert:"attribute vec3 aPosition;\n\nattribute float aOutline;\n\nuniform mat4 projMatrix;\n\nuniform mat4 modelMatrix;\n\nuniform mat4 modelViewMatrix;\n\nuniform mat4 positionMatrix;\n\nuniform float instance;\n\n#include <get_output>\n\n\n\nvarying float vOutline;\n\nvoid main()\n\n{\n\n    mat4 localPositionMatrix = getPositionMatrix();\n\n    gl_Position = projMatrix * modelViewMatrix * localPositionMatrix * getPosition(aPosition);\n\n    if (instance == 0.0) {\n\n        vOutline = 1.0;\n\n    } else {\n\n        vOutline = aOutline;\n\n    }\n\n}\n\n",frag:"precision highp float;\n\nvarying float vOutline;\n\nvoid main() {\n\n    gl_FragColor = vec4(vOutline);\n\n}\n\n",uniforms:[{name:"modelViewMatrix",type:"function",fn:(i,g)=>_A([],g.viewMatrix,g.modelMatrix)}],positionAttribute:"POSITION",extraCommandProps:{viewport:this.viewport,cull:{enable:!1},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}}));const g=this.getOutlineMeshes();g.length&&(this._outlineScene=this._outlineScene||new wP.Scene,this._outlineScene.setMeshes(g),this.renderer.render(this.extentShader,{projMatrix:this._uniforms.projMatrix,viewMatrix:this._uniforms.viewMatrix},this._outlineScene,i))}getOutlineMeshes(){const i=[];if(!this.layer)return i;const g=this.layer.getGeometries();for(let m=0;m<g.length;m++){if(g[m]._converted)continue;const _=g[m]._getOutlineMeshes();Po.pushIn(i,_)}for(const g in this._multigltfmarker){const m=this._multigltfmarker[g]._getOutlineMeshes();Po.pushIn(i,m)}return i}_disposePBRResource(){this.canvas&&wP.pbr.PBRUtils.logoutIBLResOnCanvas(this.canvas,this.getMap())}_updateLightUniforms(i){const g=this.layer.getMap(),{iblTexes:m,dfgLUT:_}=wP.pbr.PBRUtils.getIBLResOnCanvas(this.canvas);if(g&&g.getLights()){const b=wP.pbr.PBRUtils.getPBRUniforms(g,m,_,i&&i.ssr,i&&i.jitter),T=g.getLights();this._uniforms.ambientColor=T.ambient&&T.ambient.color?T.ambient.color:[.2,.2,.2],b&&Po.extend(this._uniforms,b)}else{const m=wP.pbr.PBRUtils.getPBRUniforms(g,null,_,i&&i.ssr,i&&i.jitter);Po.extend(this._uniforms,m)}}_createGLContext(i,g){const m=["webgl","experimental-webgl"];let _=null;for(let b=0;b<m.length;++b){try{_=i.getContext(m[b],g)}catch(i){}if(_)break}return _}_pick(i,g,m={}){if(!this._picking||!this.layer.isVisible())return null;const _=this.layer.getMap();if(this._needRefreshPicking||this.canvas.gl&&this.canvas.gl.wrap){if(!this._toRenderMeshes||!Object.keys(this._toRenderMeshes).length)return null;const i=this._getToRenderMeshes(),g=Po.extend({},this._uniforms);g.pointSize=this.layer.options.pointSize||1,this._picking.render(i,g,!0),this._needRefreshPicking=!1}const b=this._picking[m.returnAll?"pickAll":"pick"](i,g,m.tolerance||3,{projMatrix:_.projMatrix,viewMatrix:_.viewMatrix,projViewMatrix:_.projViewMatrix,pointSize:this.layer.options.pointSize||1},{viewMatrix:_.viewMatrix,projMatrix:_.projMatrix,returnPoint:!0});if(b.length){const i={},g=[];for(let m=0;m<b.length;m++)if(!i[b[m].pickingId]){const _=this._getResult(b[m]);i[b[m].pickingId]=!0,g.push(_)}return g}return this._getResult(b)}_getResult(i){const{meshId:g,pickingId:m,point:_,coordinate:b}=i,T=this._getToRenderMeshes()[g],P=this._squeezeTarget(m);return{meshId:g,mesh:T,data:this.layer._getMarkerMap()[P],pickingId:m,point:_,coordinate:b,index:m-P,nodeIndex:this._getNodeIndex(g)}}_getNodeIndex(i){const g=this._getToRenderMeshes()[i];return g&&g.properties.nodeIndex}_squeezeTarget(i){if(!FY(i))return null;if(this.layer._getMarkerMap()[i])return i;const g=Object.keys(this.layer._getMarkerMap()),m=g.length;let _=0,b=m-1,T=Math.floor((_+b)/2);for(;_<=m-1&&b>=0;){if(_===b)return g[_];if(g[T]<=i&&i<g[T+1])return g[T];i<g[T]?(b=T-1,T=Math.floor((_+b)/2)):g[T+1]<i&&(_=T+1,T=Math.floor((_+b)/2))}return null}isInFrustum(i){const g=this.layer.getMap(),m=i.getBoundingBox();if(!m||"multigltfmarker"===i.getGLTFMarkerType())return!0;const _=z_(IQ,m.min,m.max);return!!qj(g.projViewMatrix,_)}getRenderMeshesTest(){return this._getToRenderMeshes()}isMarkerTransparent(i){return i._isTransparent()}getMarkerFitSizeScale(i){return i._getFitSizeScale()}getMarkerFitTranslate(i){return i._getFitTranslate()}getFBORayPicking(){return this._picking}getShaderList(){return this._shaderList}}const OQ=/\{ *([\w_]+) *\}/g;class kt extends lt{constructor(i,g){super(i,g),this._type="effectmarker"}static fromJSON(i){return new kt(i.coordinates,i.options)}isAnimated(){return!0}setTexture(i){const g=this.getLayer()&&this.getLayer().getRenderer();if(g){const m=this.getTextureUrl();g._removeTexture(m),g._linkTexture(i)}return super.updateSymbol({textureUrl:i}),this}_getTextureFromLayer(i){const g=this.getTextureUrl(),m=this.getLayer()&&this.getLayer().getRenderer();if(m){let _=g;const b=this._getTextureNames();if(b){const m=this.isAnimationLooped(),T=this.getAnimationSpeed()||1,P=m?Math.floor(.01*i*T)%b.length:Math.floor(.01*i);_=g.replace(OQ,b[P]),this.setUniform("width",1),this.setUniform("height",1),this.setUniform("uvOffset",[0,0])}return m._getTexture(_,this._getPickingId())}return null}_getTextureNames(){const i=this._getInternalSymbol();return i&&i.textureNames}getTextureUrl(){const i=this._getInternalSymbol();return i&&i.textureUrl||"default"}getUrl(){return"plane"}getShader(){return"effect"}setTransparent(i){return this.options.symbol.transparent=i,this}isTransparent(){return this.options.symbol.transparent}updateUV(i){const g=this.isAnimationLooped(),m=this.getAnimationSpeed()||1,_=this.getUniforms()||{},b=_.width||1,T=_.height||1;let P;const I=this.getEffectType();"uv"===I?P=g?.01*i*m%(b*T):.01*i:"sequence"===I&&(P=g?Math.floor(.01*i*m)%(b*T):Math.floor(.01*i));const H=Math.floor(P%b),W=Math.floor(P/b),q=this._getTextureFromLayer(i);this._getSymbol()?(this.setUniform("uvOffset",[H,W]),this.setUniform("width",b),this.setUniform("height",T),this.setUniform("texture",q)):this._setPropInExternSymbol("uniforms",{uvOffset:[H,W],width:b,height:T,texture:q})}_setExternSymbol(i){super._setExternSymbol(i);const g=this.getLayer()&&this.getLayer().getRenderer();if(g){const i=this.getTextureUrl();g._linkTexture(i)}}getEffectType(){const i=this._getInternalSymbol();return i&&i.effect||"uv"}setEffectType(i){return this._getInternalSymbol().effect=i,this}remove(){const i=this.getLayer()&&this.getLayer().getRenderer();if(i){const g=this.getTextureUrl();i._removeTexture(g)}super.remove()}}const EQ=["Point","Polygon","LineString","MultiPoint","MultiPolygon","MultiLineString","GeometryCollection","Feature","FeatureCollection"].reduce(((i,g)=>(i[g]=!0,i)),{}),RQ={toGeometry:function(i,g){if(Po.isString(i)&&(i=Po.parseJSON(i)),Array.isArray(i)){const m=[];for(let _=0,b=i.length;_<b;_++){const b=RQ._convert(i[_],g);Array.isArray(b)?Po.pushIn(m,b):m.push(b)}return m}return RQ._convert(i,g)},_convert:function(i,g){if(!i||Po.isNil(i.type))return null;const m=i.type;if("Feature"===m){const m=RQ._convert(i.geometry,g);return m?(m.setId(i.id),m.setProperties(i.properties),m):null}if("FeatureCollection"===m){const m=i.features;return m?RQ.toGeometry(m,g):null}if("Point"===m)return function(i,g){return"EffectLayer"===g?new kt(i):new lt(i)}(i.coordinates,g);if("GeometryCollection"===m){const m=i.geometries,_=[],b=m.length;for(let i=0;i<b;i++)_.push(RQ._convert(m[i],g));return _}throw new Error("geometry's type is invalid, only support type of Point")},isGeoJSON:function(i){return!(!i||"object"!=typeof i||!i.type||!EQ[i.type]||i instanceof gu)}},LQ=/\{*(\$root)*\}/g;class wt extends td{constructor(i,g,m){!g||g instanceof gu||Array.isArray(g)||EQ[g.type]||(m=g,g=null),super(i,null,m),this.pickingId=0,this._markerMap={},this._modelMap={},this._idList={};this.setStyle(m&&m.style),g&&this.addGeometry(g)}static registerShader(i,g,m,_){UY[i]={name:i,type:g,config:m,uniforms:_}}static removeShader(i){delete UY[i]}static getShaders(){const i=[];for(const g in UY)i.push({shader:g,uniforms:UY[g].uniforms});return i}static getShaderMap(){return UY}addGeometry(i,g){let m=RQ.isGeoJSON(i)?RQ.toGeometry(i,this.getJSONType()):i;m=Array.isArray(m)?m:[m];for(let i=0;i<m.length;i++)if(!this._isAccept(m[i]))return void console.error("type of geometry is invalid");super.addGeometry(m,g),Array.isArray(m)&&this.addMarker(m)}addMarker(i){for(let g=0;g<i.length;g++){const m=i[g];m._setPickingId(this.pickingId),this._markerMap[this.pickingId]=m;const _=m.getId();_&&(this._idList[_]=m),m.fire("add",{type:"add",target:m,layer:this});const b=m.getUrl(),T=this.getRenderer();if(T&&T._multigltfmarker[b]){m.fire("load",{type:"load",target:m,data:T._multigltfmarker[b]._getGLTFData()})}if("multigltfmarker"===m.getGLTFMarkerType()){const i=m.getCount()||1;this.pickingId+=i}else this.pickingId++}}_loadModel(i){const g=this.getRenderer();g&&g.loginGLTFMarker(i)}toJSON(i){i||(i={});const g={type:this.getJSONType(),id:this.getId(),options:this.config()};if((DY(i.style)||i.style)&&(g.style=this.getStyle()),DY(i.geometries)||i.geometries){const i=[],m=this._geoList;for(let g=0;g<m.length;g++){const _=m[g]._toJSONObject();i.push(_)}g.geometries=i}return g}_isAccept(i){return!!i.getGLTFMarkerType&&this.options.markerTypes.indexOf(i.getGLTFMarkerType())>-1}setStyle(i){return i?(this.options.style=i,this._layerStyle=JSON.parse(JSON.stringify(i)),this._styleMarkerList(),this.fire("setstyle",{target:this,style:this._layerStyle}),this):(delete this._layerStyle,delete this.options.style,this)}getStyle(){return this.options.style}updateSymbol(i,g){const m=this.getStyle();this._updateSymbolInStyle(i,g,m),this._updateSymbolInStyle(i,g,this._layerStyle),this._styleMarkerList(),this.fire("updatesymbol",{target:this,index:i,symbol:g})}_updateSymbolInStyle(i,g,m){if(!m)return;const _=(m.style?m.style:m)[i].symbol||{};for(const i in g)_[i]=g[i]}_styleMarkerList(){this._processRootUrl(this._layerStyle);this._cookedStyles=KL(this._layerStyle.style?this._layerStyle.style:this._layerStyle),this._geoList.forEach((function(i){this._styleMarker(i)}),this)}getGLTFUrls(){return Object.keys(this._modelMap)}_processRootUrl(i){Po.isString(i.$root)&&i.style.forEach((g=>{const m=g.symbol.url;m&&m.indexOf("{$root}")>-1&&(g.symbol.url=m.replace(LQ,i.$root))}))}_styleMarker(i){if(!this._cookedStyles)return!1;for(let g=0,m=this._cookedStyles.length;g<m;g++)if(!0===this._cookedStyles[g].filter({properties:i.getProperties()})){const m=this._cookedStyles[g].symbol;return i._setPropInExternSymbol("url",m.url),i.updateSymbol(m),!0}return!1}_filterOutline(i){if(this._cookedStyles)for(let g=0,m=this._cookedStyles.length;g<m;g++)!0===this._cookedStyles[g].filter({properties:i.getProperties()})&&this._cookedStyles[g].outline&&i.outline()}_deleteMarker(i){const g=Po.isString(i)?this._idList[i]._getPickingId():i._getPickingId(),m=this.getRenderer();m&&m._deleteScene(g),delete this._markerMap[g],delete this._idList[i]}clear(){return super.clear(),this._markerMap={},this._idList={},this}_getMarkerMap(){return this._markerMap}_pick(i,g,m){const _=this.getRenderer();return _?_._pick(i,g,m):null}_isModelsLoadComplete(){const i=this._geoList;for(let g=0;g<i.length;g++)if(!i[g].isLoaded())return!1;return!0}_getMarkerContainerExtent(i){const g=this.getRenderer();return g?g._getMarkerContainerExtent(i):null}_updateGeometries(i){const g=this.getRenderer();g&&g._updateGeometries(i)}outlineBatch(i){const g=this._layerStyle.style?this._layerStyle.style:this._layerStyle;g[i].outline=!0,this._cookedStyles=KL(g),this._geoList.forEach((i=>{this._filterOutline(i)}))}outlineAll(){this._geoList.forEach((i=>{i.outline()}))}cancelOutline(){this._layerStyle&&(this._layerStyle.style?this._layerStyle.style:this._layerStyle).forEach((i=>{delete i.outline})),this._geoList.forEach((i=>{i.cancelOutline()}))}}wt.mergeOptions({renderer:"gl",doubleBuffer:!1,glOptions:null,markerEvents:!0,forceRenderOnZooming:!0,forceRenderOnMoving:!0,forceRenderOnRotating:!0});class Ot extends(WO(wt)){static initDefaultShader(){const i={shader:{positionAttribute:"POSITION",normalAttribute:"NORMAL",extraCommandProps:{blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}},material:new wP.PhongMaterial};Ot.registerShader("phong","PhongShader",i.shader,i.material.getUniforms());const g={shader:{positionAttribute:"POSITION",normalAttribute:"NORMAL",tangentAttribute:"TANGENT",colorAttribute:"COLOR_0",uv0Attribute:"TEXCOORD_0",uv1Attribute:"TEXCOORD_1",extraCommandProps:{cull:{enable:!0},frontFace:"ccw",blend:{enable:(i,g)=>!!g.meshConfig.transparent,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"},equation:"add"}}},material:new wP.pbr.StandardMaterial({})};Ot.registerShader("pbr","pbr.StandardShader",g.shader,g.material.getUniforms()),Ot.registerShader("depth","pbr.StandardDepthShader",g.shader,g.material.getUniforms());const m={shader:{positionAttribute:"POSITION",color0Attribute:"COLOR_0",extraCommandProps:{blend:{enable:!1,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}},material:new wP.Material};Ot.registerShader("pointline","PointLineShader",m.shader,m.material.getUniforms());const _={shader:{positionAttribute:"POSITION",extraCommandProps:{blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"},equation:"add"}}},material:new wP.Material({lineColor:[0,0,0,1],lineOpacity:1})};Ot.registerShader("wireframe","EdgeShader",_.shader,_.material.getUniforms());const b={shader:{positionAttribute:"POSITION",normalAttribute:"NORMAL",extraCommandProps:{blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}},material:new wP.StandardLiteMaterial};Ot.registerShader("pbr-lite","StandardLiteShader",b.shader,b.material.getUniforms())}static fromJSON(i){if(!i||"GLTFLayer"!==i.type)return null;const g=new Ot(i.id,i.options),m=i.geometries,_=[];for(let i=0;i<m.length;i++){const g=m[i].type,b=lt.getJSONClass(g);if(!b||!b.fromJSON)throw new Error("unsupported gltfmarker type:"+g);const T=b.fromJSON(m[i]);T&&_.push(T)}return g.addGeometry(_),i.style&&g.setStyle(i.style),g}setURLModifier(i){return this._urlModifier=i,this}getURLModifier(){return this._urlModifier}onAdd(){const i=this.getMap();this._geoList.forEach((g=>{FY(g.getZoomOnAdded())||g.setZoomOnAdded(i.getZoom())})),super.onAdd()}onRemove(){super.onRemove(),this.clear()}identify(i,g){const m=this.getMap();if(!m)return[];const _=m.coordinateToContainerPoint(new pl(i));return this.identifyAtPoint(_,g)}identifyAtPoint(i,g={}){const m=[];if(!g.excludeMasks){const _=this.identifyMask(i,g);_&&_.length&&Po.pushIn(m,_)}const _=this.getMap();if(!_)return[];const b=_.getDevicePixelRatio(),T=this._pick(i.x*b,i.y*b,g);if(T&&(T.data||T.length))if(g.includeInternals&&!g.excludeMasks){m.push(T.data);const i=g.domEvent;i&&(i.gltfPickingInfo=i.gltfPickingInfo||{},i.gltfPickingInfo[this.getId()]=T)}else m.push(T);return g&&g.filter&&!g.excludeMasks?m.filter((i=>g.filter(i.data||i))):m}_updateMarkerMap(){this.pickingId=0;const i={};for(const g in this._markerMap){const m=this._markerMap[g];m._setPickingId(this.pickingId),m._setDirty(!0),i[this.pickingId]=m;const _=m.getCount()||1;this.pickingId+=_}this._markerMap=i}_onGeometryEvent(i){if(!i||!i.target)return;const g=i.type;if("meshcreate"===g)this._onMeshCreate(i);else if("modelerror"===g)this._onModelError(i);else if("positionchange"===g){const i=this.getRenderer();i&&i.setToRedraw()}super._onGeometryEvent(i)}_onModelError(i){const{url:g,info:m}=i;console.error(m),this.fire("modelerror",{type:"modelerror",url:g,info:m})}_onMeshCreate(i){this._modelMap[i.url]=1,this.getRenderer().setToRedraw(),this._isModelsLoadComplete()&&this.fire("modelload",{models:this.getGLTFUrls()})}}Ot.initDefaultShader(),Ot.mergeOptions({markerTypes:["gltfmarker","multigltfmarker"],pointSize:1}),Ot.registerJSONType("GLTFLayer"),Ot.registerRenderer("gl",St);const DQ=new pl(0,0),FQ=new un(0,0),NQ=new un(0,0),HQ=new un(0,0);const BQ=new pl(0,0),zQ=[],VQ=new un(0,0),UQ=new un(0,0);class Nt extends ft{constructor(i,g){super(null,g),this.on("load",(()=>{this.setCoordinates(i)}))}static fromJSON(i){return new Nt(i.data,i.options)}setCoordinates(i){this._coordinates=i,this._updateData()}getCoordinates(){return this._coordinates}toJSON(){const i=JSON.parse(JSON.stringify({coordinates:this._coordinates,options:this.options,type:"GLTFLineString"})),g=this.getId();Po.isNil(g)||(i.options.id=g);const m=this.getProperties();return i.options&&(i.options.properties=m),i}_updateData(){const i=this._coordinates;if(!i)return;this.removeAllData();const g=this.getMap(),m=g.getGLRes(),_=g.getProjection(),b=this._calGLTFScale();for(let T=0;T<i.length-1;T++){const P=this._toCoordinate(i[T]),I=this._toCoordinate(i[T+1]),H=g.coordinateToPointAtRes(P,m,VQ),W=g.coordinateToPointAtRes(I,m,UQ),q=this._calProjectionScale(P,I),$=_.measureLenBetween(P,I);this.gltfPack.arrangeAlongLine(H,W,$,b,q,this.options).forEach((i=>{i.coordinates=GQ(P,I,i.t),this.addData(i)}))}this._dirty=!0}_calGLTFScale(){const i=[1,1,1],g=this.getModelHeight();g&&this._calModelHeightScale(i,g);const m=this.getSymbol();return qA(zQ,Po.isNil(m.scaleX)?1:m.scaleX,Po.isNil(m.scaleY)?1:m.scaleY,Po.isNil(m.scaleZ)?1:m.scaleZ),$A(i,i,zQ)}_calProjectionScale(i,g){const m=this.getMap(),_=m.getGLRes();return BQ.set(0,(i.y+g.y)/2),m.altitudeToPoint(100,_,BQ)/m.altitudeToPoint(100,_)}_toCoordinate(i){return Array.isArray(i)?new pl(i):i}}function GQ(i,g,m){const _=jQ(i.x,g.x,m),b=jQ(i.y,g.y,m),T=jQ(i.z||0,g.z||0,m);return new i.constructor(_,b,T)}function jQ(i,g,m){return i+m*(g-i)}if(Nt.mergeOptions({direction:0,gapLength:0,scaleVertex:!0}),Nt.registerJSONType("GLTFLineString"),rx){const i=Uu.VERSION;if(i.indexOf("1.0.0-beta")>=0||i.indexOf("1.0.0-alpha")>=0){Os("@maptalks/gltf-layer",rx.inject(LY))}else Os("@maptalks/gltf-layer",(function(){return rx.inject(LY)}))}else Os("@maptalks/gltf-layer",LY);"undefined"!=typeof console&&console.log("@maptalks/gltf-layer v0.106.0");
/*!
   * @maptalks/transform-control v0.106.1
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.org
   */
const WQ={yuanhuan:{accessors:[{name:"����С��_1_0_positions",componentType:5126,count:104,min:[-5.407599925994873,-5.404099941253662,0],max:[5.405200004577637,5.406300067901611,0],type:"VEC3",bufferView:0,byteOffset:0},{name:"����С��_1_0_normals",componentType:5126,count:104,min:[0,0,1],max:[0,0,1],type:"VEC3",bufferView:1,byteOffset:0},{name:"����С��_1_0_indices",componentType:5123,count:288,min:[0],max:[103],type:"SCALAR",bufferView:2,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"缩放圈-新",byteLength:3072,uri:"data:application/octet-stream;base64,KVyjQLbzPT4AAAAAZvesQLbzPT4AAAAAhsmqQC7/YT8AAAAAZ0ShQDC7Vz8AAAAA+u2lwGKhxr8AAAAArK2cwLpJvL8AAAAAEFihwB04V78AAAAAXdyqwE7RYb8AAAAAat6lQEaUxj8AAAAAApqcQG+BvD8AAAAAB18EQFOWlcAAAAAA+u0LQLBynsAAAAAARPoxQNSalMAAAAAAJzEoQIxKjMAAAAAAQBNVQFyPiMAAAAAAIEFJQMDsgMAAAAAA0950QK36dMAAAAAAejZnQFRSZ8AAAAAAXdyAQBBYScAAAAAA+n6IQI0oVcAAAAAAcoqUQAMJMsAAAAAAKjqMQIlBKMAAAAAAXdyAQFdbSUAAAAAA+n6IQDsBVUAAAAAA0950QBTQdEAAAAAAejZnQA5PZ0AAAAAA+n6IwI0oVcAAAAAAwOyAwBBYScAAAAAAXkuMwIlBKMAAAAAA0ZGUwAMJMsAAAAAA5j+8P9ejnMAAAAAAkDFXP65HocAAAAAA1JrGPz7opcAAAAAA/7I7PvhTo8AAAAAA/7I7PmPurMAAAAAAM8RhP/vLqsAAAAAADwutwLbzPT4AAAAA0m+jwLbzPT4AAAAAEFihwDC7Vz8AAAAAXdyqwC7/YT8AAAAArK2cwG+BvD8AAAAA+u2lwEaUxj8AAAAADXGewN/gC0AAAAAAa5qVwIV8BEAAAAAAXkuMwAFNKEAAAAAA0ZGUwD7oMUAAAAAAlIeVQIV8BEAAAAAAlWWeQN/gC0AAAAAAcoqUQD7oMUAAAAAAKjqMQAFNKEAAAAAAQBNVQBB6iEAAAAAAIEFJQKfogEAAAAAAW9N0wK36dMAAAAAAsVBnwFRSZ8AAAAAAlWWeQM/3C8AAAAAAlIeVQNxoBMAAAAAA+n6IwDsBVUAAAAAAwOyAwFdbSUAAAAAAsVBnwA5PZ0AAAAAAW9N0wBTQdEAAAAAAd74LwLBynsAAAAAAkxi8v9ejnMAAAAAAwFsEwFOWlcAAAAAARpRWv65HocAAAAAAayvGvz7opcAAAAAA2c43vvhTo8AAAAAA2c43vmPurMAAAAAAt9Fgv/vLqsAAAAAAt9Fgv7fRqkAAAAAAayvGvybkpUAAAAAAd74LwAponkAAAAAA2c43vv5lo0AAAAAA2c43vmkArUAAAAAARpRWvzxOoUAAAAAAkxi8v9ejnEAAAAAAOdYxwHKKlEAAAAAAwFsEwDqSlUAAAAAA+zoowNBEjEAAAAAAJlNJwKfogEAAAAAAUPxUwBB6iEAAAAAAat6lQGKhxr8AAAAAApqcQLpJvL8AAAAAhsmqQE7RYb8AAAAAZ0ShQB04V78AAAAAZvesQP+yO74AAAAAKVyjQP+yO74AAAAAM8RhP7fRqkAAAAAA/7I7PmkArUAAAAAA/7I7Pv5lo0AAAAAA+u0LQAponkAAAAAA1JrGPybkpUAAAAAAkDFXPzxOoUAAAAAA5j+8P9ejnEAAAAAARPoxQHKKlEAAAAAAB18EQDqSlUAAAAAAJzEoQNBEjEAAAAAA+zoowIxKjMAAAAAAOdYxwNSalMAAAAAAUPxUwFyPiMAAAAAAJlNJwMDsgMAAAAAAa5qVwNxoBMAAAAAADXGewM/3C8AAAAAA0m+jwP+yO74AAAAADwutwP+yO74AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAABAAIAAAACAAMABAAFAAYABAAGAAcAAwACAAgAAwAIAAkACgALAAwACgAMAA0ADQAMAA4ADQAOAA8ADwAOABAADwAQABEAEgATABQAEgAUABUAFgAXABgAFgAYABkAGgAbABwAGgAcAB0AHgALAAoAHwALAB4AHwAgAAsAIQAgAB8AIgAjACAAIgAgACEAJAAlACYAJAAmACcAJwAmACgAJwAoACkAKgArACwAKgAsAC0ALgAvADAALgAwADEAGQAYADIAGQAyADMANAA1ABsANAAbABoAFQAUADYAFQA2ADcAOAA5ADoAOAA6ADsAPAA9AD4APAA/AD0AQAA/ADwAQABBAD8AQgBBAEAAQgBAAEMARABFAEYARABGAEcARABHAEgARgBJAEcARgBKAEkASwBKAEYASwBMAEoASwBNAEwACQAIAC8ACQAvAC4ALQAsADkALQA5ADgAOwA6AE4AOwBOAE8ATwBOAE0ATwBNAEsAKQAoACsAKQArACoANwA2AFAANwBQAFEAUQBQAFIAUQBSAFMAUwBSAFQAUwBUAFUAVgBXAFgAVgBYAFkAVgBZAFoAWwBZAFgAXABZAFsAXABdAFkAXgBdAFwAXwBdAF4APAA+AGAAPABgAGEAMQAwABcAMQAXABYAYgBjADUAYgA1ADQAYQBgAGMAYQBjAGIAMwAyAF0AMwBdAF8AHQAcAGQAHQBkAGUAZQBkAAUAZQAFAAQAZgBnAAcAZgAHAAYAEQAQABMAEQATABIA"}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:1248,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:1248,byteOffset:1248,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:576,byteOffset:2496,target:34963}],materials:[{name:"SVGMat_001",pbrMetallicRoughness:{baseColorFactor:[.5,.5,.5,1],metallicFactor:0,roughnessFactor:1},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"����С��_1",primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2,material:0,mode:4}]}],nodes:[{name:"����С��",mesh:0}],scene:0,scenes:[{nodes:[0]}]},yuanhuan41:{accessors:[{name:"Բ��_1_0_positions",componentType:5126,count:39,min:[0,0,0],max:[5.489999771118164,0,5.488900184631348],type:"VEC3",bufferView:0,byteOffset:0},{name:"Բ��_1_0_normals",componentType:5126,count:39,min:[0,-.999939501285553,-1],max:[.13969914615154266,1,1],type:"VEC3",bufferView:1,byteOffset:0},{name:"Բ��_1_0_indices",componentType:5123,count:105,min:[0],max:[38],type:"SCALAR",bufferView:2,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"yh41",byteLength:1148,uri:"data:application/octet-stream;base64,8tKXQAAAAACoNU09FK6vQAAAAAB1Ako/FK6vQAAAAAAAAACATfOAQAAAAAACmkg+K4dWQAAAAAAIrNw+WvUtQAAAAABbsT8/X5gIQAAAAACMSpI/OUWbQAAAAAD0/VQ/LbKHQAAAAAD0/XQ/W0JqQAAAAAC6SZQ/dLXNPwAAAACfq80/H4VHQAAAAAB0JLc/ZognQAAAAAA1XuI/YVSSPwAAAAAukAhABaMKQAAAAAB4nApABcU/PwAAAACF6y1Aw2TiPwAAAACRfidASS63PwAAAABKe0dAJLncPgAAAACze1ZAj1OUPwAAAADjNmpAAppIPgAAAADu64BAnRF1PwAAAAD8qYdAqDVNPQAAAADBypdAgQRVPwAAAAAIPZtAAAAAAAAAAAASpa9AAwlKPwAAAAASpa9AJJd/PAAAAAASpa9AAwlKPwAAAAASpa9AAAAAAAAAAAASpa9Asp1vPQAAAAASpa9AJLn8PQAAAAASpa9AqoJRPgAAAAASpa9ARwOYPgAAAAASpa9AHhbKPgAAAAASpa9A2hv8PgAAAAASpa9A5q4VPwAAAAASpa9A+n4qPwAAAAASpa9AQxw7PwAAAAASpa9AwhdGPwAAAAASpa9AAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAJ5X/OwL+fz8AAACAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIC/Kzs0PAn8f78AAACApLK/PA7uf78AAACAeJkZPefRfz8AAACA+ZldPQSgf78AAACA6XSTPelVfz8AAACALLO3PdT3fr8AAACAfkjZPR2Ofr8AAACANf32Paohfj8AAACAeUYHPqDBfT8AAACASw0PPlt9fb8AAACAAAABAAIAAwABAAAABAABAAMABQABAAQABgAHAAUABwABAAUABgAIAAcABgAJAAgACgAJAAYACgALAAkACgAMAAsADQAMAAoADQAOAAwADwAOAA0ADwAQAA4ADwARABAAEgARAA8AEgATABEAFAATABIAFAAVABMAFgAVABQAFgAXABUAGAAXABYAGAAZABcAGgAbABwAHQAbABoAHgAbAB0AHwAbAB4AIAAbAB8AIQAbACAAIgAbACEAIwAbACIAJAAbACMAJQAbACQAJgAbACUAAAA="}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:468,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:468,byteOffset:468,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:212,byteOffset:936,target:34963}],materials:[{name:"SVGMat_002",pbrMetallicRoughness:{baseColorFactor:[.588,.588,.588,1],metallicFactor:0,roughnessFactor:.99},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"Բ��_1",primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2,material:0,mode:4}]}],nodes:[{name:"Բ��",mesh:0}],scene:0,scenes:[{nodes:[0]}]},yuanhuan411:{accessors:[{name:"����СȦ_1_0_positions",componentType:5126,count:28,min:[.026000000536441803,-4.6834001541137695,0],max:[4.696700096130371,-.014800000004470348,0],type:"VEC3",bufferView:0,byteOffset:0},{name:"����СȦ_1_0_normals",componentType:5126,count:28,min:[0,0,1],max:[0,0,1],type:"VEC3",bufferView:1,byteOffset:0},{name:"����СȦ_1_0_indices",componentType:5123,count:78,min:[0],max:[27],type:"SCALAR",bufferView:2,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"yuanhuan411",byteLength:828,uri:"data:application/octet-stream;base64,ufwXQLN7Mr8AAAAAObRAQLFQK78AAAAA1ediQMWP8b4AAAAAGQQ6QCv2174AAAAAqFdeQHUCWr4AAAAA7FGCQL6fmr0AAAAAHHyDQDLmrr4AAAAAXkuWQJf/kL4AAAAAXkuWQLN7crwAAAAAMCrxP2RdhL8AAAAA/BgDQJeQn78AAAAADeARQAg9i78AAAAAukkIQISeXb8AAAAAZaogQH/Zbb8AAAAA7Q3ePr4wOcAAAAAA5IMuP9/gP8AAAAAAJQZxPwrXH8AAAAAAPZs1P6UsF8AAAAAAdy2hP0VHAsAAAAAAb/CFP5eQ778AAAAA0ES4P32utr8AAAAAAprQPyL9zr8AAAAAi/1lPqqCXcAAAAAA9dv3PtcSYsAAAAAADi2yPZvmgcAAAAAAYTK1PssQg8AAAAAA9P3UPGrelcAAAAAA4liXPmrelcAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAABAAIAAAACAAMAAwACAAQABQAGAAcABQAHAAgABAACAAYABAAGAAUACQAKAAsACQALAAwAAAANAAEADgAPABAADgAQABEAEQAQABIAEQASABMAFAAVAAoAFAAKAAkADAALAA0ADAANAAAAFgAXAA8AFgAPAA4AGAAZABcAGAAXABYAGgAZABgAGgAbABkAEwASABUAEwAVABQA"}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:336,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:336,byteOffset:336,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:156,byteOffset:672,target:34963}],materials:[{name:"SVGMat",pbrMetallicRoughness:{baseColorFactor:[.588,.588,.588,1],metallicFactor:0,roughnessFactor:.99},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"����СȦ_1",primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2,material:0,mode:4}]}],nodes:[{name:"����СȦ",mesh:0}],scene:0,scenes:[{nodes:[0]}]},yuanpan:{accessors:[{name:"Circle001_1_0_positions",componentType:5126,count:28,min:[-1.9510999917984009,0,-1.9510999917984009],max:[1.9510999917984009,0,1.9510999917984009],type:"VEC3",bufferView:0,byteOffset:0},{name:"Circle001_1_0_normals",componentType:5126,count:28,min:[0,1,0],max:[0,1,0],type:"VEC3",bufferView:1,byteOffset:0},{name:"Circle001_1_0_indices",componentType:5123,count:78,min:[0],max:[27],type:"SCALAR",bufferView:2,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"yuanpan",byteLength:828,uri:"data:application/octet-stream;base64,S+rkvgAAAADRIvM/AAAAAAAAAAClvfk/S+rkPgAAAADRIvM/0SLzvwAAAABL6uQ+MlXgvwAAAACsi1s/c9fCvwAAAACvJZw/pb35vwAAAAAAAAAA0SLzvwAAAABL6uS+MlXgvwAAAACsi1u/c9fCvwAAAACvJZy/ryWcvwAAAABz18K/rItbvwAAAAAyVeC/S+rkvgAAAADRIvO/AAAAgAAAAAClvfm/S+rkPgAAAADRIvO/rItbPwAAAAAyVeC/ryWcPwAAAABz18K/c9fCPwAAAACvJZy/MlXgPwAAAACsi1u/0SLzPwAAAABL6uS+pb35PwAAAAAAAACA0SLzPwAAAABL6uQ+MlXgPwAAAACsi1s/c9fCPwAAAACvJZw/ryWcvwAAAABz18I/ryWcPwAAAABz18I/rItbvwAAAAAyVeA/rItbPwAAAAAyVeA/AAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAAAAAAAgD8AAACAAAABAAIAAwAEAAUABgADAAUABwAGAAUACAAHAAUACQAIAAUACgAJAAUACwAKAAUADAALAAUADQAMAAUADgANAAUADwAOAAUAEAAPAAUAEQAQAAUAEgARAAUAEwASAAUAFAATAAUAFQAUAAUAFgAVAAUAFwAWAAUAFwAFABgAGQAXABgAGQAYABoAGwAZABoAAgAbABoAAAACABoA"}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:336,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:336,byteOffset:336,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:156,byteOffset:672,target:34963}],materials:[{name:"wire_008110135",pbrMetallicRoughness:{baseColorFactor:[.0314,.4314,.5294,1],metallicFactor:0,roughnessFactor:.968},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"Circle001_1",primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2,material:0,mode:4}]}],nodes:[{name:"Circle001",mesh:0}],scene:0,scenes:[{nodes:[0]}]},zzhou:{accessors:[{name:"Cube.001-Mesh_0_positions",componentType:5126,count:45,min:[-.2711470127105713,-5.473427772521973,-.2711470127105713],max:[.2711470127105713,.46298399567604065,.2711470127105713],type:"VEC3",bufferView:0,byteOffset:0},{name:"Cube.001-Mesh_0_normals",componentType:5126,count:45,min:[-1,-1,-1],max:[1,1,1],type:"VEC3",bufferView:1,byteOffset:0},{name:"Cube.001-Mesh_0_texcoords",componentType:5126,count:45,min:[.125,0],max:[.875,1],type:"VEC2",bufferView:2,byteOffset:0},{name:"Cube.001-Mesh_0_indices",componentType:5123,count:72,min:[0],max:[44],type:"SCALAR",bufferView:3,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"Z",byteLength:1584,uri:"data:application/octet-stream;base64,/waNvZMdK77/Bo09/waNPZMdK77/Bo09/waNPR4Kr8D/Bo09l+KKPVImr8D/Bo09/waNvVImr8D/Bo09yNOKPsjTir7I04o+AAAAAD0M7T4AAAAAyNOKvsjTir7I04o+yNOKvsjTir7I04o+AAAAAD0M7T4AAAAAyNOKvsjTir7I04q+yNOKvsjTir7I04q+yNOKPsjTir7I04q+yNOKPsjTir7I04o+yNOKvsjTir7I04o+yNOKPsjTir7I04q+AAAAAD0M7T4AAAAAyNOKPsjTir7I04o+yNOKvsjTir7I04q+AAAAAD0M7T4AAAAAyNOKPsjTir7I04q+/waNPZMdK77/Bo09/waNPZMdK77/Bo29/waNPVImr8D/Bo29/waNPVImr8D/Bo09/waNPR4Kr8D/Bo09/waNvZMdK77/Bo09/waNvVImr8D/Bo09/waNvVImr8D/Bo29/waNvZMdK77/Bo29/waNvZMdK77/Bo29/waNvVImr8D/Bo29/waNPVImr8D/Bo29/waNPZMdK77/Bo29/waNPZMdK77/Bo09/waNvZMdK77/Bo09/waNvZMdK77/Bo29/waNPZMdK77/Bo29/waNvVImr8D/Bo09cooOO1Imr8BAMTI7/waNvVImr8D/Bo29/waNPVImr8D/Bo29/waNPVImr8D/Bo09l+KKPVImr8D/Bo09/waNPVImr8D/Bo09AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAAAAAAAAAIC/AAAAAFFmsT5wJHA/AAAAAFFmsT5wJHA/AAAAAFFmsT5wJHA/cCRwv1FmsT4AAAAAcCRwv1FmsT4AAAAAcCRwv1FmsT4AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAcCRwP1FmsT4AAAAAcCRwP1FmsT4AAAAAcCRwP1FmsT4AAAAAAAAAAFFmsT5wJHC/AAAAAFFmsT5wJHC/AAAAAFFmsT5wJHC/AACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAvwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAAAAAAAAAAAAgD8AAAAAAADAPgAAQD8AAMA+AACAP2L1Hz8AAIA/AAAgP3uDfz8AACA/AABAPwAAwD4AAIA+AAAgPwAAAAAAAMA+AAAAAAAAwD4AAIA/AAAgPwAAQD8AAMA+AABAPwAAAD4AAAA/AADAPgAAAD8AAMA+AACAPgAAAD4AAIA+AADAPgAAAD8AACA/AACAPgAAwD4AAIA+AADAPgAAQD8AACA/AAAAPwAAwD4AAAA/AADAPgAAAD8AAMA+AABAPwAAID8AAEA/AAAgPwAAAD9i9R8/AAAAPwAAwD4AAAA/AAAgPwAAAD8AACA/AACAPgAAwD4AAIA+AADAPgAAgD4AACA/AACAPgAAID8AAAAAAADAPgAAAAAAAAA+AAAAPwAAwD4AAAA/AADAPgAAgD4AAAA+AACAPgAAID8AAAA/vAJBP/mGwj4AACA/AACAPgAAYD8AAIA+AAAgPwAAgD97g18/AAAAPwAAYD8AAAA/AAABAAIAAgADAAQAAgAEAAAABQAGAAcACAAJAAoACwAMAA0ACwANAA4ADwAQABEAEgATABQAFQAWABcAFwAYABkAFwAZABUAGgAbABwAGgAcAB0AHgAfACAAHgAgACEAIgAjACQAIgAkACUAJgAnACgAKAAnACkAAwACACoAKQAnACsAKQArACwAJwAmACsA"}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:540,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:540,byteOffset:540,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:360,byteOffset:1080,byteStride:8,target:34962},{name:"bufferView_3",buffer:0,byteLength:144,byteOffset:1440,target:34963}],materials:[{name:"Material.001",pbrMetallicRoughness:{baseColorFactor:[.8,.8,.8,1],metallicFactor:0,roughnessFactor:.676000006},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"Cube.001-Mesh",primitives:[{attributes:{POSITION:0,NORMAL:1,TEXCOORD_0:2},indices:3,material:0,mode:4}]}],nodes:[{name:"Cube.001",mesh:0}],scene:0,scenes:[{nodes:[0]}]},jiantou:{accessors:[{name:"��ͷ_1_0_positions",componentType:5126,count:7,min:[-.47690001130104065,-.8044000267982483,0],max:[.47780001163482666,0,0],type:"VEC3",bufferView:0,byteOffset:0},{name:"��ͷ_1_0_normals",componentType:5126,count:7,min:[0,0,1],max:[0,0,1],type:"VEC3",bufferView:1,byteOffset:0},{name:"��ͷ_1_0_indices",componentType:5123,count:15,min:[0],max:[6],type:"SCALAR",bufferView:2,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"jiantou",byteLength:200,uri:"data:application/octet-stream;base64,bxIDOintTb8AAAAAH/RsvsKGp74AAAAAPSz0vsKGp74AAAAANs17PsKGp74AAAAANKL0PsKGp74AAAAANs17PgAAAAAAAAAAH/RsvgAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAABAAIAAAADAAEAAAAEAAMAAQAFAAYAAQADAAUAAAA="}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:84,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:84,byteOffset:84,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:32,byteOffset:168,target:34963}],materials:[{name:"SVGMat_003",pbrMetallicRoughness:{baseColorFactor:[.588,.588,.588,1],metallicFactor:0,roughnessFactor:.99},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"��ͷ_1",primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2,material:0,mode:4}]}],nodes:[{name:"��ͷ",mesh:0}],scene:0,scenes:[{nodes:[0]}]},xuanzhuan:{accessors:[{name:"��ת001_1_0_positions",componentType:5126,count:369,min:[-6.572299957275391,-7.298999786376953,0],max:[6.5742998123168945,7.298299789428711,0],type:"VEC3",bufferView:0,byteOffset:0},{name:"��ת001_1_0_normals",componentType:5126,count:369,min:[0,-1,0],max:[0,0,1],type:"VEC3",bufferView:1,byteOffset:0},{name:"��ת001_1_0_indices",componentType:5123,count:1089,min:[0],max:[368],type:"SCALAR",bufferView:2,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"旋转-新",byteLength:11036,uri:"data:application/octet-stream;base64,1zQDwHql3kAAAAAA48e4vgMJ1kAAAAAAQmD1v6yL6UAAAAAA2qxqv1Fr0EAAAAAAVHSkvnuD1UAAAAAAF7eRvjXv1EAAAAAAyeV/vqVO1EAAAAAA5INevsuh00AAAAAAW7E/vpHt0kAAAAAAZogjvoMv0kAAAAAAAwkKvrpr0UAAAAAA+aDnvTSi0EAAAAAAXCDBvWfVz0AAAAAAqoLZv4NRy0AAAAAALv+hvfcGz0AAAAAAAwmKvVg5zkAAAAAA/Yd0vYtszUAAAAAAak1zvSBBzUAAAAAA1xJyveQUzUAAAAAAIEFxvTLmzEAAAAAARdhwvd21zEAAAAAARdhwvbaEzEAAAAAAIEFxvb1SzEAAAAAAs3tyvSEfzEAAAAAARrZzvYXry0AAAAAAayt2vRe3y0AAAAAAkKB4vQaBy0AAAAAASFB8vfVKy0AAAAAAhXwcwLRZw0AAAAAAbjSAveQUy0AAAAAA3EaDvcX+ykAAAAAAb/CFvTLmykAAAAAAcM6IvRTQykAAAAAAcayLvSS5ykAAAAAAcoqOvQWjykAAAAAA4XqUvWx4ykAAAAAAUI2XvSBjykAAAAAACD2bvQFNykAAAAAAUrievbU3ykAAAAAAeJyivTojykAAAAAA5x2nve0NykAAAAAAMCqpvaMBykAAAAAAVp+rvVr1yUAAAAAAexSuvbPqyUAAAAAAxSCwvTvfyUAAAAAA6pWyvfLSyUAAAAAAoda0vUvIyUAAAAAAx0u3vQK8yUAAAAAAWvW5vVuxyUAAAAAA7Z68vYenyUAAAAAA7ny/veCcyUAAAAAAgSbCvQyTyUAAAAAAgQTFvQmKyUAAAAAA1CvlvRUdyUAAAAAAXW0FviS5yEAAAAAALNQavjVeyEAAAAAADi0yvqYKyEAAAAAAlkNLvki/x0AAAAAA5q5lvhx8x0AAAAAAZaqAvqs+x0AAAAAA4L6OvsgHx0AAAAAAyAedvnPXxkAAAAAAlkOrvqytxkAAAAAAEFi5vs6IxkAAAAAAH4XLvpVlxkAAAAAAAwnKvjhnxkAAAAAA54zIvjhnxkAAAAAAsAPHvgpoxkAAAAAAOwHNvsNkxkAAAAAAO3DOvvFjxkAAAAAA0ETYvpJcxkAAAAAAV+zPvk5ixkAAAAAAV1vRvtlfxkAAAAAAWMrSvgdfxkAAAAAAWDnUvmRdxkAAAAAAIo7VvpJcxkAAAAAA6+LWvpJcxkAAAAAAiIXavgRWxkAAAAAAJLncvkhQxkAAAAAA2/nevl5LxkAAAAAAkzrhvhdIxkAAAAAASnvjvtBExkAAAAAAMzPzvoY4xkAAAAAAArzlvrhAxkAAAAAAufznvkI+xkAAAAAAcT3qvs07xkAAAAAAKH7svlg5xkAAAAAAxLHuvoY4xkAAAAAAfPLwvoY4xkAAAAAA9Gz2vsoyxkAAAAAAtab5vj0sxkAAAAAAduD8vlInxkAAAAAAqRMAvzojxkAAAAAApb0Bv08exkAAAAAAE2EDvzcaxkAAAAAAnREFv00VxkAAAAAAC7UGvzQRxkAAAAAAlWUIv0oMxkAAAAAAHhYKv18HxkAAAAAAGsALv6MBxkAAAAAADk8Pv7n8xUAAAAAAgEgPv7n8xUAAAAAApHANv7n8xUAAAAAAUwWrv90kwkAAAAAASS4Pv7n8xUAAAAAApHANv7n8xUAAAAAAgEgPv7n8xUAAAAAA9wYPv7n8xUAAAAAAidIOv7n8xUAAAAAAG54Ov7n8xUAAAAAAIGMOv7n8xUAAAAAAJCgOv7n8xUAAAAAAKe0Nv7n8xUAAAAAASL8Nv7n8xUAAAAAA9pcNv7n8xUAAAAAAv30Nv7n8xUAAAAAABoFJwDm0uEAAAAAAZvcEwJtVu0AAAAAAwcoxwOzAsUAAAAAARiUFQFdbu8AAAAAAdZMcQM9mw8AAAAAA9pdJQIPAuMAAAAAAtvMxQEvIscAAAAAA2IFzQISeq8AAAAAAjLlbQECkpcAAAAAAZveMQPkxnMAAAAAAPQqBQNEil8AAAAAA+zqeQJOpisAAAAAAdk+SQPd1hsAAAAAAA3ihQFafZ8AAAAAAnl6tQN5xbsAAAAAAsi66QCEfRMAAAAAASFCuQLTIPsAAAAAA4XrEQPW5FsAAAAAAHqe4QJ/NEsAAAAAA1xLMQJhMzb8AAAAA6UjAQFInyL8AAAAAnMTQQM4ZUb8AAAAAsAPFQKMBTL8AAAAAduCMwKMjWcAAAAAA9P1wwOauOcAAAAAA6GqDwG1WGcAAAAAA46WZwA5PM8AAAAAANKLGQBe30TkAAAAAqmDSQBe30TkAAAAAdQLMwEYlzT8AAAAALUPAwAAAyD8AAAAAvp+4wFK4EkAAAAAArWnEwAWjFkAAAAAAF0iuwGizPkAAAAAATx66wI4GREAAAAAAXW2hwAmKZ0AAAAAAPE6twEtZbkAAAAAAW0KSwFFrhkAAAAAAayuewO2eikAAAAAAUPyAwPwYl0AAAAAA1eeMwK8lnEAAAAAAyJhbwA+cpUAAAAAAoWdzwDqSq0AAAAAA6GqrP8cpwsAAAAAA+zoQP6MBxsAAAAAAbqPZPxNhy8AAAAAAYHYPPxsNxsAAAAAAukkMPzQRxsAAAAAA0gAOPxsNxsAAAAAARPoNPxsNxsAAAAAAexQOPxsNxsAAAAAAPzUOPxsNxsAAAAAAIGMOPxsNxsAAAAAAcooOPxsNxsAAAAAAUrgOPxsNxsAAAAAAMuYOPxsNxsAAAAAAoBoPPxsNxsAAAAAAZDsPPxsNxsAAAAAAKVwPPxsNxsAAAAAA0m8PPxsNxsAAAAAAMZkKP00VxsAAAAAAp+gIPzcaxsAAAAAAqz4HPyEfxsAAAAAAIo4FP90kxsAAAAAAmN0DP2srxsAAAAAADi0CPycxxsAAAAAAhXwAP+M2xsAAAAAA9pf9PnE9xsAAAAAA/kP6PltCxsAAAAAA6+L2PqJFxsAAAAAA2IHzPulIxsAAAAAAc2jxPl5LxsAAAAAADk/vPtNNxsAAAAAAqDXtPkhQxsAAAAAAKA/rPr1SxsAAAAAAjNvoPmFUxsAAAAAAC7XmPjJVxsAAAAAAVHTkPgRWxsAAAAAA003iPnlYxsAAAAAAGw3gPh1axsAAAAAAZMzdPpJcxsAAAAAArIvbPgdfxsAAAAAA9UrZPnxhxsAAAAAA2c7XPvFjxsAAAAAA2V/WPpVlxsAAAAAA2PDUPgpoxsAAAAAA847TPn9qxsAAAAAA8x/SPiJsxsAAAAAA8rDQPvRsxsAAAAAA8kHPPphuxsAAAAAAKe3NPg1xxsAAAAAAKH7MPt5xxsAAAAAADALLPlR0xsAAAAAADJPJPsl2xsAAAAAA8BbIPj55xsAAAAAA4za6PryWxsAAAAAATRWsPvW5xsAAAAAASL+dPuvixsAAAAAAYHaPPp0Rx8AAAAAA5WGBPgtGx8AAAAAAi2xnPtiBx8AAAAAAOwFNPtbFx8AAAAAA6gQ0PmIQyMAAAAAAP8YcPiBjyMAAAAAA3pMHPrG/yMAAAAAAZ0TpPdEiycAAAAAAg1HJPcWPycAAAAAAy6HFPQ+cycAAAAAA7lrCPYenycAAAAAAEhS/PdCzycAAAAAAowG8PRrAycAAAAAAEFi5PZLLycAAAAAAfa62PdzXycAAAAAA6gS0PVTjycAAAAAAxY+xPZ7vycAAAAAADk+vPef7ycAAAAAA6NmsPV8HysAAAAAAn82qPakTysAAAAAAeVioPfMfysAAAAAAwaikPT81ysAAAAAA5WGhPYxKysAAAAAACRuePapgysAAAAAACD2bPcl2ysAAAAAAB1+YPbmNysAAAAAAdLWVPamkysAAAAAAvJaQPVvTysAAAAAABFaOPRzrysAAAAAA3+CLPd4Cy8AAAAAAldSJPXEby8AAAAAAcF+HPTMzy8AAAAAA3bWEPc9my8AAAAAALNRqP1Z90MAAAAAAuECCPciYy8AAAAAA3GiAPZLLy8AAAAAAtvN9PS7/y8AAAAAASFB8PScxzMAAAAAA/kN6PSBjzMAAAAAAI9t5PUaUzMAAAAAAI9t5PRHHzMAAAAAAI9t5PTj4zMAAAAAA/kN6PV8pzcAAAAAAkX57PYZazcAAAAAAJLl8PQmKzcAAAAAAcoqOPdZWzsAAAAAAMEymPaMjz8AAAAAAXW3FPZ7vz8AAAAAAjLnrPfW50MAAAAAAqz4DQN213sAAAAAAgy8MPmN/0cAAAAAA5q4lPrhA0sAAAAAAE/JBPn/70sAAAAAAnMRgPhSu08AAAAAAJQaBPnlY1MAAAAAAPL2SPpT21MAAAAAAeHqlPgmK1cAAAAAAhxa5Pr8O1sAAAAAA63P1P2iR6cAAAAAApb1Bv4xKsEAAAAAAMlVAP4xKsEAAAAAAw2QquxDpsUAAAAAAMne9v/OOq0AAAAAA3bW8P/OOq0AAAAAAYqEKwG/wo0AAAAAAcT0KQG/wo0AAAAAA/7IzwG6jmUAAAAAAak0zQG6jmUAAAAAA8IVZwAHejEAAAAAAHcklvw6+lkAAAAAAw2Qqu8UgmEAAAAAAxm0kPw6+lkAAAAAAuB5ZQAHejEAAAAAAc2ihP5aykkAAAAAA1xKiv5aykkAAAAAAKH7sP+AtjEAAAAAAjSjtv+AtjEAAAAAAuK97wBSue0AAAAAAOUV7QBSue0AAAAAAnl4ZQHBfg0AAAAAAdLUZwHBfg0AAAAAAXro5QGDlcEAAAAAA7Q06wGDlcEAAAAAAduCMwPCFWUAAAAAAZaqMQPCFWUAAAAAAqvFWQJAxV0AAAAAA3EZXwJAxV0AAAAAA46WZwEa2M0AAAAAA0m+ZQEa2M0AAAAAAHqdwQIv9OUAAAAAA9P1wwIv9OUAAAAAAIEGDQLWmGUAAAAAA6GqDwLWmGUAAAAAAnzyMwMZt7L8AAAAAiPSjwHE9CsAAAAAAIEGDQG1WGcAAAAAA0m+ZQA5PM8AAAAAA07yjQHE9CsAAAAAANBGMQMZt7L8AAAAA+1yrQAisvL8AAAAA6pWSQBBYob8AAAAAOpKrwAisvL8AAAAAVcGSwBBYob8AAAAA+8uWwI9TJL8AAAAA002wwG40QL8AAAAAYqGWQMbcJT8AAAAA8BawQPfkQT8AAAAA+1yrQE2EvT8AAAAA6pWSQJEPoj8AAAAAVTCYwInSXjsAAAAA+u2xwInSXjsAAAAA6gSYQInSXjsAAAAARraxQInSXjsAAAAAObTQwEXYUD8AAAAAIv3EwBrASz8AAAAAYqGWQI9TJL8AAAAA8BawQG40QL8AAAAA+8uWwMbcJT8AAAAA002wwPfkQT8AAAAAVcGSwJEPoj8AAAAAOpKrwE2EvT8AAAAAnzyMwOQU7T8AAAAAiPSjwEymCkAAAAAA07yjQEymCkAAAAAANBGMQOQU7T8AAAAAHqdwQOauOcAAAAAAZaqMQKMjWcAAAAAA3EZXwOviVsAAAAAAqvFWQOviVsAAAAAA7Q06wLyWcMAAAAAAXro5QLyWcMAAAAAAOUV7QMdLe8AAAAAAuK97wMdLe8AAAAAAdLUZwHo2g8AAAAAAnl4ZQHo2g8AAAAAAuB5ZQE+vjMAAAAAA8IVZwE+vjMAAAAAAjSjtv+oEjMAAAAAAKH7sP+oEjMAAAAAA1xKiv86IksAAAAAAc2ihP86IksAAAAAAak0zQGB2mcAAAAAA/7IzwGB2mcAAAAAAHcklv0aUlsAAAAAAxm0kP0aUlsAAAAAAw2Qqu/32l8AAAAAAcT0KQDPEo8AAAAAAYqEKwDPEo8AAAAAA3bW8P4hjq8AAAAAAMne9v4hjq8AAAAAAMlVAPyEfsMAAAAAApb1BvyEfsMAAAAAAw2Qqu3e+scAAAAAASFDSwG8Sg7oAAAAASZ3GwG8Sg7oAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAgL8AAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAABAAIAAwABAAAAAwAEAAEAAwAFAAQAAwAGAAUAAwAHAAYAAwAIAAcAAwAJAAgAAwAKAAkAAwALAAoAAwAMAAsADQAMAAMADQAOAAwADQAPAA4ADQAQAA8ADQARABAADQASABEADQATABIADQAUABMADQAVABQADQAWABUADQAXABYADQAYABcADQAZABgADQAaABkADQAbABoAHAAbAA0AHAAdABsAHAAeAB0AHAAfAB4AHAAgAB8AHAAhACAAHAAiACEAHAAjACIAHAAkACMAHAAlACQAHAAmACUAHAAnACYAHAAoACcAHAApACgAHAAqACkAHAArACoAHAAsACsAHAAtACwAHAAuAC0AHAAvAC4AHAAwAC8AHAAxADAAHAAyADEAHAAzADIAHAA0ADMAHAA1ADQAHAA2ADUAHAA3ADYAHAA4ADcAHAA5ADgAHAA6ADkAHAA7ADoAHAA8ADsAHAA9ADwAHAA+AD0AHAA/AD4AHABAAD8AQABBAD8AQQBCAD8AQgBDAD8AHABAAEQAHABEAEUAHABGAEUARgBHAEUARgBIAEcARgBJAEgARgBKAEkARgBLAEoARgBMAEsAHABNAEYAHABOAE0AHABPAE4AHABQAE8AHABRAFAAHABSAFEAUgBTAFEAUgBUAFMAUgBVAFQAUgBWAFUAUgBXAFYAUgBYAFcAHABZAFIAHABaAFkAHABbAFoAHABcAFsAHABdAFwAHABeAF0AHABfAF4AHABgAF8AHABhAGAAHABiAGEAHABjAGIAHABjAGQAZABlAGMAZQBmAGMAHABnAGQAaABpAGoAawBpAGgAbABpAGsAbQBpAGwAbgBpAG0AbwBpAG4AcABpAG8AcQBpAHAAcgBpAHEAcwBpAHIAdABnABwAdAB1AGcAdAB2AHUAdwB4AHkAdwB5AHoAegB5AHsAegB7AHwAfAB7AH0AfAB9AH4AfgB9AH8AfgB/AIAAgQCCAIMAgQCDAIQAhACDAIUAhACFAIYAhgCFAIcAhgCHAIgAiACHAIkAiACJAIoAiwCMAI0AiwCNAI4AjwCKAJAAigCJAJAAkQCSAJMAkQCTAJQAlACTAJUAlACVAJYAlgCVAJcAlgCXAJgAgAB/AIIAgACCAIEAmACXAJkAmACZAJoAmgCZAJsAmgCbAJwAnACbAJ0AnACdAJ4AngCdAHYAngB2AHQAnwB4AHcAoAB4AJ8AoAChAHgAogChAKAAowCkAKUAowCmAKQAowCnAKYAowCoAKcAowCpAKgAowCqAKkAowCrAKoAowCsAKsAowCtAKwAowCuAK0AowCvAK4AowCiAK8AowChAKIAsAChAKMAsQChALAAsgChALEAswChALIAtAChALMAtQChALQAtgChALUAtwChALYAuAChALcAuQChALgAugChALkAuwChALoAvAChALsAvQChALwAvgChAL0AvwChAL4AwAChAL8AwQChAMAAwgChAMEAwwChAMIAxAChAMMAxQChAMQAxgChAMUAxwChAMYAyAChAMcAyQChAMgAygChAMkAywChAMoAzAChAMsAzQChAMwAzgChAM0AzwChAM4A0AChAM8A0QChANAA0gChANEA0wChANIA1AChANMA1QChANQA1gChANUA1wChANYA2AChANcA2QChANgA2gChANkA2wChANoA3AChANsA3QChANwA3gChAN0A3wChAN4A4AChAN8A4QChAOAA4gChAOEA4wChAOIA5AChAOMA5QChAOQA5gChAOUA5wChAOYA6AChAOcA6QChAOgA6gChAOkA6wChAOoA7AChAOsA7QChAOwA7gChAO0A7wChAO4A8AChAO8A8QChAO8A8gChAPEA8wChAPIA9AChAPMA9QChAPQA9gChAPUA9gD3AKEA+AD3APYA+QD3APgA+gD3APkA+wD3APoA/AD3APsA/QD3APwA/gD3AP0A/wD3AP4AAAH3AP8AAQH3AAABAgH3AAEBAwH3AAIBBAH3AAMBBQH3AAQBBgH3AAUBBgEHAfcACAEHAQYBCQEHAQgBCgEHAQkBCwEHAQoBDAEHAQsBDQEHAQwBDgEHAQ0BDwEHAQ4BEAEHAQ8BEQESARMBFAESAREBFAEVARIBFgEVARQBFgEXARUBGAEXARYBGAEZARcBGgEbARgBGwEcARgBHAEZARgBHAEdARkBHQEeARkBHwEeAR0BGgEgARsBIQEeAR8BGgEiASABIwEiARoBIQEkAR4BJQEkASEBIwEmASIBJwEkASUBIwEoASYBKQEoASMBJwEqASQBKwEqAScBKQEsASgBLQEsASkBKwEuASoBLwEuASsBLQEwASwBMQEuAS8BLQEyATABjgCNADMBjgAzATQBNQE2ATcBNQE3ATgBOAE3ATkBOAE5AToBOwE8AT0BOwE9AT4BPwFAAUEBPwFBAUIBPgE9AUMBPgFDAUQBRQFGAUABRQFAAT8BRwFIAZIARwGSAJEASQFKAUYBSQFGAUUBRAFDAUsBRAFLAUwBOgE5AUoBOgFKAUkBTAFLAU0BTAFNAU4BTgFNAU8BTgFPAVABQgFBAVEBQgFRAVIBUgFRAS4BUgEuATEBNAEzATwBNAE8ATsBUwFUATYBUwE2ATUBUAFPATIBUAEyAS0BiwBVAYwAVgFUAVMBiwBXAVUBWAFUAVYBWAFZAVQBWgFXAYsAWgFbAVcBXAFZAVgBXAFdAVkBXgFbAVoBXgFfAVsBYAFdAVwBXgFhAV8BYgFdAWABYgFjAV0BZAFhAV4BZAFlAWEBZgFjAWIBZAFnAWUBZwFjAWYBZAFjAWcBZAFoAWMBaQFoAWQBaQFqAWgBawFqAWkBawFsAWoBbQFsAWsBbQFuAWwBbwFwAUgBbwFIAUcBAAA="}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:4428,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:4428,byteOffset:4428,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:2180,byteOffset:8856,target:34963}],materials:[{name:"SVGMat",pbrMetallicRoughness:{baseColorFactor:[.5,.5,.5,1],metallicFactor:0,roughnessFactor:1},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"��ת001_1",primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2,material:0,mode:4}]}],nodes:[{name:"��ת001",mesh:0}],scene:0,scenes:[{nodes:[0]}]},plane:{accessors:[{name:"Rectangle001_1_0_positions",componentType:5126,count:4,min:[-5,-5,0],max:[5,5,0],type:"VEC3",bufferView:0,byteOffset:0},{name:"Rectangle001_1_0_normals",componentType:5126,count:4,min:[0,0,1],max:[0,0,1],type:"VEC3",bufferView:1,byteOffset:0},{name:"Rectangle001_1_0_indices",componentType:5123,count:6,min:[0],max:[3],type:"SCALAR",bufferView:2,byteOffset:0}],asset:{generator:"obj2gltf",version:"2.0"},buffers:[{name:"plane",byteLength:108,uri:"data:application/octet-stream;base64,AACgQAAAoEAAAAAAAACgwAAAoEAAAAAAAACgwAAAoMAAAAAAAACgQAAAoMAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAABAAIAAgADAAAA"}],bufferViews:[{name:"bufferView_0",buffer:0,byteLength:48,byteOffset:0,byteStride:12,target:34962},{name:"bufferView_1",buffer:0,byteLength:48,byteOffset:48,byteStride:12,target:34962},{name:"bufferView_2",buffer:0,byteLength:12,byteOffset:96,target:34963}],materials:[{name:"wire_225198087",pbrMetallicRoughness:{baseColorFactor:[.8824,.7765,.3412,1],metallicFactor:0,roughnessFactor:.968},emissiveFactor:[0,0,0],alphaMode:"OPAQUE",doubleSided:!1}],meshes:[{name:"Rectangle001_1",primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2,material:0,mode:4}]}],nodes:[{name:"Rectangle001",mesh:0}],scene:0,scenes:[{nodes:[0]}]},xyzScale:{asset:{generator:"Khronos glTF Blender I/O v1.6.16",version:"2.0"},scene:0,scenes:[{name:"Scene",nodes:[0,1,2,3,4,5,6]}],nodes:[{mesh:0,name:"Cube",scale:[.7008190751075745,.014999999664723873,.014999999664723873]},{mesh:1,name:"Cube.001",scale:[.10000000149011612,.10000000149011612,.10000000149011612]},{mesh:2,name:"Cube.004",rotation:[0,-.7071068286895752,0,.7071068286895752],scale:[.7008190751075745,.014999999664723873,.014999999664723873]},{mesh:3,name:"Cube.003",rotation:[0,-.7071068286895752,0,.7071068286895752],scale:[.10000000149011612,.10000000149011612,.10000000149011612]},{mesh:4,name:"Cube.006",rotation:[0,0,.7071068286895752,.7071068286895752],scale:[.7008190751075745,.014999999664723873,.014999999664723873]},{mesh:5,name:"Cube.005",rotation:[0,0,.7071068286895752,.7071068286895752],scale:[.10000000149011612,.10000000149011612,.10000000149011612]},{mesh:6,name:"Cube.002",scale:[.10000000149011612,.10000000149011612,.10000000149011612]}],materials:[{doubleSided:!0,name:"Material",pbrMetallicRoughness:{baseColorFactor:[.6938720345497131,.020288480445742607,.011612260714173317,1],metallicFactor:0,roughnessFactor:.4000000059604645}},{doubleSided:!0,name:"Material.001",pbrMetallicRoughness:{baseColorFactor:[.6938720345497131,.020288480445742607,.011612260714173317,1],metallicFactor:0,roughnessFactor:.4000000059604645}},{doubleSided:!0,name:"Material.002",pbrMetallicRoughness:{baseColorFactor:[.626582869887352,.626582869887352,.626582869887352,1],metallicFactor:0,roughnessFactor:.4000000059604645}},{doubleSided:!0,name:"Material.006",pbrMetallicRoughness:{baseColorFactor:[.11193240433931351,.5583405494689941,.033104799687862396,1],metallicFactor:0,roughnessFactor:.4000000059604645}},{doubleSided:!0,name:"Material.005",pbrMetallicRoughness:{baseColorFactor:[.11193240433931351,.5583405494689941,.033104799687862396,1],metallicFactor:0,roughnessFactor:.4000000059604645}},{doubleSided:!0,name:"Material.010",pbrMetallicRoughness:{baseColorFactor:[.004391402006149292,.21223078668117523,.5209956169128418,1],metallicFactor:0,roughnessFactor:.4000000059604645}},{doubleSided:!0,name:"Material.009",pbrMetallicRoughness:{baseColorFactor:[.004391402006149292,.21223078668117523,.5209956169128418,1],metallicFactor:0,roughnessFactor:.4000000059604645}}],meshes:[{name:"Cube",primitives:[{attributes:{POSITION:0,NORMAL:1,TEXCOORD_0:2},indices:3,material:0}]},{name:"Cube.001",primitives:[{attributes:{POSITION:4,NORMAL:5,TEXCOORD_0:6},indices:3,material:1}]},{name:"Cube.006",primitives:[{attributes:{POSITION:10,NORMAL:11,TEXCOORD_0:12},indices:3,material:3}]},{name:"Cube.005",primitives:[{attributes:{POSITION:13,NORMAL:14,TEXCOORD_0:15},indices:3,material:4}]},{name:"Cube.010",primitives:[{attributes:{POSITION:16,NORMAL:17,TEXCOORD_0:18},indices:3,material:5}]},{name:"Cube.009",primitives:[{attributes:{POSITION:19,NORMAL:20,TEXCOORD_0:21},indices:3,material:6}]},{name:"Cube.002",primitives:[{attributes:{POSITION:7,NORMAL:8,TEXCOORD_0:9},indices:3,material:2}]}],accessors:[{bufferView:0,componentType:5126,count:24,max:[2.0003609657287598,1,1],min:[.0003610849380493164,-1,-1],type:"VEC3"},{bufferView:1,componentType:5126,count:24,type:"VEC3"},{bufferView:2,componentType:5126,count:24,type:"VEC2"},{bufferView:3,componentType:5123,count:36,type:"SCALAR"},{bufferView:4,componentType:5126,count:24,max:[14.549108505249023,1,1],min:[12.549108505249023,-1,-1],type:"VEC3"},{bufferView:5,componentType:5126,count:24,type:"VEC3"},{bufferView:6,componentType:5126,count:24,type:"VEC2"},{bufferView:7,componentType:5126,count:24,max:[1,1,1],min:[-1,-1,-1],type:"VEC3"},{bufferView:8,componentType:5126,count:24,type:"VEC3"},{bufferView:9,componentType:5126,count:24,type:"VEC2"},{bufferView:10,componentType:5126,count:24,max:[2.0003609657287598,1,1],min:[.0003610849380493164,-1,-1],type:"VEC3"},{bufferView:11,componentType:5126,count:24,type:"VEC3"},{bufferView:12,componentType:5126,count:24,type:"VEC2"},{bufferView:13,componentType:5126,count:24,max:[14.549108505249023,1,1],min:[12.549108505249023,-1,-1],type:"VEC3"},{bufferView:14,componentType:5126,count:24,type:"VEC3"},{bufferView:15,componentType:5126,count:24,type:"VEC2"},{bufferView:16,componentType:5126,count:24,max:[2.0003609657287598,1,1],min:[.0003610849380493164,-1,-1],type:"VEC3"},{bufferView:17,componentType:5126,count:24,type:"VEC3"},{bufferView:18,componentType:5126,count:24,type:"VEC2"},{bufferView:19,componentType:5126,count:24,max:[14.549108505249023,1,1],min:[12.549108505249023,-1,-1],type:"VEC3"},{bufferView:20,componentType:5126,count:24,type:"VEC3"},{bufferView:21,componentType:5126,count:24,type:"VEC2"}],bufferViews:[{buffer:0,byteLength:288,byteOffset:0},{buffer:0,byteLength:288,byteOffset:288},{buffer:0,byteLength:192,byteOffset:576},{buffer:0,byteLength:72,byteOffset:768},{buffer:0,byteLength:288,byteOffset:840},{buffer:0,byteLength:288,byteOffset:1128},{buffer:0,byteLength:192,byteOffset:1416},{buffer:0,byteLength:288,byteOffset:1608},{buffer:0,byteLength:288,byteOffset:1896},{buffer:0,byteLength:192,byteOffset:2184},{buffer:0,byteLength:288,byteOffset:2376},{buffer:0,byteLength:288,byteOffset:2664},{buffer:0,byteLength:192,byteOffset:2952},{buffer:0,byteLength:288,byteOffset:3144},{buffer:0,byteLength:288,byteOffset:3432},{buffer:0,byteLength:192,byteOffset:3720},{buffer:0,byteLength:288,byteOffset:3912},{buffer:0,byteLength:288,byteOffset:4200},{buffer:0,byteLength:192,byteOffset:4488},{buffer:0,byteLength:288,byteOffset:4680},{buffer:0,byteLength:288,byteOffset:4968},{buffer:0,byteLength:192,byteOffset:5256}],buffers:[{byteLength:5448,uri:"data:application/octet-stream;base64,6gUAQAAAgD8AAIC/6gUAQAAAgD8AAIC/6gUAQAAAgD8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgD8AAIA/6gUAQAAAgD8AAIA/6gUAQAAAgD8AAIA/6gUAQAAAgL8AAIA/6gUAQAAAgL8AAIA/6gUAQAAAgL8AAIA/AFC9OQAAgD8AAIC/AFC9OQAAgD8AAIC/AFC9OQAAgD8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgD8AAIA/AFC9OQAAgD8AAIA/AFC9OQAAgD8AAIA/AFC9OQAAgL8AAIA/AFC9OQAAgL8AAIA/AFC9OQAAgL8AAIA/AAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AACAPwAAAAAAAACAAACAvwAAAAAAAACAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAgPwAAAD8AACA/AAAAPwAAID8AAAA/AADAPgAAAD8AAMA+AAAAPwAAwD4AAAA/AAAgPwAAgD4AACA/AACAPgAAID8AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAQD8AACA/AABAPwAAYD8AAAA/AADAPgAAQD8AAAA+AAAAPwAAwD4AAEA/AAAgPwAAgD8AACA/AAAAAAAAYD8AAIA+AADAPgAAgD8AAAA+AACAPgAAwD4AAAAAAQAOABQAAQAUAAcACgAGABMACgATABcAFQASAAwAFQAMAA8AEAADAAkAEAAJABYABQACAAgABQAIAAsAEQANAAAAEQAAAAQAJsloQQAAgD8AAIC/JsloQQAAgD8AAIC/JsloQQAAgD8AAIC/JsloQQAAgL8AAIC/JsloQQAAgL8AAIC/JsloQQAAgL8AAIC/JsloQQAAgD8AAIA/JsloQQAAgD8AAIA/JsloQQAAgD8AAIA/JsloQQAAgL8AAIA/JsloQQAAgL8AAIA/JsloQQAAgL8AAIA/JslIQQAAgD8AAIC/JslIQQAAgD8AAIC/JslIQQAAgD8AAIC/JslIQQAAgL8AAIC/JslIQQAAgL8AAIC/JslIQQAAgL8AAIC/JslIQQAAgD8AAIA/JslIQQAAgD8AAIA/JslIQQAAgD8AAIA/JslIQQAAgL8AAIA/JslIQQAAgL8AAIA/JslIQQAAgL8AAIA/AAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AACAPwAAAAAAAACAAACAvwAAAAAAAACAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAgPwAAAD8AACA/AAAAPwAAID8AAAA/AADAPgAAAD8AAMA+AAAAPwAAwD4AAAA/AAAgPwAAgD4AACA/AACAPgAAID8AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAQD8AACA/AABAPwAAYD8AAAA/AADAPgAAQD8AAAA+AAAAPwAAwD4AAEA/AAAgPwAAgD8AACA/AAAAAAAAYD8AAIA+AADAPgAAgD8AAAA+AACAPgAAwD4AAAAAAACAPwAAgD8AAIC/AACAPwAAgD8AAIC/AACAPwAAgD8AAIC/AACAPwAAgL8AAIC/AACAPwAAgL8AAIC/AACAPwAAgL8AAIC/AACAPwAAgD8AAIA/AACAPwAAgD8AAIA/AACAPwAAgD8AAIA/AACAPwAAgL8AAIA/AACAPwAAgL8AAIA/AACAPwAAgL8AAIA/AACAvwAAgD8AAIC/AACAvwAAgD8AAIC/AACAvwAAgD8AAIC/AACAvwAAgL8AAIC/AACAvwAAgL8AAIC/AACAvwAAgL8AAIC/AACAvwAAgD8AAIA/AACAvwAAgD8AAIA/AACAvwAAgD8AAIA/AACAvwAAgL8AAIA/AACAvwAAgL8AAIA/AACAvwAAgL8AAIA/AAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AACAPwAAAAAAAACAAACAvwAAAAAAAACAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAgPwAAAD8AACA/AAAAPwAAID8AAAA/AADAPgAAAD8AAMA+AAAAPwAAwD4AAAA/AAAgPwAAgD4AACA/AACAPgAAID8AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAQD8AACA/AABAPwAAYD8AAAA/AADAPgAAQD8AAAA+AAAAPwAAwD4AAEA/AAAgPwAAgD8AACA/AAAAAAAAYD8AAIA+AADAPgAAgD8AAAA+AACAPgAAwD4AAAAA6gUAQAAAgD8AAIC/6gUAQAAAgD8AAIC/6gUAQAAAgD8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgD8AAIA/6gUAQAAAgD8AAIA/6gUAQAAAgD8AAIA/6gUAQAAAgL8AAIA/6gUAQAAAgL8AAIA/6gUAQAAAgL8AAIA/AFC9OQAAgD8AAIC/AFC9OQAAgD8AAIC/AFC9OQAAgD8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgD8AAIA/AFC9OQAAgD8AAIA/AFC9OQAAgD8AAIA/AFC9OQAAgL8AAIA/AFC9OQAAgL8AAIA/AFC9OQAAgL8AAIA/AAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AACAPwAAAAAAAACAAACAvwAAAAAAAACAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAgPwAAAD8AACA/AAAAPwAAID8AAAA/AADAPgAAAD8AAMA+AAAAPwAAwD4AAAA/AAAgPwAAgD4AACA/AACAPgAAID8AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAQD8AACA/AABAPwAAYD8AAAA/AADAPgAAQD8AAAA+AAAAPwAAwD4AAEA/AAAgPwAAgD8AACA/AAAAAAAAYD8AAIA+AADAPgAAgD8AAAA+AACAPgAAwD4AAAAAJsloQQAAgD8AAIC/JsloQQAAgD8AAIC/JsloQQAAgD8AAIC/JsloQQAAgL8AAIC/JsloQQAAgL8AAIC/JsloQQAAgL8AAIC/JsloQQAAgD8AAIA/JsloQQAAgD8AAIA/JsloQQAAgD8AAIA/JsloQQAAgL8AAIA/JsloQQAAgL8AAIA/JsloQQAAgL8AAIA/JslIQQAAgD8AAIC/JslIQQAAgD8AAIC/JslIQQAAgD8AAIC/JslIQQAAgL8AAIC/JslIQQAAgL8AAIC/JslIQQAAgL8AAIC/JslIQQAAgD8AAIA/JslIQQAAgD8AAIA/JslIQQAAgD8AAIA/JslIQQAAgL8AAIA/JslIQQAAgL8AAIA/JslIQQAAgL8AAIA/AAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AACAPwAAAAAAAACAAACAvwAAAAAAAACAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAgPwAAAD8AACA/AAAAPwAAID8AAAA/AADAPgAAAD8AAMA+AAAAPwAAwD4AAAA/AAAgPwAAgD4AACA/AACAPgAAID8AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAQD8AACA/AABAPwAAYD8AAAA/AADAPgAAQD8AAAA+AAAAPwAAwD4AAEA/AAAgPwAAgD8AACA/AAAAAAAAYD8AAIA+AADAPgAAgD8AAAA+AACAPgAAwD4AAAAA6gUAQAAAgD8AAIC/6gUAQAAAgD8AAIC/6gUAQAAAgD8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgL8AAIC/6gUAQAAAgD8AAIA/6gUAQAAAgD8AAIA/6gUAQAAAgD8AAIA/6gUAQAAAgL8AAIA/6gUAQAAAgL8AAIA/6gUAQAAAgL8AAIA/AFC9OQAAgD8AAIC/AFC9OQAAgD8AAIC/AFC9OQAAgD8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgL8AAIC/AFC9OQAAgD8AAIA/AFC9OQAAgD8AAIA/AFC9OQAAgD8AAIA/AFC9OQAAgL8AAIA/AFC9OQAAgL8AAIA/AFC9OQAAgL8AAIA/AAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AACAPwAAAAAAAACAAACAvwAAAAAAAACAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAgPwAAAD8AACA/AAAAPwAAID8AAAA/AADAPgAAAD8AAMA+AAAAPwAAwD4AAAA/AAAgPwAAgD4AACA/AACAPgAAID8AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAQD8AACA/AABAPwAAYD8AAAA/AADAPgAAQD8AAAA+AAAAPwAAwD4AAEA/AAAgPwAAgD8AACA/AAAAAAAAYD8AAIA+AADAPgAAgD8AAAA+AACAPgAAwD4AAAAAJsloQQAAgD8AAIC/JsloQQAAgD8AAIC/JsloQQAAgD8AAIC/JsloQQAAgL8AAIC/JsloQQAAgL8AAIC/JsloQQAAgL8AAIC/JsloQQAAgD8AAIA/JsloQQAAgD8AAIA/JsloQQAAgD8AAIA/JsloQQAAgL8AAIA/JsloQQAAgL8AAIA/JsloQQAAgL8AAIA/JslIQQAAgD8AAIC/JslIQQAAgD8AAIC/JslIQQAAgD8AAIC/JslIQQAAgL8AAIC/JslIQQAAgL8AAIC/JslIQQAAgL8AAIC/JslIQQAAgD8AAIA/JslIQQAAgD8AAIA/JslIQQAAgD8AAIA/JslIQQAAgL8AAIA/JslIQQAAgL8AAIA/JslIQQAAgL8AAIA/AAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAPwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAPwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AACAPwAAAAAAAACAAACAvwAAAAAAAACAAAAAAAAAAAAAAIC/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIC/AACAvwAAAAAAAACAAAAAAAAAAAAAAIA/AAAAAAAAgD8AAACAAACAvwAAAAAAAACAAAAAAAAAgL8AAACAAAAAAAAAAAAAAIA/AAAgPwAAAD8AACA/AAAAPwAAID8AAAA/AADAPgAAAD8AAMA+AAAAPwAAwD4AAAA/AAAgPwAAgD4AACA/AACAPgAAID8AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAQD8AACA/AABAPwAAYD8AAAA/AADAPgAAQD8AAAA+AAAAPwAAwD4AAEA/AAAgPwAAgD8AACA/AAAAAAAAYD8AAIA+AADAPgAAgD8AAAA+AACAPgAAwD4AAAAA"}]}},qQ=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")},XQ=qQ(),ZQ=XQ.gl_trans__coders=XQ.gl_trans__coders||{};ZQ.inject=function(i){const g=i.toString(),m=g.indexOf("{")+1,_=g.substring(0,m),b=XQ.gl_trans__coders=XQ.gl_trans__coders||{};let T=`${_}\n    const _____getGlobal = ${qQ.toString()};\n    const g___lobals = _____getGlobal()\n    const tran_____scoders = g___lobals['gl_trans__coders'] = g___lobals['gl_trans__coders'] || {};`;for(const i in b)"inject"!==i&&"getTranscoder"!==i&&"registerTranscoder"!==i&&(T+='tran_____scoders["'+i+'"] ='+b[i].toString()+"\n;");return T+="\n("+qQ().maptalks_gltf_loader_bundle.toString()+")({});\n",T+="\n"+g.substring(_.length),T},ZQ.registerTranscoder=function(i,g){ZQ[i]=g},ZQ.getTranscoder=function(i){return ZQ[i]};const $Q=qQ().maptalks_gltf_loader;function YQ(i,g,m,_,b,T){const P=[],I=OA([],o_([],m[0],m[1],m[2]),g,_),H=function(i){return new $Q.GLTFLoader("",JSON.parse(JSON.stringify(WQ[i]))).load().then((i=>i))}(i);return H.then((i=>{wP.GLTFHelper.exportGLTFPack(i).getMeshesInfo().forEach(((i,H)=>{const W=new wP.Material({color:b||i.materialInfo.baseColorFactor}),q=new wP.Mesh(i.geometry,W);q.setUniform("uPickingId",T+H);const $=q.getDefines();$.HAS_PICKING_ID=2,q.setDefines($),q.translate=g,q.rotation=m,q.scaling=_,_A(q.localTransform,I,i.nodeMatrix),q.originTransform=gA([],q.localTransform),q.originColor=b||i.materialInfo.baseColorFactor,P.push(q)})),T>100&&(P[0].properties.relatedMeshes=P.slice(1,2),P[1].properties.relatedMeshes=P.slice(0,1),P[2].properties.relatedMeshes=P.slice(3,4),P[3].properties.relatedMeshes=P.slice(2,3),P[4].properties.relatedMeshes=P.slice(5,6),P[5].properties.relatedMeshes=P.slice(4,5),P[6].properties.relatedMeshes=P.slice(0,6))})),P}function QQ(i,g){return Math.abs(i)*Math.sign(g)}function JQ(i,g){const m=i.getCoordinates(),_=g.coordinateToPointAtRes(m,g.getGLRes()),b=[_.x,_.y,0];XA(b,b,KQ(g,i.getTranslation()));const T=function(i,g,m){return i._pointAtResToContainerPoint(g,m,void 0)}(g,new un(b[0],b[1]),g.getGLRes());T.x+=85;const P=function(i,g,m){{const _=i.containerPointToCoordinate(g);return i.coordinateToPointAtRes(_,m)}}(g,T,g.getGLRes());return Math.sqrt(Math.pow(P.x-b[0],2)+Math.pow(P.y-b[1],2))/5.272881136101205}function KQ(i,g){if(!i)return g;const m=i.distanceToPointAtRes(g[0],g[1],i.getGLRes()),_=i.altitudeToPoint(g[2],i.getGLRes());return qA([],QQ(m.x,g[0]),QQ(m.y,g[1]),QQ(_,g[2]))}let eJ=class y{constructor(i){this.A=i,this._meshes=this.t()}setCoordinate(i){this.A=i}t(){const i=[],g=340/177,m=YQ("jiantou",[1.2*g,0,0],[0,0,90],[g,g,g],[89/255,206/255,147/255,0],7),_=YQ("jiantou",[0,1.2*g,0],[0,0,180],[g,g,g],[89/255,206/255,147/255,0],8),b=YQ("jiantou",[-1.2*g,0,0],[0,0,270],[g,g,g],[89/255,206/255,147/255,0],9),T=YQ("jiantou",[0,-1.2*g,0],[0,0,0],[g,g,g],[89/255,206/255,147/255,0],10);return i.push(m,_,b,T),i}getMeshes(){return this._meshes}},tJ=class p{constructor(i){this.A=i,this._meshes=this.t()}setCoordinate(i){this.A=i}t(){const i=[],g=340/177,m=YQ("xuanzhuan",[0,0,0],[180,0,0],[.5*g,.5*g,.5*g],[50/255,130/255,184/255,.8],11);return i.push(m),i}getMeshes(){return this._meshes}},nJ=class v{constructor(i){this.A=i,this._meshes=this.t()}setCoordinate(i){this.A=i}t(){const i=[],g=340/177,m=YQ("yuanhuan",[0,0,0],[0,0,0],[.5*g,.5*g,.5*g],[149/255,179/255,199/255,.5],12);return i.push(m),i}getMeshes(){return this._meshes}};class d{constructor(i){this.A=i,this._meshes=this.t()}setCoordinate(i){this.A=i}t(){const i=[],g=YQ("plane",[0,0,0],[0,0,0],[10,10,10],[1,0,0,.5],16);return i.push(g),i}getMeshes(){return this._meshes}}class L{constructor(i){this.A=i,this._meshes=this.t()}setCoordinate(i){this.A=i}t(){const i=[],g=YQ("xyzScale",[0,0,0],[0,0,0],[2,2,2],null,113);return i.push(g),i}getMeshes(){return this._meshes}}const rJ=[],iJ=[],oJ=[],sJ=[],aJ=[],lJ=[177/170,177/170,177/170],hJ=[],cJ=[1,2,3,4,12];class k{constructor(){this.translate=new eJ,this.rotation=new tJ,this.scaling=new nJ,this.planeHelper=new d,this.xyzScaleHelper=new L,this._meshes=this.t(),this.i=!0}t(){const i={};i.translate=this.translate.getMeshes(),i.rotation=this.rotation.getMeshes(),i.scaling=this.scaling.getMeshes(),i.planeHelper=this.planeHelper.getMeshes(),i.xyzScale=this.xyzScaleHelper.getMeshes();const g=340/177,m=YQ("yuanhuan41",[-2.745*g,2.745*g,0],[90,0,0],[.5*g,.5*g,.5*g],[149/255,179/255,199/255,.6],1),_=YQ("yuanhuan41",[2.745*g,2.745*g,0],[-90,0,180],[.5*g,.5*g,.5*g],[50/255,130/255,184/255,.5],2),b=YQ("yuanhuan41",[2.745*g,-2.745*g,0],[90,0,180],[.5*g,.5*g,.5*g],[149/255,179/255,199/255,.6],3),T=YQ("yuanhuan41",[-2.745*g,-2.745*g,0],[-90,0,0],[.5*g,.5*g,.5*g],[50/255,130/255,184/255,.5],4),P=YQ("yuanpan",[0,0,0],[90,0,0],[.5*g,.5*g,.5*g],[89/255,206/255,147/255,.5],5),I=YQ("zzhou",[0,0,6.5],[90,0,0],[1,1,1],[14/255,127/255,191/255,1],6);return i.translate.push(m,_,b,T,P,I),i}updateMatrix(i,g,m,_,b){const T=g.getCoordinates(),P=i.coordinateToPointAtRes(T,i.getGLRes()),I=g.o();qA(iJ,P.x,P.y,I);const H=WA(rJ,b),W=KQ(i,g.getTranslation());XA(iJ,iJ,W),XA(iJ,iJ,H);for(const b in this._meshes)for(let T=0;T<this._meshes[b].length;T++){const P=this._meshes[b][T];for(let T=0;T<P.length;T++){const I=P[T],H=I.getUniform("uPickingId"),W=WA(rJ,I.translate);let q=WA(hJ,I.rotation);const $=I.scaling;if(11===H&&(this.i?(q[2]+=m,I.rotation[2]+=m):this.i||(q[2]+=m,I.rotation[2]+=m,q[0]=360,q[2]-=90)),H>100&&1===g.getTargets().length&&(q=g.getTargets()[0].getRotation()),cJ.indexOf(H)>-1)if(12!==H)$[0]+=_,$[1]+=_,$[2]+=_;else{const i=this._meshes.translate[4][0];$[0]=1.2*i.scaling[0],$[1]=1.2*i.scaling[0],$[2]=1.2*i.scaling[0]}let ye=JQ(g,i);if(ye=qA(oJ,ye,ye,ye),$A(W,W,ye),$A(ye,ye,$),1===H||2===H||3===H||4===H){const i=$A(aJ,$,lJ);$A(W,W,i)}const Re=o_(sJ,q[0],q[1],q[2]);if(XA(W,W,iJ),"xyzScale"===b){const i=OA([],Re,W,ye);_A(I.localTransform,i,I.originTransform)}else OA(I.localTransform,Re,W,ye)}}}getMeshes(i){const g={};return i?("xyzScale"===i?g[i]=this._meshes[i]:(g.translate=this._meshes.translate,"translate"!==i&&(g[i]=this._meshes[i])),g):g}I(i){this.i=i}dispose(){for(const i in this._meshes)for(let g=0;g<this._meshes[i].length;g++){const m=this._meshes[i][g];for(let i=0;i<m.length;i++){const g=m[i];g.geometry.dispose(),g.dispose()}}}}const uJ=[],fJ=[],dJ=[],pJ=new un(0,0),gJ=[],mJ=[],AJ=[],yJ=[0,0,0];class G{constructor(){this.C=[],this.h=[0,0,0],this.l=[1,1,1],this.P=[0,0,0]}D(i){Array.isArray(i)?i.forEach((i=>{this.D(i)})):(i.on("remove",this.u,this),i.m={coordinate:i.getCoordinates(),translation:i.getTranslation(),rotation:i.getRotation(),scale:i.getScale()},this.C.push(i))}B(){this.C.forEach((i=>{i.off("remove",this.u,this)})),this.C=[]}p(i,g,m,_,b,T,P){for(let P=0;P<this.C.length;P++){const I=this.C[P],H=I.getRotation(),W=I.getScale(),q=this.v(T,I,_,m,g);let $=null;$=_>=0?_:_*(this.options&&this.options.scaleStrength||1);const ye=XA(AJ,qA(uJ,$*W[0],$*W[1],$*W[2]),W),Re=Math.min(...ye);if(Math.abs(Re)<b){const i=Math.abs(Re);ye[0]=ye[0]*(b/i),ye[1]=ye[1]*(b/i),ye[2]=ye[2]*(b/i)}const Be=XA(H,m,H);I.setCoordinates(q),this.L(i,ye,W);const Ge=I.getTranslation();I.setTRS(Ge,Be,ye)}qA(AJ,_,_,_),XA(this.P,m,this.P),XA(this.l,AJ,this.l),XA(this.h,g,this.h),i.indexOf("translate")>-1?P.fire("positionchange",{action:i,type:"positionchange",transformtarget:this.C,center:this.getCoordinates(),scale:this.l,rotation:this.P,translation:this.h,deltaTranslate:g,deltaRotation:m,deltaScale:_}):P.fire("transforming",{action:i,type:"transforming",transformtarget:this.C,center:this.C[0].getTransformOrigin(),scale:this.l,rotation:this.P,translation:this.h,deltaTranslate:g,deltaRotation:m,deltaScale:_})}v(i,g,m,_,b){const T=g.getCenter(),P=g.getTransformOrigin(),I=i.getGLRes(),H=i.coordinateToPointAtRes(T,I,pJ);H.z=i.altitudeToPoint(T.z,I),qA(gJ,H.x,H.y,H.z||0);const W=i.coordinateToPointAtRes(P,I,pJ);W.z=i.altitudeToPoint(P.z,I),qA(mJ,W.x,W.y,W.z||0);const q=cy(uJ,gJ,mJ),$=o_(fJ,0,0,_[2]);qA(AJ,m+1,m+1,m+1);oy(q,q,OA(dJ,$,b,AJ)),XA(q,q,mJ),pJ.set(q[0],q[1]);const ye=i.pointAtResToCoordinate(pJ,I);return ye.z=q[2]/i.altitudeToPoint(1,I),ye}L(i,g,m){return"x-scale"===i&&(g[1]=m[1],g[2]=m[2]),"y-scale"===i&&(g[0]=m[0],g[2]=m[2]),"z-scale"===i&&(g[0]=m[0],g[1]=m[1]),g}M(){this.C.forEach((i=>{if(i.m){const{coordinate:g,translation:m,rotation:_,scale:b}=i.m;i.setCoordinates(g),i.setTRS(m,_,b)}}))}getScale(){return this.l}getTranslation(){return 1===this.C.length&&this.C[0].getTranslation()||yJ}getRotation(){return this.P}O(){return this.C[0]?this.C[0].getLayer():null}getCoordinates(){let i=0,g=0,m=0;const _=this.C.length;if(!_)return null;for(let b=0;b<_;b++){const _=this.C[b].getCenter();i+=_.x,g+=_.y,m+=_.z||0}i/=_,g/=_,m/=_;const b=new pl(i,g,m);for(let i=0;i<_;i++)this.C[i].setTransformOrigin(b);return b}u(i){const g=i.target,m=this.C.indexOf(g);m>-1&&(delete g.m,this.C.splice(m,1))}getTargets(){return this.C}o(){let i=0;const g=this.C.length;for(let m=0;m<g;m++)i+=this.C[m].getPointZ();return i/=g,i}F(){for(let i=0;i<this.C.length;i++)if(this.C[i].isVisible())return!0;return!1}}const _J=[5,6,7,8,9,10],vJ=[5,7,8,9,10],xJ=[2,4,11],bJ=[1,3,12],wJ=[12,16],TJ=[1,2,3,4],SJ=[1,2,3,4,12],MJ=[],CJ=[],PJ=[],IJ=[],kJ=[],OJ=[],EJ=[];class IA extends(Za(hl(Ya))){constructor(i={}){super(i),this.options=i,this.mouseAction="moving",this.U=this.options.mode||"translate",this.V=!0,this.TransformHelper=new k,this.S=new G,this.helperScene=new wP.Scene([]),this.addToMapCount=0,this.k()}setCoordinates(i){this.T.setCoordinates(i),this.transform(this.T)}enable(){return this.V=!0,this.layerRenderer&&this.layerRenderer.setToRedraw(),this}disable(){return this.V=!1,this.layerRenderer&&this.layerRenderer.setToRedraw(),this.map&&this.map.resetCursor(),this}setMode(i){this.U=i,this._(),this.layerRenderer&&this.layerRenderer.setToRedraw(),this.fire("modechange",{mode:i,type:"modechange"})}getMode(){return this.U}isEnable(){return this.V}H(i){_J.indexOf(i)>-1?this.U="translate":xJ.indexOf(i)>-1?this.U="rotation":bJ.indexOf(i)>-1?this.U="scaling":"xyzScale"!==this.U&&(this.U="translate")}J(){return this.U}addTo(i){if(this.map)return this.N(),void console.warn("transform control has been added to a map, it suggest remove from the map before");this.addToMapCount++,this.map=i;const g=i.getLayers((i=>i instanceof GroupGLLayer))[0];this.R.addTo(g||this.map),this.container=i.getContainer(),i.on("dom:mousemove",this.K,this),i.on("dom:mousedown",this.G,this),i.on("dom:mouseup",this.j,this),i.on("zooming moving dragrotating",this.Z,this),this.Y()}k(){this.R=new Ot(`${Qn}_transformcontrol`),this.T=new lt([0,0],{symbol:{url:"cube",modelHeight:1,uniforms:{polygonOpacity:.01}}}).addTo(this.R)}remove(){this.map&&(this.N(),this.TransformHelper.dispose(),this.R.remove(),this.layerRenderer&&this.layerRenderer.setToRedraw(),delete this.T,delete this.R,delete this.map,delete this.layer,delete this.layerRenderer,delete this.container,delete this.S)}N(){this.container&&this.map&&(this.map.off("dom:mousemove",this.K,this),this.map.off("dom:mousedown",this.G,this),this.map.off("dom:mouseup",this.j,this),this.map.off("zooming moving dragrotating",this.Z,this),this.layer&&this.layer.off("renderend",this.render,this))}K(i){if(this.W()){if(this.currentMousePosition={x:i.containerPoint.x,y:i.containerPoint.y},"moving"===this.mouseAction){const i=this.q();this.currentPickingObject=this.X(this.currentMousePosition,i,"meshes"),this.currentPickingObject&&null!=this.currentPickingObject.pickingId?(this.H(this.currentPickingObject.pickingId),this.$(6===this.currentPickingObject.pickingId)):(this.$(!1),this.H()),this.AA()}this.eA(this.currentMousePosition)}}G(i){if(!this.W()||0!==i.domEvent.button)return;const g=this.q();this.currentMousePosition={x:i.containerPoint.x,y:i.containerPoint.y},this.tA=!0,this.currentPickingObject=this.X(this.currentMousePosition,g,"meshes"),this.firstDownPoint=this.X(this.currentMousePosition,g,"meshes"),this.currentPickingObject&&null!=this.currentPickingObject.meshId?(this.mouseAction="transform",this.sA(this.currentPickingObject.pickingId),this.map.config("zoomable",!1),this.map.config("draggable",!1),this.layerRenderer&&this.layerRenderer.setToRedraw()):(this.mouseAction="pan",this.map.config("zoomable",!0),this.map.config("draggable",!0),this._()),this.lastMousePosition=this.currentMousePosition,this.lastPickingObject=this.currentPickingObject,this.lastPickingMesh=g[this.currentPickingObject.meshId]}j(){"transform"===this.mouseAction&&(this.firstDownPoint=null,this._(),this.tA=!0,this.fire("transformend",{action:this.iA,type:"transformend",transformtarget:this.S.getTargets()})),this.mouseAction="moving","xyzScale"!==this.U&&(this.U="translate"),this.map.config("zoomable",!0),this.map.config("draggable",!0),this.layerRenderer&&this.layerRenderer.setToRedraw()}Z(){const i=this.TransformHelper.planeHelper.getMeshes()[0][0],g=this.map.getBearing();i.rotation[2]=-g,this.nA()}nA(){this.W()&&(this.TransformHelper.updateMatrix(this.map,this.S,0,0,[0,0,0]),this.tA=!0)}picked(i){if(!this.layerRenderer)return!1;const g=this.q();let m=i;i instanceof un||(m=this.map.coordinateToContainerPoint(new pl(i)));const _=this.X(m,g,"picked");return!(!_||null===_.meshId)}_(){const i=this.TransformHelper.getMeshes("scaling").scaling[0][0],g=340/177;i.scaling=[.6*g,.6*g,.6*g],this.layerRenderer&&(this.oA(i),this.IA())}IA(){this.TransformHelper._meshes.translate.forEach((i=>{for(let g=0;g<i.length;g++){const m=i[g];TJ.indexOf(m.getUniform("uPickingId"))>-1&&m.material.set("color",m.originColor)}}))}oA(i){const g=this.S.getCoordinates(),m=this.map.coordinateToPointAtRes(g,this.map.getGLRes()),_=[m.x,m.y,0],b=KQ(this.map,this.S.getTranslation());XA(_,_,b);const T=WA([],i.translate),P=i.scaling;let I=JQ(this.S,this.map);I=qA([],I,I,I),$A(T,T,I),$A(I,I,P),XA(T,T,_),OA(i.localTransform,[0,0,0,1],T,I),this.q().forEach((i=>{const g=i.getUniform("uPickingId");if(1===g||3===g||2===g||4===g){const g=WA([],i.translate),m=170/177;i.scaling=[m,m,m];const b=i.scaling,T=i.rotation;let P=JQ(this.S,this.map);P=qA([],P,P,P),$A(g,g,P),$A(P,P,b),XA(g,g,_);const I=o_([],T[0],T[1],T[2]);OA(i.localTransform,I,g,P)}}))}gA(i){const g=this.map.containerPointToCoordinate(i),m=this.map.coordinateToPointAtRes(g,this.map.getGLRes());return{point:[m.x,m.y]}}eA(i){if("transform"===this.mouseAction){const i=this.J(),g=KQ(this.map,this.S.getTranslation()),m=this.S.o();let _=null,b=null;if(g[2]+m<.01&&"z-translate"!==this.iA)_=this.gA(this.currentMousePosition),b=this.gA(this.lastMousePosition);else{const i=this.TransformHelper.planeHelper.getMeshes()[0];if(_=this.X(this.currentMousePosition,i,"plane"),b=this.X(this.lastMousePosition,i,"plane"),!_||null===_.meshId||!b||null===b.meshId)return}const T=[0,0,0],P=[0,0,0];let I=0,H=0,W=0;if("translate"===i){if("xy-translate"===this.iA){const i=_.point[1]-b.point[1];T[0]=_.point[0]-b.point[0],T[1]=i}else if("x-translate"===this.iA){T[0]=_.point[0]-b.point[0]}else if("y-translate"===this.iA){T[1]=_.point[1]-b.point[1]}else if("z-translate"===this.iA){let i=0;if(this.rA()){const g=this.map.getGLRes(),m=this.map._pointAtResToContainerPoint(new un(b.point[0],b.point[1]),g),T=this.map._pointAtResToContainerPoint(new un(_.point[0],_.point[1]),g),P=Z_(z_(IJ,_.point[0]-b.point[0],_.point[1]-b.point[1]));i=T.y<m.y?P:-P}else i=_.point[2]-b.point[2];T[2]=i}}else if("rotation"===i)H=this.aA(_.point,b.point),this.TransformHelper.I(H>=0),P[2]+=H;else if("scaling"===i||"xyzScale"===i){const i=this.CA(),g=Z_(z_(IJ,this.firstDownPoint.point[0]-i[0],this.firstDownPoint.point[1]-i[1])),m=Z_(z_(IJ,b.point[0]-i[0],b.point[1]-i[1]));I=this.hA(_.point,b.point,i,m),W=this.hA(_.point,b.point,i,g)}this.TransformHelper.updateMatrix(this.map,this.S,H,W,T),this.S.p(this.iA,T,P,I,.01,this.map,this)}this.lastMousePosition=i,this.lastPickingObject=this.currentPickingObject;const g=this.q();this.lastPickingMesh=g[this.currentPickingObject.meshId]}hA(i,g,m,_,b){const T=(Z_(z_(IJ,i[0]-m[0],i[1]-m[1]))-Z_(z_(IJ,g[0]-m[0],g[1]-m[1])))/_;return b?(b[0]-.01)*T:T}CA(){const i=this.map,g=this.S.getCoordinates(),m=i.coordinateToPointAtRes(g,i.getGLRes()),_=qA(kJ,m.x,m.y,0);return XA(_,_,KQ(i,this.S.getTranslation())),_}$(i){const g=this.TransformHelper.planeHelper.getMeshes()[0][0],m=CA(PJ,g.localTransform),_=PA(CJ,g.localTransform);let b=o_(MJ,0,0,0);const T=this.map.getBearing();i&&!this.rA()?(b=o_(MJ,90,0,-T),0===g.rotation[0]&&(this.tA=!0),qA(g.rotation,90,0,-T)):(90===g.rotation[0]&&(this.tA=!0),qA(g.rotation,0,0,-T)),OA(g.localTransform,b,m,_)}rA(){if(this.map.getPitch())return!1;const i=this.map.cameraPosition,g=this.map.coordinateToPointAtRes(this.map.getCenter(),this.map.getGLRes());qA(g,g.x,g.y,0);const m=this.S.getCoordinates(),_=this.map.coordinateToPointAtRes(m,this.map.getGLRes()),b=KQ(this.map,this.S.getTranslation()),T=qA(PJ,_.x,_.y,0);return ay(ZA([],i,XA(T,T,b)),ZA([],i,g))<1/180*Math.PI}AA(){const i=this.q();if(this.currentPickingObject&&null!=this.currentPickingObject.meshId){this.wA(),this.lastPickingObject&&null!=this.lastPickingObject.meshId&&this.lastPickingObject.meshId!==this.currentPickingObject.meshId&&this.cA();const g=i[this.currentPickingObject.meshId];if(g&&wJ.indexOf(this.currentPickingObject.pickingId)<0)if(this.currentPickingObject.pickingId>100)this.QA(g);else{g.material.set("color",[g.originColor[0],g.originColor[1],g.originColor[2],.8]),this.fA(g,.5)}this.layerRenderer.setToRedraw()}else this.lastPickingObject&&null!=this.lastPickingObject.meshId&&(this.map.resetCursor(),this.cA(),this.layerRenderer.setToRedraw())}QA(i){const g=[1,179/255,2/255,1];i.material.set("color",g),i.properties.relatedMeshes&&i.properties.relatedMeshes.forEach((i=>{i.material.set("color",g)}))}wA(){6===this.currentPickingObject.pickingId?this.map.setCursor("ns-resize"):vJ.indexOf(this.currentPickingObject.pickingId)>-1?this.map.setCursor("move"):this.map.setCursor("pointer")}cA(){const i=this.lastPickingMesh;if(!i)return;const g=i.getUniform("uPickingId"),m=this.q();vJ.indexOf(g)>-1?m.forEach((i=>{vJ.indexOf(i.getUniform("uPickingId"))>-1&&i.material.set("color",i.originColor)})):SJ.indexOf(g)>-1?m.forEach((i=>{const g=i.getUniform("uPickingId");TJ.indexOf(g)>-1&&i.material.set("color",i.originColor)})):11===g&&m.forEach((i=>{TJ.indexOf(i.getUniform("uPickingId"))>-1&&i.material.set("color",i.originColor)})),i.material.set("color",i.originColor),i.properties.relatedMeshes&&i.properties.relatedMeshes.forEach((i=>{i.material.set("color",i.originColor)}))}fA(i,g){const m=i.getUniform("uPickingId"),_=this.q();vJ.indexOf(m)>-1?_.forEach((m=>{if(vJ.indexOf(m.getUniform("uPickingId"))>-1&&m.getUniform("uPickingId")!==i.getUniform("uPickingId")){m.material.set("color",[m.originColor[0],m.originColor[1],m.originColor[2],g])}})):"scaling"===this.U?_.forEach((i=>{const g=i.getUniform("uPickingId");if(1===g||3===g||2===g||4===g){i.material.set("color",[149/255,179/255,199/255,.8])}})):"rotation"===this.U&&_.forEach((i=>{const g=i.getUniform("uPickingId");if(1===g||3===g||2===g||4===g){const g=i.originColor;i.material.set("color",[g[0],g[1],g[2],0])}}))}reset(){this.map&&this.S&&(this.S.M(),this.TransformHelper.updateMatrix(this.map,this.S,0,0,[0,0,0]))}aA(i,g){const m=this.CA(),_=z_(OJ,g[0]-m[0],g[1]-m[1]),b=z_(EJ,i[0]-m[0],i[1]-m[1]),T=Math.atan2(_[1],_[0]);return(Math.atan2(b[1],b[0])-T)/Math.PI*180}sA(i){return this.iA=113===i||114===i?"x-scale":115===i||116===i?"z-scale":117===i||118===i?"y-scale":119===i?"xyz-scale":5===i?"xy-translate":6===i?"z-translate":7===i||9===i?"x-translate":8===i||10===i?"y-translate":11===i?"z-rotate":"scale",this.iA}transform(i){if(!i)return;if(this.layerRenderer&&this.layerRenderer.layer&&(this.layerRenderer.layer.off("renderend",this.render),this.layerRenderer.layer.off("resizeCanvas",this.lA)),!this.map)return void console.error("should add to a target first");if(this.S&&(this.S.B(),this.S.D(i)),!this.S.getTargets().length)return;this.TransformHelper.updateMatrix(this.map,this.S,0,0,[0,0,0]),this.PA(),this.tA=!0}getTransformTarget(){return this.S}u(){delete this.S}PA(){const i=this.S.O();i&&(i.off("renderend",this.render),i.off("resizeCanvas",this.lA));const g=this.map,m=i.getRenderer();this.layerRenderer=m,this.regl=m.regl,this.renderer=m.renderer,this.DA=this.layerRenderer.getFBORayPicking(),this.uA={projViewMatrix:g.projViewMatrix,projMatrix:g.projMatrix,viewMatrix:g.viewMatrix,pointSize:1},i.on("renderend",this.render,this),i.on("resizeCanvas",this.lA,this),m.setToRedraw()}lA(){this.DA.clear(),this.tA=!0}X(i,g,m){const _=this.map;if(!(_&&this.DA&&this.layerRenderer&&this.layerRenderer.canvas))return null;const b=_.getDevicePixelRatio(),T=i.x*b,P=i.y*b,I=this.uA;return(this.tA||this.layerRenderer.canvas.gl&&this.layerRenderer.canvas.gl.wrap||!this.mA||this.mA!==m)&&(this.DA.render(g,I,!0),this.mA=m,this.tA=!1),this.DA.pick(T,P,10,I,{viewMatrix:this.map.viewMatrix,projMatrix:this.map.projMatrix,returnPoint:!0})}Y(){const i=this.map.getDevicePixelRatio();this.bA=new wP.MeshShader({vert:"attribute vec3 aPosition;\n\nuniform mat4 projViewModelMatrix;\n\n\n\nvoid main()\n\n{\n\n    gl_Position = projViewModelMatrix * vec4(aPosition, 1.0);\n\n\n\n}\n\n",frag:"precision mediump float;\n\nuniform vec4 color;\n\n\n\nvoid main() {\n\n    gl_FragColor = color;\n\n}\n\n",uniforms:["color",{name:"projViewModelMatrix",type:"function",fn:function(i,g){return _A([],g.projViewMatrix,g.modelMatrix)}}],extraCommandProps:{viewport:{x:0,y:0,width:()=>this.map?this.map.width*i:1,height:()=>this.map?this.map.height*i:1},depth:{enable:!0,func:"always",mask:!0,range:[0,0]},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}},defines:{}})}render(){if(!this.W())return;const i=this.q();this.helperScene.setMeshes(i);const g=this.layerRenderer.getFrameContext();if(g&&g.renderTarget&&this.layerRenderer.getFrameTimestamp()!==g.timestamp)return;this.nA(),this.bA.filter=g&&g.sceneFilter;this.renderer.render(this.bA,this.uA,this.helperScene,g&&g.renderTarget&&g.renderTarget.fbo)}q(){let i=[];const g=this.TransformHelper.getMeshes(this.U);for(const m in g){if("translate"===m)continue;const _=g[m];for(let g=0;g<_.length;g++)i=i.concat(_[g])}const m=g.translate;if(m)for(let g=0;g<m.length;g++)i=i.concat(m[g]);return i}W(){const i=this.layerRenderer,g=i&&i.layer;return i&&this.S&&g&&g.isVisible()&&this.S.F()&&this.regl&&this.V}}IA.mergeOptions({scaleStrength:2}),"undefined"!=typeof console&&console.log("@maptalks/transform-control v0.106.1");
/*!
   * @maptalks/video-layer v0.103.0
   * LICENSE : UNLICENSED
   * (c) 2016-2025 maptalks.org
   */
/*!
  * Contains code from THREE.js
  * MIT License
  * https://github.com/mrdoob/three.js
  */
for(var RJ=[],LJ=0;LJ<6;LJ++)RJ[LJ]=[];var DJ=[];function FJ(i,g,m){var _,b,T,P,I,H,W,q,$,ye,Re,Be,Ge,je,Xe,Ze,Ye;b=(_=i)[0],T=_[1],P=_[2],W=_[5],q=_[6],Re=_[9],Be=_[10],Xe=_[13],Ze=_[14],NJ(RJ[0],(I=_[3])-b,($=_[7])-(H=_[4]),(Ge=_[11])-(ye=_[8]),(Ye=_[15])-(je=_[12])),NJ(RJ[1],I+b,$+H,Ge+ye,Ye+je),NJ(RJ[2],I+T,$+W,Ge+Re,Ye+Xe),NJ(RJ[3],I-T,$-W,Ge-Re,Ye-Xe),NJ(RJ[4],I-P,$-q,Ge-Be,Ye-Ze),NJ(RJ[5],I+P,$+q,Ge+Be,Ye+Ze);for(var Qe=0;Qe<6;Qe++){var Je=RJ[Qe];if(DJ[0]=Je[0]>0?g[1][0]:g[0][0],DJ[1]=Je[1]>0?g[1][1]:g[0][1],DJ[2]=Je[2]>0?g[1][2]:g[0][2],HJ(Je,DJ)<0)return!1}return!0}function NJ(i,g,m,_,b){var T=1/Math.sqrt(g*g+m*m+_*_);return i[0]=g*T,i[1]=m*T,i[2]=_*T,i[3]=b*T,i}function HJ(i,g){return i[0]*g[0]+i[1]*g[1]+i[2]*g[2]+i[3]}const BJ={vert:"\n    attribute vec3 aPosition;\n    attribute vec2 aTexCoord;\n    uniform mat4 projViewModelMatrix;\n    uniform mat4 positionMatrix;\n    uniform mat4 modelMatrix;\n    varying vec2 vTexCoords;\n    #include <get_output>\n    void main()\n    {\n        mat4 localPositionMatrix = getPositionMatrix();\n        vec4 localPosition = getPosition(aPosition);\n        gl_Position = projViewModelMatrix * localPositionMatrix * localPosition;\n        vTexCoords = aTexCoord;\n    }\n",frag:"\n    precision mediump float;\n    uniform sampler2D videoTexture;\n    uniform float opacity;\n\n    varying vec2 vTexCoords;\n    void main() {\n        vec4 color = texture2D(videoTexture, vTexCoords);\n        gl_FragColor = color * opacity;\n    }\n",uniforms:[{name:"projViewModelMatrix",type:"function",fn:(i,g)=>_A([],g.projViewMatrix,g.modelMatrix)},"texture","opacity"],positionAttribute:"POSITION",extraCommandProps:{depth:{enable:!0,func:"always"},cull:{enable:!1,face:"back"},frontFace:"cw",blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"},equation:"add"}}},zJ=[1,0,3,3,2,1];function VJ(i,g,m){if(!i)return null;const _=i.coordinateToPointAtRes(g,i.getGLRes());return[_.x,_.y,m]}class x extends(Za(hl(Ya))){constructor(i,g){super(g),this.setCoordinates(i),this._createVideo()}setCoordinates(i){this._coordinates=i}getCoordinates(){return this._coordinates}setVideo(i){this._videoState="stop",this.options.url=i,delete this.options.elementId,this._createVideo()}setElementId(i){this._videoState="stop",this.options.elementId=i,delete this.options.url,this._createVideo()}_createVideo(){this._videoState="stop";const i=this.options.url;let g=document.getElementById(this.options.elementId);if(i&&(g=document.createElement("video"),g.src=i),!g)throw new Error("there is no element or url setting for video mask");g.autoplay=!0,g.loop=!0,g.muted=!0,g.play(),g.addEventListener("playing",(()=>{this._videoState="playing",this.fire("playing",{state:this._videoState,url:i})})),g.addEventListener("pause",(()=>{this._videoState="pause",this.fire("pause",{state:this._videoState,url:i})})),g.addEventListener("error",(()=>{throw this._videoState="pause",this.fire("error",{state:this._videoState,url:i}),new Error("video resource load error")})),this.video=g}getVideo(){return this.video}_setVideoId(i){this._videoId=i}_getVideoId(){return this._videoId}addTo(i){if(this._layer)throw new Error("VideoSurface cannot be added to two or more layers at the same time.");return i.addSurfaces(this),this}show(){return this.options.visible=!0,this}hide(){return this.options.visible=!1,this}isVisible(){return this.options.visible}play(){this.video&&this.video.play()}pause(){this.video&&this.video.pause()}setAudio(i){this.video.muted=i}setOpacity(i){this.options.opacity=i}getOpacity(){return this.options.opacity}remove(){delete this.video;const i=this.getLayer();i&&i.removeVideoSurfaces(this),this.endEdit()}getLayer(){return this._layer}_canDrawing(){return"playing"===this._videoState}startEdit(){const i=this.getLayer();if(!i)return void console.warn("videosurface should be added to a map before edit");const g=i.getMap();if(!g)return void console.warn("videosurface should be added to a map before edit");if(this._clearEditHelper(),!this._editHelpLayer){const m=i.getId();this._editHelpLayer=new nd(`internal_${m}_edit`).addTo(g)}const m=this.getCoordinates();this._editHelpPolygon=new gf(m,{symbol:{lineColor:"#34495e",lineWidth:2,polygonFill:"rgb(135,196,240)",polygonOpacity:.1}}).addTo(this._editHelpLayer),this._editHelpPolygon.startEdit({newVertexHandleSymbol:{polygonFill:"rgba(0, 0, 0, 0)",polygonOpacity:0,markerType:"ellipse",markerWidth:1,markerHeight:1}}),this._editHelpPolygon.on("shapechange",(g=>{const m=g.target.getCoordinates()[0].slice(0,4).map((i=>[i.x,i.y,0]));this.setCoordinates(m),i.getRenderer()._updateCoordinates(this)}),this)}endEdit(){this._editHelpLayer&&(this._editHelpPolygon.endEdit(),this._editHelpPolygon.remove(),this._editHelpLayer.remove()),delete this._editHelpLayer,delete this._editHelpPolygon}_clearEditHelper(){this._editHelpLayer&&this._editHelpLayer.clear(),delete this._editHelpPolygon}}x.mergeOptions({opacity:1,visible:!0});class w extends Fu{constructor(i,g,m){!g||Array.isArray(g)||g instanceof x||(m=g,g=null),super(i,m),this._videoSurfaceMap={},this.videoId=0,this._videoSurfaceMap={},this.videoId=0,g&&this.addSurfaces(g)}addSurfaces(i){if(i)if(Array.isArray(i))i.forEach((i=>{this.addMarker(i)}));else{i._layer=this,this._videoSurfaceMap[this.videoId]=i,i._setVideoId(this.videoId);const g=this.getRenderer();g?g._getRegl()&&g._createScene(i):this.on("renderercreate",(g=>{g.renderer._getRegl()&&g.renderer._createScene(i)})),this.videoId++}}showTopAlways(i){this.options.showTopAlways=i;const g=this.getRenderer();g&&g._updateShader()}setDoubleSide(i){this.options.doubleSide=i;const g=this.getRenderer();g&&g._updateShader()}getVideoSurfaces(){const i=[];for(const g in this._videoSurfaceMap)i.push(this._videoSurfaceMap[g]);return i}removeVideoSurfaces(i){if(Array.isArray(i))i.forEach((i=>{this.removeVideoSurfaces(i)}));else{const g=i._getVideoId(),m=this.getRenderer();m&&m._deleteScene(g),delete this._videoSurfaceMap[g]}}remove(){this.clear(),super.remove()}clear(){const i=this.getVideoSurfaces();for(let g=0;g<i.length;g++)i[g].remove()}}w.mergeOptions({renderer:"gl",doubleBuffer:!1,glOptions:null,markerEvents:!0,forceRenderOnZooming:!0,forceRenderOnMoving:!0,forceRenderOnRotating:!0,showTopAlways:!0,doubleSide:!0}),w.registerJSONType("VideoLayer"),w.registerRenderer("gl",class y extends Om.CanvasRenderer{constructor(i){super(i),this._scenes={}}draw(i,g){this.prepareCanvas(),this._renderScene(g)}drawOnInteracting(i,g,m){this._renderScene(m)}needToRedraw(){return!0}hitDetect(){return!1}createContext(){if(this.canvas.gl&&this.canvas.gl.wrap)this.gl=this.canvas.gl.wrap(),this.regl=this.canvas.gl.regl;else{const i=this.layer.options.glOptions||{alpha:!0,depth:!0,stencil:!0};this.glOptions=i,this.gl=this.gl||this._createGLContext(this.canvas,i),this.regl=Wm({gl:this.gl,extensions:["ANGLE_instanced_arrays","OES_texture_float","OES_texture_half_float","OES_texture_float_linear","OES_texture_half_float_linear","EXT_shader_texture_lod","OES_element_index_uint","OES_standard_derivatives","WEBGL_depth_texture"],optionalExtensions:this.layer.options.glExtensions||[]})}this._initShader(),this._initRenderer();const i=this.layer.getVideoSurfaces();for(let g=0;g<i.length;g++)this._createScene(i[g])}_createGLContext(i,g){const m=["webgl","experimental-webgl"];let _=null;for(let b=0;b<m.length;++b){try{_=i.getContext(m[b],g)}catch(i){}if(_)break}return _}_initRenderer(){const i=this.layer.getMap(),g=new wP.Renderer(this.regl);this.renderer=g,this._uniforms={projMatrix:i.projMatrix,projViewMatrix:i.projViewMatrix,viewMatrix:i.viewMatrix,halton:[.2107,-.0202],uHalton:[.2107,-.0202],uCameraPosition:i.cameraPosition,cameraPosition:i.cameraPosition,globalTexSize:[i.width,i.height]}}_getRegl(){return this.regl}_initShader(){this.viewport={x:0,y:0,width:()=>this.canvas?this.canvas.width:1,height:()=>this.canvas?this.canvas.height:1},this._updateShader()}_updateShader(){this._shader&&this._shader.dispose(),this.layer.options.showTopAlways?(BJ.extraCommandProps.depth.mask=!1,BJ.extraCommandProps.depth.range=[0,0]):(delete BJ.extraCommandProps.depth.mask,delete BJ.extraCommandProps.depth.range),BJ.extraCommandProps.cull.enable=!this.layer.options.doubleSide,this._shader=new wP.MeshShader(BJ)}_createScene(i){const g=this.regl.texture(),m=new wP.Material({videoTexture:g,opacity:1}),_=i.getCoordinates(),{worldCenter:b,points:T}=this._transformCoordToWorld(_),P=this._createGeometry(T),I=new wP.Mesh(P,m);this._updateMatrix(I,b);const H=new wP.Scene(I),W=i._getVideoId();this._scenes[W]=H}_updateCoordinates(i){const g=i._getVideoId(),m=this._scenes[g].getMeshes()[0],_=i.getCoordinates();m.geometry.dispose();const{worldCenter:b,points:T}=this._transformCoordToWorld(_),P=this._createGeometry(T);m.geometry=P,this._updateMatrix(m,b)}_renderScene(i){const g=this.layer.getVideoSurfaces().filter((i=>i.isVisible()));if(!g.length)return;const m=this._createSceneInFrustum(g);if(!m)return;let _=null;i&&(_=i.renderTarget&&i.renderTarget.fbo),this.renderer.render(this._shader,this._uniforms,m,_)}_createGeometry(i){return new wP.Geometry({POSITION:i,TEXCOORD:[0,0,1,0,1,1,0,1]},zJ,0,{primitive:"triangles",positionAttribute:"POSITION",uv0Attribute:"TEXCOORD",normalAttribute:"NORMAL",positionSize:3})}_transformCoordToWorld(i){let g=[];const m=this.getMap(),_=new gf(i).getCenter(),b=VJ(m,_,0);return this._worldCenter=b,m&&i.forEach((i=>{const _=new pl(i[0],i[1]),T=m.altitudeToPoint(i[2]||0,m.getGLRes()),P=VJ(m,_,T);P[0]=P[0]-b[0],P[1]=P[1]-b[1],g=g.concat(P)})),{worldCenter:b,points:g}}_createSceneInFrustum(i){const g=[],m=this.layer.getMap();for(let _=0;_<i.length;_++){const b=i[_],T=this._scenes[b._getVideoId()];if(!T)continue;const P=T.getMeshes();for(let i=0;i<P.length;i++){const _=P[i],T=_.getMaterial(),I=T.get("videoTexture");I&&b._canDrawing()&&(I(b.video),T.set("opacity",b.getOpacity())),FJ(m.projViewMatrix,_.getBoundingBox())&&g.push(_)}}return g.length?new wP.Scene(g):null}_updateMatrix(i,g){OA(i.localTransform,o_([],0,0,0),g,[1,1,1])}remove(){this._shader&&this._shader.dispose(),super.remove()}_deleteScene(i){const g=this._scenes[i];g&&g.getMeshes().forEach((i=>{i.geometry.dispose(),i.material&&i.material.dispose(),i.dispose()}))}}),"undefined"!=typeof console&&console.log("@maptalks/video-layer v0.103.0"),"undefined"!=typeof window&&(window.maptalksgl=window.maptalksgl||{},window.maptalksgl.transcoders=window.maptalksgl.transcoders||rx),i.Ajax=ri,i.ArcConnectorLine=Jf,i.ArcCurve=Vf,i.Area3DTool=class Area3DTool extends Measure3DTool{_addHelperLayer(){super._addHelperLayer(),this._helperLayer=new nd(Qn+"_area3dtool").addTo(this._map),this._markerLayer=new nd(Qn+"_area3dtool_marker").addTo(this._map)}_drawVertexMarker(){const i=this._getPolygonCoordinates(this._drawCoordinates);this._helperGeometry.setCoordinates(i),this._polygon.setCoordinates(i);const g=this._markerLayer.getGeometries(),m=this._helperLayer.getGeometries().length;for(let i=0;i<g.length;i++){const _=g[i].getId();_!=="label"+m&&_.indexOf(`${m}_`)>-1&&g[i].remove()}for(let i=0;i<this._drawCoordinates.length;i++)new yf(this._drawCoordinates[i],{id:m+"_"+i,symbol:this.options.vertexSymbol}).addTo(this._markerLayer);this._drawLabel()}_getPolygonCoordinates(i){const g=i.map((i=>i));return i.length>2&&g.push(i[0]),g}_drawLabel(){const i=this.getMeasureResult(),g=(("zh-CN"===this.options.language?0:1)?"area: ":"面积: ")+this._getUnitContent(i),m=this._drawCoordinates[this._drawCoordinates.length-1],_=this._helperLayer.getGeometries().length,b=Po.extend({id:"label"+_},this.options.labelSymbol);this._label?(this._label.setContent(g),this._label.setCoordinates(m)):this._label=new Zf(g,m,b).addTo(this._markerLayer)}_getUnitContent(i){let g;g="zh-CN"===this.options.language?[" 平方米"," 平方公里"," 平方英尺"," 平方英里"]:[" sq.m"," sq.km"," sq.ft"," sq.mi"];let m="";if(this.options.metric&&(this._measure=i<1e6?i.toFixed(2):(i/1e6).toFixed(2),this._units=i<1e6?g[0]:g[1]),this.options.imperial){m.length>0&&(m+="\n");const _=27878400;this._measure=(i*=3.2808399)<_?i.toFixed(2):(i/_).toFixed(2),this._units=i<_?g[2]:g[3]}return m+=this._measure+this._units,m}_addHelperGeometry(i){this._helperGeometry||(this._helperGeometry=new vf([i],{symbol:this.options.symbol}).addTo(this._helperLayer),this._polygon=new gf([i])),this._drawVertexMarker(),this._first=!0}getMeasureResult(){return this._polygon.getArea()}},i.AreaTool=Dd,i.B3DMLoader=ns,i.BBOXUtil=Yo,i.BillBoardPainter=BillBoardPainter,i.BillBoardPlugin=eG,i.BoxInsideClipMask=class BoxInsideClipper extends BoxClipMask{constructor(i,g){super(i,g),this._mode="clip-inside"}},i.BoxOutsideClipMask=class BoxOutsideClipper extends BoxClipMask{constructor(i,g){super(i,g),this._mode="clip-outside"}},i.Browser=$t,i.CMPTLoader=gs,i.COLOR_PROPERTIES=rr,i.CRS=gl,i.Canvas=Va,i.CanvasCompatible=Ck,i.CanvasLayer=Ig,i.CanvasTileLayer=Jp,i.Circle=Df,i.Class=Ya,i.ClipInsideMask=class ClipInsideMask extends ClipMask{constructor(i,g){super(i,g),this._mode="clip-inside"}},i.ClipOutsideMask=ClipOutsideMask,i.CollisionIndex=va,i.ColorMask=class ColorMask extends Mask{constructor(i,g){super(i,g),this._mode="color"}setHeightRange(i){this.options.heightRange=i,this._fireEvent("heightrangechange")}_createMesh(i){const g=this._createGeometry(i),m=new Mesh(g);return this._setDefines(m),this._setLocalTransform(m),m}_updateUniforms(i,g,m){const _=this._getMaskMode();i.setUniform("maskMode",_);const b=this._getMaskColor();if(i.setUniform("maskColor",b),yI(g)){const _=this._getHeightRange();_[0]=(_[0]-m)*g,_[1]=(_[1]-m)*g,i.setUniform("heightRange",_)}}_setDefines(i){const g=i.getDefines();g.HAS_MASK_COLOR=1,i.setDefines(g)}_getHeightRange(){const i=[0,0];return this.options.heightRange&&(i[0]=this._altitudeToPoint(this.options.heightRange[0]),i[1]=this._altitudeToPoint(this.options.heightRange[1])),i}},i.ConnectorLine=Qf,i.ContextUtil=Jk,i.Coordinate=pl,i.CubicBezierCurve=Uf,i.Curve=zf,i.DEFAULT_TEXT_SIZE=14,i.Distance3DTool=class Distance3DTool extends Measure3DTool{_addHelperLayer(){super._addHelperLayer(),this._helperLayer=new nd(Qn+"_distance3dtool").addTo(this._map),this._markerLayer=new nd(Qn+"_distance3dtool_marker").addTo(this._map)}_drawVertexMarker(){this._helperGeometry.setCoordinates(this._drawCoordinates);const i=this._markerLayer.getGeometries(),g=this._helperLayer.getGeometries().length;for(let m=0;m<i.length;m++){const _=i[m].getId();_!=="label"+g&&_.indexOf(`${g}_`)>-1&&i[m].remove()}for(let i=0;i<this._drawCoordinates.length;i++)new yf(this._drawCoordinates[i],{id:g+"_"+i,symbol:this.options.vertexSymbol}).addTo(this._markerLayer);this._drawLabel()}_drawLabel(){const i=this.getMeasureResult(),g=(("zh-CN"===this.options.language?0:1)?"distance: ":"距离: ")+this._getUnitContent(i),m=this._drawCoordinates[this._drawCoordinates.length-1],_=this._helperLayer.getGeometries().length,b=Po.extend({id:"label"+_},this.options.labelSymbol);this._label?(this._label.setContent(g),this._label.setCoordinates(m)):this._label=new Zf(g,m,b).addTo(this._markerLayer)}_getUnitContent(i){let g;g="zh-CN"===this.options.language?[" 米"," 公里"," 英尺"," 英里"]:[" m"," km"," feet"," mile"];let m="";return this.options.metric&&(this._measure=i<1e3?i.toFixed(1):(i/1e3).toFixed(2),this._units=i<1e3?g[0]:g[1]),this.options.imperial&&(m.length>0&&(m+="\n"),this._measure=(i*=3.2808399)<5280?i.toFixed(1):(i/5280).toFixed(2),this._units=i<5280?g[2]:g[3]),m+=this._measure+this._units,m}_addHelperGeometry(i){this._helperGeometry||(this._helperGeometry=new vf([i],{symbol:this.options.symbol}).addTo(this._helperLayer)),this._drawVertexMarker(),this._first=!0}getMeasureResult(){return this._helperGeometry.getLength()}},i.DistanceTool=Ld,i.DomUtil=ni,i.DragHandler=dl,i.DrawTool=ad,i.DrawToolLayer=nd,i.ElevateMask=class ElevateMask extends FlatMask{constructor(i,g){super(i,g),this.setElevation(g.elevation),this._mode="elevate"}setElevation(i){this.options.elevation=i,this.setFlatheight(this.options.elevation)}},i.Ellipse=Nf,i.Eventable=Za,i.Extent=Pl,i.ExtrudePolygonLayer=ExtrudePolygonLayer,i.FillPainter=FillPainter,i.FillPlugin=zU,i.FilterUtil=Bj,i.FlatInsideMask=class FlatInsideMask extends FlatMask{constructor(i,g){super(i,g),this._mode="flat-inside"}},i.FlatOutsideMask=class FlatInsideMask extends FlatMask{constructor(i,g){super(i,g),this._mode="flat-outside"}},i.GEOJSON_TYPES=Kn,i.GEOMETRY_COLLECTION_TYPES=Jn,i.GLContext=Qv,i.GLTFGeometry=class Rt extends lt{_calSpatialScale(i){const g=this.getMap(),m=g.getGLRes(),_=g.distanceToPointAtRes(100,100,m,this.getCenter()),b=g.altitudeToPoint(100,m);return i[0]*=_.x/100,i[1]*=_.y/100,i[2]*=b/100,i}},i.GLTFLayer=Ot,i.GLTFLineString=Nt,i.GLTFMarker=lt,i.GLTFMercatorGeometry=class Ct extends lt{_calSpatialScale(i){const g=this.getMap(),m=g.getGLRes(),_=this.getCoordinates(),b=g.coordToPointAtRes(_,m,NQ),T=xh.EPSG3857.project(_,DQ)._add(1,1),P=xh.EPSG3857.unproject(T,FQ),I=g.coordToPointAtRes(P,m,HQ),H=I.x-b.x,W=I.y-b.y,q=g.altitudeToPoint(100,m);return i[0]*=H,i[1]*=W,i[2]*=q/100,i}},i.GLTFPhongPlugin=YU,i.GLTFStandardPlugin=QU,i.Geo3DTilesLayer=Vo,i.Geo3DTilesUtil=pq,i.Geo3DTransform=Kq,i.GeoJSON=Lf,i.GeoJSONVectorTileLayer=GeoJSONVectorTileLayer,i.Geometry=gu,i.GeometryCollection=bf,i.GlobalConfig=T,i.GlobalEvent=Ja,i.GroundPainter=GroundPainter,i.GroupGLLayer=GroupGLLayer,i.GroupTileLayer=Xp,i.Handler=$a,i.Handlerable=hl,i.HeatmapPlugin=JU,i.HeatmapProcess=HeatmapProcess,i.Height3DTool=class Height3DTool extends Measure3DTool{_addHelperLayer(){super._addHelperLayer(),this._helperLayer=new nd(Qn+"_height3dtool").addTo(this._map),this._markerLayer=new nd(Qn+"_height3dtool_marker").addTo(this._map)}_msOnDrawVertex(i){super._msOnDrawVertex(i),this._drawCoordinates.length>1&&(this._drawEnd(),this.disable())}_drawVertexMarker(){const i=this._markerLayer.getGeometries(),g=this._helperLayer.getGeometries().length;for(let m=0;m<i.length;m++){const _=i[m].getId();_!=="label"+g+"_"+m&&0===_.indexOf(`${g}_`)&&i[m].remove()}for(let i=0;i<this._drawCoordinates.length;i++)new yf(this._drawCoordinates[i],{id:g+"_"+i,symbol:this.options.vertexSymbol}).addTo(this._markerLayer);const m=this._drawCoordinates.length;if(m>1){const i=new pl([this._drawCoordinates[m-1].x,this._drawCoordinates[m-1].y,this._drawCoordinates[m-2].z]);new yf(i,{id:g+"_2",symbol:this.options.vertexSymbol}).addTo(this._markerLayer);const _=[].concat(this._drawCoordinates);_.push(i),_.push(this._drawCoordinates[0]);const b=_.map((i=>i.z));this._helperGeometry.setCoordinates(_),this._helperGeometry.setProperties({altitude:b});const T=this._map.getProjection().measureLenBetween(_[0],_[2]),P=_[1].z-_[2].z,I=Math.sqrt(Math.pow(T,2)+Math.pow(P,2));this._drawLabel(_,[I,P,T])}}_drawLabel(i,g){for(let m=0;m<i.length-1;m++){const _=i[m],b=i[m+1],T="zh-CN"===this.options.language?0:1,P=this._getUnitContent(g[m]),I=dR[T][m]+":"+P,H="label"+this._helperLayer.getGeometries().length+"_"+m,W=JSON.parse(JSON.stringify(this.options.labelSymbol));W.id=H,m<2&&(W.boxStyle.symbol.textDx*=-1);const q=1===m?_:new pl((_.x+b.x)/2,(_.y+b.y)/2,(_.z+b.z)/2),$=this._markerLayer.getGeometryById(H),ye=`${H}_marker`,Re=this._markerLayer.getGeometryById(ye);$?($.setContent(I),$.setCoordinates(q),Re.setCoordinates(q)):(new Zf(I,q,W).addTo(this._markerLayer),new yf(q,{id:ye,symbol:this.options.vertexSymbol}).addTo(this._markerLayer))}}_getUnitContent(i){let g;g="zh-CN"===this.options.language?[" 米"," 公里"," 英尺"," 英里"]:[" m"," km"," feet"," mile"];let m="";return this.options.metric&&(this._measure=i<1e3?i.toFixed(1):(i/1e3).toFixed(2),this._units=i<1e3?g[0]:g[1]),this.options.imperial&&(m.length>0&&(m+="\n"),this._measure=(i*=3.2808399)<5280?i.toFixed(1):(i/5280).toFixed(2),this._units=i<5280?g[2]:g[3]),m+=this._measure+this._units,m}_addHelperGeometry(i){this._helperGeometry||(this._helperGeometry=new vf([i],{symbol:this.options.symbol}).addTo(this._helperLayer)),this._drawVertexMarker(),this._first=!0}getMeasureResult(){return this._helperGeometry.getLength()}},i.HighlightUtil=WE,i.INTERNAL_LAYER_PREFIX=Qn,i.IconPainter=IconPainter,i.IconPlugin=GU,i.ImageLayer=yg,i.ImageMask=class ImageMask extends Mask{constructor(i,g){super(i,g),this._mode="texture"}setUrl(i){this.options.url=i;const g=this._mesh;if(g&&g.material){const i=g.material.get("maskTexture");if(i){this._createTexture(i);const g=this.getLayer();g&&g.getRenderer().setToRedraw()}}}_createMesh(i){const{geometry:g,copyGeometry:m}=this._createGeometry(i),_=new Mesh(g),b=i.texture();return this._createTexture(b),_.material=new Material({maskTexture:b}),this._setDefines(_),this._setLocalTransform(_),this._copyMesh=new Mesh(m),this._setLocalTransform(this._copyMesh),_}_updateUniforms(i){const g=this._getMaskMode();i.setUniform("maskMode",g);const m=this._getMaskColor();if(i.setUniform("maskColor",m),this._positions&&this._positions.length)for(let g=0;g<4;g++)i.setUniform("mask_position"+g,this._positions.slice(3*g,3*g+3))}_setDefines(i){const g=i.getDefines();g.HAS_TEXTURE=1,i.setDefines(g)}_createTexture(i){const g=new Image;g.src=this.options.url,g.crossOrigin="anonymous",g.onload=function(){i(g)},g.onerror=function(){console.warn("Image load error")}}getBBox(){return this._copyMesh.getBoundingBox()}},i.JSONAble=ll,i.LRUCache=Js,i.Label=Zf,i.Layer=Fu,i.LineGradientPlugin=UU,i.LinePainter=LinePainter,i.LinePlugin=VU,i.LineString=vf,i.LineStringLayer=LineStringLayer,i.LitPlugin=ZU,i.Map=Uu,i.MapGLRenderer=MapGLRenderer,i.MapGPURenderer=MapGPURenderer,i.MapTool=id,i.MapboxUtil=Ji,i.MapboxVectorTileLayer=MapboxVectorTileLayer,i.Marker=yf,i.MaskLayerMixin=WO,i.MaskRendererMixin=uO,i.Measure3DTool=Measure3DTool,i.MicroTask=Qs,i.MultiGLTFMarker=ft,i.MultiLineString=Pf,i.MultiPoint=Mf,i.MultiPolygon=If,i.NUMERICAL_PROPERTIES=nr,i.NativeLinePainter=NativeLinePainter,i.NativeLinePlugin=WU,i.NativePointPainter=NativePointPainter,i.OverlayLayer=td,i.PackUtil=Hj,i.ParticleLayer=Og,i.PhongPainter=PhongPainter,i.PhongPlugin=qU,i.Point=un,i.PointExtent=kl,i.PointLayer=PointLayer,i.PointLayerRenderer=PointLayerRenderer,i.Polygon=gf,i.PolygonLayer=PolygonLayer,i.QuadBezierCurve=Gf,i.RESOURCE_PROPERTIES=er,i.RESOURCE_SIZE_PROPERTIES=tr,i.RayCaster=RayCaster,i.Rectangle=Hf,i.ResourceProxy=ai,i.SYMBOLS_NEED_REBUILD_IN_VECTOR=Vj,i.SYMBOLS_NEED_REBUILD_IN_VT=zj,i.Sector=Bf,i.Size=ir,i.SpatialReference=uu,i.StringUtil=Sr,i.TerrainFlatMaskPainter=TerrainFlatMaskPainter,i.TerrainFlatMaskPlugin=tG,i.TextBox=Xf,i.TextMarker=qf,i.TextPainter=TextPainter,i.TextPlugin=jU,i.TileConfig=yp,i.TileLayer=Up,i.TileSystem=mp,i.TransformControl=IA,i.Transformation=Ol,i.TubePlugin=$U,i.Util=Po,i.Vector3DLayer=Vector3DLayer,i.VectorLayer=Mg,i.VectorTileLayer=VectorTileLayer,i.VectorTileLayerRenderer=VectorTileLayerRenderer,i.VideoLayer=w,i.VideoMask=class VideoMask extends Mask{constructor(i,g){super(i,g),this._mode="texture"}play(){this._video&&this._video.play()}pause(){this._video&&this._video.pause()}setAudio(i){this._video&&(this.video.muted=i)}setUrl(i){this.options.url=i,this._createVideo(i)}getState(){return this._videoState}_createMesh(i){const{geometry:g,copyGeometry:m}=this._createGeometry(i),_=new Mesh(g),b=this._createVideoTexture(i);return _.material=new Material({maskTexture:b}),this._setDefines(_),this._setLocalTransform(_),this._copyMesh=new Mesh(m),this._setLocalTransform(this._copyMesh),_}_updateUniforms(i){const g=this._getMaskMode();if(i.setUniform("maskMode",g),this._positions&&this._positions.length)for(let g=0;g<4;g++)i.setUniform("mask_position"+g,this._positions.slice(3*g,3*g+3));const m=this._getMaskColor();i.setUniform("maskColor",m)}_setDefines(i){const g=i.getDefines();g.HAS_TEXTURE=1,i.setDefines(g)}_createVideoTexture(i){this._createVideo();return i.texture()}_createVideo(){this._videoState="stop";const i=this.options.url;let g=document.getElementById(this.options.elementId);if(i&&(g=document.createElement("video"),g.src=i),!g)throw new Error("there is no element or url setting for video mask");g.autoplay=this.options.autoplay||!0,g.loop=this.options.loop||!0,g.muted=this.options.muted||!0,g.play(),g.addEventListener("playing",(()=>{this._videoState="playing"})),g.addEventListener("pause",(()=>{this._videoState="pause"})),this._video=g}_update(){const i=this._mesh;if(i&&i.material){const g=i.material.get("maskTexture");g&&this._video&&this._needUpdate()&&g(this._video)}}_needUpdate(){return"playing"===this._videoState}},i.VideoSurface=x,i.WMSTileLayer=Qp,i.WaterPlugin=KU,i.WireframePainter=WireframePainter,i.WireframePlugin=XU,i.animate=lf,i.animation=hf,i.color=dI,i.control=gp,i.createREGL=Wm,i.earcut=Vx,i.formatResourceUrl=li,i.getDefaultSpatialReference=function(){return JSON.parse(JSON.stringify(cu()))},i.getResouceCacheInstance=Ko,i.getVectorPacker=JD,i.mat2=tA,i.mat2d=iA,i.mat3=pA,i.mat4=VA,i.math=Ts,i.measurer=ql,i.parseSVG=ci,i.projection=xh,i.quat=O_,i.quat2=N_,i.registerWorkerAdapter=Os,i.renderer=Om,i.reshader=wP,i.symbolizer=Vc,i.transcoders=rx,i.ui=np,i.vec2=av,i.vec3=yy,i.vec4=Xy,i.worker=Um,"undefined"!=typeof console&&console.log("maptalks-gl v0.115.0")}));
//# sourceMappingURL=maptalks-gl.js.map
